//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armweb

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// WebAppsClient contains the methods for the WebApps group.
// Don't use this type directly, use NewWebAppsClient() instead.
type WebAppsClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewWebAppsClient creates a new instance of WebAppsClient with the specified values.
func NewWebAppsClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *WebAppsClient {
	cp := arm.ClientOptions{}
	if options != nil {
		cp = *options
	}
	if len(cp.Host) == 0 {
		cp.Host = arm.AzurePublicCloud
	}
	return &WebAppsClient{subscriptionID: subscriptionID, ep: string(cp.Host), pl: armruntime.NewPipeline(module, version, credential, &cp)}
}

// AddPremierAddOn - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AddPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnOptions) (WebAppsAddPremierAddOnResponse, error) {
	req, err := client.addPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return WebAppsAddPremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsAddPremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsAddPremierAddOnResponse{}, client.addPremierAddOnHandleError(resp)
	}
	return client.addPremierAddOnHandleResponse(resp)
}

// addPremierAddOnCreateRequest creates the AddPremierAddOn request.
func (client *WebAppsClient) addPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// addPremierAddOnHandleResponse handles the AddPremierAddOn response.
func (client *WebAppsClient) addPremierAddOnHandleResponse(resp *http.Response) (WebAppsAddPremierAddOnResponse, error) {
	result := WebAppsAddPremierAddOnResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsAddPremierAddOnResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// addPremierAddOnHandleError handles the AddPremierAddOn error response.
func (client *WebAppsClient) addPremierAddOnHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// AddPremierAddOnSlot - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AddPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnSlotOptions) (WebAppsAddPremierAddOnSlotResponse, error) {
	req, err := client.addPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return WebAppsAddPremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsAddPremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsAddPremierAddOnSlotResponse{}, client.addPremierAddOnSlotHandleError(resp)
	}
	return client.addPremierAddOnSlotHandleResponse(resp)
}

// addPremierAddOnSlotCreateRequest creates the AddPremierAddOnSlot request.
func (client *WebAppsClient) addPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOn, options *WebAppsAddPremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// addPremierAddOnSlotHandleResponse handles the AddPremierAddOnSlot response.
func (client *WebAppsClient) addPremierAddOnSlotHandleResponse(resp *http.Response) (WebAppsAddPremierAddOnSlotResponse, error) {
	result := WebAppsAddPremierAddOnSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsAddPremierAddOnSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// addPremierAddOnSlotHandleError handles the AddPremierAddOnSlot error response.
func (client *WebAppsClient) addPremierAddOnSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// AnalyzeCustomHostname - Description for Analyze a custom hostname.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AnalyzeCustomHostname(ctx context.Context, resourceGroupName string, name string, options *WebAppsAnalyzeCustomHostnameOptions) (WebAppsAnalyzeCustomHostnameResponse, error) {
	req, err := client.analyzeCustomHostnameCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsAnalyzeCustomHostnameResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsAnalyzeCustomHostnameResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsAnalyzeCustomHostnameResponse{}, client.analyzeCustomHostnameHandleError(resp)
	}
	return client.analyzeCustomHostnameHandleResponse(resp)
}

// analyzeCustomHostnameCreateRequest creates the AnalyzeCustomHostname request.
func (client *WebAppsClient) analyzeCustomHostnameCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsAnalyzeCustomHostnameOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// analyzeCustomHostnameHandleResponse handles the AnalyzeCustomHostname response.
func (client *WebAppsClient) analyzeCustomHostnameHandleResponse(resp *http.Response) (WebAppsAnalyzeCustomHostnameResponse, error) {
	result := WebAppsAnalyzeCustomHostnameResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameAnalysisResult); err != nil {
		return WebAppsAnalyzeCustomHostnameResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// analyzeCustomHostnameHandleError handles the AnalyzeCustomHostname error response.
func (client *WebAppsClient) analyzeCustomHostnameHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// AnalyzeCustomHostnameSlot - Description for Analyze a custom hostname.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) AnalyzeCustomHostnameSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsAnalyzeCustomHostnameSlotOptions) (WebAppsAnalyzeCustomHostnameSlotResponse, error) {
	req, err := client.analyzeCustomHostnameSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsAnalyzeCustomHostnameSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsAnalyzeCustomHostnameSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsAnalyzeCustomHostnameSlotResponse{}, client.analyzeCustomHostnameSlotHandleError(resp)
	}
	return client.analyzeCustomHostnameSlotHandleResponse(resp)
}

// analyzeCustomHostnameSlotCreateRequest creates the AnalyzeCustomHostnameSlot request.
func (client *WebAppsClient) analyzeCustomHostnameSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsAnalyzeCustomHostnameSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/analyzeCustomHostname"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.HostName != nil {
		reqQP.Set("hostName", *options.HostName)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// analyzeCustomHostnameSlotHandleResponse handles the AnalyzeCustomHostnameSlot response.
func (client *WebAppsClient) analyzeCustomHostnameSlotHandleResponse(resp *http.Response) (WebAppsAnalyzeCustomHostnameSlotResponse, error) {
	result := WebAppsAnalyzeCustomHostnameSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CustomHostnameAnalysisResult); err != nil {
		return WebAppsAnalyzeCustomHostnameSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// analyzeCustomHostnameSlotHandleError handles the AnalyzeCustomHostnameSlot error response.
func (client *WebAppsClient) analyzeCustomHostnameSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ApplySlotConfigToProduction - Description for Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ApplySlotConfigToProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigToProductionOptions) (WebAppsApplySlotConfigToProductionResponse, error) {
	req, err := client.applySlotConfigToProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return WebAppsApplySlotConfigToProductionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsApplySlotConfigToProductionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsApplySlotConfigToProductionResponse{}, client.applySlotConfigToProductionHandleError(resp)
	}
	return WebAppsApplySlotConfigToProductionResponse{RawResponse: resp}, nil
}

// applySlotConfigToProductionCreateRequest creates the ApplySlotConfigToProduction request.
func (client *WebAppsClient) applySlotConfigToProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigToProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// applySlotConfigToProductionHandleError handles the ApplySlotConfigToProduction error response.
func (client *WebAppsClient) applySlotConfigToProductionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ApplySlotConfigurationSlot - Description for Applies the configuration settings from the target slot onto the current slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ApplySlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigurationSlotOptions) (WebAppsApplySlotConfigurationSlotResponse, error) {
	req, err := client.applySlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return WebAppsApplySlotConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsApplySlotConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsApplySlotConfigurationSlotResponse{}, client.applySlotConfigurationSlotHandleError(resp)
	}
	return WebAppsApplySlotConfigurationSlotResponse{RawResponse: resp}, nil
}

// applySlotConfigurationSlotCreateRequest creates the ApplySlotConfigurationSlot request.
func (client *WebAppsClient) applySlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsApplySlotConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/applySlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// applySlotConfigurationSlotHandleError handles the ApplySlotConfigurationSlot error response.
func (client *WebAppsClient) applySlotConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginApproveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionOptions) (WebAppsApproveOrRejectPrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return WebAppsApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result := WebAppsApproveOrRejectPrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.ApproveOrRejectPrivateEndpointConnection", "", resp, client.pl, client.approveOrRejectPrivateEndpointConnectionHandleError)
	if err != nil {
		return WebAppsApproveOrRejectPrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &WebAppsApproveOrRejectPrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnection - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.approveOrRejectPrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionCreateRequest creates the ApproveOrRejectPrivateEndpointConnection request.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, privateEndpointWrapper)
}

// approveOrRejectPrivateEndpointConnectionHandleError handles the ApproveOrRejectPrivateEndpointConnection error response.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginApproveOrRejectPrivateEndpointConnectionSlot - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginApproveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (WebAppsApproveOrRejectPrivateEndpointConnectionSlotPollerResponse, error) {
	resp, err := client.approveOrRejectPrivateEndpointConnectionSlot(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options)
	if err != nil {
		return WebAppsApproveOrRejectPrivateEndpointConnectionSlotPollerResponse{}, err
	}
	result := WebAppsApproveOrRejectPrivateEndpointConnectionSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.ApproveOrRejectPrivateEndpointConnectionSlot", "", resp, client.pl, client.approveOrRejectPrivateEndpointConnectionSlotHandleError)
	if err != nil {
		return WebAppsApproveOrRejectPrivateEndpointConnectionSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsApproveOrRejectPrivateEndpointConnectionSlotPoller{
		pt: pt,
	}
	return result, nil
}

// ApproveOrRejectPrivateEndpointConnectionSlot - Description for Approves or rejects a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*http.Response, error) {
	req, err := client.approveOrRejectPrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, privateEndpointWrapper, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.approveOrRejectPrivateEndpointConnectionSlotHandleError(resp)
	}
	return resp, nil
}

// approveOrRejectPrivateEndpointConnectionSlotCreateRequest creates the ApproveOrRejectPrivateEndpointConnectionSlot request.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, privateEndpointWrapper PrivateLinkConnectionApprovalRequestResource, options *WebAppsBeginApproveOrRejectPrivateEndpointConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, privateEndpointWrapper)
}

// approveOrRejectPrivateEndpointConnectionSlotHandleError handles the ApproveOrRejectPrivateEndpointConnectionSlot error response.
func (client *WebAppsClient) approveOrRejectPrivateEndpointConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Backup - Description for Creates a backup of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Backup(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsBackupOptions) (WebAppsBackupResponse, error) {
	req, err := client.backupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsBackupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsBackupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsBackupResponse{}, client.backupHandleError(resp)
	}
	return client.backupHandleResponse(resp)
}

// backupCreateRequest creates the Backup request.
func (client *WebAppsClient) backupCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// backupHandleResponse handles the Backup response.
func (client *WebAppsClient) backupHandleResponse(resp *http.Response) (WebAppsBackupResponse, error) {
	result := WebAppsBackupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsBackupResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// backupHandleError handles the Backup error response.
func (client *WebAppsClient) backupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BackupSlot - Description for Creates a backup of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsBackupSlotOptions) (WebAppsBackupSlotResponse, error) {
	req, err := client.backupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsBackupSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsBackupSlotResponse{}, client.backupSlotHandleError(resp)
	}
	return client.backupSlotHandleResponse(resp)
}

// backupSlotCreateRequest creates the BackupSlot request.
func (client *WebAppsClient) backupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// backupSlotHandleResponse handles the BackupSlot response.
func (client *WebAppsClient) backupSlotHandleResponse(resp *http.Response) (WebAppsBackupSlotResponse, error) {
	result := WebAppsBackupSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsBackupSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// backupSlotHandleError handles the BackupSlot error response.
func (client *WebAppsClient) backupSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateDeployment - Description for Create a deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateDeployment(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *WebAppsCreateDeploymentOptions) (WebAppsCreateDeploymentResponse, error) {
	req, err := client.createDeploymentCreateRequest(ctx, resourceGroupName, name, id, deployment, options)
	if err != nil {
		return WebAppsCreateDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateDeploymentResponse{}, client.createDeploymentHandleError(resp)
	}
	return client.createDeploymentHandleResponse(resp)
}

// createDeploymentCreateRequest creates the CreateDeployment request.
func (client *WebAppsClient) createDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, deployment Deployment, options *WebAppsCreateDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, deployment)
}

// createDeploymentHandleResponse handles the CreateDeployment response.
func (client *WebAppsClient) createDeploymentHandleResponse(resp *http.Response) (WebAppsCreateDeploymentResponse, error) {
	result := WebAppsCreateDeploymentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsCreateDeploymentResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createDeploymentHandleError handles the CreateDeployment error response.
func (client *WebAppsClient) createDeploymentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateDeploymentSlot - Description for Create a deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *WebAppsCreateDeploymentSlotOptions) (WebAppsCreateDeploymentSlotResponse, error) {
	req, err := client.createDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, deployment, options)
	if err != nil {
		return WebAppsCreateDeploymentSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateDeploymentSlotResponse{}, client.createDeploymentSlotHandleError(resp)
	}
	return client.createDeploymentSlotHandleResponse(resp)
}

// createDeploymentSlotCreateRequest creates the CreateDeploymentSlot request.
func (client *WebAppsClient) createDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, deployment Deployment, options *WebAppsCreateDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, deployment)
}

// createDeploymentSlotHandleResponse handles the CreateDeploymentSlot response.
func (client *WebAppsClient) createDeploymentSlotHandleResponse(resp *http.Response) (WebAppsCreateDeploymentSlotResponse, error) {
	result := WebAppsCreateDeploymentSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsCreateDeploymentSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createDeploymentSlotHandleError handles the CreateDeploymentSlot error response.
func (client *WebAppsClient) createDeploymentSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateFunction - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateFunctionOptions) (WebAppsCreateFunctionPollerResponse, error) {
	resp, err := client.createFunction(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
	if err != nil {
		return WebAppsCreateFunctionPollerResponse{}, err
	}
	result := WebAppsCreateFunctionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateFunction", "", resp, client.pl, client.createFunctionHandleError)
	if err != nil {
		return WebAppsCreateFunctionPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateFunctionPoller{
		pt: pt,
	}
	return result, nil
}

// CreateFunction - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createFunction(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateFunctionOptions) (*http.Response, error) {
	req, err := client.createFunctionCreateRequest(ctx, resourceGroupName, name, functionName, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, client.createFunctionHandleError(resp)
	}
	return resp, nil
}

// createFunctionCreateRequest creates the CreateFunction request.
func (client *WebAppsClient) createFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, functionEnvelope)
}

// createFunctionHandleError handles the CreateFunction error response.
func (client *WebAppsClient) createFunctionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateInstanceFunctionSlot - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateInstanceFunctionSlotOptions) (WebAppsCreateInstanceFunctionSlotPollerResponse, error) {
	resp, err := client.createInstanceFunctionSlot(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
	if err != nil {
		return WebAppsCreateInstanceFunctionSlotPollerResponse{}, err
	}
	result := WebAppsCreateInstanceFunctionSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateInstanceFunctionSlot", "", resp, client.pl, client.createInstanceFunctionSlotHandleError)
	if err != nil {
		return WebAppsCreateInstanceFunctionSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateInstanceFunctionSlotPoller{
		pt: pt,
	}
	return result, nil
}

// CreateInstanceFunctionSlot - Description for Create function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateInstanceFunctionSlotOptions) (*http.Response, error) {
	req, err := client.createInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, functionEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, client.createInstanceFunctionSlotHandleError(resp)
	}
	return resp, nil
}

// createInstanceFunctionSlotCreateRequest creates the CreateInstanceFunctionSlot request.
func (client *WebAppsClient) createInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, functionEnvelope FunctionEnvelope, options *WebAppsBeginCreateInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, functionEnvelope)
}

// createInstanceFunctionSlotHandleError handles the CreateInstanceFunctionSlot error response.
func (client *WebAppsClient) createInstanceFunctionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateInstanceMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationOptions) (WebAppsCreateInstanceMSDeployOperationPollerResponse, error) {
	resp, err := client.createInstanceMSDeployOperation(ctx, resourceGroupName, name, instanceID, msDeploy, options)
	if err != nil {
		return WebAppsCreateInstanceMSDeployOperationPollerResponse{}, err
	}
	result := WebAppsCreateInstanceMSDeployOperationPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateInstanceMSDeployOperation", "", resp, client.pl, client.createInstanceMSDeployOperationHandleError)
	if err != nil {
		return WebAppsCreateInstanceMSDeployOperationPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateInstanceMSDeployOperationPoller{
		pt: pt,
	}
	return result, nil
}

// CreateInstanceMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createInstanceMSDeployOperation(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationOptions) (*http.Response, error) {
	req, err := client.createInstanceMSDeployOperationCreateRequest(ctx, resourceGroupName, name, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, client.createInstanceMSDeployOperationHandleError(resp)
	}
	return resp, nil
}

// createInstanceMSDeployOperationCreateRequest creates the CreateInstanceMSDeployOperation request.
func (client *WebAppsClient) createInstanceMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// createInstanceMSDeployOperationHandleError handles the CreateInstanceMSDeployOperation error response.
func (client *WebAppsClient) createInstanceMSDeployOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// BeginCreateInstanceMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationSlotOptions) (WebAppsCreateInstanceMSDeployOperationSlotPollerResponse, error) {
	resp, err := client.createInstanceMSDeployOperationSlot(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
	if err != nil {
		return WebAppsCreateInstanceMSDeployOperationSlotPollerResponse{}, err
	}
	result := WebAppsCreateInstanceMSDeployOperationSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateInstanceMSDeployOperationSlot", "", resp, client.pl, client.createInstanceMSDeployOperationSlotHandleError)
	if err != nil {
		return WebAppsCreateInstanceMSDeployOperationSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateInstanceMSDeployOperationSlotPoller{
		pt: pt,
	}
	return result, nil
}

// CreateInstanceMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createInstanceMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationSlotOptions) (*http.Response, error) {
	req, err := client.createInstanceMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, client.createInstanceMSDeployOperationSlotHandleError(resp)
	}
	return resp, nil
}

// createInstanceMSDeployOperationSlotCreateRequest creates the CreateInstanceMSDeployOperationSlot request.
func (client *WebAppsClient) createInstanceMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, msDeploy MSDeploy, options *WebAppsBeginCreateInstanceMSDeployOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// createInstanceMSDeployOperationSlotHandleError handles the CreateInstanceMSDeployOperationSlot error response.
func (client *WebAppsClient) createInstanceMSDeployOperationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// BeginCreateMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationOptions) (WebAppsCreateMSDeployOperationPollerResponse, error) {
	resp, err := client.createMSDeployOperation(ctx, resourceGroupName, name, msDeploy, options)
	if err != nil {
		return WebAppsCreateMSDeployOperationPollerResponse{}, err
	}
	result := WebAppsCreateMSDeployOperationPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateMSDeployOperation", "", resp, client.pl, client.createMSDeployOperationHandleError)
	if err != nil {
		return WebAppsCreateMSDeployOperationPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateMSDeployOperationPoller{
		pt: pt,
	}
	return result, nil
}

// CreateMSDeployOperation - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createMSDeployOperation(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationOptions) (*http.Response, error) {
	req, err := client.createMSDeployOperationCreateRequest(ctx, resourceGroupName, name, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, client.createMSDeployOperationHandleError(resp)
	}
	return resp, nil
}

// createMSDeployOperationCreateRequest creates the CreateMSDeployOperation request.
func (client *WebAppsClient) createMSDeployOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// createMSDeployOperationHandleError handles the CreateMSDeployOperation error response.
func (client *WebAppsClient) createMSDeployOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// BeginCreateMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationSlotOptions) (WebAppsCreateMSDeployOperationSlotPollerResponse, error) {
	resp, err := client.createMSDeployOperationSlot(ctx, resourceGroupName, name, slot, msDeploy, options)
	if err != nil {
		return WebAppsCreateMSDeployOperationSlotPollerResponse{}, err
	}
	result := WebAppsCreateMSDeployOperationSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateMSDeployOperationSlot", "", resp, client.pl, client.createMSDeployOperationSlotHandleError)
	if err != nil {
		return WebAppsCreateMSDeployOperationSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateMSDeployOperationSlotPoller{
		pt: pt,
	}
	return result, nil
}

// CreateMSDeployOperationSlot - Description for Invoke the MSDeploy web app extension.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createMSDeployOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationSlotOptions) (*http.Response, error) {
	req, err := client.createMSDeployOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, msDeploy, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return nil, client.createMSDeployOperationSlotHandleError(resp)
	}
	return resp, nil
}

// createMSDeployOperationSlotCreateRequest creates the CreateMSDeployOperationSlot request.
func (client *WebAppsClient) createMSDeployOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, msDeploy MSDeploy, options *WebAppsBeginCreateMSDeployOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, msDeploy)
}

// createMSDeployOperationSlotHandleError handles the CreateMSDeployOperationSlot error response.
func (client *WebAppsClient) createMSDeployOperationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusConflict:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// BeginCreateOrUpdate - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateOptions) (WebAppsCreateOrUpdatePollerResponse, error) {
	resp, err := client.createOrUpdate(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdatePollerResponse{}, err
	}
	result := WebAppsCreateOrUpdatePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateOrUpdate", "", resp, client.pl, client.createOrUpdateHandleError)
	if err != nil {
		return WebAppsCreateOrUpdatePollerResponse{}, err
	}
	result.Poller = &WebAppsCreateOrUpdatePoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdate - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdate(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateOptions) (*http.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *WebAppsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *WebAppsClient) createOrUpdateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateConfiguration - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationOptions) (WebAppsCreateOrUpdateConfigurationResponse, error) {
	req, err := client.createOrUpdateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return WebAppsCreateOrUpdateConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateConfigurationResponse{}, client.createOrUpdateConfigurationHandleError(resp)
	}
	return client.createOrUpdateConfigurationHandleResponse(resp)
}

// createOrUpdateConfigurationCreateRequest creates the CreateOrUpdateConfiguration request.
func (client *WebAppsClient) createOrUpdateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// createOrUpdateConfigurationHandleResponse handles the CreateOrUpdateConfiguration response.
func (client *WebAppsClient) createOrUpdateConfigurationHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateConfigurationResponse, error) {
	result := WebAppsCreateOrUpdateConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsCreateOrUpdateConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateConfigurationHandleError handles the CreateOrUpdateConfiguration error response.
func (client *WebAppsClient) createOrUpdateConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateConfigurationSlot - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationSlotOptions) (WebAppsCreateOrUpdateConfigurationSlotResponse, error) {
	req, err := client.createOrUpdateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return WebAppsCreateOrUpdateConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateConfigurationSlotResponse{}, client.createOrUpdateConfigurationSlotHandleError(resp)
	}
	return client.createOrUpdateConfigurationSlotHandleResponse(resp)
}

// createOrUpdateConfigurationSlotCreateRequest creates the CreateOrUpdateConfigurationSlot request.
func (client *WebAppsClient) createOrUpdateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsCreateOrUpdateConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// createOrUpdateConfigurationSlotHandleResponse handles the CreateOrUpdateConfigurationSlot response.
func (client *WebAppsClient) createOrUpdateConfigurationSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateConfigurationSlotResponse, error) {
	result := WebAppsCreateOrUpdateConfigurationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsCreateOrUpdateConfigurationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateConfigurationSlotHandleError handles the CreateOrUpdateConfigurationSlot error response.
func (client *WebAppsClient) createOrUpdateConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateDomainOwnershipIdentifier - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierOptions) (WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse, error) {
	req, err := client.createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse{}, client.createOrUpdateDomainOwnershipIdentifierHandleError(resp)
	}
	return client.createOrUpdateDomainOwnershipIdentifierHandleResponse(resp)
}

// createOrUpdateDomainOwnershipIdentifierCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifier request.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// createOrUpdateDomainOwnershipIdentifierHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifier response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse, error) {
	result := WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateDomainOwnershipIdentifierHandleError handles the CreateOrUpdateDomainOwnershipIdentifier error response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateDomainOwnershipIdentifierSlot - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, client.createOrUpdateDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return client.createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// createOrUpdateDomainOwnershipIdentifierSlotCreateRequest creates the CreateOrUpdateDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// createOrUpdateDomainOwnershipIdentifierSlotHandleResponse handles the CreateOrUpdateDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse, error) {
	result := WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsCreateOrUpdateDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateDomainOwnershipIdentifierSlotHandleError handles the CreateOrUpdateDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) createOrUpdateDomainOwnershipIdentifierSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateFunctionSecret - Description for Add or update a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretOptions) (WebAppsCreateOrUpdateFunctionSecretResponse, error) {
	req, err := client.createOrUpdateFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, key, options)
	if err != nil {
		return WebAppsCreateOrUpdateFunctionSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateFunctionSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return WebAppsCreateOrUpdateFunctionSecretResponse{}, client.createOrUpdateFunctionSecretHandleError(resp)
	}
	return client.createOrUpdateFunctionSecretHandleResponse(resp)
}

// createOrUpdateFunctionSecretCreateRequest creates the CreateOrUpdateFunctionSecret request.
func (client *WebAppsClient) createOrUpdateFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateFunctionSecretHandleResponse handles the CreateOrUpdateFunctionSecret response.
func (client *WebAppsClient) createOrUpdateFunctionSecretHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateFunctionSecretResponse, error) {
	result := WebAppsCreateOrUpdateFunctionSecretResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsCreateOrUpdateFunctionSecretResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateFunctionSecretHandleError handles the CreateOrUpdateFunctionSecret error response.
func (client *WebAppsClient) createOrUpdateFunctionSecretHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateFunctionSecretSlot - Description for Add or update a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretSlotOptions) (WebAppsCreateOrUpdateFunctionSecretSlotResponse, error) {
	req, err := client.createOrUpdateFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, key, options)
	if err != nil {
		return WebAppsCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateFunctionSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return WebAppsCreateOrUpdateFunctionSecretSlotResponse{}, client.createOrUpdateFunctionSecretSlotHandleError(resp)
	}
	return client.createOrUpdateFunctionSecretSlotHandleResponse(resp)
}

// createOrUpdateFunctionSecretSlotCreateRequest creates the CreateOrUpdateFunctionSecretSlot request.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateFunctionSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateFunctionSecretSlotHandleResponse handles the CreateOrUpdateFunctionSecretSlot response.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateFunctionSecretSlotResponse, error) {
	result := WebAppsCreateOrUpdateFunctionSecretSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsCreateOrUpdateFunctionSecretSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateFunctionSecretSlotHandleError handles the CreateOrUpdateFunctionSecretSlot error response.
func (client *WebAppsClient) createOrUpdateFunctionSecretSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateHostNameBinding - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingOptions) (WebAppsCreateOrUpdateHostNameBindingResponse, error) {
	req, err := client.createOrUpdateHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, hostNameBinding, options)
	if err != nil {
		return WebAppsCreateOrUpdateHostNameBindingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateHostNameBindingResponse{}, client.createOrUpdateHostNameBindingHandleError(resp)
	}
	return client.createOrUpdateHostNameBindingHandleResponse(resp)
}

// createOrUpdateHostNameBindingCreateRequest creates the CreateOrUpdateHostNameBinding request.
func (client *WebAppsClient) createOrUpdateHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, hostNameBinding)
}

// createOrUpdateHostNameBindingHandleResponse handles the CreateOrUpdateHostNameBinding response.
func (client *WebAppsClient) createOrUpdateHostNameBindingHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateHostNameBindingResponse, error) {
	result := WebAppsCreateOrUpdateHostNameBindingResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsCreateOrUpdateHostNameBindingResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateHostNameBindingHandleError handles the CreateOrUpdateHostNameBinding error response.
func (client *WebAppsClient) createOrUpdateHostNameBindingHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateHostNameBindingSlot - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingSlotOptions) (WebAppsCreateOrUpdateHostNameBindingSlotResponse, error) {
	req, err := client.createOrUpdateHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, hostName, slot, hostNameBinding, options)
	if err != nil {
		return WebAppsCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateHostNameBindingSlotResponse{}, client.createOrUpdateHostNameBindingSlotHandleError(resp)
	}
	return client.createOrUpdateHostNameBindingSlotHandleResponse(resp)
}

// createOrUpdateHostNameBindingSlotCreateRequest creates the CreateOrUpdateHostNameBindingSlot request.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, slot string, hostNameBinding HostNameBinding, options *WebAppsCreateOrUpdateHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, hostNameBinding)
}

// createOrUpdateHostNameBindingSlotHandleResponse handles the CreateOrUpdateHostNameBindingSlot response.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateHostNameBindingSlotResponse, error) {
	result := WebAppsCreateOrUpdateHostNameBindingSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsCreateOrUpdateHostNameBindingSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateHostNameBindingSlotHandleError handles the CreateOrUpdateHostNameBindingSlot error response.
func (client *WebAppsClient) createOrUpdateHostNameBindingSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateHostSecret - Description for Add or update a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretOptions) (WebAppsCreateOrUpdateHostSecretResponse, error) {
	req, err := client.createOrUpdateHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, key, options)
	if err != nil {
		return WebAppsCreateOrUpdateHostSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateHostSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return WebAppsCreateOrUpdateHostSecretResponse{}, client.createOrUpdateHostSecretHandleError(resp)
	}
	return client.createOrUpdateHostSecretHandleResponse(resp)
}

// createOrUpdateHostSecretCreateRequest creates the CreateOrUpdateHostSecret request.
func (client *WebAppsClient) createOrUpdateHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateHostSecretHandleResponse handles the CreateOrUpdateHostSecret response.
func (client *WebAppsClient) createOrUpdateHostSecretHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateHostSecretResponse, error) {
	result := WebAppsCreateOrUpdateHostSecretResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsCreateOrUpdateHostSecretResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateHostSecretHandleError handles the CreateOrUpdateHostSecret error response.
func (client *WebAppsClient) createOrUpdateHostSecretHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateHostSecretSlot - Description for Add or update a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretSlotOptions) (WebAppsCreateOrUpdateHostSecretSlotResponse, error) {
	req, err := client.createOrUpdateHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, key, options)
	if err != nil {
		return WebAppsCreateOrUpdateHostSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateHostSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return WebAppsCreateOrUpdateHostSecretSlotResponse{}, client.createOrUpdateHostSecretSlotHandleError(resp)
	}
	return client.createOrUpdateHostSecretSlotHandleResponse(resp)
}

// createOrUpdateHostSecretSlotCreateRequest creates the CreateOrUpdateHostSecretSlot request.
func (client *WebAppsClient) createOrUpdateHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, key KeyInfo, options *WebAppsCreateOrUpdateHostSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, key)
}

// createOrUpdateHostSecretSlotHandleResponse handles the CreateOrUpdateHostSecretSlot response.
func (client *WebAppsClient) createOrUpdateHostSecretSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateHostSecretSlotResponse, error) {
	result := WebAppsCreateOrUpdateHostSecretSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.KeyInfo); err != nil {
		return WebAppsCreateOrUpdateHostSecretSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateHostSecretSlotHandleError handles the CreateOrUpdateHostSecretSlot error response.
func (client *WebAppsClient) createOrUpdateHostSecretSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateHybridConnection - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionOptions) (WebAppsCreateOrUpdateHybridConnectionResponse, error) {
	req, err := client.createOrUpdateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateHybridConnectionResponse{}, client.createOrUpdateHybridConnectionHandleError(resp)
	}
	return client.createOrUpdateHybridConnectionHandleResponse(resp)
}

// createOrUpdateHybridConnectionCreateRequest creates the CreateOrUpdateHybridConnection request.
func (client *WebAppsClient) createOrUpdateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateHybridConnectionHandleResponse handles the CreateOrUpdateHybridConnection response.
func (client *WebAppsClient) createOrUpdateHybridConnectionHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateHybridConnectionResponse, error) {
	result := WebAppsCreateOrUpdateHybridConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsCreateOrUpdateHybridConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateHybridConnectionHandleError handles the CreateOrUpdateHybridConnection error response.
func (client *WebAppsClient) createOrUpdateHybridConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateHybridConnectionSlot - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionSlotOptions) (WebAppsCreateOrUpdateHybridConnectionSlotResponse, error) {
	req, err := client.createOrUpdateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateHybridConnectionSlotResponse{}, client.createOrUpdateHybridConnectionSlotHandleError(resp)
	}
	return client.createOrUpdateHybridConnectionSlotHandleResponse(resp)
}

// createOrUpdateHybridConnectionSlotCreateRequest creates the CreateOrUpdateHybridConnectionSlot request.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsCreateOrUpdateHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateHybridConnectionSlotHandleResponse handles the CreateOrUpdateHybridConnectionSlot response.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateHybridConnectionSlotResponse, error) {
	result := WebAppsCreateOrUpdateHybridConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsCreateOrUpdateHybridConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateHybridConnectionSlotHandleError handles the CreateOrUpdateHybridConnectionSlot error response.
func (client *WebAppsClient) createOrUpdateHybridConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdatePublicCertificate - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdatePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateOptions) (WebAppsCreateOrUpdatePublicCertificateResponse, error) {
	req, err := client.createOrUpdatePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, publicCertificate, options)
	if err != nil {
		return WebAppsCreateOrUpdatePublicCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdatePublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdatePublicCertificateResponse{}, client.createOrUpdatePublicCertificateHandleError(resp)
	}
	return client.createOrUpdatePublicCertificateHandleResponse(resp)
}

// createOrUpdatePublicCertificateCreateRequest creates the CreateOrUpdatePublicCertificate request.
func (client *WebAppsClient) createOrUpdatePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, publicCertificate)
}

// createOrUpdatePublicCertificateHandleResponse handles the CreateOrUpdatePublicCertificate response.
func (client *WebAppsClient) createOrUpdatePublicCertificateHandleResponse(resp *http.Response) (WebAppsCreateOrUpdatePublicCertificateResponse, error) {
	result := WebAppsCreateOrUpdatePublicCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsCreateOrUpdatePublicCertificateResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdatePublicCertificateHandleError handles the CreateOrUpdatePublicCertificate error response.
func (client *WebAppsClient) createOrUpdatePublicCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdatePublicCertificateSlot - Description for Creates a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdatePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateSlotOptions) (WebAppsCreateOrUpdatePublicCertificateSlotResponse, error) {
	req, err := client.createOrUpdatePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, publicCertificateName, slot, publicCertificate, options)
	if err != nil {
		return WebAppsCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdatePublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdatePublicCertificateSlotResponse{}, client.createOrUpdatePublicCertificateSlotHandleError(resp)
	}
	return client.createOrUpdatePublicCertificateSlotHandleResponse(resp)
}

// createOrUpdatePublicCertificateSlotCreateRequest creates the CreateOrUpdatePublicCertificateSlot request.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, slot string, publicCertificate PublicCertificate, options *WebAppsCreateOrUpdatePublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, publicCertificate)
}

// createOrUpdatePublicCertificateSlotHandleResponse handles the CreateOrUpdatePublicCertificateSlot response.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdatePublicCertificateSlotResponse, error) {
	result := WebAppsCreateOrUpdatePublicCertificateSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsCreateOrUpdatePublicCertificateSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdatePublicCertificateSlotHandleError handles the CreateOrUpdatePublicCertificateSlot error response.
func (client *WebAppsClient) createOrUpdatePublicCertificateSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateRelayServiceConnection - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionOptions) (WebAppsCreateOrUpdateRelayServiceConnectionResponse, error) {
	req, err := client.createOrUpdateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateRelayServiceConnectionResponse{}, client.createOrUpdateRelayServiceConnectionHandleError(resp)
	}
	return client.createOrUpdateRelayServiceConnectionHandleResponse(resp)
}

// createOrUpdateRelayServiceConnectionCreateRequest creates the CreateOrUpdateRelayServiceConnection request.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateRelayServiceConnectionHandleResponse handles the CreateOrUpdateRelayServiceConnection response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateRelayServiceConnectionResponse, error) {
	result := WebAppsCreateOrUpdateRelayServiceConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsCreateOrUpdateRelayServiceConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateRelayServiceConnectionHandleError handles the CreateOrUpdateRelayServiceConnection error response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateRelayServiceConnectionSlot - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionSlotOptions) (WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse, error) {
	req, err := client.createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse{}, client.createOrUpdateRelayServiceConnectionSlotHandleError(resp)
	}
	return client.createOrUpdateRelayServiceConnectionSlotHandleResponse(resp)
}

// createOrUpdateRelayServiceConnectionSlotCreateRequest creates the CreateOrUpdateRelayServiceConnectionSlot request.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsCreateOrUpdateRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateRelayServiceConnectionSlotHandleResponse handles the CreateOrUpdateRelayServiceConnectionSlot response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse, error) {
	result := WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsCreateOrUpdateRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateRelayServiceConnectionSlotHandleError handles the CreateOrUpdateRelayServiceConnectionSlot error response.
func (client *WebAppsClient) createOrUpdateRelayServiceConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateSlotOptions) (WebAppsCreateOrUpdateSlotPollerResponse, error) {
	resp, err := client.createOrUpdateSlot(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateSlotPollerResponse{}, err
	}
	result := WebAppsCreateOrUpdateSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateOrUpdateSlot", "", resp, client.pl, client.createOrUpdateSlotHandleError)
	if err != nil {
		return WebAppsCreateOrUpdateSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateOrUpdateSlotPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateSlotOptions) (*http.Response, error) {
	req, err := client.createOrUpdateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.createOrUpdateSlotHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateSlotCreateRequest creates the CreateOrUpdateSlot request.
func (client *WebAppsClient) createOrUpdateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope Site, options *WebAppsBeginCreateOrUpdateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// createOrUpdateSlotHandleError handles the CreateOrUpdateSlot error response.
func (client *WebAppsClient) createOrUpdateSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlOptions) (WebAppsCreateOrUpdateSourceControlPollerResponse, error) {
	resp, err := client.createOrUpdateSourceControl(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return WebAppsCreateOrUpdateSourceControlPollerResponse{}, err
	}
	result := WebAppsCreateOrUpdateSourceControlPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateOrUpdateSourceControl", "", resp, client.pl, client.createOrUpdateSourceControlHandleError)
	if err != nil {
		return WebAppsCreateOrUpdateSourceControlPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateOrUpdateSourceControlPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlOptions) (*http.Response, error) {
	req, err := client.createOrUpdateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.createOrUpdateSourceControlHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateSourceControlCreateRequest creates the CreateOrUpdateSourceControl request.
func (client *WebAppsClient) createOrUpdateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// createOrUpdateSourceControlHandleError handles the CreateOrUpdateSourceControl error response.
func (client *WebAppsClient) createOrUpdateSourceControlHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginCreateOrUpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginCreateOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlSlotOptions) (WebAppsCreateOrUpdateSourceControlSlotPollerResponse, error) {
	resp, err := client.createOrUpdateSourceControlSlot(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return WebAppsCreateOrUpdateSourceControlSlotPollerResponse{}, err
	}
	result := WebAppsCreateOrUpdateSourceControlSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.CreateOrUpdateSourceControlSlot", "", resp, client.pl, client.createOrUpdateSourceControlSlotHandleError)
	if err != nil {
		return WebAppsCreateOrUpdateSourceControlSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsCreateOrUpdateSourceControlSlotPoller{
		pt: pt,
	}
	return result, nil
}

// CreateOrUpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) createOrUpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlSlotOptions) (*http.Response, error) {
	req, err := client.createOrUpdateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return nil, client.createOrUpdateSourceControlSlotHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateSourceControlSlotCreateRequest creates the CreateOrUpdateSourceControlSlot request.
func (client *WebAppsClient) createOrUpdateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsBeginCreateOrUpdateSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// createOrUpdateSourceControlSlotHandleError handles the CreateOrUpdateSourceControlSlot error response.
func (client *WebAppsClient) createOrUpdateSourceControlSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleError(resp)
	}
	return client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck request.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	result := WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleError handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheck error response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	req, err := client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp)
	}
	return client.createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest creates the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot request.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	result := WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsCreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleError handles the CreateOrUpdateSwiftVirtualNetworkConnectionWithCheckSlot error response.
func (client *WebAppsClient) createOrUpdateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateVnetConnection - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsCreateOrUpdateVnetConnectionOptions) (WebAppsCreateOrUpdateVnetConnectionResponse, error) {
	req, err := client.createOrUpdateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateVnetConnectionResponse{}, client.createOrUpdateVnetConnectionHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionHandleResponse(resp)
}

// createOrUpdateVnetConnectionCreateRequest creates the CreateOrUpdateVnetConnection request.
func (client *WebAppsClient) createOrUpdateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsCreateOrUpdateVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionHandleResponse handles the CreateOrUpdateVnetConnection response.
func (client *WebAppsClient) createOrUpdateVnetConnectionHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateVnetConnectionResponse, error) {
	result := WebAppsCreateOrUpdateVnetConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsCreateOrUpdateVnetConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateVnetConnectionHandleError handles the CreateOrUpdateVnetConnection error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateVnetConnectionGateway - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewayOptions) (WebAppsCreateOrUpdateVnetConnectionGatewayResponse, error) {
	req, err := client.createOrUpdateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateVnetConnectionGatewayResponse{}, client.createOrUpdateVnetConnectionGatewayHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionGatewayHandleResponse(resp)
}

// createOrUpdateVnetConnectionGatewayCreateRequest creates the CreateOrUpdateVnetConnectionGateway request.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionGatewayHandleResponse handles the CreateOrUpdateVnetConnectionGateway response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateVnetConnectionGatewayResponse, error) {
	result := WebAppsCreateOrUpdateVnetConnectionGatewayResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsCreateOrUpdateVnetConnectionGatewayResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateVnetConnectionGatewayHandleError handles the CreateOrUpdateVnetConnectionGateway error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewayHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateVnetConnectionGatewaySlot - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewaySlotOptions) (WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse, error) {
	req, err := client.createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse{}, client.createOrUpdateVnetConnectionGatewaySlotHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp)
}

// createOrUpdateVnetConnectionGatewaySlotCreateRequest creates the CreateOrUpdateVnetConnectionGatewaySlot request.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsCreateOrUpdateVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionGatewaySlotHandleResponse handles the CreateOrUpdateVnetConnectionGatewaySlot response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse, error) {
	result := WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsCreateOrUpdateVnetConnectionGatewaySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateVnetConnectionGatewaySlotHandleError handles the CreateOrUpdateVnetConnectionGatewaySlot error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionGatewaySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// CreateOrUpdateVnetConnectionSlot - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) CreateOrUpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsCreateOrUpdateVnetConnectionSlotOptions) (WebAppsCreateOrUpdateVnetConnectionSlotResponse, error) {
	req, err := client.createOrUpdateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsCreateOrUpdateVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsCreateOrUpdateVnetConnectionSlotResponse{}, client.createOrUpdateVnetConnectionSlotHandleError(resp)
	}
	return client.createOrUpdateVnetConnectionSlotHandleResponse(resp)
}

// createOrUpdateVnetConnectionSlotCreateRequest creates the CreateOrUpdateVnetConnectionSlot request.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsCreateOrUpdateVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// createOrUpdateVnetConnectionSlotHandleResponse handles the CreateOrUpdateVnetConnectionSlot response.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotHandleResponse(resp *http.Response) (WebAppsCreateOrUpdateVnetConnectionSlotResponse, error) {
	result := WebAppsCreateOrUpdateVnetConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsCreateOrUpdateVnetConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// createOrUpdateVnetConnectionSlotHandleError handles the CreateOrUpdateVnetConnectionSlot error response.
func (client *WebAppsClient) createOrUpdateVnetConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Delete - Description for Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Delete(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteOptions) (WebAppsDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteResponse{}, client.deleteHandleError(resp)
	}
	return WebAppsDeleteResponse{RawResponse: resp}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *WebAppsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *WebAppsClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteBackup - Description for Deletes a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackup(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsDeleteBackupOptions) (WebAppsDeleteBackupResponse, error) {
	req, err := client.deleteBackupCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return WebAppsDeleteBackupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteBackupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteBackupResponse{}, client.deleteBackupHandleError(resp)
	}
	return WebAppsDeleteBackupResponse{RawResponse: resp}, nil
}

// deleteBackupCreateRequest creates the DeleteBackup request.
func (client *WebAppsClient) deleteBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsDeleteBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupHandleError handles the DeleteBackup error response.
func (client *WebAppsClient) deleteBackupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteBackupConfiguration - Description for Deletes the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteBackupConfigurationOptions) (WebAppsDeleteBackupConfigurationResponse, error) {
	req, err := client.deleteBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsDeleteBackupConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteBackupConfigurationResponse{}, client.deleteBackupConfigurationHandleError(resp)
	}
	return WebAppsDeleteBackupConfigurationResponse{RawResponse: resp}, nil
}

// deleteBackupConfigurationCreateRequest creates the DeleteBackupConfiguration request.
func (client *WebAppsClient) deleteBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupConfigurationHandleError handles the DeleteBackupConfiguration error response.
func (client *WebAppsClient) deleteBackupConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteBackupConfigurationSlot - Description for Deletes the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteBackupConfigurationSlotOptions) (WebAppsDeleteBackupConfigurationSlotResponse, error) {
	req, err := client.deleteBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsDeleteBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteBackupConfigurationSlotResponse{}, client.deleteBackupConfigurationSlotHandleError(resp)
	}
	return WebAppsDeleteBackupConfigurationSlotResponse{RawResponse: resp}, nil
}

// deleteBackupConfigurationSlotCreateRequest creates the DeleteBackupConfigurationSlot request.
func (client *WebAppsClient) deleteBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupConfigurationSlotHandleError handles the DeleteBackupConfigurationSlot error response.
func (client *WebAppsClient) deleteBackupConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteBackupSlot - Description for Deletes a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteBackupSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsDeleteBackupSlotOptions) (WebAppsDeleteBackupSlotResponse, error) {
	req, err := client.deleteBackupSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return WebAppsDeleteBackupSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteBackupSlotResponse{}, client.deleteBackupSlotHandleError(resp)
	}
	return WebAppsDeleteBackupSlotResponse{RawResponse: resp}, nil
}

// deleteBackupSlotCreateRequest creates the DeleteBackupSlot request.
func (client *WebAppsClient) deleteBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsDeleteBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteBackupSlotHandleError handles the DeleteBackupSlot error response.
func (client *WebAppsClient) deleteBackupSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteContinuousWebJob - Description for Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteContinuousWebJobOptions) (WebAppsDeleteContinuousWebJobResponse, error) {
	req, err := client.deleteContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsDeleteContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteContinuousWebJobResponse{}, client.deleteContinuousWebJobHandleError(resp)
	}
	return WebAppsDeleteContinuousWebJobResponse{RawResponse: resp}, nil
}

// deleteContinuousWebJobCreateRequest creates the DeleteContinuousWebJob request.
func (client *WebAppsClient) deleteContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteContinuousWebJobHandleError handles the DeleteContinuousWebJob error response.
func (client *WebAppsClient) deleteContinuousWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteContinuousWebJobSlot - Description for Delete a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteContinuousWebJobSlotOptions) (WebAppsDeleteContinuousWebJobSlotResponse, error) {
	req, err := client.deleteContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsDeleteContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteContinuousWebJobSlotResponse{}, client.deleteContinuousWebJobSlotHandleError(resp)
	}
	return WebAppsDeleteContinuousWebJobSlotResponse{RawResponse: resp}, nil
}

// deleteContinuousWebJobSlotCreateRequest creates the DeleteContinuousWebJobSlot request.
func (client *WebAppsClient) deleteContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteContinuousWebJobSlotHandleError handles the DeleteContinuousWebJobSlot error response.
func (client *WebAppsClient) deleteContinuousWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteDeployment - Description for Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsDeleteDeploymentOptions) (WebAppsDeleteDeploymentResponse, error) {
	req, err := client.deleteDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return WebAppsDeleteDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteDeploymentResponse{}, client.deleteDeploymentHandleError(resp)
	}
	return WebAppsDeleteDeploymentResponse{RawResponse: resp}, nil
}

// deleteDeploymentCreateRequest creates the DeleteDeployment request.
func (client *WebAppsClient) deleteDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsDeleteDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDeploymentHandleError handles the DeleteDeployment error response.
func (client *WebAppsClient) deleteDeploymentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteDeploymentSlot - Description for Delete a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsDeleteDeploymentSlotOptions) (WebAppsDeleteDeploymentSlotResponse, error) {
	req, err := client.deleteDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return WebAppsDeleteDeploymentSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteDeploymentSlotResponse{}, client.deleteDeploymentSlotHandleError(resp)
	}
	return WebAppsDeleteDeploymentSlotResponse{RawResponse: resp}, nil
}

// deleteDeploymentSlotCreateRequest creates the DeleteDeploymentSlot request.
func (client *WebAppsClient) deleteDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsDeleteDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDeploymentSlotHandleError handles the DeleteDeploymentSlot error response.
func (client *WebAppsClient) deleteDeploymentSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteDomainOwnershipIdentifier - Description for Deletes a domain ownership identifier for a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsDeleteDomainOwnershipIdentifierOptions) (WebAppsDeleteDomainOwnershipIdentifierResponse, error) {
	req, err := client.deleteDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return WebAppsDeleteDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteDomainOwnershipIdentifierResponse{}, client.deleteDomainOwnershipIdentifierHandleError(resp)
	}
	return WebAppsDeleteDomainOwnershipIdentifierResponse{RawResponse: resp}, nil
}

// deleteDomainOwnershipIdentifierCreateRequest creates the DeleteDomainOwnershipIdentifier request.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsDeleteDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDomainOwnershipIdentifierHandleError handles the DeleteDomainOwnershipIdentifier error response.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteDomainOwnershipIdentifierSlot - Description for Deletes a domain ownership identifier for a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsDeleteDomainOwnershipIdentifierSlotOptions) (WebAppsDeleteDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.deleteDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return WebAppsDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteDomainOwnershipIdentifierSlotResponse{}, client.deleteDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return WebAppsDeleteDomainOwnershipIdentifierSlotResponse{RawResponse: resp}, nil
}

// deleteDomainOwnershipIdentifierSlotCreateRequest creates the DeleteDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsDeleteDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteDomainOwnershipIdentifierSlotHandleError handles the DeleteDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) deleteDomainOwnershipIdentifierSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteFunction - Description for Delete a function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsDeleteFunctionOptions) (WebAppsDeleteFunctionResponse, error) {
	req, err := client.deleteFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsDeleteFunctionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteFunctionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteFunctionResponse{}, client.deleteFunctionHandleError(resp)
	}
	return WebAppsDeleteFunctionResponse{RawResponse: resp}, nil
}

// deleteFunctionCreateRequest creates the DeleteFunction request.
func (client *WebAppsClient) deleteFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsDeleteFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFunctionHandleError handles the DeleteFunction error response.
func (client *WebAppsClient) deleteFunctionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteFunctionSecret - Description for Delete a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteFunctionSecret(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *WebAppsDeleteFunctionSecretOptions) (WebAppsDeleteFunctionSecretResponse, error) {
	req, err := client.deleteFunctionSecretCreateRequest(ctx, resourceGroupName, name, functionName, keyName, options)
	if err != nil {
		return WebAppsDeleteFunctionSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteFunctionSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteFunctionSecretResponse{}, client.deleteFunctionSecretHandleError(resp)
	}
	return WebAppsDeleteFunctionSecretResponse{RawResponse: resp}, nil
}

// deleteFunctionSecretCreateRequest creates the DeleteFunctionSecret request.
func (client *WebAppsClient) deleteFunctionSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, options *WebAppsDeleteFunctionSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFunctionSecretHandleError handles the DeleteFunctionSecret error response.
func (client *WebAppsClient) deleteFunctionSecretHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteFunctionSecretSlot - Description for Delete a function secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteFunctionSecretSlot(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *WebAppsDeleteFunctionSecretSlotOptions) (WebAppsDeleteFunctionSecretSlotResponse, error) {
	req, err := client.deleteFunctionSecretSlotCreateRequest(ctx, resourceGroupName, name, functionName, keyName, slot, options)
	if err != nil {
		return WebAppsDeleteFunctionSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteFunctionSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteFunctionSecretSlotResponse{}, client.deleteFunctionSecretSlotHandleError(resp)
	}
	return WebAppsDeleteFunctionSecretSlotResponse{RawResponse: resp}, nil
}

// deleteFunctionSecretSlotCreateRequest creates the DeleteFunctionSecretSlot request.
func (client *WebAppsClient) deleteFunctionSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, keyName string, slot string, options *WebAppsDeleteFunctionSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/keys/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFunctionSecretSlotHandleError handles the DeleteFunctionSecretSlot error response.
func (client *WebAppsClient) deleteFunctionSecretSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteHostNameBinding - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsDeleteHostNameBindingOptions) (WebAppsDeleteHostNameBindingResponse, error) {
	req, err := client.deleteHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return WebAppsDeleteHostNameBindingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteHostNameBindingResponse{}, client.deleteHostNameBindingHandleError(resp)
	}
	return WebAppsDeleteHostNameBindingResponse{RawResponse: resp}, nil
}

// deleteHostNameBindingCreateRequest creates the DeleteHostNameBinding request.
func (client *WebAppsClient) deleteHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsDeleteHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostNameBindingHandleError handles the DeleteHostNameBinding error response.
func (client *WebAppsClient) deleteHostNameBindingHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteHostNameBindingSlot - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsDeleteHostNameBindingSlotOptions) (WebAppsDeleteHostNameBindingSlotResponse, error) {
	req, err := client.deleteHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return WebAppsDeleteHostNameBindingSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteHostNameBindingSlotResponse{}, client.deleteHostNameBindingSlotHandleError(resp)
	}
	return WebAppsDeleteHostNameBindingSlotResponse{RawResponse: resp}, nil
}

// deleteHostNameBindingSlotCreateRequest creates the DeleteHostNameBindingSlot request.
func (client *WebAppsClient) deleteHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsDeleteHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostNameBindingSlotHandleError handles the DeleteHostNameBindingSlot error response.
func (client *WebAppsClient) deleteHostNameBindingSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteHostSecret - Description for Delete a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostSecret(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *WebAppsDeleteHostSecretOptions) (WebAppsDeleteHostSecretResponse, error) {
	req, err := client.deleteHostSecretCreateRequest(ctx, resourceGroupName, name, keyType, keyName, options)
	if err != nil {
		return WebAppsDeleteHostSecretResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteHostSecretResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteHostSecretResponse{}, client.deleteHostSecretHandleError(resp)
	}
	return WebAppsDeleteHostSecretResponse{RawResponse: resp}, nil
}

// deleteHostSecretCreateRequest creates the DeleteHostSecret request.
func (client *WebAppsClient) deleteHostSecretCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, options *WebAppsDeleteHostSecretOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostSecretHandleError handles the DeleteHostSecret error response.
func (client *WebAppsClient) deleteHostSecretHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteHostSecretSlot - Description for Delete a host level secret.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHostSecretSlot(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *WebAppsDeleteHostSecretSlotOptions) (WebAppsDeleteHostSecretSlotResponse, error) {
	req, err := client.deleteHostSecretSlotCreateRequest(ctx, resourceGroupName, name, keyType, keyName, slot, options)
	if err != nil {
		return WebAppsDeleteHostSecretSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteHostSecretSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteHostSecretSlotResponse{}, client.deleteHostSecretSlotHandleError(resp)
	}
	return WebAppsDeleteHostSecretSlotResponse{RawResponse: resp}, nil
}

// deleteHostSecretSlotCreateRequest creates the DeleteHostSecretSlot request.
func (client *WebAppsClient) deleteHostSecretSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, keyType string, keyName string, slot string, options *WebAppsDeleteHostSecretSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/{keyType}/{keyName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if keyType == "" {
		return nil, errors.New("parameter keyType cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyType}", url.PathEscape(keyType))
	if keyName == "" {
		return nil, errors.New("parameter keyName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{keyName}", url.PathEscape(keyName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHostSecretSlotHandleError handles the DeleteHostSecretSlot error response.
func (client *WebAppsClient) deleteHostSecretSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteHybridConnection - Description for Removes a Hybrid Connection from this site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsDeleteHybridConnectionOptions) (WebAppsDeleteHybridConnectionResponse, error) {
	req, err := client.deleteHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return WebAppsDeleteHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteHybridConnectionResponse{}, client.deleteHybridConnectionHandleError(resp)
	}
	return WebAppsDeleteHybridConnectionResponse{RawResponse: resp}, nil
}

// deleteHybridConnectionCreateRequest creates the DeleteHybridConnection request.
func (client *WebAppsClient) deleteHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsDeleteHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHybridConnectionHandleError handles the DeleteHybridConnection error response.
func (client *WebAppsClient) deleteHybridConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteHybridConnectionSlot - Description for Removes a Hybrid Connection from this site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsDeleteHybridConnectionSlotOptions) (WebAppsDeleteHybridConnectionSlotResponse, error) {
	req, err := client.deleteHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return WebAppsDeleteHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteHybridConnectionSlotResponse{}, client.deleteHybridConnectionSlotHandleError(resp)
	}
	return WebAppsDeleteHybridConnectionSlotResponse{RawResponse: resp}, nil
}

// deleteHybridConnectionSlotCreateRequest creates the DeleteHybridConnectionSlot request.
func (client *WebAppsClient) deleteHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsDeleteHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHybridConnectionSlotHandleError handles the DeleteHybridConnectionSlot error response.
func (client *WebAppsClient) deleteHybridConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteInstanceFunctionSlot - Description for Delete a function for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsDeleteInstanceFunctionSlotOptions) (WebAppsDeleteInstanceFunctionSlotResponse, error) {
	req, err := client.deleteInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsDeleteInstanceFunctionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteInstanceFunctionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteInstanceFunctionSlotResponse{}, client.deleteInstanceFunctionSlotHandleError(resp)
	}
	return WebAppsDeleteInstanceFunctionSlotResponse{RawResponse: resp}, nil
}

// deleteInstanceFunctionSlotCreateRequest creates the DeleteInstanceFunctionSlot request.
func (client *WebAppsClient) deleteInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsDeleteInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteInstanceFunctionSlotHandleError handles the DeleteInstanceFunctionSlot error response.
func (client *WebAppsClient) deleteInstanceFunctionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteInstanceProcess - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web
// site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsDeleteInstanceProcessOptions) (WebAppsDeleteInstanceProcessResponse, error) {
	req, err := client.deleteInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return WebAppsDeleteInstanceProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteInstanceProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteInstanceProcessResponse{}, client.deleteInstanceProcessHandleError(resp)
	}
	return WebAppsDeleteInstanceProcessResponse{RawResponse: resp}, nil
}

// deleteInstanceProcessCreateRequest creates the DeleteInstanceProcess request.
func (client *WebAppsClient) deleteInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsDeleteInstanceProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteInstanceProcessHandleError handles the DeleteInstanceProcess error response.
func (client *WebAppsClient) deleteInstanceProcessHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteInstanceProcessSlot - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a
// web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsDeleteInstanceProcessSlotOptions) (WebAppsDeleteInstanceProcessSlotResponse, error) {
	req, err := client.deleteInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return WebAppsDeleteInstanceProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteInstanceProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteInstanceProcessSlotResponse{}, client.deleteInstanceProcessSlotHandleError(resp)
	}
	return WebAppsDeleteInstanceProcessSlotResponse{RawResponse: resp}, nil
}

// deleteInstanceProcessSlotCreateRequest creates the DeleteInstanceProcessSlot request.
func (client *WebAppsClient) deleteInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsDeleteInstanceProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteInstanceProcessSlotHandleError handles the DeleteInstanceProcessSlot error response.
func (client *WebAppsClient) deleteInstanceProcessSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeletePremierAddOn - Description for Delete a premier add-on from an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsDeletePremierAddOnOptions) (WebAppsDeletePremierAddOnResponse, error) {
	req, err := client.deletePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return WebAppsDeletePremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeletePremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeletePremierAddOnResponse{}, client.deletePremierAddOnHandleError(resp)
	}
	return WebAppsDeletePremierAddOnResponse{RawResponse: resp}, nil
}

// deletePremierAddOnCreateRequest creates the DeletePremierAddOn request.
func (client *WebAppsClient) deletePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsDeletePremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePremierAddOnHandleError handles the DeletePremierAddOn error response.
func (client *WebAppsClient) deletePremierAddOnHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeletePremierAddOnSlot - Description for Delete a premier add-on from an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsDeletePremierAddOnSlotOptions) (WebAppsDeletePremierAddOnSlotResponse, error) {
	req, err := client.deletePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return WebAppsDeletePremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeletePremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeletePremierAddOnSlotResponse{}, client.deletePremierAddOnSlotHandleError(resp)
	}
	return WebAppsDeletePremierAddOnSlotResponse{RawResponse: resp}, nil
}

// deletePremierAddOnSlotCreateRequest creates the DeletePremierAddOnSlot request.
func (client *WebAppsClient) deletePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsDeletePremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePremierAddOnSlotHandleError handles the DeletePremierAddOnSlot error response.
func (client *WebAppsClient) deletePremierAddOnSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginDeletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsBeginDeletePrivateEndpointConnectionOptions) (WebAppsDeletePrivateEndpointConnectionPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnection(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return WebAppsDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result := WebAppsDeletePrivateEndpointConnectionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.DeletePrivateEndpointConnection", "", resp, client.pl, client.deletePrivateEndpointConnectionHandleError)
	if err != nil {
		return WebAppsDeletePrivateEndpointConnectionPollerResponse{}, err
	}
	result.Poller = &WebAppsDeletePrivateEndpointConnectionPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePrivateEndpointConnection - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) deletePrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsBeginDeletePrivateEndpointConnectionOptions) (*http.Response, error) {
	req, err := client.deletePrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePrivateEndpointConnectionHandleError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionCreateRequest creates the DeletePrivateEndpointConnection request.
func (client *WebAppsClient) deletePrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsBeginDeletePrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePrivateEndpointConnectionHandleError handles the DeletePrivateEndpointConnection error response.
func (client *WebAppsClient) deletePrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginDeletePrivateEndpointConnectionSlot - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginDeletePrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsBeginDeletePrivateEndpointConnectionSlotOptions) (WebAppsDeletePrivateEndpointConnectionSlotPollerResponse, error) {
	resp, err := client.deletePrivateEndpointConnectionSlot(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return WebAppsDeletePrivateEndpointConnectionSlotPollerResponse{}, err
	}
	result := WebAppsDeletePrivateEndpointConnectionSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.DeletePrivateEndpointConnectionSlot", "", resp, client.pl, client.deletePrivateEndpointConnectionSlotHandleError)
	if err != nil {
		return WebAppsDeletePrivateEndpointConnectionSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsDeletePrivateEndpointConnectionSlotPoller{
		pt: pt,
	}
	return result, nil
}

// DeletePrivateEndpointConnectionSlot - Description for Deletes a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsBeginDeletePrivateEndpointConnectionSlotOptions) (*http.Response, error) {
	req, err := client.deletePrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deletePrivateEndpointConnectionSlotHandleError(resp)
	}
	return resp, nil
}

// deletePrivateEndpointConnectionSlotCreateRequest creates the DeletePrivateEndpointConnectionSlot request.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsBeginDeletePrivateEndpointConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePrivateEndpointConnectionSlotHandleError handles the DeletePrivateEndpointConnectionSlot error response.
func (client *WebAppsClient) deletePrivateEndpointConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteProcess - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsDeleteProcessOptions) (WebAppsDeleteProcessResponse, error) {
	req, err := client.deleteProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return WebAppsDeleteProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteProcessResponse{}, client.deleteProcessHandleError(resp)
	}
	return WebAppsDeleteProcessResponse{RawResponse: resp}, nil
}

// deleteProcessCreateRequest creates the DeleteProcess request.
func (client *WebAppsClient) deleteProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsDeleteProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProcessHandleError handles the DeleteProcess error response.
func (client *WebAppsClient) deleteProcessHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteProcessSlot - Description for Terminate a process by its ID for a web site, or a deployment slot, or specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsDeleteProcessSlotOptions) (WebAppsDeleteProcessSlotResponse, error) {
	req, err := client.deleteProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return WebAppsDeleteProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteProcessSlotResponse{}, client.deleteProcessSlotHandleError(resp)
	}
	return WebAppsDeleteProcessSlotResponse{RawResponse: resp}, nil
}

// deleteProcessSlotCreateRequest creates the DeleteProcessSlot request.
func (client *WebAppsClient) deleteProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsDeleteProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteProcessSlotHandleError handles the DeleteProcessSlot error response.
func (client *WebAppsClient) deleteProcessSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeletePublicCertificate - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsDeletePublicCertificateOptions) (WebAppsDeletePublicCertificateResponse, error) {
	req, err := client.deletePublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return WebAppsDeletePublicCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeletePublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeletePublicCertificateResponse{}, client.deletePublicCertificateHandleError(resp)
	}
	return WebAppsDeletePublicCertificateResponse{RawResponse: resp}, nil
}

// deletePublicCertificateCreateRequest creates the DeletePublicCertificate request.
func (client *WebAppsClient) deletePublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsDeletePublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePublicCertificateHandleError handles the DeletePublicCertificate error response.
func (client *WebAppsClient) deletePublicCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeletePublicCertificateSlot - Description for Deletes a hostname binding for an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeletePublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsDeletePublicCertificateSlotOptions) (WebAppsDeletePublicCertificateSlotResponse, error) {
	req, err := client.deletePublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return WebAppsDeletePublicCertificateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeletePublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeletePublicCertificateSlotResponse{}, client.deletePublicCertificateSlotHandleError(resp)
	}
	return WebAppsDeletePublicCertificateSlotResponse{RawResponse: resp}, nil
}

// deletePublicCertificateSlotCreateRequest creates the DeletePublicCertificateSlot request.
func (client *WebAppsClient) deletePublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsDeletePublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deletePublicCertificateSlotHandleError handles the DeletePublicCertificateSlot error response.
func (client *WebAppsClient) deletePublicCertificateSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteRelayServiceConnection - Description for Deletes a relay service connection by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsDeleteRelayServiceConnectionOptions) (WebAppsDeleteRelayServiceConnectionResponse, error) {
	req, err := client.deleteRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return WebAppsDeleteRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteRelayServiceConnectionResponse{}, client.deleteRelayServiceConnectionHandleError(resp)
	}
	return WebAppsDeleteRelayServiceConnectionResponse{RawResponse: resp}, nil
}

// deleteRelayServiceConnectionCreateRequest creates the DeleteRelayServiceConnection request.
func (client *WebAppsClient) deleteRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsDeleteRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteRelayServiceConnectionHandleError handles the DeleteRelayServiceConnection error response.
func (client *WebAppsClient) deleteRelayServiceConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteRelayServiceConnectionSlot - Description for Deletes a relay service connection by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsDeleteRelayServiceConnectionSlotOptions) (WebAppsDeleteRelayServiceConnectionSlotResponse, error) {
	req, err := client.deleteRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return WebAppsDeleteRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteRelayServiceConnectionSlotResponse{}, client.deleteRelayServiceConnectionSlotHandleError(resp)
	}
	return WebAppsDeleteRelayServiceConnectionSlotResponse{RawResponse: resp}, nil
}

// deleteRelayServiceConnectionSlotCreateRequest creates the DeleteRelayServiceConnectionSlot request.
func (client *WebAppsClient) deleteRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsDeleteRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteRelayServiceConnectionSlotHandleError handles the DeleteRelayServiceConnectionSlot error response.
func (client *WebAppsClient) deleteRelayServiceConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSiteExtension - Description for Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsDeleteSiteExtensionOptions) (WebAppsDeleteSiteExtensionResponse, error) {
	req, err := client.deleteSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return WebAppsDeleteSiteExtensionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSiteExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteSiteExtensionResponse{}, client.deleteSiteExtensionHandleError(resp)
	}
	return WebAppsDeleteSiteExtensionResponse{RawResponse: resp}, nil
}

// deleteSiteExtensionCreateRequest creates the DeleteSiteExtension request.
func (client *WebAppsClient) deleteSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsDeleteSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSiteExtensionHandleError handles the DeleteSiteExtension error response.
func (client *WebAppsClient) deleteSiteExtensionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSiteExtensionSlot - Description for Remove a site extension from a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsDeleteSiteExtensionSlotOptions) (WebAppsDeleteSiteExtensionSlotResponse, error) {
	req, err := client.deleteSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return WebAppsDeleteSiteExtensionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSiteExtensionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsDeleteSiteExtensionSlotResponse{}, client.deleteSiteExtensionSlotHandleError(resp)
	}
	return WebAppsDeleteSiteExtensionSlotResponse{RawResponse: resp}, nil
}

// deleteSiteExtensionSlotCreateRequest creates the DeleteSiteExtensionSlot request.
func (client *WebAppsClient) deleteSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsDeleteSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSiteExtensionSlotHandleError handles the DeleteSiteExtensionSlot error response.
func (client *WebAppsClient) deleteSiteExtensionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSlot - Description for Deletes a web, mobile, or API app, or one of the deployment slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSlotOptions) (WebAppsDeleteSlotResponse, error) {
	req, err := client.deleteSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsDeleteSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteSlotResponse{}, client.deleteSlotHandleError(resp)
	}
	return WebAppsDeleteSlotResponse{RawResponse: resp}, nil
}

// deleteSlotCreateRequest creates the DeleteSlot request.
func (client *WebAppsClient) deleteSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DeleteMetrics != nil {
		reqQP.Set("deleteMetrics", strconv.FormatBool(*options.DeleteMetrics))
	}
	if options != nil && options.DeleteEmptyServerFarm != nil {
		reqQP.Set("deleteEmptyServerFarm", strconv.FormatBool(*options.DeleteEmptyServerFarm))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSlotHandleError handles the DeleteSlot error response.
func (client *WebAppsClient) deleteSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSourceControl - Description for Deletes the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSourceControl(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSourceControlOptions) (WebAppsDeleteSourceControlResponse, error) {
	req, err := client.deleteSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsDeleteSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsDeleteSourceControlResponse{}, client.deleteSourceControlHandleError(resp)
	}
	return WebAppsDeleteSourceControlResponse{RawResponse: resp}, nil
}

// deleteSourceControlCreateRequest creates the DeleteSourceControl request.
func (client *WebAppsClient) deleteSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AdditionalFlags != nil {
		reqQP.Set("additionalFlags", *options.AdditionalFlags)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSourceControlHandleError handles the DeleteSourceControl error response.
func (client *WebAppsClient) deleteSourceControlHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSourceControlSlot - Description for Deletes the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSourceControlSlotOptions) (WebAppsDeleteSourceControlSlotResponse, error) {
	req, err := client.deleteSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsDeleteSourceControlSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsDeleteSourceControlSlotResponse{}, client.deleteSourceControlSlotHandleError(resp)
	}
	return WebAppsDeleteSourceControlSlotResponse{RawResponse: resp}, nil
}

// deleteSourceControlSlotCreateRequest creates the DeleteSourceControlSlot request.
func (client *WebAppsClient) deleteSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.AdditionalFlags != nil {
		reqQP.Set("additionalFlags", *options.AdditionalFlags)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSourceControlSlotHandleError handles the DeleteSourceControlSlot error response.
func (client *WebAppsClient) deleteSourceControlSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSwiftVirtualNetwork - Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSwiftVirtualNetwork(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSwiftVirtualNetworkOptions) (WebAppsDeleteSwiftVirtualNetworkResponse, error) {
	req, err := client.deleteSwiftVirtualNetworkCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsDeleteSwiftVirtualNetworkResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSwiftVirtualNetworkResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteSwiftVirtualNetworkResponse{}, client.deleteSwiftVirtualNetworkHandleError(resp)
	}
	return WebAppsDeleteSwiftVirtualNetworkResponse{RawResponse: resp}, nil
}

// deleteSwiftVirtualNetworkCreateRequest creates the DeleteSwiftVirtualNetwork request.
func (client *WebAppsClient) deleteSwiftVirtualNetworkCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsDeleteSwiftVirtualNetworkOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSwiftVirtualNetworkHandleError handles the DeleteSwiftVirtualNetwork error response.
func (client *WebAppsClient) deleteSwiftVirtualNetworkHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteSwiftVirtualNetworkSlot - Description for Deletes a Swift Virtual Network connection from an app (or deployment slot).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteSwiftVirtualNetworkSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSwiftVirtualNetworkSlotOptions) (WebAppsDeleteSwiftVirtualNetworkSlotResponse, error) {
	req, err := client.deleteSwiftVirtualNetworkSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteSwiftVirtualNetworkSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteSwiftVirtualNetworkSlotResponse{}, client.deleteSwiftVirtualNetworkSlotHandleError(resp)
	}
	return WebAppsDeleteSwiftVirtualNetworkSlotResponse{RawResponse: resp}, nil
}

// deleteSwiftVirtualNetworkSlotCreateRequest creates the DeleteSwiftVirtualNetworkSlot request.
func (client *WebAppsClient) deleteSwiftVirtualNetworkSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsDeleteSwiftVirtualNetworkSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteSwiftVirtualNetworkSlotHandleError handles the DeleteSwiftVirtualNetworkSlot error response.
func (client *WebAppsClient) deleteSwiftVirtualNetworkSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteTriggeredWebJob - Description for Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteTriggeredWebJobOptions) (WebAppsDeleteTriggeredWebJobResponse, error) {
	req, err := client.deleteTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsDeleteTriggeredWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteTriggeredWebJobResponse{}, client.deleteTriggeredWebJobHandleError(resp)
	}
	return WebAppsDeleteTriggeredWebJobResponse{RawResponse: resp}, nil
}

// deleteTriggeredWebJobCreateRequest creates the DeleteTriggeredWebJob request.
func (client *WebAppsClient) deleteTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsDeleteTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteTriggeredWebJobHandleError handles the DeleteTriggeredWebJob error response.
func (client *WebAppsClient) deleteTriggeredWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteTriggeredWebJobSlot - Description for Delete a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteTriggeredWebJobSlotOptions) (WebAppsDeleteTriggeredWebJobSlotResponse, error) {
	req, err := client.deleteTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsDeleteTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsDeleteTriggeredWebJobSlotResponse{}, client.deleteTriggeredWebJobSlotHandleError(resp)
	}
	return WebAppsDeleteTriggeredWebJobSlotResponse{RawResponse: resp}, nil
}

// deleteTriggeredWebJobSlotCreateRequest creates the DeleteTriggeredWebJobSlot request.
func (client *WebAppsClient) deleteTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsDeleteTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteTriggeredWebJobSlotHandleError handles the DeleteTriggeredWebJobSlot error response.
func (client *WebAppsClient) deleteTriggeredWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DeleteVnetConnection - Description for Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsDeleteVnetConnectionOptions) (WebAppsDeleteVnetConnectionResponse, error) {
	req, err := client.deleteVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return WebAppsDeleteVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteVnetConnectionResponse{}, client.deleteVnetConnectionHandleError(resp)
	}
	return WebAppsDeleteVnetConnectionResponse{RawResponse: resp}, nil
}

// deleteVnetConnectionCreateRequest creates the DeleteVnetConnection request.
func (client *WebAppsClient) deleteVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsDeleteVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteVnetConnectionHandleError handles the DeleteVnetConnection error response.
func (client *WebAppsClient) deleteVnetConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DeleteVnetConnectionSlot - Description for Deletes a connection from an app (or deployment slot to a named virtual network.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DeleteVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsDeleteVnetConnectionSlotOptions) (WebAppsDeleteVnetConnectionSlotResponse, error) {
	req, err := client.deleteVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return WebAppsDeleteVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDeleteVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDeleteVnetConnectionSlotResponse{}, client.deleteVnetConnectionSlotHandleError(resp)
	}
	return WebAppsDeleteVnetConnectionSlotResponse{RawResponse: resp}, nil
}

// deleteVnetConnectionSlotCreateRequest creates the DeleteVnetConnectionSlot request.
func (client *WebAppsClient) deleteVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsDeleteVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// deleteVnetConnectionSlotHandleError handles the DeleteVnetConnectionSlot error response.
func (client *WebAppsClient) deleteVnetConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// DiscoverBackup - Description for Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get information about
// the databases stored in a backup.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DiscoverBackup(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsDiscoverBackupOptions) (WebAppsDiscoverBackupResponse, error) {
	req, err := client.discoverBackupCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsDiscoverBackupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDiscoverBackupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDiscoverBackupResponse{}, client.discoverBackupHandleError(resp)
	}
	return client.discoverBackupHandleResponse(resp)
}

// discoverBackupCreateRequest creates the DiscoverBackup request.
func (client *WebAppsClient) discoverBackupCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsDiscoverBackupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// discoverBackupHandleResponse handles the DiscoverBackup response.
func (client *WebAppsClient) discoverBackupHandleResponse(resp *http.Response) (WebAppsDiscoverBackupResponse, error) {
	result := WebAppsDiscoverBackupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreRequest); err != nil {
		return WebAppsDiscoverBackupResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// discoverBackupHandleError handles the DiscoverBackup error response.
func (client *WebAppsClient) discoverBackupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// DiscoverBackupSlot - Description for Discovers an existing app backup that can be restored from a blob in Azure storage. Use this to get information
// about the databases stored in a backup.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) DiscoverBackupSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsDiscoverBackupSlotOptions) (WebAppsDiscoverBackupSlotResponse, error) {
	req, err := client.discoverBackupSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsDiscoverBackupSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsDiscoverBackupSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsDiscoverBackupSlotResponse{}, client.discoverBackupSlotHandleError(resp)
	}
	return client.discoverBackupSlotHandleResponse(resp)
}

// discoverBackupSlotCreateRequest creates the DiscoverBackupSlot request.
func (client *WebAppsClient) discoverBackupSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsDiscoverBackupSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/discoverbackup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// discoverBackupSlotHandleResponse handles the DiscoverBackupSlot response.
func (client *WebAppsClient) discoverBackupSlotHandleResponse(resp *http.Response) (WebAppsDiscoverBackupSlotResponse, error) {
	result := WebAppsDiscoverBackupSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RestoreRequest); err != nil {
		return WebAppsDiscoverBackupSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// discoverBackupSlotHandleError handles the DiscoverBackupSlot error response.
func (client *WebAppsClient) discoverBackupSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GenerateNewSitePublishingPassword - Description for Generates a new publishing password for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GenerateNewSitePublishingPassword(ctx context.Context, resourceGroupName string, name string, options *WebAppsGenerateNewSitePublishingPasswordOptions) (WebAppsGenerateNewSitePublishingPasswordResponse, error) {
	req, err := client.generateNewSitePublishingPasswordCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGenerateNewSitePublishingPasswordResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGenerateNewSitePublishingPasswordResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsGenerateNewSitePublishingPasswordResponse{}, client.generateNewSitePublishingPasswordHandleError(resp)
	}
	return WebAppsGenerateNewSitePublishingPasswordResponse{RawResponse: resp}, nil
}

// generateNewSitePublishingPasswordCreateRequest creates the GenerateNewSitePublishingPassword request.
func (client *WebAppsClient) generateNewSitePublishingPasswordCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGenerateNewSitePublishingPasswordOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// generateNewSitePublishingPasswordHandleError handles the GenerateNewSitePublishingPassword error response.
func (client *WebAppsClient) generateNewSitePublishingPasswordHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GenerateNewSitePublishingPasswordSlot - Description for Generates a new publishing password for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GenerateNewSitePublishingPasswordSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGenerateNewSitePublishingPasswordSlotOptions) (WebAppsGenerateNewSitePublishingPasswordSlotResponse, error) {
	req, err := client.generateNewSitePublishingPasswordSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGenerateNewSitePublishingPasswordSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsGenerateNewSitePublishingPasswordSlotResponse{}, client.generateNewSitePublishingPasswordSlotHandleError(resp)
	}
	return WebAppsGenerateNewSitePublishingPasswordSlotResponse{RawResponse: resp}, nil
}

// generateNewSitePublishingPasswordSlotCreateRequest creates the GenerateNewSitePublishingPasswordSlot request.
func (client *WebAppsClient) generateNewSitePublishingPasswordSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGenerateNewSitePublishingPasswordSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/newpassword"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// generateNewSitePublishingPasswordSlotHandleError handles the GenerateNewSitePublishingPasswordSlot error response.
func (client *WebAppsClient) generateNewSitePublishingPasswordSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Get - Description for Gets the details of a web, mobile, or API app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Get(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetOptions) (WebAppsGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *WebAppsClient) getCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *WebAppsClient) getHandleResponse(resp *http.Response) (WebAppsGetResponse, error) {
	result := WebAppsGetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsGetResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHandleError handles the Get error response.
func (client *WebAppsClient) getHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetAppSettingKeyVaultReference - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingKeyVaultReference(ctx context.Context, resourceGroupName string, name string, appSettingKey string, options *WebAppsGetAppSettingKeyVaultReferenceOptions) (WebAppsGetAppSettingKeyVaultReferenceResponse, error) {
	req, err := client.getAppSettingKeyVaultReferenceCreateRequest(ctx, resourceGroupName, name, appSettingKey, options)
	if err != nil {
		return WebAppsGetAppSettingKeyVaultReferenceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetAppSettingKeyVaultReferenceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetAppSettingKeyVaultReferenceResponse{}, client.getAppSettingKeyVaultReferenceHandleError(resp)
	}
	return client.getAppSettingKeyVaultReferenceHandleResponse(resp)
}

// getAppSettingKeyVaultReferenceCreateRequest creates the GetAppSettingKeyVaultReference request.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettingKey string, options *WebAppsGetAppSettingKeyVaultReferenceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings/{appSettingKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if appSettingKey == "" {
		return nil, errors.New("parameter appSettingKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{appSettingKey}", url.PathEscape(appSettingKey))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingKeyVaultReferenceHandleResponse handles the GetAppSettingKeyVaultReference response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceHandleResponse(resp *http.Response) (WebAppsGetAppSettingKeyVaultReferenceResponse, error) {
	result := WebAppsGetAppSettingKeyVaultReferenceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsGetAppSettingKeyVaultReferenceResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAppSettingKeyVaultReferenceHandleError handles the GetAppSettingKeyVaultReference error response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAppSettingKeyVaultReferenceSlot - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingKeyVaultReferenceSlot(ctx context.Context, resourceGroupName string, name string, appSettingKey string, slot string, options *WebAppsGetAppSettingKeyVaultReferenceSlotOptions) (WebAppsGetAppSettingKeyVaultReferenceSlotResponse, error) {
	req, err := client.getAppSettingKeyVaultReferenceSlotCreateRequest(ctx, resourceGroupName, name, appSettingKey, slot, options)
	if err != nil {
		return WebAppsGetAppSettingKeyVaultReferenceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetAppSettingKeyVaultReferenceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetAppSettingKeyVaultReferenceSlotResponse{}, client.getAppSettingKeyVaultReferenceSlotHandleError(resp)
	}
	return client.getAppSettingKeyVaultReferenceSlotHandleResponse(resp)
}

// getAppSettingKeyVaultReferenceSlotCreateRequest creates the GetAppSettingKeyVaultReferenceSlot request.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettingKey string, slot string, options *WebAppsGetAppSettingKeyVaultReferenceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings/{appSettingKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if appSettingKey == "" {
		return nil, errors.New("parameter appSettingKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{appSettingKey}", url.PathEscape(appSettingKey))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingKeyVaultReferenceSlotHandleResponse handles the GetAppSettingKeyVaultReferenceSlot response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotHandleResponse(resp *http.Response) (WebAppsGetAppSettingKeyVaultReferenceSlotResponse, error) {
	result := WebAppsGetAppSettingKeyVaultReferenceSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsGetAppSettingKeyVaultReferenceSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAppSettingKeyVaultReferenceSlotHandleError handles the GetAppSettingKeyVaultReferenceSlot error response.
func (client *WebAppsClient) getAppSettingKeyVaultReferenceSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAppSettingsKeyVaultReferences - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingsKeyVaultReferences(resourceGroupName string, name string, options *WebAppsGetAppSettingsKeyVaultReferencesOptions) *WebAppsGetAppSettingsKeyVaultReferencesPager {
	return &WebAppsGetAppSettingsKeyVaultReferencesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getAppSettingsKeyVaultReferencesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsGetAppSettingsKeyVaultReferencesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
	}
}

// getAppSettingsKeyVaultReferencesCreateRequest creates the GetAppSettingsKeyVaultReferences request.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAppSettingsKeyVaultReferencesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingsKeyVaultReferencesHandleResponse handles the GetAppSettingsKeyVaultReferences response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesHandleResponse(resp *http.Response) (WebAppsGetAppSettingsKeyVaultReferencesResponse, error) {
	result := WebAppsGetAppSettingsKeyVaultReferencesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsGetAppSettingsKeyVaultReferencesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAppSettingsKeyVaultReferencesHandleError handles the GetAppSettingsKeyVaultReferences error response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAppSettingsKeyVaultReferencesSlot - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAppSettingsKeyVaultReferencesSlot(resourceGroupName string, name string, slot string, options *WebAppsGetAppSettingsKeyVaultReferencesSlotOptions) *WebAppsGetAppSettingsKeyVaultReferencesSlotPager {
	return &WebAppsGetAppSettingsKeyVaultReferencesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getAppSettingsKeyVaultReferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsGetAppSettingsKeyVaultReferencesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
	}
}

// getAppSettingsKeyVaultReferencesSlotCreateRequest creates the GetAppSettingsKeyVaultReferencesSlot request.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAppSettingsKeyVaultReferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAppSettingsKeyVaultReferencesSlotHandleResponse handles the GetAppSettingsKeyVaultReferencesSlot response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotHandleResponse(resp *http.Response) (WebAppsGetAppSettingsKeyVaultReferencesSlotResponse, error) {
	result := WebAppsGetAppSettingsKeyVaultReferencesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsGetAppSettingsKeyVaultReferencesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAppSettingsKeyVaultReferencesSlotHandleError handles the GetAppSettingsKeyVaultReferencesSlot error response.
func (client *WebAppsClient) getAppSettingsKeyVaultReferencesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAuthSettings - Description for Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsOptions) (WebAppsGetAuthSettingsResponse, error) {
	req, err := client.getAuthSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetAuthSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetAuthSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetAuthSettingsResponse{}, client.getAuthSettingsHandleError(resp)
	}
	return client.getAuthSettingsHandleResponse(resp)
}

// getAuthSettingsCreateRequest creates the GetAuthSettings request.
func (client *WebAppsClient) getAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsHandleResponse handles the GetAuthSettings response.
func (client *WebAppsClient) getAuthSettingsHandleResponse(resp *http.Response) (WebAppsGetAuthSettingsResponse, error) {
	result := WebAppsGetAuthSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsGetAuthSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAuthSettingsHandleError handles the GetAuthSettings error response.
func (client *WebAppsClient) getAuthSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAuthSettingsSlot - Description for Gets the Authentication/Authorization settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsSlotOptions) (WebAppsGetAuthSettingsSlotResponse, error) {
	req, err := client.getAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetAuthSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetAuthSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetAuthSettingsSlotResponse{}, client.getAuthSettingsSlotHandleError(resp)
	}
	return client.getAuthSettingsSlotHandleResponse(resp)
}

// getAuthSettingsSlotCreateRequest creates the GetAuthSettingsSlot request.
func (client *WebAppsClient) getAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsSlotHandleResponse handles the GetAuthSettingsSlot response.
func (client *WebAppsClient) getAuthSettingsSlotHandleResponse(resp *http.Response) (WebAppsGetAuthSettingsSlotResponse, error) {
	result := WebAppsGetAuthSettingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsGetAuthSettingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAuthSettingsSlotHandleError handles the GetAuthSettingsSlot error response.
func (client *WebAppsClient) getAuthSettingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAuthSettingsV2 - Description for Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettingsV2(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsV2Options) (WebAppsGetAuthSettingsV2Response, error) {
	req, err := client.getAuthSettingsV2CreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetAuthSettingsV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetAuthSettingsV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetAuthSettingsV2Response{}, client.getAuthSettingsV2HandleError(resp)
	}
	return client.getAuthSettingsV2HandleResponse(resp)
}

// getAuthSettingsV2CreateRequest creates the GetAuthSettingsV2 request.
func (client *WebAppsClient) getAuthSettingsV2CreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetAuthSettingsV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsV2HandleResponse handles the GetAuthSettingsV2 response.
func (client *WebAppsClient) getAuthSettingsV2HandleResponse(resp *http.Response) (WebAppsGetAuthSettingsV2Response, error) {
	result := WebAppsGetAuthSettingsV2Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsGetAuthSettingsV2Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAuthSettingsV2HandleError handles the GetAuthSettingsV2 error response.
func (client *WebAppsClient) getAuthSettingsV2HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetAuthSettingsV2Slot - Description for Gets site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetAuthSettingsV2Slot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsV2SlotOptions) (WebAppsGetAuthSettingsV2SlotResponse, error) {
	req, err := client.getAuthSettingsV2SlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetAuthSettingsV2SlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetAuthSettingsV2SlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetAuthSettingsV2SlotResponse{}, client.getAuthSettingsV2SlotHandleError(resp)
	}
	return client.getAuthSettingsV2SlotHandleResponse(resp)
}

// getAuthSettingsV2SlotCreateRequest creates the GetAuthSettingsV2Slot request.
func (client *WebAppsClient) getAuthSettingsV2SlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetAuthSettingsV2SlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getAuthSettingsV2SlotHandleResponse handles the GetAuthSettingsV2Slot response.
func (client *WebAppsClient) getAuthSettingsV2SlotHandleResponse(resp *http.Response) (WebAppsGetAuthSettingsV2SlotResponse, error) {
	result := WebAppsGetAuthSettingsV2SlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsGetAuthSettingsV2SlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getAuthSettingsV2SlotHandleError handles the GetAuthSettingsV2Slot error response.
func (client *WebAppsClient) getAuthSettingsV2SlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBackupConfiguration - Description for Gets the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetBackupConfigurationOptions) (WebAppsGetBackupConfigurationResponse, error) {
	req, err := client.getBackupConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetBackupConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetBackupConfigurationResponse{}, client.getBackupConfigurationHandleError(resp)
	}
	return client.getBackupConfigurationHandleResponse(resp)
}

// getBackupConfigurationCreateRequest creates the GetBackupConfiguration request.
func (client *WebAppsClient) getBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupConfigurationHandleResponse handles the GetBackupConfiguration response.
func (client *WebAppsClient) getBackupConfigurationHandleResponse(resp *http.Response) (WebAppsGetBackupConfigurationResponse, error) {
	result := WebAppsGetBackupConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsGetBackupConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getBackupConfigurationHandleError handles the GetBackupConfiguration error response.
func (client *WebAppsClient) getBackupConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBackupConfigurationSlot - Description for Gets the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetBackupConfigurationSlotOptions) (WebAppsGetBackupConfigurationSlotResponse, error) {
	req, err := client.getBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetBackupConfigurationSlotResponse{}, client.getBackupConfigurationSlotHandleError(resp)
	}
	return client.getBackupConfigurationSlotHandleResponse(resp)
}

// getBackupConfigurationSlotCreateRequest creates the GetBackupConfigurationSlot request.
func (client *WebAppsClient) getBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupConfigurationSlotHandleResponse handles the GetBackupConfigurationSlot response.
func (client *WebAppsClient) getBackupConfigurationSlotHandleResponse(resp *http.Response) (WebAppsGetBackupConfigurationSlotResponse, error) {
	result := WebAppsGetBackupConfigurationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsGetBackupConfigurationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getBackupConfigurationSlotHandleError handles the GetBackupConfigurationSlot error response.
func (client *WebAppsClient) getBackupConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBackupStatus - Description for Gets a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupStatus(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsGetBackupStatusOptions) (WebAppsGetBackupStatusResponse, error) {
	req, err := client.getBackupStatusCreateRequest(ctx, resourceGroupName, name, backupID, options)
	if err != nil {
		return WebAppsGetBackupStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetBackupStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetBackupStatusResponse{}, client.getBackupStatusHandleError(resp)
	}
	return client.getBackupStatusHandleResponse(resp)
}

// getBackupStatusCreateRequest creates the GetBackupStatus request.
func (client *WebAppsClient) getBackupStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, options *WebAppsGetBackupStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupStatusHandleResponse handles the GetBackupStatus response.
func (client *WebAppsClient) getBackupStatusHandleResponse(resp *http.Response) (WebAppsGetBackupStatusResponse, error) {
	result := WebAppsGetBackupStatusResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsGetBackupStatusResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getBackupStatusHandleError handles the GetBackupStatus error response.
func (client *WebAppsClient) getBackupStatusHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetBackupStatusSlot - Description for Gets a backup of an app by its ID.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetBackupStatusSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsGetBackupStatusSlotOptions) (WebAppsGetBackupStatusSlotResponse, error) {
	req, err := client.getBackupStatusSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, options)
	if err != nil {
		return WebAppsGetBackupStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetBackupStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetBackupStatusSlotResponse{}, client.getBackupStatusSlotHandleError(resp)
	}
	return client.getBackupStatusSlotHandleResponse(resp)
}

// getBackupStatusSlotCreateRequest creates the GetBackupStatusSlot request.
func (client *WebAppsClient) getBackupStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, options *WebAppsGetBackupStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getBackupStatusSlotHandleResponse handles the GetBackupStatusSlot response.
func (client *WebAppsClient) getBackupStatusSlotHandleResponse(resp *http.Response) (WebAppsGetBackupStatusSlotResponse, error) {
	result := WebAppsGetBackupStatusSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsGetBackupStatusSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getBackupStatusSlotHandleError handles the GetBackupStatusSlot error response.
func (client *WebAppsClient) getBackupStatusSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetConfiguration - Description for Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications, Always
// On, etc.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetConfigurationOptions) (WebAppsGetConfigurationResponse, error) {
	req, err := client.getConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetConfigurationResponse{}, client.getConfigurationHandleError(resp)
	}
	return client.getConfigurationHandleResponse(resp)
}

// getConfigurationCreateRequest creates the GetConfiguration request.
func (client *WebAppsClient) getConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationHandleResponse handles the GetConfiguration response.
func (client *WebAppsClient) getConfigurationHandleResponse(resp *http.Response) (WebAppsGetConfigurationResponse, error) {
	result := WebAppsGetConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsGetConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getConfigurationHandleError handles the GetConfiguration error response.
func (client *WebAppsClient) getConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetConfigurationSlot - Description for Gets the configuration of an app, such as platform version and bitness, default documents, virtual applications,
// Always On, etc.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetConfigurationSlotOptions) (WebAppsGetConfigurationSlotResponse, error) {
	req, err := client.getConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetConfigurationSlotResponse{}, client.getConfigurationSlotHandleError(resp)
	}
	return client.getConfigurationSlotHandleResponse(resp)
}

// getConfigurationSlotCreateRequest creates the GetConfigurationSlot request.
func (client *WebAppsClient) getConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationSlotHandleResponse handles the GetConfigurationSlot response.
func (client *WebAppsClient) getConfigurationSlotHandleResponse(resp *http.Response) (WebAppsGetConfigurationSlotResponse, error) {
	result := WebAppsGetConfigurationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsGetConfigurationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getConfigurationSlotHandleError handles the GetConfigurationSlot error response.
func (client *WebAppsClient) getConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetConfigurationSnapshot - Description for Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsGetConfigurationSnapshotOptions) (WebAppsGetConfigurationSnapshotResponse, error) {
	req, err := client.getConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return WebAppsGetConfigurationSnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetConfigurationSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetConfigurationSnapshotResponse{}, client.getConfigurationSnapshotHandleError(resp)
	}
	return client.getConfigurationSnapshotHandleResponse(resp)
}

// getConfigurationSnapshotCreateRequest creates the GetConfigurationSnapshot request.
func (client *WebAppsClient) getConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsGetConfigurationSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationSnapshotHandleResponse handles the GetConfigurationSnapshot response.
func (client *WebAppsClient) getConfigurationSnapshotHandleResponse(resp *http.Response) (WebAppsGetConfigurationSnapshotResponse, error) {
	result := WebAppsGetConfigurationSnapshotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsGetConfigurationSnapshotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getConfigurationSnapshotHandleError handles the GetConfigurationSnapshot error response.
func (client *WebAppsClient) getConfigurationSnapshotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetConfigurationSnapshotSlot - Description for Gets a snapshot of the configuration of an app at a previous point in time.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsGetConfigurationSnapshotSlotOptions) (WebAppsGetConfigurationSnapshotSlotResponse, error) {
	req, err := client.getConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return WebAppsGetConfigurationSnapshotSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetConfigurationSnapshotSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetConfigurationSnapshotSlotResponse{}, client.getConfigurationSnapshotSlotHandleError(resp)
	}
	return client.getConfigurationSnapshotSlotHandleResponse(resp)
}

// getConfigurationSnapshotSlotCreateRequest creates the GetConfigurationSnapshotSlot request.
func (client *WebAppsClient) getConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsGetConfigurationSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getConfigurationSnapshotSlotHandleResponse handles the GetConfigurationSnapshotSlot response.
func (client *WebAppsClient) getConfigurationSnapshotSlotHandleResponse(resp *http.Response) (WebAppsGetConfigurationSnapshotSlotResponse, error) {
	result := WebAppsGetConfigurationSnapshotSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsGetConfigurationSnapshotSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getConfigurationSnapshotSlotHandleError handles the GetConfigurationSnapshotSlot error response.
func (client *WebAppsClient) getConfigurationSnapshotSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetContainerLogsZip - Description for Gets the ZIP archived docker log files for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetContainerLogsZip(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetContainerLogsZipOptions) (WebAppsGetContainerLogsZipResponse, error) {
	req, err := client.getContainerLogsZipCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetContainerLogsZipResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetContainerLogsZipResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsGetContainerLogsZipResponse{}, client.getContainerLogsZipHandleError(resp)
	}
	return WebAppsGetContainerLogsZipResponse{RawResponse: resp}, nil
}

// getContainerLogsZipCreateRequest creates the GetContainerLogsZip request.
func (client *WebAppsClient) getContainerLogsZipCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetContainerLogsZipOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/zip")
	return req, nil
}

// getContainerLogsZipHandleError handles the GetContainerLogsZip error response.
func (client *WebAppsClient) getContainerLogsZipHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetContainerLogsZipSlot - Description for Gets the ZIP archived docker log files for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetContainerLogsZipSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetContainerLogsZipSlotOptions) (WebAppsGetContainerLogsZipSlotResponse, error) {
	req, err := client.getContainerLogsZipSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetContainerLogsZipSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetContainerLogsZipSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsGetContainerLogsZipSlotResponse{}, client.getContainerLogsZipSlotHandleError(resp)
	}
	return WebAppsGetContainerLogsZipSlotResponse{RawResponse: resp}, nil
}

// getContainerLogsZipSlotCreateRequest creates the GetContainerLogsZipSlot request.
func (client *WebAppsClient) getContainerLogsZipSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetContainerLogsZipSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs/zip/download"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/zip")
	return req, nil
}

// getContainerLogsZipSlotHandleError handles the GetContainerLogsZipSlot error response.
func (client *WebAppsClient) getContainerLogsZipSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetContinuousWebJob - Description for Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetContinuousWebJobOptions) (WebAppsGetContinuousWebJobResponse, error) {
	req, err := client.getContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsGetContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetContinuousWebJobResponse{}, client.getContinuousWebJobHandleError(resp)
	}
	return client.getContinuousWebJobHandleResponse(resp)
}

// getContinuousWebJobCreateRequest creates the GetContinuousWebJob request.
func (client *WebAppsClient) getContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getContinuousWebJobHandleResponse handles the GetContinuousWebJob response.
func (client *WebAppsClient) getContinuousWebJobHandleResponse(resp *http.Response) (WebAppsGetContinuousWebJobResponse, error) {
	result := WebAppsGetContinuousWebJobResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJob); err != nil {
		return WebAppsGetContinuousWebJobResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getContinuousWebJobHandleError handles the GetContinuousWebJob error response.
func (client *WebAppsClient) getContinuousWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetContinuousWebJobSlot - Description for Gets a continuous web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetContinuousWebJobSlotOptions) (WebAppsGetContinuousWebJobSlotResponse, error) {
	req, err := client.getContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsGetContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetContinuousWebJobSlotResponse{}, client.getContinuousWebJobSlotHandleError(resp)
	}
	return client.getContinuousWebJobSlotHandleResponse(resp)
}

// getContinuousWebJobSlotCreateRequest creates the GetContinuousWebJobSlot request.
func (client *WebAppsClient) getContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getContinuousWebJobSlotHandleResponse handles the GetContinuousWebJobSlot response.
func (client *WebAppsClient) getContinuousWebJobSlotHandleResponse(resp *http.Response) (WebAppsGetContinuousWebJobSlotResponse, error) {
	result := WebAppsGetContinuousWebJobSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJob); err != nil {
		return WebAppsGetContinuousWebJobSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getContinuousWebJobSlotHandleError handles the GetContinuousWebJobSlot error response.
func (client *WebAppsClient) getContinuousWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetDeployment - Description for Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDeployment(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsGetDeploymentOptions) (WebAppsGetDeploymentResponse, error) {
	req, err := client.getDeploymentCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return WebAppsGetDeploymentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetDeploymentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetDeploymentResponse{}, client.getDeploymentHandleError(resp)
	}
	return client.getDeploymentHandleResponse(resp)
}

// getDeploymentCreateRequest creates the GetDeployment request.
func (client *WebAppsClient) getDeploymentCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsGetDeploymentOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDeploymentHandleResponse handles the GetDeployment response.
func (client *WebAppsClient) getDeploymentHandleResponse(resp *http.Response) (WebAppsGetDeploymentResponse, error) {
	result := WebAppsGetDeploymentResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsGetDeploymentResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDeploymentHandleError handles the GetDeployment error response.
func (client *WebAppsClient) getDeploymentHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDeploymentSlot - Description for Get a deployment by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDeploymentSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsGetDeploymentSlotOptions) (WebAppsGetDeploymentSlotResponse, error) {
	req, err := client.getDeploymentSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return WebAppsGetDeploymentSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetDeploymentSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetDeploymentSlotResponse{}, client.getDeploymentSlotHandleError(resp)
	}
	return client.getDeploymentSlotHandleResponse(resp)
}

// getDeploymentSlotCreateRequest creates the GetDeploymentSlot request.
func (client *WebAppsClient) getDeploymentSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsGetDeploymentSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDeploymentSlotHandleResponse handles the GetDeploymentSlot response.
func (client *WebAppsClient) getDeploymentSlotHandleResponse(resp *http.Response) (WebAppsGetDeploymentSlotResponse, error) {
	result := WebAppsGetDeploymentSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsGetDeploymentSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDeploymentSlotHandleError handles the GetDeploymentSlot error response.
func (client *WebAppsClient) getDeploymentSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDiagnosticLogsConfiguration - Description for Gets the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDiagnosticLogsConfiguration(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetDiagnosticLogsConfigurationOptions) (WebAppsGetDiagnosticLogsConfigurationResponse, error) {
	req, err := client.getDiagnosticLogsConfigurationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetDiagnosticLogsConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetDiagnosticLogsConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetDiagnosticLogsConfigurationResponse{}, client.getDiagnosticLogsConfigurationHandleError(resp)
	}
	return client.getDiagnosticLogsConfigurationHandleResponse(resp)
}

// getDiagnosticLogsConfigurationCreateRequest creates the GetDiagnosticLogsConfiguration request.
func (client *WebAppsClient) getDiagnosticLogsConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetDiagnosticLogsConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDiagnosticLogsConfigurationHandleResponse handles the GetDiagnosticLogsConfiguration response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationHandleResponse(resp *http.Response) (WebAppsGetDiagnosticLogsConfigurationResponse, error) {
	result := WebAppsGetDiagnosticLogsConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsGetDiagnosticLogsConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDiagnosticLogsConfigurationHandleError handles the GetDiagnosticLogsConfiguration error response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDiagnosticLogsConfigurationSlot - Description for Gets the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDiagnosticLogsConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetDiagnosticLogsConfigurationSlotOptions) (WebAppsGetDiagnosticLogsConfigurationSlotResponse, error) {
	req, err := client.getDiagnosticLogsConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetDiagnosticLogsConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetDiagnosticLogsConfigurationSlotResponse{}, client.getDiagnosticLogsConfigurationSlotHandleError(resp)
	}
	return client.getDiagnosticLogsConfigurationSlotHandleResponse(resp)
}

// getDiagnosticLogsConfigurationSlotCreateRequest creates the GetDiagnosticLogsConfigurationSlot request.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetDiagnosticLogsConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDiagnosticLogsConfigurationSlotHandleResponse handles the GetDiagnosticLogsConfigurationSlot response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotHandleResponse(resp *http.Response) (WebAppsGetDiagnosticLogsConfigurationSlotResponse, error) {
	result := WebAppsGetDiagnosticLogsConfigurationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsGetDiagnosticLogsConfigurationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDiagnosticLogsConfigurationSlotHandleError handles the GetDiagnosticLogsConfigurationSlot error response.
func (client *WebAppsClient) getDiagnosticLogsConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDomainOwnershipIdentifier - Description for Get domain ownership identifier for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsGetDomainOwnershipIdentifierOptions) (WebAppsGetDomainOwnershipIdentifierResponse, error) {
	req, err := client.getDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, options)
	if err != nil {
		return WebAppsGetDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetDomainOwnershipIdentifierResponse{}, client.getDomainOwnershipIdentifierHandleError(resp)
	}
	return client.getDomainOwnershipIdentifierHandleResponse(resp)
}

// getDomainOwnershipIdentifierCreateRequest creates the GetDomainOwnershipIdentifier request.
func (client *WebAppsClient) getDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, options *WebAppsGetDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDomainOwnershipIdentifierHandleResponse handles the GetDomainOwnershipIdentifier response.
func (client *WebAppsClient) getDomainOwnershipIdentifierHandleResponse(resp *http.Response) (WebAppsGetDomainOwnershipIdentifierResponse, error) {
	result := WebAppsGetDomainOwnershipIdentifierResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsGetDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDomainOwnershipIdentifierHandleError handles the GetDomainOwnershipIdentifier error response.
func (client *WebAppsClient) getDomainOwnershipIdentifierHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetDomainOwnershipIdentifierSlot - Description for Get domain ownership identifier for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsGetDomainOwnershipIdentifierSlotOptions) (WebAppsGetDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.getDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, options)
	if err != nil {
		return WebAppsGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetDomainOwnershipIdentifierSlotResponse{}, client.getDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return client.getDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// getDomainOwnershipIdentifierSlotCreateRequest creates the GetDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, options *WebAppsGetDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDomainOwnershipIdentifierSlotHandleResponse handles the GetDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (WebAppsGetDomainOwnershipIdentifierSlotResponse, error) {
	result := WebAppsGetDomainOwnershipIdentifierSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsGetDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getDomainOwnershipIdentifierSlotHandleError handles the GetDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) getDomainOwnershipIdentifierSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetFtpAllowed - Description for Returns whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFtpAllowed(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFtpAllowedOptions) (WebAppsGetFtpAllowedResponse, error) {
	req, err := client.getFtpAllowedCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetFtpAllowedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetFtpAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetFtpAllowedResponse{}, client.getFtpAllowedHandleError(resp)
	}
	return client.getFtpAllowedHandleResponse(resp)
}

// getFtpAllowedCreateRequest creates the GetFtpAllowed request.
func (client *WebAppsClient) getFtpAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFtpAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFtpAllowedHandleResponse handles the GetFtpAllowed response.
func (client *WebAppsClient) getFtpAllowedHandleResponse(resp *http.Response) (WebAppsGetFtpAllowedResponse, error) {
	result := WebAppsGetFtpAllowedResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsGetFtpAllowedResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getFtpAllowedHandleError handles the GetFtpAllowed error response.
func (client *WebAppsClient) getFtpAllowedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetFtpAllowedSlot - Description for Returns whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFtpAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFtpAllowedSlotOptions) (WebAppsGetFtpAllowedSlotResponse, error) {
	req, err := client.getFtpAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetFtpAllowedSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetFtpAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetFtpAllowedSlotResponse{}, client.getFtpAllowedSlotHandleError(resp)
	}
	return client.getFtpAllowedSlotHandleResponse(resp)
}

// getFtpAllowedSlotCreateRequest creates the GetFtpAllowedSlot request.
func (client *WebAppsClient) getFtpAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFtpAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFtpAllowedSlotHandleResponse handles the GetFtpAllowedSlot response.
func (client *WebAppsClient) getFtpAllowedSlotHandleResponse(resp *http.Response) (WebAppsGetFtpAllowedSlotResponse, error) {
	result := WebAppsGetFtpAllowedSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsGetFtpAllowedSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getFtpAllowedSlotHandleError handles the GetFtpAllowedSlot error response.
func (client *WebAppsClient) getFtpAllowedSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetFunction - Description for Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFunction(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsGetFunctionOptions) (WebAppsGetFunctionResponse, error) {
	req, err := client.getFunctionCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsGetFunctionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetFunctionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetFunctionResponse{}, client.getFunctionHandleError(resp)
	}
	return client.getFunctionHandleResponse(resp)
}

// getFunctionCreateRequest creates the GetFunction request.
func (client *WebAppsClient) getFunctionCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsGetFunctionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFunctionHandleResponse handles the GetFunction response.
func (client *WebAppsClient) getFunctionHandleResponse(resp *http.Response) (WebAppsGetFunctionResponse, error) {
	result := WebAppsGetFunctionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelope); err != nil {
		return WebAppsGetFunctionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getFunctionHandleError handles the GetFunction error response.
func (client *WebAppsClient) getFunctionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetFunctionsAdminToken - Description for Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFunctionsAdminToken(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFunctionsAdminTokenOptions) (WebAppsGetFunctionsAdminTokenResponse, error) {
	req, err := client.getFunctionsAdminTokenCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetFunctionsAdminTokenResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetFunctionsAdminTokenResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetFunctionsAdminTokenResponse{}, client.getFunctionsAdminTokenHandleError(resp)
	}
	return client.getFunctionsAdminTokenHandleResponse(resp)
}

// getFunctionsAdminTokenCreateRequest creates the GetFunctionsAdminToken request.
func (client *WebAppsClient) getFunctionsAdminTokenCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetFunctionsAdminTokenOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFunctionsAdminTokenHandleResponse handles the GetFunctionsAdminToken response.
func (client *WebAppsClient) getFunctionsAdminTokenHandleResponse(resp *http.Response) (WebAppsGetFunctionsAdminTokenResponse, error) {
	result := WebAppsGetFunctionsAdminTokenResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsGetFunctionsAdminTokenResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getFunctionsAdminTokenHandleError handles the GetFunctionsAdminToken error response.
func (client *WebAppsClient) getFunctionsAdminTokenHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetFunctionsAdminTokenSlot - Description for Fetch a short lived token that can be exchanged for a master key.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetFunctionsAdminTokenSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFunctionsAdminTokenSlotOptions) (WebAppsGetFunctionsAdminTokenSlotResponse, error) {
	req, err := client.getFunctionsAdminTokenSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetFunctionsAdminTokenSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetFunctionsAdminTokenSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetFunctionsAdminTokenSlotResponse{}, client.getFunctionsAdminTokenSlotHandleError(resp)
	}
	return client.getFunctionsAdminTokenSlotHandleResponse(resp)
}

// getFunctionsAdminTokenSlotCreateRequest creates the GetFunctionsAdminTokenSlot request.
func (client *WebAppsClient) getFunctionsAdminTokenSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetFunctionsAdminTokenSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/admin/token"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getFunctionsAdminTokenSlotHandleResponse handles the GetFunctionsAdminTokenSlot response.
func (client *WebAppsClient) getFunctionsAdminTokenSlotHandleResponse(resp *http.Response) (WebAppsGetFunctionsAdminTokenSlotResponse, error) {
	result := WebAppsGetFunctionsAdminTokenSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsGetFunctionsAdminTokenSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getFunctionsAdminTokenSlotHandleError handles the GetFunctionsAdminTokenSlot error response.
func (client *WebAppsClient) getFunctionsAdminTokenSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetHostNameBinding - Description for Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHostNameBinding(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsGetHostNameBindingOptions) (WebAppsGetHostNameBindingResponse, error) {
	req, err := client.getHostNameBindingCreateRequest(ctx, resourceGroupName, name, hostName, options)
	if err != nil {
		return WebAppsGetHostNameBindingResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetHostNameBindingResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetHostNameBindingResponse{}, client.getHostNameBindingHandleError(resp)
	}
	return client.getHostNameBindingHandleResponse(resp)
}

// getHostNameBindingCreateRequest creates the GetHostNameBinding request.
func (client *WebAppsClient) getHostNameBindingCreateRequest(ctx context.Context, resourceGroupName string, name string, hostName string, options *WebAppsGetHostNameBindingOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHostNameBindingHandleResponse handles the GetHostNameBinding response.
func (client *WebAppsClient) getHostNameBindingHandleResponse(resp *http.Response) (WebAppsGetHostNameBindingResponse, error) {
	result := WebAppsGetHostNameBindingResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsGetHostNameBindingResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHostNameBindingHandleError handles the GetHostNameBinding error response.
func (client *WebAppsClient) getHostNameBindingHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetHostNameBindingSlot - Description for Get the named hostname binding for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHostNameBindingSlot(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsGetHostNameBindingSlotOptions) (WebAppsGetHostNameBindingSlotResponse, error) {
	req, err := client.getHostNameBindingSlotCreateRequest(ctx, resourceGroupName, name, slot, hostName, options)
	if err != nil {
		return WebAppsGetHostNameBindingSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetHostNameBindingSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetHostNameBindingSlotResponse{}, client.getHostNameBindingSlotHandleError(resp)
	}
	return client.getHostNameBindingSlotHandleResponse(resp)
}

// getHostNameBindingSlotCreateRequest creates the GetHostNameBindingSlot request.
func (client *WebAppsClient) getHostNameBindingSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, hostName string, options *WebAppsGetHostNameBindingSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings/{hostName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if hostName == "" {
		return nil, errors.New("parameter hostName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{hostName}", url.PathEscape(hostName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHostNameBindingSlotHandleResponse handles the GetHostNameBindingSlot response.
func (client *WebAppsClient) getHostNameBindingSlotHandleResponse(resp *http.Response) (WebAppsGetHostNameBindingSlotResponse, error) {
	result := WebAppsGetHostNameBindingSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBinding); err != nil {
		return WebAppsGetHostNameBindingSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHostNameBindingSlotHandleError handles the GetHostNameBindingSlot error response.
func (client *WebAppsClient) getHostNameBindingSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetHybridConnection - Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsGetHybridConnectionOptions) (WebAppsGetHybridConnectionResponse, error) {
	req, err := client.getHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, options)
	if err != nil {
		return WebAppsGetHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetHybridConnectionResponse{}, client.getHybridConnectionHandleError(resp)
	}
	return client.getHybridConnectionHandleResponse(resp)
}

// getHybridConnectionCreateRequest creates the GetHybridConnection request.
func (client *WebAppsClient) getHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, options *WebAppsGetHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHybridConnectionHandleResponse handles the GetHybridConnection response.
func (client *WebAppsClient) getHybridConnectionHandleResponse(resp *http.Response) (WebAppsGetHybridConnectionResponse, error) {
	result := WebAppsGetHybridConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsGetHybridConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHybridConnectionHandleError handles the GetHybridConnection error response.
func (client *WebAppsClient) getHybridConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetHybridConnectionSlot - Description for Retrieves a specific Service Bus Hybrid Connection used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsGetHybridConnectionSlotOptions) (WebAppsGetHybridConnectionSlotResponse, error) {
	req, err := client.getHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, options)
	if err != nil {
		return WebAppsGetHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetHybridConnectionSlotResponse{}, client.getHybridConnectionSlotHandleError(resp)
	}
	return client.getHybridConnectionSlotHandleResponse(resp)
}

// getHybridConnectionSlotCreateRequest creates the GetHybridConnectionSlot request.
func (client *WebAppsClient) getHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, options *WebAppsGetHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHybridConnectionSlotHandleResponse handles the GetHybridConnectionSlot response.
func (client *WebAppsClient) getHybridConnectionSlotHandleResponse(resp *http.Response) (WebAppsGetHybridConnectionSlotResponse, error) {
	result := WebAppsGetHybridConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsGetHybridConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getHybridConnectionSlotHandleError handles the GetHybridConnectionSlot error response.
func (client *WebAppsClient) getHybridConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInstanceFunctionSlot - Description for Get function information by its ID for web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceFunctionSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsGetInstanceFunctionSlotOptions) (WebAppsGetInstanceFunctionSlotResponse, error) {
	req, err := client.getInstanceFunctionSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsGetInstanceFunctionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceFunctionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceFunctionSlotResponse{}, client.getInstanceFunctionSlotHandleError(resp)
	}
	return client.getInstanceFunctionSlotHandleResponse(resp)
}

// getInstanceFunctionSlotCreateRequest creates the GetInstanceFunctionSlot request.
func (client *WebAppsClient) getInstanceFunctionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsGetInstanceFunctionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceFunctionSlotHandleResponse handles the GetInstanceFunctionSlot response.
func (client *WebAppsClient) getInstanceFunctionSlotHandleResponse(resp *http.Response) (WebAppsGetInstanceFunctionSlotResponse, error) {
	result := WebAppsGetInstanceFunctionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelope); err != nil {
		return WebAppsGetInstanceFunctionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceFunctionSlotHandleError handles the GetInstanceFunctionSlot error response.
func (client *WebAppsClient) getInstanceFunctionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceInfo - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceInfo(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceInfoOptions) (WebAppsGetInstanceInfoResponse, error) {
	req, err := client.getInstanceInfoCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceInfoResponse{}, client.getInstanceInfoHandleError(resp)
	}
	return client.getInstanceInfoHandleResponse(resp)
}

// getInstanceInfoCreateRequest creates the GetInstanceInfo request.
func (client *WebAppsClient) getInstanceInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceInfoHandleResponse handles the GetInstanceInfo response.
func (client *WebAppsClient) getInstanceInfoHandleResponse(resp *http.Response) (WebAppsGetInstanceInfoResponse, error) {
	result := WebAppsGetInstanceInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebSiteInstanceStatus); err != nil {
		return WebAppsGetInstanceInfoResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceInfoHandleError handles the GetInstanceInfo error response.
func (client *WebAppsClient) getInstanceInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInstanceInfoSlot - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceInfoSlot(ctx context.Context, resourceGroupName string, name string, instanceID string, slot string, options *WebAppsGetInstanceInfoSlotOptions) (WebAppsGetInstanceInfoSlotResponse, error) {
	req, err := client.getInstanceInfoSlotCreateRequest(ctx, resourceGroupName, name, instanceID, slot, options)
	if err != nil {
		return WebAppsGetInstanceInfoSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceInfoSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceInfoSlotResponse{}, client.getInstanceInfoSlotHandleError(resp)
	}
	return client.getInstanceInfoSlotHandleResponse(resp)
}

// getInstanceInfoSlotCreateRequest creates the GetInstanceInfoSlot request.
func (client *WebAppsClient) getInstanceInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, slot string, options *WebAppsGetInstanceInfoSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceInfoSlotHandleResponse handles the GetInstanceInfoSlot response.
func (client *WebAppsClient) getInstanceInfoSlotHandleResponse(resp *http.Response) (WebAppsGetInstanceInfoSlotResponse, error) {
	result := WebAppsGetInstanceInfoSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebSiteInstanceStatus); err != nil {
		return WebAppsGetInstanceInfoSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceInfoSlotHandleError handles the GetInstanceInfoSlot error response.
func (client *WebAppsClient) getInstanceInfoSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInstanceMSDeployLog - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMSDeployLog(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMSDeployLogOptions) (WebAppsGetInstanceMSDeployLogResponse, error) {
	req, err := client.getInstanceMSDeployLogCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceMSDeployLogResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceMSDeployLogResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceMSDeployLogResponse{}, client.getInstanceMSDeployLogHandleError(resp)
	}
	return client.getInstanceMSDeployLogHandleResponse(resp)
}

// getInstanceMSDeployLogCreateRequest creates the GetInstanceMSDeployLog request.
func (client *WebAppsClient) getInstanceMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMSDeployLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMSDeployLogHandleResponse handles the GetInstanceMSDeployLog response.
func (client *WebAppsClient) getInstanceMSDeployLogHandleResponse(resp *http.Response) (WebAppsGetInstanceMSDeployLogResponse, error) {
	result := WebAppsGetInstanceMSDeployLogResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsGetInstanceMSDeployLogResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceMSDeployLogHandleError handles the GetInstanceMSDeployLog error response.
func (client *WebAppsClient) getInstanceMSDeployLogHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceMSDeployLogSlot - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMSDeployLogSlotOptions) (WebAppsGetInstanceMSDeployLogSlotResponse, error) {
	req, err := client.getInstanceMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceMSDeployLogSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceMSDeployLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceMSDeployLogSlotResponse{}, client.getInstanceMSDeployLogSlotHandleError(resp)
	}
	return client.getInstanceMSDeployLogSlotHandleResponse(resp)
}

// getInstanceMSDeployLogSlotCreateRequest creates the GetInstanceMSDeployLogSlot request.
func (client *WebAppsClient) getInstanceMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMSDeployLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMSDeployLogSlotHandleResponse handles the GetInstanceMSDeployLogSlot response.
func (client *WebAppsClient) getInstanceMSDeployLogSlotHandleResponse(resp *http.Response) (WebAppsGetInstanceMSDeployLogSlotResponse, error) {
	result := WebAppsGetInstanceMSDeployLogSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsGetInstanceMSDeployLogSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceMSDeployLogSlotHandleError handles the GetInstanceMSDeployLogSlot error response.
func (client *WebAppsClient) getInstanceMSDeployLogSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceMsDeployStatus - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMsDeployStatus(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMsDeployStatusOptions) (WebAppsGetInstanceMsDeployStatusResponse, error) {
	req, err := client.getInstanceMsDeployStatusCreateRequest(ctx, resourceGroupName, name, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceMsDeployStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceMsDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceMsDeployStatusResponse{}, client.getInstanceMsDeployStatusHandleError(resp)
	}
	return client.getInstanceMsDeployStatusHandleResponse(resp)
}

// getInstanceMsDeployStatusCreateRequest creates the GetInstanceMsDeployStatus request.
func (client *WebAppsClient) getInstanceMsDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsGetInstanceMsDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMsDeployStatusHandleResponse handles the GetInstanceMsDeployStatus response.
func (client *WebAppsClient) getInstanceMsDeployStatusHandleResponse(resp *http.Response) (WebAppsGetInstanceMsDeployStatusResponse, error) {
	result := WebAppsGetInstanceMsDeployStatusResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsGetInstanceMsDeployStatusResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceMsDeployStatusHandleError handles the GetInstanceMsDeployStatus error response.
func (client *WebAppsClient) getInstanceMsDeployStatusHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInstanceMsDeployStatusSlot - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceMsDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMsDeployStatusSlotOptions) (WebAppsGetInstanceMsDeployStatusSlotResponse, error) {
	req, err := client.getInstanceMsDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceMsDeployStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceMsDeployStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceMsDeployStatusSlotResponse{}, client.getInstanceMsDeployStatusSlotHandleError(resp)
	}
	return client.getInstanceMsDeployStatusSlotHandleResponse(resp)
}

// getInstanceMsDeployStatusSlotCreateRequest creates the GetInstanceMsDeployStatusSlot request.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsGetInstanceMsDeployStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceMsDeployStatusSlotHandleResponse handles the GetInstanceMsDeployStatusSlot response.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotHandleResponse(resp *http.Response) (WebAppsGetInstanceMsDeployStatusSlotResponse, error) {
	result := WebAppsGetInstanceMsDeployStatusSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsGetInstanceMsDeployStatusSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceMsDeployStatusSlotHandleError handles the GetInstanceMsDeployStatusSlot error response.
func (client *WebAppsClient) getInstanceMsDeployStatusSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetInstanceProcess - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcess(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessOptions) (WebAppsGetInstanceProcessResponse, error) {
	req, err := client.getInstanceProcessCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceProcessResponse{}, client.getInstanceProcessHandleError(resp)
	}
	return client.getInstanceProcessHandleResponse(resp)
}

// getInstanceProcessCreateRequest creates the GetInstanceProcess request.
func (client *WebAppsClient) getInstanceProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessHandleResponse handles the GetInstanceProcess response.
func (client *WebAppsClient) getInstanceProcessHandleResponse(resp *http.Response) (WebAppsGetInstanceProcessResponse, error) {
	result := WebAppsGetInstanceProcessResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsGetInstanceProcessResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceProcessHandleError handles the GetInstanceProcess error response.
func (client *WebAppsClient) getInstanceProcessHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceProcessDump - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessDumpOptions) (WebAppsGetInstanceProcessDumpResponse, error) {
	req, err := client.getInstanceProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceProcessDumpResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceProcessDumpResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceProcessDumpResponse{}, client.getInstanceProcessDumpHandleError(resp)
	}
	return WebAppsGetInstanceProcessDumpResponse{RawResponse: resp}, nil
}

// getInstanceProcessDumpCreateRequest creates the GetInstanceProcessDump request.
func (client *WebAppsClient) getInstanceProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsGetInstanceProcessDumpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessDumpHandleError handles the GetInstanceProcessDump error response.
func (client *WebAppsClient) getInstanceProcessDumpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceProcessDumpSlot - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessDumpSlotOptions) (WebAppsGetInstanceProcessDumpSlotResponse, error) {
	req, err := client.getInstanceProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceProcessDumpSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceProcessDumpSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceProcessDumpSlotResponse{}, client.getInstanceProcessDumpSlotHandleError(resp)
	}
	return WebAppsGetInstanceProcessDumpSlotResponse{RawResponse: resp}, nil
}

// getInstanceProcessDumpSlotCreateRequest creates the GetInstanceProcessDumpSlot request.
func (client *WebAppsClient) getInstanceProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessDumpSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessDumpSlotHandleError handles the GetInstanceProcessDumpSlot error response.
func (client *WebAppsClient) getInstanceProcessDumpSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceProcessModule - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *WebAppsGetInstanceProcessModuleOptions) (WebAppsGetInstanceProcessModuleResponse, error) {
	req, err := client.getInstanceProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceProcessModuleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceProcessModuleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceProcessModuleResponse{}, client.getInstanceProcessModuleHandleError(resp)
	}
	return client.getInstanceProcessModuleHandleResponse(resp)
}

// getInstanceProcessModuleCreateRequest creates the GetInstanceProcessModule request.
func (client *WebAppsClient) getInstanceProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, instanceID string, options *WebAppsGetInstanceProcessModuleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessModuleHandleResponse handles the GetInstanceProcessModule response.
func (client *WebAppsClient) getInstanceProcessModuleHandleResponse(resp *http.Response) (WebAppsGetInstanceProcessModuleResponse, error) {
	result := WebAppsGetInstanceProcessModuleResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsGetInstanceProcessModuleResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceProcessModuleHandleError handles the GetInstanceProcessModule error response.
func (client *WebAppsClient) getInstanceProcessModuleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceProcessModuleSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *WebAppsGetInstanceProcessModuleSlotOptions) (WebAppsGetInstanceProcessModuleSlotResponse, error) {
	req, err := client.getInstanceProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceProcessModuleSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceProcessModuleSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceProcessModuleSlotResponse{}, client.getInstanceProcessModuleSlotHandleError(resp)
	}
	return client.getInstanceProcessModuleSlotHandleResponse(resp)
}

// getInstanceProcessModuleSlotCreateRequest creates the GetInstanceProcessModuleSlot request.
func (client *WebAppsClient) getInstanceProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, instanceID string, options *WebAppsGetInstanceProcessModuleSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessModuleSlotHandleResponse handles the GetInstanceProcessModuleSlot response.
func (client *WebAppsClient) getInstanceProcessModuleSlotHandleResponse(resp *http.Response) (WebAppsGetInstanceProcessModuleSlotResponse, error) {
	result := WebAppsGetInstanceProcessModuleSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsGetInstanceProcessModuleSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceProcessModuleSlotHandleError handles the GetInstanceProcessModuleSlot error response.
func (client *WebAppsClient) getInstanceProcessModuleSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetInstanceProcessSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetInstanceProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessSlotOptions) (WebAppsGetInstanceProcessSlotResponse, error) {
	req, err := client.getInstanceProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
	if err != nil {
		return WebAppsGetInstanceProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetInstanceProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetInstanceProcessSlotResponse{}, client.getInstanceProcessSlotHandleError(resp)
	}
	return client.getInstanceProcessSlotHandleResponse(resp)
}

// getInstanceProcessSlotCreateRequest creates the GetInstanceProcessSlot request.
func (client *WebAppsClient) getInstanceProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsGetInstanceProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getInstanceProcessSlotHandleResponse handles the GetInstanceProcessSlot response.
func (client *WebAppsClient) getInstanceProcessSlotHandleResponse(resp *http.Response) (WebAppsGetInstanceProcessSlotResponse, error) {
	result := WebAppsGetInstanceProcessSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsGetInstanceProcessSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getInstanceProcessSlotHandleError handles the GetInstanceProcessSlot error response.
func (client *WebAppsClient) getInstanceProcessSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetMSDeployLog - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployLog(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployLogOptions) (WebAppsGetMSDeployLogResponse, error) {
	req, err := client.getMSDeployLogCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetMSDeployLogResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetMSDeployLogResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetMSDeployLogResponse{}, client.getMSDeployLogHandleError(resp)
	}
	return client.getMSDeployLogHandleResponse(resp)
}

// getMSDeployLogCreateRequest creates the GetMSDeployLog request.
func (client *WebAppsClient) getMSDeployLogCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployLogHandleResponse handles the GetMSDeployLog response.
func (client *WebAppsClient) getMSDeployLogHandleResponse(resp *http.Response) (WebAppsGetMSDeployLogResponse, error) {
	result := WebAppsGetMSDeployLogResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsGetMSDeployLogResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMSDeployLogHandleError handles the GetMSDeployLog error response.
func (client *WebAppsClient) getMSDeployLogHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetMSDeployLogSlot - Description for Get the MSDeploy Log for the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployLogSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployLogSlotOptions) (WebAppsGetMSDeployLogSlotResponse, error) {
	req, err := client.getMSDeployLogSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetMSDeployLogSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetMSDeployLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetMSDeployLogSlotResponse{}, client.getMSDeployLogSlotHandleError(resp)
	}
	return client.getMSDeployLogSlotHandleResponse(resp)
}

// getMSDeployLogSlotCreateRequest creates the GetMSDeployLogSlot request.
func (client *WebAppsClient) getMSDeployLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployLogSlotHandleResponse handles the GetMSDeployLogSlot response.
func (client *WebAppsClient) getMSDeployLogSlotHandleResponse(resp *http.Response) (WebAppsGetMSDeployLogSlotResponse, error) {
	result := WebAppsGetMSDeployLogSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployLog); err != nil {
		return WebAppsGetMSDeployLogSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMSDeployLogSlotHandleError handles the GetMSDeployLogSlot error response.
func (client *WebAppsClient) getMSDeployLogSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetMSDeployStatus - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployStatusOptions) (WebAppsGetMSDeployStatusResponse, error) {
	req, err := client.getMSDeployStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetMSDeployStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetMSDeployStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetMSDeployStatusResponse{}, client.getMSDeployStatusHandleError(resp)
	}
	return client.getMSDeployStatusHandleResponse(resp)
}

// getMSDeployStatusCreateRequest creates the GetMSDeployStatus request.
func (client *WebAppsClient) getMSDeployStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMSDeployStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployStatusHandleResponse handles the GetMSDeployStatus response.
func (client *WebAppsClient) getMSDeployStatusHandleResponse(resp *http.Response) (WebAppsGetMSDeployStatusResponse, error) {
	result := WebAppsGetMSDeployStatusResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsGetMSDeployStatusResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMSDeployStatusHandleError handles the GetMSDeployStatus error response.
func (client *WebAppsClient) getMSDeployStatusHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetMSDeployStatusSlot - Description for Get the status of the last MSDeploy operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMSDeployStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployStatusSlotOptions) (WebAppsGetMSDeployStatusSlotResponse, error) {
	req, err := client.getMSDeployStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetMSDeployStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetMSDeployStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetMSDeployStatusSlotResponse{}, client.getMSDeployStatusSlotHandleError(resp)
	}
	return client.getMSDeployStatusSlotHandleResponse(resp)
}

// getMSDeployStatusSlotCreateRequest creates the GetMSDeployStatusSlot request.
func (client *WebAppsClient) getMSDeployStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMSDeployStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/extensions/MSDeploy"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMSDeployStatusSlotHandleResponse handles the GetMSDeployStatusSlot response.
func (client *WebAppsClient) getMSDeployStatusSlotHandleResponse(resp *http.Response) (WebAppsGetMSDeployStatusSlotResponse, error) {
	result := WebAppsGetMSDeployStatusSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MSDeployStatus); err != nil {
		return WebAppsGetMSDeployStatusSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMSDeployStatusSlotHandleError handles the GetMSDeployStatusSlot error response.
func (client *WebAppsClient) getMSDeployStatusSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetMigrateMySQLStatus - Description for Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMigrateMySQLStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMigrateMySQLStatusOptions) (WebAppsGetMigrateMySQLStatusResponse, error) {
	req, err := client.getMigrateMySQLStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetMigrateMySQLStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetMigrateMySQLStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetMigrateMySQLStatusResponse{}, client.getMigrateMySQLStatusHandleError(resp)
	}
	return client.getMigrateMySQLStatusHandleResponse(resp)
}

// getMigrateMySQLStatusCreateRequest creates the GetMigrateMySQLStatus request.
func (client *WebAppsClient) getMigrateMySQLStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetMigrateMySQLStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMigrateMySQLStatusHandleResponse handles the GetMigrateMySQLStatus response.
func (client *WebAppsClient) getMigrateMySQLStatusHandleResponse(resp *http.Response) (WebAppsGetMigrateMySQLStatusResponse, error) {
	result := WebAppsGetMigrateMySQLStatusResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrateMySQLStatus); err != nil {
		return WebAppsGetMigrateMySQLStatusResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMigrateMySQLStatusHandleError handles the GetMigrateMySQLStatus error response.
func (client *WebAppsClient) getMigrateMySQLStatusHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetMigrateMySQLStatusSlot - Description for Returns the status of MySql in app migration, if one is active, and whether or not MySql in app is enabled
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetMigrateMySQLStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMigrateMySQLStatusSlotOptions) (WebAppsGetMigrateMySQLStatusSlotResponse, error) {
	req, err := client.getMigrateMySQLStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetMigrateMySQLStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetMigrateMySQLStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetMigrateMySQLStatusSlotResponse{}, client.getMigrateMySQLStatusSlotHandleError(resp)
	}
	return client.getMigrateMySQLStatusSlotHandleResponse(resp)
}

// getMigrateMySQLStatusSlotCreateRequest creates the GetMigrateMySQLStatusSlot request.
func (client *WebAppsClient) getMigrateMySQLStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetMigrateMySQLStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/migratemysql/status"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getMigrateMySQLStatusSlotHandleResponse handles the GetMigrateMySQLStatusSlot response.
func (client *WebAppsClient) getMigrateMySQLStatusSlotHandleResponse(resp *http.Response) (WebAppsGetMigrateMySQLStatusSlotResponse, error) {
	result := WebAppsGetMigrateMySQLStatusSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MigrateMySQLStatus); err != nil {
		return WebAppsGetMigrateMySQLStatusSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getMigrateMySQLStatusSlotHandleError handles the GetMigrateMySQLStatusSlot error response.
func (client *WebAppsClient) getMigrateMySQLStatusSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTraceOperation - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationOptions) (WebAppsGetNetworkTraceOperationResponse, error) {
	req, err := client.getNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsGetNetworkTraceOperationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTraceOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsGetNetworkTraceOperationResponse{}, client.getNetworkTraceOperationHandleError(resp)
	}
	return client.getNetworkTraceOperationHandleResponse(resp)
}

// getNetworkTraceOperationCreateRequest creates the GetNetworkTraceOperation request.
func (client *WebAppsClient) getNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationHandleResponse handles the GetNetworkTraceOperation response.
func (client *WebAppsClient) getNetworkTraceOperationHandleResponse(resp *http.Response) (WebAppsGetNetworkTraceOperationResponse, error) {
	result := WebAppsGetNetworkTraceOperationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTraceOperationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTraceOperationHandleError handles the GetNetworkTraceOperation error response.
func (client *WebAppsClient) getNetworkTraceOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTraceOperationSlot - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotOptions) (WebAppsGetNetworkTraceOperationSlotResponse, error) {
	req, err := client.getNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsGetNetworkTraceOperationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTraceOperationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsGetNetworkTraceOperationSlotResponse{}, client.getNetworkTraceOperationSlotHandleError(resp)
	}
	return client.getNetworkTraceOperationSlotHandleResponse(resp)
}

// getNetworkTraceOperationSlotCreateRequest creates the GetNetworkTraceOperationSlot request.
func (client *WebAppsClient) getNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationSlotHandleResponse handles the GetNetworkTraceOperationSlot response.
func (client *WebAppsClient) getNetworkTraceOperationSlotHandleResponse(resp *http.Response) (WebAppsGetNetworkTraceOperationSlotResponse, error) {
	result := WebAppsGetNetworkTraceOperationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTraceOperationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTraceOperationSlotHandleError handles the GetNetworkTraceOperationSlot error response.
func (client *WebAppsClient) getNetworkTraceOperationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTraceOperationSlotV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperationSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotV2Options) (WebAppsGetNetworkTraceOperationSlotV2Response, error) {
	req, err := client.getNetworkTraceOperationSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsGetNetworkTraceOperationSlotV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTraceOperationSlotV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsGetNetworkTraceOperationSlotV2Response{}, client.getNetworkTraceOperationSlotV2HandleError(resp)
	}
	return client.getNetworkTraceOperationSlotV2HandleResponse(resp)
}

// getNetworkTraceOperationSlotV2CreateRequest creates the GetNetworkTraceOperationSlotV2 request.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTraceOperationSlotV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationSlotV2HandleResponse handles the GetNetworkTraceOperationSlotV2 response.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2HandleResponse(resp *http.Response) (WebAppsGetNetworkTraceOperationSlotV2Response, error) {
	result := WebAppsGetNetworkTraceOperationSlotV2Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTraceOperationSlotV2Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTraceOperationSlotV2HandleError handles the GetNetworkTraceOperationSlotV2 error response.
func (client *WebAppsClient) getNetworkTraceOperationSlotV2HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTraceOperationV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraceOperationV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationV2Options) (WebAppsGetNetworkTraceOperationV2Response, error) {
	req, err := client.getNetworkTraceOperationV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsGetNetworkTraceOperationV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTraceOperationV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsGetNetworkTraceOperationV2Response{}, client.getNetworkTraceOperationV2HandleError(resp)
	}
	return client.getNetworkTraceOperationV2HandleResponse(resp)
}

// getNetworkTraceOperationV2CreateRequest creates the GetNetworkTraceOperationV2 request.
func (client *WebAppsClient) getNetworkTraceOperationV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTraceOperationV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/current/operationresults/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTraceOperationV2HandleResponse handles the GetNetworkTraceOperationV2 response.
func (client *WebAppsClient) getNetworkTraceOperationV2HandleResponse(resp *http.Response) (WebAppsGetNetworkTraceOperationV2Response, error) {
	result := WebAppsGetNetworkTraceOperationV2Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTraceOperationV2Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTraceOperationV2HandleError handles the GetNetworkTraceOperationV2 error response.
func (client *WebAppsClient) getNetworkTraceOperationV2HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTraces - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTraces(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesOptions) (WebAppsGetNetworkTracesResponse, error) {
	req, err := client.getNetworkTracesCreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsGetNetworkTracesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTracesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetNetworkTracesResponse{}, client.getNetworkTracesHandleError(resp)
	}
	return client.getNetworkTracesHandleResponse(resp)
}

// getNetworkTracesCreateRequest creates the GetNetworkTraces request.
func (client *WebAppsClient) getNetworkTracesCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesHandleResponse handles the GetNetworkTraces response.
func (client *WebAppsClient) getNetworkTracesHandleResponse(resp *http.Response) (WebAppsGetNetworkTracesResponse, error) {
	result := WebAppsGetNetworkTracesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTracesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTracesHandleError handles the GetNetworkTraces error response.
func (client *WebAppsClient) getNetworkTracesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTracesSlot - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTracesSlot(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotOptions) (WebAppsGetNetworkTracesSlotResponse, error) {
	req, err := client.getNetworkTracesSlotCreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsGetNetworkTracesSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTracesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetNetworkTracesSlotResponse{}, client.getNetworkTracesSlotHandleError(resp)
	}
	return client.getNetworkTracesSlotHandleResponse(resp)
}

// getNetworkTracesSlotCreateRequest creates the GetNetworkTracesSlot request.
func (client *WebAppsClient) getNetworkTracesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesSlotHandleResponse handles the GetNetworkTracesSlot response.
func (client *WebAppsClient) getNetworkTracesSlotHandleResponse(resp *http.Response) (WebAppsGetNetworkTracesSlotResponse, error) {
	result := WebAppsGetNetworkTracesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTracesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTracesSlotHandleError handles the GetNetworkTracesSlot error response.
func (client *WebAppsClient) getNetworkTracesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTracesSlotV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTracesSlotV2(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotV2Options) (WebAppsGetNetworkTracesSlotV2Response, error) {
	req, err := client.getNetworkTracesSlotV2CreateRequest(ctx, resourceGroupName, name, operationID, slot, options)
	if err != nil {
		return WebAppsGetNetworkTracesSlotV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTracesSlotV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetNetworkTracesSlotV2Response{}, client.getNetworkTracesSlotV2HandleError(resp)
	}
	return client.getNetworkTracesSlotV2HandleResponse(resp)
}

// getNetworkTracesSlotV2CreateRequest creates the GetNetworkTracesSlotV2 request.
func (client *WebAppsClient) getNetworkTracesSlotV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, slot string, options *WebAppsGetNetworkTracesSlotV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesSlotV2HandleResponse handles the GetNetworkTracesSlotV2 response.
func (client *WebAppsClient) getNetworkTracesSlotV2HandleResponse(resp *http.Response) (WebAppsGetNetworkTracesSlotV2Response, error) {
	result := WebAppsGetNetworkTracesSlotV2Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTracesSlotV2Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTracesSlotV2HandleError handles the GetNetworkTracesSlotV2 error response.
func (client *WebAppsClient) getNetworkTracesSlotV2HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetNetworkTracesV2 - Description for Gets a named operation for a network trace capturing (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetNetworkTracesV2(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesV2Options) (WebAppsGetNetworkTracesV2Response, error) {
	req, err := client.getNetworkTracesV2CreateRequest(ctx, resourceGroupName, name, operationID, options)
	if err != nil {
		return WebAppsGetNetworkTracesV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetNetworkTracesV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetNetworkTracesV2Response{}, client.getNetworkTracesV2HandleError(resp)
	}
	return client.getNetworkTracesV2HandleResponse(resp)
}

// getNetworkTracesV2CreateRequest creates the GetNetworkTracesV2 request.
func (client *WebAppsClient) getNetworkTracesV2CreateRequest(ctx context.Context, resourceGroupName string, name string, operationID string, options *WebAppsGetNetworkTracesV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTraces/{operationId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getNetworkTracesV2HandleResponse handles the GetNetworkTracesV2 response.
func (client *WebAppsClient) getNetworkTracesV2HandleResponse(resp *http.Response) (WebAppsGetNetworkTracesV2Response, error) {
	result := WebAppsGetNetworkTracesV2Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkTraceArray); err != nil {
		return WebAppsGetNetworkTracesV2Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getNetworkTracesV2HandleError handles the GetNetworkTracesV2 error response.
func (client *WebAppsClient) getNetworkTracesV2HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPremierAddOn - Description for Gets a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsGetPremierAddOnOptions) (WebAppsGetPremierAddOnResponse, error) {
	req, err := client.getPremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, options)
	if err != nil {
		return WebAppsGetPremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPremierAddOnResponse{}, client.getPremierAddOnHandleError(resp)
	}
	return client.getPremierAddOnHandleResponse(resp)
}

// getPremierAddOnCreateRequest creates the GetPremierAddOn request.
func (client *WebAppsClient) getPremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, options *WebAppsGetPremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPremierAddOnHandleResponse handles the GetPremierAddOn response.
func (client *WebAppsClient) getPremierAddOnHandleResponse(resp *http.Response) (WebAppsGetPremierAddOnResponse, error) {
	result := WebAppsGetPremierAddOnResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsGetPremierAddOnResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPremierAddOnHandleError handles the GetPremierAddOn error response.
func (client *WebAppsClient) getPremierAddOnHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPremierAddOnSlot - Description for Gets a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsGetPremierAddOnSlotOptions) (WebAppsGetPremierAddOnSlotResponse, error) {
	req, err := client.getPremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, options)
	if err != nil {
		return WebAppsGetPremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPremierAddOnSlotResponse{}, client.getPremierAddOnSlotHandleError(resp)
	}
	return client.getPremierAddOnSlotHandleResponse(resp)
}

// getPremierAddOnSlotCreateRequest creates the GetPremierAddOnSlot request.
func (client *WebAppsClient) getPremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, options *WebAppsGetPremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPremierAddOnSlotHandleResponse handles the GetPremierAddOnSlot response.
func (client *WebAppsClient) getPremierAddOnSlotHandleResponse(resp *http.Response) (WebAppsGetPremierAddOnSlotResponse, error) {
	result := WebAppsGetPremierAddOnSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsGetPremierAddOnSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPremierAddOnSlotHandleError handles the GetPremierAddOnSlot error response.
func (client *WebAppsClient) getPremierAddOnSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateAccess - Description for Gets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateAccess(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateAccessOptions) (WebAppsGetPrivateAccessResponse, error) {
	req, err := client.getPrivateAccessCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetPrivateAccessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPrivateAccessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPrivateAccessResponse{}, client.getPrivateAccessHandleError(resp)
	}
	return client.getPrivateAccessHandleResponse(resp)
}

// getPrivateAccessCreateRequest creates the GetPrivateAccess request.
func (client *WebAppsClient) getPrivateAccessCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateAccessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateAccessHandleResponse handles the GetPrivateAccess response.
func (client *WebAppsClient) getPrivateAccessHandleResponse(resp *http.Response) (WebAppsGetPrivateAccessResponse, error) {
	result := WebAppsGetPrivateAccessResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsGetPrivateAccessResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateAccessHandleError handles the GetPrivateAccess error response.
func (client *WebAppsClient) getPrivateAccessHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateAccessSlot - Description for Gets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateAccessSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateAccessSlotOptions) (WebAppsGetPrivateAccessSlotResponse, error) {
	req, err := client.getPrivateAccessSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetPrivateAccessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPrivateAccessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPrivateAccessSlotResponse{}, client.getPrivateAccessSlotHandleError(resp)
	}
	return client.getPrivateAccessSlotHandleResponse(resp)
}

// getPrivateAccessSlotCreateRequest creates the GetPrivateAccessSlot request.
func (client *WebAppsClient) getPrivateAccessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateAccessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateAccessSlotHandleResponse handles the GetPrivateAccessSlot response.
func (client *WebAppsClient) getPrivateAccessSlotHandleResponse(resp *http.Response) (WebAppsGetPrivateAccessSlotResponse, error) {
	result := WebAppsGetPrivateAccessSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsGetPrivateAccessSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateAccessSlotHandleError handles the GetPrivateAccessSlot error response.
func (client *WebAppsClient) getPrivateAccessSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnection - Description for Gets a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnection(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsGetPrivateEndpointConnectionOptions) (WebAppsGetPrivateEndpointConnectionResponse, error) {
	req, err := client.getPrivateEndpointConnectionCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, options)
	if err != nil {
		return WebAppsGetPrivateEndpointConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPrivateEndpointConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPrivateEndpointConnectionResponse{}, client.getPrivateEndpointConnectionHandleError(resp)
	}
	return client.getPrivateEndpointConnectionHandleResponse(resp)
}

// getPrivateEndpointConnectionCreateRequest creates the GetPrivateEndpointConnection request.
func (client *WebAppsClient) getPrivateEndpointConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, options *WebAppsGetPrivateEndpointConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionHandleResponse handles the GetPrivateEndpointConnection response.
func (client *WebAppsClient) getPrivateEndpointConnectionHandleResponse(resp *http.Response) (WebAppsGetPrivateEndpointConnectionResponse, error) {
	result := WebAppsGetPrivateEndpointConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return WebAppsGetPrivateEndpointConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionHandleError handles the GetPrivateEndpointConnection error response.
func (client *WebAppsClient) getPrivateEndpointConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnectionList - Description for Gets the list of private endpoint connections associated with a site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnectionList(resourceGroupName string, name string, options *WebAppsGetPrivateEndpointConnectionListOptions) *WebAppsGetPrivateEndpointConnectionListPager {
	return &WebAppsGetPrivateEndpointConnectionListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getPrivateEndpointConnectionListCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsGetPrivateEndpointConnectionListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
	}
}

// getPrivateEndpointConnectionListCreateRequest creates the GetPrivateEndpointConnectionList request.
func (client *WebAppsClient) getPrivateEndpointConnectionListCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateEndpointConnectionListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListHandleResponse handles the GetPrivateEndpointConnectionList response.
func (client *WebAppsClient) getPrivateEndpointConnectionListHandleResponse(resp *http.Response) (WebAppsGetPrivateEndpointConnectionListResponse, error) {
	result := WebAppsGetPrivateEndpointConnectionListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return WebAppsGetPrivateEndpointConnectionListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionListHandleError handles the GetPrivateEndpointConnectionList error response.
func (client *WebAppsClient) getPrivateEndpointConnectionListHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnectionListSlot - Description for Gets the list of private endpoint connections associated with a site
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnectionListSlot(resourceGroupName string, name string, slot string, options *WebAppsGetPrivateEndpointConnectionListSlotOptions) *WebAppsGetPrivateEndpointConnectionListSlotPager {
	return &WebAppsGetPrivateEndpointConnectionListSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getPrivateEndpointConnectionListSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsGetPrivateEndpointConnectionListSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PrivateEndpointConnectionCollection.NextLink)
		},
	}
}

// getPrivateEndpointConnectionListSlotCreateRequest creates the GetPrivateEndpointConnectionListSlot request.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateEndpointConnectionListSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionListSlotHandleResponse handles the GetPrivateEndpointConnectionListSlot response.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotHandleResponse(resp *http.Response) (WebAppsGetPrivateEndpointConnectionListSlotResponse, error) {
	result := WebAppsGetPrivateEndpointConnectionListSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateEndpointConnectionCollection); err != nil {
		return WebAppsGetPrivateEndpointConnectionListSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionListSlotHandleError handles the GetPrivateEndpointConnectionListSlot error response.
func (client *WebAppsClient) getPrivateEndpointConnectionListSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateEndpointConnectionSlot - Description for Gets a private endpoint connection
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateEndpointConnectionSlot(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsGetPrivateEndpointConnectionSlotOptions) (WebAppsGetPrivateEndpointConnectionSlotResponse, error) {
	req, err := client.getPrivateEndpointConnectionSlotCreateRequest(ctx, resourceGroupName, name, privateEndpointConnectionName, slot, options)
	if err != nil {
		return WebAppsGetPrivateEndpointConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPrivateEndpointConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPrivateEndpointConnectionSlotResponse{}, client.getPrivateEndpointConnectionSlotHandleError(resp)
	}
	return client.getPrivateEndpointConnectionSlotHandleResponse(resp)
}

// getPrivateEndpointConnectionSlotCreateRequest creates the GetPrivateEndpointConnectionSlot request.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, privateEndpointConnectionName string, slot string, options *WebAppsGetPrivateEndpointConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateEndpointConnections/{privateEndpointConnectionName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if privateEndpointConnectionName == "" {
		return nil, errors.New("parameter privateEndpointConnectionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{privateEndpointConnectionName}", url.PathEscape(privateEndpointConnectionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateEndpointConnectionSlotHandleResponse handles the GetPrivateEndpointConnectionSlot response.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotHandleResponse(resp *http.Response) (WebAppsGetPrivateEndpointConnectionSlotResponse, error) {
	result := WebAppsGetPrivateEndpointConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RemotePrivateEndpointConnectionARMResource); err != nil {
		return WebAppsGetPrivateEndpointConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateEndpointConnectionSlotHandleError handles the GetPrivateEndpointConnectionSlot error response.
func (client *WebAppsClient) getPrivateEndpointConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateLinkResources - Description for Gets the private link resources
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateLinkResources(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateLinkResourcesOptions) (WebAppsGetPrivateLinkResourcesResponse, error) {
	req, err := client.getPrivateLinkResourcesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetPrivateLinkResourcesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPrivateLinkResourcesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPrivateLinkResourcesResponse{}, client.getPrivateLinkResourcesHandleError(resp)
	}
	return client.getPrivateLinkResourcesHandleResponse(resp)
}

// getPrivateLinkResourcesCreateRequest creates the GetPrivateLinkResources request.
func (client *WebAppsClient) getPrivateLinkResourcesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetPrivateLinkResourcesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesHandleResponse handles the GetPrivateLinkResources response.
func (client *WebAppsClient) getPrivateLinkResourcesHandleResponse(resp *http.Response) (WebAppsGetPrivateLinkResourcesResponse, error) {
	result := WebAppsGetPrivateLinkResourcesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return WebAppsGetPrivateLinkResourcesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateLinkResourcesHandleError handles the GetPrivateLinkResources error response.
func (client *WebAppsClient) getPrivateLinkResourcesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPrivateLinkResourcesSlot - Description for Gets the private link resources
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPrivateLinkResourcesSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateLinkResourcesSlotOptions) (WebAppsGetPrivateLinkResourcesSlotResponse, error) {
	req, err := client.getPrivateLinkResourcesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetPrivateLinkResourcesSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPrivateLinkResourcesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPrivateLinkResourcesSlotResponse{}, client.getPrivateLinkResourcesSlotHandleError(resp)
	}
	return client.getPrivateLinkResourcesSlotHandleResponse(resp)
}

// getPrivateLinkResourcesSlotCreateRequest creates the GetPrivateLinkResourcesSlot request.
func (client *WebAppsClient) getPrivateLinkResourcesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetPrivateLinkResourcesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateLinkResources"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPrivateLinkResourcesSlotHandleResponse handles the GetPrivateLinkResourcesSlot response.
func (client *WebAppsClient) getPrivateLinkResourcesSlotHandleResponse(resp *http.Response) (WebAppsGetPrivateLinkResourcesSlotResponse, error) {
	result := WebAppsGetPrivateLinkResourcesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateLinkResourcesWrapper); err != nil {
		return WebAppsGetPrivateLinkResourcesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPrivateLinkResourcesSlotHandleError handles the GetPrivateLinkResourcesSlot error response.
func (client *WebAppsClient) getPrivateLinkResourcesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetProcess - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcess(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessOptions) (WebAppsGetProcessResponse, error) {
	req, err := client.getProcessCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return WebAppsGetProcessResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetProcessResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetProcessResponse{}, client.getProcessHandleError(resp)
	}
	return client.getProcessHandleResponse(resp)
}

// getProcessCreateRequest creates the GetProcess request.
func (client *WebAppsClient) getProcessCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessHandleResponse handles the GetProcess response.
func (client *WebAppsClient) getProcessHandleResponse(resp *http.Response) (WebAppsGetProcessResponse, error) {
	result := WebAppsGetProcessResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsGetProcessResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getProcessHandleError handles the GetProcess error response.
func (client *WebAppsClient) getProcessHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetProcessDump - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessDump(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessDumpOptions) (WebAppsGetProcessDumpResponse, error) {
	req, err := client.getProcessDumpCreateRequest(ctx, resourceGroupName, name, processID, options)
	if err != nil {
		return WebAppsGetProcessDumpResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetProcessDumpResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetProcessDumpResponse{}, client.getProcessDumpHandleError(resp)
	}
	return WebAppsGetProcessDumpResponse{RawResponse: resp}, nil
}

// getProcessDumpCreateRequest creates the GetProcessDump request.
func (client *WebAppsClient) getProcessDumpCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsGetProcessDumpOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessDumpHandleError handles the GetProcessDump error response.
func (client *WebAppsClient) getProcessDumpHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetProcessDumpSlot - Description for Get a memory dump of a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessDumpSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessDumpSlotOptions) (WebAppsGetProcessDumpSlotResponse, error) {
	req, err := client.getProcessDumpSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return WebAppsGetProcessDumpSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetProcessDumpSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetProcessDumpSlotResponse{}, client.getProcessDumpSlotHandleError(resp)
	}
	return WebAppsGetProcessDumpSlotResponse{RawResponse: resp}, nil
}

// getProcessDumpSlotCreateRequest creates the GetProcessDumpSlot request.
func (client *WebAppsClient) getProcessDumpSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessDumpSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/dump"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessDumpSlotHandleError handles the GetProcessDumpSlot error response.
func (client *WebAppsClient) getProcessDumpSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetProcessModule - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessModule(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *WebAppsGetProcessModuleOptions) (WebAppsGetProcessModuleResponse, error) {
	req, err := client.getProcessModuleCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, options)
	if err != nil {
		return WebAppsGetProcessModuleResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetProcessModuleResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetProcessModuleResponse{}, client.getProcessModuleHandleError(resp)
	}
	return client.getProcessModuleHandleResponse(resp)
}

// getProcessModuleCreateRequest creates the GetProcessModule request.
func (client *WebAppsClient) getProcessModuleCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, options *WebAppsGetProcessModuleOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessModuleHandleResponse handles the GetProcessModule response.
func (client *WebAppsClient) getProcessModuleHandleResponse(resp *http.Response) (WebAppsGetProcessModuleResponse, error) {
	result := WebAppsGetProcessModuleResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsGetProcessModuleResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getProcessModuleHandleError handles the GetProcessModule error response.
func (client *WebAppsClient) getProcessModuleHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetProcessModuleSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessModuleSlot(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *WebAppsGetProcessModuleSlotOptions) (WebAppsGetProcessModuleSlotResponse, error) {
	req, err := client.getProcessModuleSlotCreateRequest(ctx, resourceGroupName, name, processID, baseAddress, slot, options)
	if err != nil {
		return WebAppsGetProcessModuleSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetProcessModuleSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetProcessModuleSlotResponse{}, client.getProcessModuleSlotHandleError(resp)
	}
	return client.getProcessModuleSlotHandleResponse(resp)
}

// getProcessModuleSlotCreateRequest creates the GetProcessModuleSlot request.
func (client *WebAppsClient) getProcessModuleSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, baseAddress string, slot string, options *WebAppsGetProcessModuleSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules/{baseAddress}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if baseAddress == "" {
		return nil, errors.New("parameter baseAddress cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{baseAddress}", url.PathEscape(baseAddress))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessModuleSlotHandleResponse handles the GetProcessModuleSlot response.
func (client *WebAppsClient) getProcessModuleSlotHandleResponse(resp *http.Response) (WebAppsGetProcessModuleSlotResponse, error) {
	result := WebAppsGetProcessModuleSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfo); err != nil {
		return WebAppsGetProcessModuleSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getProcessModuleSlotHandleError handles the GetProcessModuleSlot error response.
func (client *WebAppsClient) getProcessModuleSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetProcessSlot - Description for Get process information by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetProcessSlot(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessSlotOptions) (WebAppsGetProcessSlotResponse, error) {
	req, err := client.getProcessSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
	if err != nil {
		return WebAppsGetProcessSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetProcessSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetProcessSlotResponse{}, client.getProcessSlotHandleError(resp)
	}
	return client.getProcessSlotHandleResponse(resp)
}

// getProcessSlotCreateRequest creates the GetProcessSlot request.
func (client *WebAppsClient) getProcessSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsGetProcessSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getProcessSlotHandleResponse handles the GetProcessSlot response.
func (client *WebAppsClient) getProcessSlotHandleResponse(resp *http.Response) (WebAppsGetProcessSlotResponse, error) {
	result := WebAppsGetProcessSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfo); err != nil {
		return WebAppsGetProcessSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getProcessSlotHandleError handles the GetProcessSlot error response.
func (client *WebAppsClient) getProcessSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetPublicCertificate - Description for Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPublicCertificate(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsGetPublicCertificateOptions) (WebAppsGetPublicCertificateResponse, error) {
	req, err := client.getPublicCertificateCreateRequest(ctx, resourceGroupName, name, publicCertificateName, options)
	if err != nil {
		return WebAppsGetPublicCertificateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPublicCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPublicCertificateResponse{}, client.getPublicCertificateHandleError(resp)
	}
	return client.getPublicCertificateHandleResponse(resp)
}

// getPublicCertificateCreateRequest creates the GetPublicCertificate request.
func (client *WebAppsClient) getPublicCertificateCreateRequest(ctx context.Context, resourceGroupName string, name string, publicCertificateName string, options *WebAppsGetPublicCertificateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPublicCertificateHandleResponse handles the GetPublicCertificate response.
func (client *WebAppsClient) getPublicCertificateHandleResponse(resp *http.Response) (WebAppsGetPublicCertificateResponse, error) {
	result := WebAppsGetPublicCertificateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsGetPublicCertificateResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPublicCertificateHandleError handles the GetPublicCertificate error response.
func (client *WebAppsClient) getPublicCertificateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetPublicCertificateSlot - Description for Get the named public certificate for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetPublicCertificateSlot(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsGetPublicCertificateSlotOptions) (WebAppsGetPublicCertificateSlotResponse, error) {
	req, err := client.getPublicCertificateSlotCreateRequest(ctx, resourceGroupName, name, slot, publicCertificateName, options)
	if err != nil {
		return WebAppsGetPublicCertificateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetPublicCertificateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetPublicCertificateSlotResponse{}, client.getPublicCertificateSlotHandleError(resp)
	}
	return client.getPublicCertificateSlotHandleResponse(resp)
}

// getPublicCertificateSlotCreateRequest creates the GetPublicCertificateSlot request.
func (client *WebAppsClient) getPublicCertificateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publicCertificateName string, options *WebAppsGetPublicCertificateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates/{publicCertificateName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if publicCertificateName == "" {
		return nil, errors.New("parameter publicCertificateName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{publicCertificateName}", url.PathEscape(publicCertificateName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPublicCertificateSlotHandleResponse handles the GetPublicCertificateSlot response.
func (client *WebAppsClient) getPublicCertificateSlotHandleResponse(resp *http.Response) (WebAppsGetPublicCertificateSlotResponse, error) {
	result := WebAppsGetPublicCertificateSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificate); err != nil {
		return WebAppsGetPublicCertificateSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getPublicCertificateSlotHandleError handles the GetPublicCertificateSlot error response.
func (client *WebAppsClient) getPublicCertificateSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetRelayServiceConnection - Description for Gets a hybrid connection configuration by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsGetRelayServiceConnectionOptions) (WebAppsGetRelayServiceConnectionResponse, error) {
	req, err := client.getRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, options)
	if err != nil {
		return WebAppsGetRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetRelayServiceConnectionResponse{}, client.getRelayServiceConnectionHandleError(resp)
	}
	return client.getRelayServiceConnectionHandleResponse(resp)
}

// getRelayServiceConnectionCreateRequest creates the GetRelayServiceConnection request.
func (client *WebAppsClient) getRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, options *WebAppsGetRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getRelayServiceConnectionHandleResponse handles the GetRelayServiceConnection response.
func (client *WebAppsClient) getRelayServiceConnectionHandleResponse(resp *http.Response) (WebAppsGetRelayServiceConnectionResponse, error) {
	result := WebAppsGetRelayServiceConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsGetRelayServiceConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getRelayServiceConnectionHandleError handles the GetRelayServiceConnection error response.
func (client *WebAppsClient) getRelayServiceConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetRelayServiceConnectionSlot - Description for Gets a hybrid connection configuration by its name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsGetRelayServiceConnectionSlotOptions) (WebAppsGetRelayServiceConnectionSlotResponse, error) {
	req, err := client.getRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, options)
	if err != nil {
		return WebAppsGetRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetRelayServiceConnectionSlotResponse{}, client.getRelayServiceConnectionSlotHandleError(resp)
	}
	return client.getRelayServiceConnectionSlotHandleResponse(resp)
}

// getRelayServiceConnectionSlotCreateRequest creates the GetRelayServiceConnectionSlot request.
func (client *WebAppsClient) getRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, options *WebAppsGetRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getRelayServiceConnectionSlotHandleResponse handles the GetRelayServiceConnectionSlot response.
func (client *WebAppsClient) getRelayServiceConnectionSlotHandleResponse(resp *http.Response) (WebAppsGetRelayServiceConnectionSlotResponse, error) {
	result := WebAppsGetRelayServiceConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsGetRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getRelayServiceConnectionSlotHandleError handles the GetRelayServiceConnectionSlot error response.
func (client *WebAppsClient) getRelayServiceConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetScmAllowed - Description for Returns whether Scm basic auth is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetScmAllowed(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetScmAllowedOptions) (WebAppsGetScmAllowedResponse, error) {
	req, err := client.getScmAllowedCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetScmAllowedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetScmAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetScmAllowedResponse{}, client.getScmAllowedHandleError(resp)
	}
	return client.getScmAllowedHandleResponse(resp)
}

// getScmAllowedCreateRequest creates the GetScmAllowed request.
func (client *WebAppsClient) getScmAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetScmAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getScmAllowedHandleResponse handles the GetScmAllowed response.
func (client *WebAppsClient) getScmAllowedHandleResponse(resp *http.Response) (WebAppsGetScmAllowedResponse, error) {
	result := WebAppsGetScmAllowedResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsGetScmAllowedResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getScmAllowedHandleError handles the GetScmAllowed error response.
func (client *WebAppsClient) getScmAllowedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetScmAllowedSlot - Description for Returns whether Scm basic auth is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetScmAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetScmAllowedSlotOptions) (WebAppsGetScmAllowedSlotResponse, error) {
	req, err := client.getScmAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetScmAllowedSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetScmAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetScmAllowedSlotResponse{}, client.getScmAllowedSlotHandleError(resp)
	}
	return client.getScmAllowedSlotHandleResponse(resp)
}

// getScmAllowedSlotCreateRequest creates the GetScmAllowedSlot request.
func (client *WebAppsClient) getScmAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetScmAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getScmAllowedSlotHandleResponse handles the GetScmAllowedSlot response.
func (client *WebAppsClient) getScmAllowedSlotHandleResponse(resp *http.Response) (WebAppsGetScmAllowedSlotResponse, error) {
	result := WebAppsGetScmAllowedSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsGetScmAllowedSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getScmAllowedSlotHandleError handles the GetScmAllowedSlot error response.
func (client *WebAppsClient) getScmAllowedSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteConnectionStringKeyVaultReference - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReference(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceOptions) (WebAppsGetSiteConnectionStringKeyVaultReferenceResponse, error) {
	req, err := client.getSiteConnectionStringKeyVaultReferenceCreateRequest(ctx, resourceGroupName, name, connectionStringKey, options)
	if err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceResponse{}, client.getSiteConnectionStringKeyVaultReferenceHandleError(resp)
	}
	return client.getSiteConnectionStringKeyVaultReferenceHandleResponse(resp)
}

// getSiteConnectionStringKeyVaultReferenceCreateRequest creates the GetSiteConnectionStringKeyVaultReference request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings/{connectionStringKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if connectionStringKey == "" {
		return nil, errors.New("parameter connectionStringKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionStringKey}", url.PathEscape(connectionStringKey))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferenceHandleResponse handles the GetSiteConnectionStringKeyVaultReference response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceHandleResponse(resp *http.Response) (WebAppsGetSiteConnectionStringKeyVaultReferenceResponse, error) {
	result := WebAppsGetSiteConnectionStringKeyVaultReferenceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteConnectionStringKeyVaultReferenceHandleError handles the GetSiteConnectionStringKeyVaultReference error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteConnectionStringKeyVaultReferenceSlot - Description for Gets the config reference and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferenceSlot(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceSlotOptions) (WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse, error) {
	req, err := client.getSiteConnectionStringKeyVaultReferenceSlotCreateRequest(ctx, resourceGroupName, name, connectionStringKey, slot, options)
	if err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, client.getSiteConnectionStringKeyVaultReferenceSlotHandleError(resp)
	}
	return client.getSiteConnectionStringKeyVaultReferenceSlotHandleResponse(resp)
}

// getSiteConnectionStringKeyVaultReferenceSlotCreateRequest creates the GetSiteConnectionStringKeyVaultReferenceSlot request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStringKey string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferenceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings/{connectionStringKey}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if connectionStringKey == "" {
		return nil, errors.New("parameter connectionStringKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{connectionStringKey}", url.PathEscape(connectionStringKey))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferenceSlotHandleResponse handles the GetSiteConnectionStringKeyVaultReferenceSlot response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotHandleResponse(resp *http.Response) (WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse, error) {
	result := WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReference); err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferenceSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteConnectionStringKeyVaultReferenceSlotHandleError handles the GetSiteConnectionStringKeyVaultReferenceSlot error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferenceSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteConnectionStringKeyVaultReferences - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferences(resourceGroupName string, name string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesOptions) *WebAppsGetSiteConnectionStringKeyVaultReferencesPager {
	return &WebAppsGetSiteConnectionStringKeyVaultReferencesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getSiteConnectionStringKeyVaultReferencesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsGetSiteConnectionStringKeyVaultReferencesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
	}
}

// getSiteConnectionStringKeyVaultReferencesCreateRequest creates the GetSiteConnectionStringKeyVaultReferences request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/configreferences/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferencesHandleResponse handles the GetSiteConnectionStringKeyVaultReferences response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesHandleResponse(resp *http.Response) (WebAppsGetSiteConnectionStringKeyVaultReferencesResponse, error) {
	result := WebAppsGetSiteConnectionStringKeyVaultReferencesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferencesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteConnectionStringKeyVaultReferencesHandleError handles the GetSiteConnectionStringKeyVaultReferences error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteConnectionStringKeyVaultReferencesSlot - Description for Gets the config reference app settings and status of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteConnectionStringKeyVaultReferencesSlot(resourceGroupName string, name string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesSlotOptions) *WebAppsGetSiteConnectionStringKeyVaultReferencesSlotPager {
	return &WebAppsGetSiteConnectionStringKeyVaultReferencesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.getSiteConnectionStringKeyVaultReferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsGetSiteConnectionStringKeyVaultReferencesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.APIKVReferenceCollection.NextLink)
		},
	}
}

// getSiteConnectionStringKeyVaultReferencesSlotCreateRequest creates the GetSiteConnectionStringKeyVaultReferencesSlot request.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSiteConnectionStringKeyVaultReferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/configreferences/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteConnectionStringKeyVaultReferencesSlotHandleResponse handles the GetSiteConnectionStringKeyVaultReferencesSlot response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotHandleResponse(resp *http.Response) (WebAppsGetSiteConnectionStringKeyVaultReferencesSlotResponse, error) {
	result := WebAppsGetSiteConnectionStringKeyVaultReferencesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.APIKVReferenceCollection); err != nil {
		return WebAppsGetSiteConnectionStringKeyVaultReferencesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteConnectionStringKeyVaultReferencesSlotHandleError handles the GetSiteConnectionStringKeyVaultReferencesSlot error response.
func (client *WebAppsClient) getSiteConnectionStringKeyVaultReferencesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSiteExtension - Description for Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsGetSiteExtensionOptions) (WebAppsGetSiteExtensionResponse, error) {
	req, err := client.getSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return WebAppsGetSiteExtensionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSiteExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSiteExtensionResponse{}, client.getSiteExtensionHandleError(resp)
	}
	return client.getSiteExtensionHandleResponse(resp)
}

// getSiteExtensionCreateRequest creates the GetSiteExtension request.
func (client *WebAppsClient) getSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsGetSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteExtensionHandleResponse handles the GetSiteExtension response.
func (client *WebAppsClient) getSiteExtensionHandleResponse(resp *http.Response) (WebAppsGetSiteExtensionResponse, error) {
	result := WebAppsGetSiteExtensionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfo); err != nil {
		return WebAppsGetSiteExtensionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteExtensionHandleError handles the GetSiteExtension error response.
func (client *WebAppsClient) getSiteExtensionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetSiteExtensionSlot - Description for Get site extension information by its ID for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsGetSiteExtensionSlotOptions) (WebAppsGetSiteExtensionSlotResponse, error) {
	req, err := client.getSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return WebAppsGetSiteExtensionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSiteExtensionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSiteExtensionSlotResponse{}, client.getSiteExtensionSlotHandleError(resp)
	}
	return client.getSiteExtensionSlotHandleResponse(resp)
}

// getSiteExtensionSlotCreateRequest creates the GetSiteExtensionSlot request.
func (client *WebAppsClient) getSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsGetSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSiteExtensionSlotHandleResponse handles the GetSiteExtensionSlot response.
func (client *WebAppsClient) getSiteExtensionSlotHandleResponse(resp *http.Response) (WebAppsGetSiteExtensionSlotResponse, error) {
	result := WebAppsGetSiteExtensionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfo); err != nil {
		return WebAppsGetSiteExtensionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSiteExtensionSlotHandleError handles the GetSiteExtensionSlot error response.
func (client *WebAppsClient) getSiteExtensionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetSitePhpErrorLogFlag - Description for Gets web app's event logs.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSitePhpErrorLogFlag(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSitePhpErrorLogFlagOptions) (WebAppsGetSitePhpErrorLogFlagResponse, error) {
	req, err := client.getSitePhpErrorLogFlagCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetSitePhpErrorLogFlagResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSitePhpErrorLogFlagResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSitePhpErrorLogFlagResponse{}, client.getSitePhpErrorLogFlagHandleError(resp)
	}
	return client.getSitePhpErrorLogFlagHandleResponse(resp)
}

// getSitePhpErrorLogFlagCreateRequest creates the GetSitePhpErrorLogFlag request.
func (client *WebAppsClient) getSitePhpErrorLogFlagCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSitePhpErrorLogFlagOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSitePhpErrorLogFlagHandleResponse handles the GetSitePhpErrorLogFlag response.
func (client *WebAppsClient) getSitePhpErrorLogFlagHandleResponse(resp *http.Response) (WebAppsGetSitePhpErrorLogFlagResponse, error) {
	result := WebAppsGetSitePhpErrorLogFlagResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SitePhpErrorLogFlag); err != nil {
		return WebAppsGetSitePhpErrorLogFlagResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSitePhpErrorLogFlagHandleError handles the GetSitePhpErrorLogFlag error response.
func (client *WebAppsClient) getSitePhpErrorLogFlagHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSitePhpErrorLogFlagSlot - Description for Gets web app's event logs.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSitePhpErrorLogFlagSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSitePhpErrorLogFlagSlotOptions) (WebAppsGetSitePhpErrorLogFlagSlotResponse, error) {
	req, err := client.getSitePhpErrorLogFlagSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSitePhpErrorLogFlagSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSitePhpErrorLogFlagSlotResponse{}, client.getSitePhpErrorLogFlagSlotHandleError(resp)
	}
	return client.getSitePhpErrorLogFlagSlotHandleResponse(resp)
}

// getSitePhpErrorLogFlagSlotCreateRequest creates the GetSitePhpErrorLogFlagSlot request.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSitePhpErrorLogFlagSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/phplogging"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSitePhpErrorLogFlagSlotHandleResponse handles the GetSitePhpErrorLogFlagSlot response.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotHandleResponse(resp *http.Response) (WebAppsGetSitePhpErrorLogFlagSlotResponse, error) {
	result := WebAppsGetSitePhpErrorLogFlagSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SitePhpErrorLogFlag); err != nil {
		return WebAppsGetSitePhpErrorLogFlagSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSitePhpErrorLogFlagSlotHandleError handles the GetSitePhpErrorLogFlagSlot error response.
func (client *WebAppsClient) getSitePhpErrorLogFlagSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSlot - Description for Gets the details of a web, mobile, or API app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSlotOptions) (WebAppsGetSlotResponse, error) {
	req, err := client.getSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSlotResponse{}, client.getSlotHandleError(resp)
	}
	return client.getSlotHandleResponse(resp)
}

// getSlotCreateRequest creates the GetSlot request.
func (client *WebAppsClient) getSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSlotHandleResponse handles the GetSlot response.
func (client *WebAppsClient) getSlotHandleResponse(resp *http.Response) (WebAppsGetSlotResponse, error) {
	result := WebAppsGetSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsGetSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSlotHandleError handles the GetSlot error response.
func (client *WebAppsClient) getSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetSourceControl - Description for Gets the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSourceControl(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSourceControlOptions) (WebAppsGetSourceControlResponse, error) {
	req, err := client.getSourceControlCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return WebAppsGetSourceControlResponse{}, client.getSourceControlHandleError(resp)
	}
	return client.getSourceControlHandleResponse(resp)
}

// getSourceControlCreateRequest creates the GetSourceControl request.
func (client *WebAppsClient) getSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSourceControlHandleResponse handles the GetSourceControl response.
func (client *WebAppsClient) getSourceControlHandleResponse(resp *http.Response) (WebAppsGetSourceControlResponse, error) {
	result := WebAppsGetSourceControlResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsGetSourceControlResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSourceControlHandleError handles the GetSourceControl error response.
func (client *WebAppsClient) getSourceControlHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSourceControlSlot - Description for Gets the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSourceControlSlotOptions) (WebAppsGetSourceControlSlotResponse, error) {
	req, err := client.getSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetSourceControlSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return WebAppsGetSourceControlSlotResponse{}, client.getSourceControlSlotHandleError(resp)
	}
	return client.getSourceControlSlotHandleResponse(resp)
}

// getSourceControlSlotCreateRequest creates the GetSourceControlSlot request.
func (client *WebAppsClient) getSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSourceControlSlotHandleResponse handles the GetSourceControlSlot response.
func (client *WebAppsClient) getSourceControlSlotHandleResponse(resp *http.Response) (WebAppsGetSourceControlSlotResponse, error) {
	result := WebAppsGetSourceControlSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsGetSourceControlSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSourceControlSlotHandleError handles the GetSourceControlSlot error response.
func (client *WebAppsClient) getSourceControlSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSwiftVirtualNetworkConnection - Description for Gets a Swift Virtual Network connection.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSwiftVirtualNetworkConnection(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSwiftVirtualNetworkConnectionOptions) (WebAppsGetSwiftVirtualNetworkConnectionResponse, error) {
	req, err := client.getSwiftVirtualNetworkConnectionCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSwiftVirtualNetworkConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSwiftVirtualNetworkConnectionResponse{}, client.getSwiftVirtualNetworkConnectionHandleError(resp)
	}
	return client.getSwiftVirtualNetworkConnectionHandleResponse(resp)
}

// getSwiftVirtualNetworkConnectionCreateRequest creates the GetSwiftVirtualNetworkConnection request.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetSwiftVirtualNetworkConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSwiftVirtualNetworkConnectionHandleResponse handles the GetSwiftVirtualNetworkConnection response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionHandleResponse(resp *http.Response) (WebAppsGetSwiftVirtualNetworkConnectionResponse, error) {
	result := WebAppsGetSwiftVirtualNetworkConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsGetSwiftVirtualNetworkConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSwiftVirtualNetworkConnectionHandleError handles the GetSwiftVirtualNetworkConnection error response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetSwiftVirtualNetworkConnectionSlot - Description for Gets a Swift Virtual Network connection.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetSwiftVirtualNetworkConnectionSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSwiftVirtualNetworkConnectionSlotOptions) (WebAppsGetSwiftVirtualNetworkConnectionSlotResponse, error) {
	req, err := client.getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetSwiftVirtualNetworkConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetSwiftVirtualNetworkConnectionSlotResponse{}, client.getSwiftVirtualNetworkConnectionSlotHandleError(resp)
	}
	return client.getSwiftVirtualNetworkConnectionSlotHandleResponse(resp)
}

// getSwiftVirtualNetworkConnectionSlotCreateRequest creates the GetSwiftVirtualNetworkConnectionSlot request.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetSwiftVirtualNetworkConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getSwiftVirtualNetworkConnectionSlotHandleResponse handles the GetSwiftVirtualNetworkConnectionSlot response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotHandleResponse(resp *http.Response) (WebAppsGetSwiftVirtualNetworkConnectionSlotResponse, error) {
	result := WebAppsGetSwiftVirtualNetworkConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsGetSwiftVirtualNetworkConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getSwiftVirtualNetworkConnectionSlotHandleError handles the GetSwiftVirtualNetworkConnectionSlot error response.
func (client *WebAppsClient) getSwiftVirtualNetworkConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetTriggeredWebJob - Description for Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetTriggeredWebJobOptions) (WebAppsGetTriggeredWebJobResponse, error) {
	req, err := client.getTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsGetTriggeredWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetTriggeredWebJobResponse{}, client.getTriggeredWebJobHandleError(resp)
	}
	return client.getTriggeredWebJobHandleResponse(resp)
}

// getTriggeredWebJobCreateRequest creates the GetTriggeredWebJob request.
func (client *WebAppsClient) getTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobHandleResponse handles the GetTriggeredWebJob response.
func (client *WebAppsClient) getTriggeredWebJobHandleResponse(resp *http.Response) (WebAppsGetTriggeredWebJobResponse, error) {
	result := WebAppsGetTriggeredWebJobResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJob); err != nil {
		return WebAppsGetTriggeredWebJobResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getTriggeredWebJobHandleError handles the GetTriggeredWebJob error response.
func (client *WebAppsClient) getTriggeredWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetTriggeredWebJobHistory - Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJobHistory(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *WebAppsGetTriggeredWebJobHistoryOptions) (WebAppsGetTriggeredWebJobHistoryResponse, error) {
	req, err := client.getTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, id, options)
	if err != nil {
		return WebAppsGetTriggeredWebJobHistoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetTriggeredWebJobHistoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetTriggeredWebJobHistoryResponse{}, client.getTriggeredWebJobHistoryHandleError(resp)
	}
	return client.getTriggeredWebJobHistoryHandleResponse(resp)
}

// getTriggeredWebJobHistoryCreateRequest creates the GetTriggeredWebJobHistory request.
func (client *WebAppsClient) getTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, options *WebAppsGetTriggeredWebJobHistoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobHistoryHandleResponse handles the GetTriggeredWebJobHistory response.
func (client *WebAppsClient) getTriggeredWebJobHistoryHandleResponse(resp *http.Response) (WebAppsGetTriggeredWebJobHistoryResponse, error) {
	result := WebAppsGetTriggeredWebJobHistoryResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistory); err != nil {
		return WebAppsGetTriggeredWebJobHistoryResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getTriggeredWebJobHistoryHandleError handles the GetTriggeredWebJobHistory error response.
func (client *WebAppsClient) getTriggeredWebJobHistoryHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetTriggeredWebJobHistorySlot - Description for Gets a triggered web job's history by its ID for an app, , or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJobHistorySlot(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *WebAppsGetTriggeredWebJobHistorySlotOptions) (WebAppsGetTriggeredWebJobHistorySlotResponse, error) {
	req, err := client.getTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, id, slot, options)
	if err != nil {
		return WebAppsGetTriggeredWebJobHistorySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetTriggeredWebJobHistorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetTriggeredWebJobHistorySlotResponse{}, client.getTriggeredWebJobHistorySlotHandleError(resp)
	}
	return client.getTriggeredWebJobHistorySlotHandleResponse(resp)
}

// getTriggeredWebJobHistorySlotCreateRequest creates the GetTriggeredWebJobHistorySlot request.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, id string, slot string, options *WebAppsGetTriggeredWebJobHistorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history/{id}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobHistorySlotHandleResponse handles the GetTriggeredWebJobHistorySlot response.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotHandleResponse(resp *http.Response) (WebAppsGetTriggeredWebJobHistorySlotResponse, error) {
	result := WebAppsGetTriggeredWebJobHistorySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistory); err != nil {
		return WebAppsGetTriggeredWebJobHistorySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getTriggeredWebJobHistorySlotHandleError handles the GetTriggeredWebJobHistorySlot error response.
func (client *WebAppsClient) getTriggeredWebJobHistorySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetTriggeredWebJobSlot - Description for Gets a triggered web job by its ID for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetTriggeredWebJobSlotOptions) (WebAppsGetTriggeredWebJobSlotResponse, error) {
	req, err := client.getTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsGetTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetTriggeredWebJobSlotResponse{}, client.getTriggeredWebJobSlotHandleError(resp)
	}
	return client.getTriggeredWebJobSlotHandleResponse(resp)
}

// getTriggeredWebJobSlotCreateRequest creates the GetTriggeredWebJobSlot request.
func (client *WebAppsClient) getTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getTriggeredWebJobSlotHandleResponse handles the GetTriggeredWebJobSlot response.
func (client *WebAppsClient) getTriggeredWebJobSlotHandleResponse(resp *http.Response) (WebAppsGetTriggeredWebJobSlotResponse, error) {
	result := WebAppsGetTriggeredWebJobSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJob); err != nil {
		return WebAppsGetTriggeredWebJobSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getTriggeredWebJobSlotHandleError handles the GetTriggeredWebJobSlot error response.
func (client *WebAppsClient) getTriggeredWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetVnetConnection - Description for Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsGetVnetConnectionOptions) (WebAppsGetVnetConnectionResponse, error) {
	req, err := client.getVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, options)
	if err != nil {
		return WebAppsGetVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetVnetConnectionResponse{}, client.getVnetConnectionHandleError(resp)
	}
	return client.getVnetConnectionHandleResponse(resp)
}

// getVnetConnectionCreateRequest creates the GetVnetConnection request.
func (client *WebAppsClient) getVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, options *WebAppsGetVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionHandleResponse handles the GetVnetConnection response.
func (client *WebAppsClient) getVnetConnectionHandleResponse(resp *http.Response) (WebAppsGetVnetConnectionResponse, error) {
	result := WebAppsGetVnetConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsGetVnetConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVnetConnectionHandleError handles the GetVnetConnection error response.
func (client *WebAppsClient) getVnetConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetVnetConnectionGateway - Description for Gets an app's Virtual Network gateway.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *WebAppsGetVnetConnectionGatewayOptions) (WebAppsGetVnetConnectionGatewayResponse, error) {
	req, err := client.getVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, options)
	if err != nil {
		return WebAppsGetVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetVnetConnectionGatewayResponse{}, client.getVnetConnectionGatewayHandleError(resp)
	}
	return client.getVnetConnectionGatewayHandleResponse(resp)
}

// getVnetConnectionGatewayCreateRequest creates the GetVnetConnectionGateway request.
func (client *WebAppsClient) getVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, options *WebAppsGetVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionGatewayHandleResponse handles the GetVnetConnectionGateway response.
func (client *WebAppsClient) getVnetConnectionGatewayHandleResponse(resp *http.Response) (WebAppsGetVnetConnectionGatewayResponse, error) {
	result := WebAppsGetVnetConnectionGatewayResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsGetVnetConnectionGatewayResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVnetConnectionGatewayHandleError handles the GetVnetConnectionGateway error response.
func (client *WebAppsClient) getVnetConnectionGatewayHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetVnetConnectionGatewaySlot - Description for Gets an app's Virtual Network gateway.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *WebAppsGetVnetConnectionGatewaySlotOptions) (WebAppsGetVnetConnectionGatewaySlotResponse, error) {
	req, err := client.getVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, options)
	if err != nil {
		return WebAppsGetVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetVnetConnectionGatewaySlotResponse{}, client.getVnetConnectionGatewaySlotHandleError(resp)
	}
	return client.getVnetConnectionGatewaySlotHandleResponse(resp)
}

// getVnetConnectionGatewaySlotCreateRequest creates the GetVnetConnectionGatewaySlot request.
func (client *WebAppsClient) getVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, options *WebAppsGetVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionGatewaySlotHandleResponse handles the GetVnetConnectionGatewaySlot response.
func (client *WebAppsClient) getVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (WebAppsGetVnetConnectionGatewaySlotResponse, error) {
	result := WebAppsGetVnetConnectionGatewaySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsGetVnetConnectionGatewaySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVnetConnectionGatewaySlotHandleError handles the GetVnetConnectionGatewaySlot error response.
func (client *WebAppsClient) getVnetConnectionGatewaySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// GetVnetConnectionSlot - Description for Gets a virtual network the app (or deployment slot) is connected to by name.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsGetVnetConnectionSlotOptions) (WebAppsGetVnetConnectionSlotResponse, error) {
	req, err := client.getVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, options)
	if err != nil {
		return WebAppsGetVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetVnetConnectionSlotResponse{}, client.getVnetConnectionSlotHandleError(resp)
	}
	return client.getVnetConnectionSlotHandleResponse(resp)
}

// getVnetConnectionSlotCreateRequest creates the GetVnetConnectionSlot request.
func (client *WebAppsClient) getVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, options *WebAppsGetVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getVnetConnectionSlotHandleResponse handles the GetVnetConnectionSlot response.
func (client *WebAppsClient) getVnetConnectionSlotHandleResponse(resp *http.Response) (WebAppsGetVnetConnectionSlotResponse, error) {
	result := WebAppsGetVnetConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsGetVnetConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getVnetConnectionSlotHandleError handles the GetVnetConnectionSlot error response.
func (client *WebAppsClient) getVnetConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetWebJob - Description for Get webjob information for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetWebJobOptions) (WebAppsGetWebJobResponse, error) {
	req, err := client.getWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsGetWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetWebJobResponse{}, client.getWebJobHandleError(resp)
	}
	return client.getWebJobHandleResponse(resp)
}

// getWebJobCreateRequest creates the GetWebJob request.
func (client *WebAppsClient) getWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsGetWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWebJobHandleResponse handles the GetWebJob response.
func (client *WebAppsClient) getWebJobHandleResponse(resp *http.Response) (WebAppsGetWebJobResponse, error) {
	result := WebAppsGetWebJobResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJob); err != nil {
		return WebAppsGetWebJobResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getWebJobHandleError handles the GetWebJob error response.
func (client *WebAppsClient) getWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetWebJobSlot - Description for Get webjob information for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) GetWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetWebJobSlotOptions) (WebAppsGetWebJobSlotResponse, error) {
	req, err := client.getWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsGetWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsGetWebJobSlotResponse{}, client.getWebJobSlotHandleError(resp)
	}
	return client.getWebJobSlotHandleResponse(resp)
}

// getWebJobSlotCreateRequest creates the GetWebJobSlot request.
func (client *WebAppsClient) getWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsGetWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs/{webJobName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getWebJobSlotHandleResponse handles the GetWebJobSlot response.
func (client *WebAppsClient) getWebJobSlotHandleResponse(resp *http.Response) (WebAppsGetWebJobSlotResponse, error) {
	result := WebAppsGetWebJobSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJob); err != nil {
		return WebAppsGetWebJobSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// getWebJobSlotHandleError handles the GetWebJobSlot error response.
func (client *WebAppsClient) getWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// GetWebSiteContainerLogs - Description for Gets the last lines of docker logs for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetWebSiteContainerLogs(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetWebSiteContainerLogsOptions) (WebAppsGetWebSiteContainerLogsResponse, error) {
	req, err := client.getWebSiteContainerLogsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsGetWebSiteContainerLogsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetWebSiteContainerLogsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsGetWebSiteContainerLogsResponse{}, client.getWebSiteContainerLogsHandleError(resp)
	}
	return WebAppsGetWebSiteContainerLogsResponse{RawResponse: resp}, nil
}

// getWebSiteContainerLogsCreateRequest creates the GetWebSiteContainerLogs request.
func (client *WebAppsClient) getWebSiteContainerLogsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsGetWebSiteContainerLogsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/octet-stream")
	return req, nil
}

// getWebSiteContainerLogsHandleError handles the GetWebSiteContainerLogs error response.
func (client *WebAppsClient) getWebSiteContainerLogsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetWebSiteContainerLogsSlot - Description for Gets the last lines of docker logs for the given site
// If the operation fails it returns a generic error.
func (client *WebAppsClient) GetWebSiteContainerLogsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetWebSiteContainerLogsSlotOptions) (WebAppsGetWebSiteContainerLogsSlotResponse, error) {
	req, err := client.getWebSiteContainerLogsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsGetWebSiteContainerLogsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsGetWebSiteContainerLogsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsGetWebSiteContainerLogsSlotResponse{}, client.getWebSiteContainerLogsSlotHandleError(resp)
	}
	return WebAppsGetWebSiteContainerLogsSlotResponse{RawResponse: resp}, nil
}

// getWebSiteContainerLogsSlotCreateRequest creates the GetWebSiteContainerLogsSlot request.
func (client *WebAppsClient) getWebSiteContainerLogsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsGetWebSiteContainerLogsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/containerlogs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/octet-stream")
	return req, nil
}

// getWebSiteContainerLogsSlotHandleError handles the GetWebSiteContainerLogsSlot error response.
func (client *WebAppsClient) getWebSiteContainerLogsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginInstallSiteExtension - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginInstallSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsBeginInstallSiteExtensionOptions) (WebAppsInstallSiteExtensionPollerResponse, error) {
	resp, err := client.installSiteExtension(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return WebAppsInstallSiteExtensionPollerResponse{}, err
	}
	result := WebAppsInstallSiteExtensionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.InstallSiteExtension", "", resp, client.pl, client.installSiteExtensionHandleError)
	if err != nil {
		return WebAppsInstallSiteExtensionPollerResponse{}, err
	}
	result.Poller = &WebAppsInstallSiteExtensionPoller{
		pt: pt,
	}
	return result, nil
}

// InstallSiteExtension - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) installSiteExtension(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsBeginInstallSiteExtensionOptions) (*http.Response, error) {
	req, err := client.installSiteExtensionCreateRequest(ctx, resourceGroupName, name, siteExtensionID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.installSiteExtensionHandleError(resp)
	}
	return resp, nil
}

// installSiteExtensionCreateRequest creates the InstallSiteExtension request.
func (client *WebAppsClient) installSiteExtensionCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, options *WebAppsBeginInstallSiteExtensionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// installSiteExtensionHandleError handles the InstallSiteExtension error response.
func (client *WebAppsClient) installSiteExtensionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusTooManyRequests:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// BeginInstallSiteExtensionSlot - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginInstallSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsBeginInstallSiteExtensionSlotOptions) (WebAppsInstallSiteExtensionSlotPollerResponse, error) {
	resp, err := client.installSiteExtensionSlot(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return WebAppsInstallSiteExtensionSlotPollerResponse{}, err
	}
	result := WebAppsInstallSiteExtensionSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.InstallSiteExtensionSlot", "", resp, client.pl, client.installSiteExtensionSlotHandleError)
	if err != nil {
		return WebAppsInstallSiteExtensionSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsInstallSiteExtensionSlotPoller{
		pt: pt,
	}
	return result, nil
}

// InstallSiteExtensionSlot - Description for Install site extension on a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) installSiteExtensionSlot(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsBeginInstallSiteExtensionSlotOptions) (*http.Response, error) {
	req, err := client.installSiteExtensionSlotCreateRequest(ctx, resourceGroupName, name, siteExtensionID, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return nil, client.installSiteExtensionSlotHandleError(resp)
	}
	return resp, nil
}

// installSiteExtensionSlotCreateRequest creates the InstallSiteExtensionSlot request.
func (client *WebAppsClient) installSiteExtensionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, siteExtensionID string, slot string, options *WebAppsBeginInstallSiteExtensionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions/{siteExtensionId}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if siteExtensionID == "" {
		return nil, errors.New("parameter siteExtensionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{siteExtensionId}", url.PathEscape(siteExtensionID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// installSiteExtensionSlotHandleError handles the InstallSiteExtensionSlot error response.
func (client *WebAppsClient) installSiteExtensionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusTooManyRequests:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// IsCloneable - Description for Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) IsCloneable(ctx context.Context, resourceGroupName string, name string, options *WebAppsIsCloneableOptions) (WebAppsIsCloneableResponse, error) {
	req, err := client.isCloneableCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsIsCloneableResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsIsCloneableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsIsCloneableResponse{}, client.isCloneableHandleError(resp)
	}
	return client.isCloneableHandleResponse(resp)
}

// isCloneableCreateRequest creates the IsCloneable request.
func (client *WebAppsClient) isCloneableCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsIsCloneableOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// isCloneableHandleResponse handles the IsCloneable response.
func (client *WebAppsClient) isCloneableHandleResponse(resp *http.Response) (WebAppsIsCloneableResponse, error) {
	result := WebAppsIsCloneableResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteCloneability); err != nil {
		return WebAppsIsCloneableResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// isCloneableHandleError handles the IsCloneable error response.
func (client *WebAppsClient) isCloneableHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// IsCloneableSlot - Description for Shows whether an app can be cloned to another resource group or subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) IsCloneableSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsIsCloneableSlotOptions) (WebAppsIsCloneableSlotResponse, error) {
	req, err := client.isCloneableSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsIsCloneableSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsIsCloneableSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsIsCloneableSlotResponse{}, client.isCloneableSlotHandleError(resp)
	}
	return client.isCloneableSlotHandleResponse(resp)
}

// isCloneableSlotCreateRequest creates the IsCloneableSlot request.
func (client *WebAppsClient) isCloneableSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsIsCloneableSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/iscloneable"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// isCloneableSlotHandleResponse handles the IsCloneableSlot response.
func (client *WebAppsClient) isCloneableSlotHandleResponse(resp *http.Response) (WebAppsIsCloneableSlotResponse, error) {
	result := WebAppsIsCloneableSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteCloneability); err != nil {
		return WebAppsIsCloneableSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// isCloneableSlotHandleError handles the IsCloneableSlot error response.
func (client *WebAppsClient) isCloneableSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// List - Description for Get all apps for a subscription.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) List(options *WebAppsListOptions) *WebAppsListPager {
	return &WebAppsListPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listCreateRequest(ctx, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
	}
}

// listCreateRequest creates the List request.
func (client *WebAppsClient) listCreateRequest(ctx context.Context, options *WebAppsListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Web/sites"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *WebAppsClient) listHandleResponse(resp *http.Response) (WebAppsListResponse, error) {
	result := WebAppsListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return WebAppsListResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHandleError handles the List error response.
func (client *WebAppsClient) listHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListApplicationSettings - Description for Gets the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListApplicationSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsListApplicationSettingsOptions) (WebAppsListApplicationSettingsResponse, error) {
	req, err := client.listApplicationSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListApplicationSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListApplicationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListApplicationSettingsResponse{}, client.listApplicationSettingsHandleError(resp)
	}
	return client.listApplicationSettingsHandleResponse(resp)
}

// listApplicationSettingsCreateRequest creates the ListApplicationSettings request.
func (client *WebAppsClient) listApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListApplicationSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listApplicationSettingsHandleResponse handles the ListApplicationSettings response.
func (client *WebAppsClient) listApplicationSettingsHandleResponse(resp *http.Response) (WebAppsListApplicationSettingsResponse, error) {
	result := WebAppsListApplicationSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsListApplicationSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listApplicationSettingsHandleError handles the ListApplicationSettings error response.
func (client *WebAppsClient) listApplicationSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListApplicationSettingsSlot - Description for Gets the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListApplicationSettingsSlotOptions) (WebAppsListApplicationSettingsSlotResponse, error) {
	req, err := client.listApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListApplicationSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListApplicationSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListApplicationSettingsSlotResponse{}, client.listApplicationSettingsSlotHandleError(resp)
	}
	return client.listApplicationSettingsSlotHandleResponse(resp)
}

// listApplicationSettingsSlotCreateRequest creates the ListApplicationSettingsSlot request.
func (client *WebAppsClient) listApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListApplicationSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listApplicationSettingsSlotHandleResponse handles the ListApplicationSettingsSlot response.
func (client *WebAppsClient) listApplicationSettingsSlotHandleResponse(resp *http.Response) (WebAppsListApplicationSettingsSlotResponse, error) {
	result := WebAppsListApplicationSettingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsListApplicationSettingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listApplicationSettingsSlotHandleError handles the ListApplicationSettingsSlot error response.
func (client *WebAppsClient) listApplicationSettingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListAzureStorageAccounts - Description for Gets the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, options *WebAppsListAzureStorageAccountsOptions) (WebAppsListAzureStorageAccountsResponse, error) {
	req, err := client.listAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListAzureStorageAccountsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListAzureStorageAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListAzureStorageAccountsResponse{}, client.listAzureStorageAccountsHandleError(resp)
	}
	return client.listAzureStorageAccountsHandleResponse(resp)
}

// listAzureStorageAccountsCreateRequest creates the ListAzureStorageAccounts request.
func (client *WebAppsClient) listAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListAzureStorageAccountsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAzureStorageAccountsHandleResponse handles the ListAzureStorageAccounts response.
func (client *WebAppsClient) listAzureStorageAccountsHandleResponse(resp *http.Response) (WebAppsListAzureStorageAccountsResponse, error) {
	result := WebAppsListAzureStorageAccountsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsListAzureStorageAccountsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listAzureStorageAccountsHandleError handles the ListAzureStorageAccounts error response.
func (client *WebAppsClient) listAzureStorageAccountsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListAzureStorageAccountsSlot - Description for Gets the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListAzureStorageAccountsSlotOptions) (WebAppsListAzureStorageAccountsSlotResponse, error) {
	req, err := client.listAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListAzureStorageAccountsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListAzureStorageAccountsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListAzureStorageAccountsSlotResponse{}, client.listAzureStorageAccountsSlotHandleError(resp)
	}
	return client.listAzureStorageAccountsSlotHandleResponse(resp)
}

// listAzureStorageAccountsSlotCreateRequest creates the ListAzureStorageAccountsSlot request.
func (client *WebAppsClient) listAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListAzureStorageAccountsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listAzureStorageAccountsSlotHandleResponse handles the ListAzureStorageAccountsSlot response.
func (client *WebAppsClient) listAzureStorageAccountsSlotHandleResponse(resp *http.Response) (WebAppsListAzureStorageAccountsSlotResponse, error) {
	result := WebAppsListAzureStorageAccountsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsListAzureStorageAccountsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listAzureStorageAccountsSlotHandleError handles the ListAzureStorageAccountsSlot error response.
func (client *WebAppsClient) listAzureStorageAccountsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListBackupStatusSecrets - Description for Gets status of a web app backup that may be in progress, including secrets associated with the backup, such
// as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
// backup if a new URL is passed in the request body.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackupStatusSecrets(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *WebAppsListBackupStatusSecretsOptions) (WebAppsListBackupStatusSecretsResponse, error) {
	req, err := client.listBackupStatusSecretsCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return WebAppsListBackupStatusSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListBackupStatusSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListBackupStatusSecretsResponse{}, client.listBackupStatusSecretsHandleError(resp)
	}
	return client.listBackupStatusSecretsHandleResponse(resp)
}

// listBackupStatusSecretsCreateRequest creates the ListBackupStatusSecrets request.
func (client *WebAppsClient) listBackupStatusSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request BackupRequest, options *WebAppsListBackupStatusSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// listBackupStatusSecretsHandleResponse handles the ListBackupStatusSecrets response.
func (client *WebAppsClient) listBackupStatusSecretsHandleResponse(resp *http.Response) (WebAppsListBackupStatusSecretsResponse, error) {
	result := WebAppsListBackupStatusSecretsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsListBackupStatusSecretsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listBackupStatusSecretsHandleError handles the ListBackupStatusSecrets error response.
func (client *WebAppsClient) listBackupStatusSecretsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListBackupStatusSecretsSlot - Description for Gets status of a web app backup that may be in progress, including secrets associated with the backup,
// such as the Azure Storage SAS URL. Also can be used to update the SAS URL for the
// backup if a new URL is passed in the request body.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackupStatusSecretsSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *WebAppsListBackupStatusSecretsSlotOptions) (WebAppsListBackupStatusSecretsSlotResponse, error) {
	req, err := client.listBackupStatusSecretsSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return WebAppsListBackupStatusSecretsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListBackupStatusSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListBackupStatusSecretsSlotResponse{}, client.listBackupStatusSecretsSlotHandleError(resp)
	}
	return client.listBackupStatusSecretsSlotHandleResponse(resp)
}

// listBackupStatusSecretsSlotCreateRequest creates the ListBackupStatusSecretsSlot request.
func (client *WebAppsClient) listBackupStatusSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request BackupRequest, options *WebAppsListBackupStatusSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// listBackupStatusSecretsSlotHandleResponse handles the ListBackupStatusSecretsSlot response.
func (client *WebAppsClient) listBackupStatusSecretsSlotHandleResponse(resp *http.Response) (WebAppsListBackupStatusSecretsSlotResponse, error) {
	result := WebAppsListBackupStatusSecretsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItem); err != nil {
		return WebAppsListBackupStatusSecretsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listBackupStatusSecretsSlotHandleError handles the ListBackupStatusSecretsSlot error response.
func (client *WebAppsClient) listBackupStatusSecretsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListBackups - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackups(resourceGroupName string, name string, options *WebAppsListBackupsOptions) *WebAppsListBackupsPager {
	return &WebAppsListBackupsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listBackupsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListBackupsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
	}
}

// listBackupsCreateRequest creates the ListBackups request.
func (client *WebAppsClient) listBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListBackupsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listBackupsHandleResponse handles the ListBackups response.
func (client *WebAppsClient) listBackupsHandleResponse(resp *http.Response) (WebAppsListBackupsResponse, error) {
	result := WebAppsListBackupsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsListBackupsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listBackupsHandleError handles the ListBackups error response.
func (client *WebAppsClient) listBackupsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListBackupsSlot - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBackupsSlot(resourceGroupName string, name string, slot string, options *WebAppsListBackupsSlotOptions) *WebAppsListBackupsSlotPager {
	return &WebAppsListBackupsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListBackupsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
	}
}

// listBackupsSlotCreateRequest creates the ListBackupsSlot request.
func (client *WebAppsClient) listBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListBackupsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listBackupsSlotHandleResponse handles the ListBackupsSlot response.
func (client *WebAppsClient) listBackupsSlotHandleResponse(resp *http.Response) (WebAppsListBackupsSlotResponse, error) {
	result := WebAppsListBackupsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsListBackupsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listBackupsSlotHandleError handles the ListBackupsSlot error response.
func (client *WebAppsClient) listBackupsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListBasicPublishingCredentialsPolicies - Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBasicPublishingCredentialsPolicies(resourceGroupName string, name string, options *WebAppsListBasicPublishingCredentialsPoliciesOptions) *WebAppsListBasicPublishingCredentialsPoliciesPager {
	return &WebAppsListBasicPublishingCredentialsPoliciesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listBasicPublishingCredentialsPoliciesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListBasicPublishingCredentialsPoliciesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PublishingCredentialsPoliciesCollection.NextLink)
		},
	}
}

// listBasicPublishingCredentialsPoliciesCreateRequest creates the ListBasicPublishingCredentialsPolicies request.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListBasicPublishingCredentialsPoliciesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listBasicPublishingCredentialsPoliciesHandleResponse handles the ListBasicPublishingCredentialsPolicies response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesHandleResponse(resp *http.Response) (WebAppsListBasicPublishingCredentialsPoliciesResponse, error) {
	result := WebAppsListBasicPublishingCredentialsPoliciesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublishingCredentialsPoliciesCollection); err != nil {
		return WebAppsListBasicPublishingCredentialsPoliciesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listBasicPublishingCredentialsPoliciesHandleError handles the ListBasicPublishingCredentialsPolicies error response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListBasicPublishingCredentialsPoliciesSlot - Description for Returns whether Scm basic auth is allowed and whether Ftp is allowed for a given site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListBasicPublishingCredentialsPoliciesSlot(resourceGroupName string, name string, slot string, options *WebAppsListBasicPublishingCredentialsPoliciesSlotOptions) *WebAppsListBasicPublishingCredentialsPoliciesSlotPager {
	return &WebAppsListBasicPublishingCredentialsPoliciesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listBasicPublishingCredentialsPoliciesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListBasicPublishingCredentialsPoliciesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PublishingCredentialsPoliciesCollection.NextLink)
		},
	}
}

// listBasicPublishingCredentialsPoliciesSlotCreateRequest creates the ListBasicPublishingCredentialsPoliciesSlot request.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListBasicPublishingCredentialsPoliciesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listBasicPublishingCredentialsPoliciesSlotHandleResponse handles the ListBasicPublishingCredentialsPoliciesSlot response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotHandleResponse(resp *http.Response) (WebAppsListBasicPublishingCredentialsPoliciesSlotResponse, error) {
	result := WebAppsListBasicPublishingCredentialsPoliciesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublishingCredentialsPoliciesCollection); err != nil {
		return WebAppsListBasicPublishingCredentialsPoliciesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listBasicPublishingCredentialsPoliciesSlotHandleError handles the ListBasicPublishingCredentialsPoliciesSlot error response.
func (client *WebAppsClient) listBasicPublishingCredentialsPoliciesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListByResourceGroup - Description for Gets all web, mobile, and API apps in the specified resource group.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListByResourceGroup(resourceGroupName string, options *WebAppsListByResourceGroupOptions) *WebAppsListByResourceGroupPager {
	return &WebAppsListByResourceGroupPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListByResourceGroupResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
	}
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *WebAppsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *WebAppsListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.IncludeSlots != nil {
		reqQP.Set("includeSlots", strconv.FormatBool(*options.IncludeSlots))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *WebAppsClient) listByResourceGroupHandleResponse(resp *http.Response) (WebAppsListByResourceGroupResponse, error) {
	result := WebAppsListByResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return WebAppsListByResourceGroupResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *WebAppsClient) listByResourceGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListConfigurationSnapshotInfo - Description for Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp
// and the ID of the snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurationSnapshotInfo(resourceGroupName string, name string, options *WebAppsListConfigurationSnapshotInfoOptions) *WebAppsListConfigurationSnapshotInfoPager {
	return &WebAppsListConfigurationSnapshotInfoPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listConfigurationSnapshotInfoCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListConfigurationSnapshotInfoResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SiteConfigurationSnapshotInfoCollection.NextLink)
		},
	}
}

// listConfigurationSnapshotInfoCreateRequest creates the ListConfigurationSnapshotInfo request.
func (client *WebAppsClient) listConfigurationSnapshotInfoCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConfigurationSnapshotInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationSnapshotInfoHandleResponse handles the ListConfigurationSnapshotInfo response.
func (client *WebAppsClient) listConfigurationSnapshotInfoHandleResponse(resp *http.Response) (WebAppsListConfigurationSnapshotInfoResponse, error) {
	result := WebAppsListConfigurationSnapshotInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigurationSnapshotInfoCollection); err != nil {
		return WebAppsListConfigurationSnapshotInfoResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listConfigurationSnapshotInfoHandleError handles the ListConfigurationSnapshotInfo error response.
func (client *WebAppsClient) listConfigurationSnapshotInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListConfigurationSnapshotInfoSlot - Description for Gets a list of web app configuration snapshots identifiers. Each element of the list contains a timestamp
// and the ID of the snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurationSnapshotInfoSlot(resourceGroupName string, name string, slot string, options *WebAppsListConfigurationSnapshotInfoSlotOptions) *WebAppsListConfigurationSnapshotInfoSlotPager {
	return &WebAppsListConfigurationSnapshotInfoSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listConfigurationSnapshotInfoSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListConfigurationSnapshotInfoSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SiteConfigurationSnapshotInfoCollection.NextLink)
		},
	}
}

// listConfigurationSnapshotInfoSlotCreateRequest creates the ListConfigurationSnapshotInfoSlot request.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConfigurationSnapshotInfoSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationSnapshotInfoSlotHandleResponse handles the ListConfigurationSnapshotInfoSlot response.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotHandleResponse(resp *http.Response) (WebAppsListConfigurationSnapshotInfoSlotResponse, error) {
	result := WebAppsListConfigurationSnapshotInfoSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigurationSnapshotInfoCollection); err != nil {
		return WebAppsListConfigurationSnapshotInfoSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listConfigurationSnapshotInfoSlotHandleError handles the ListConfigurationSnapshotInfoSlot error response.
func (client *WebAppsClient) listConfigurationSnapshotInfoSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListConfigurations - Description for List the configurations of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurations(resourceGroupName string, name string, options *WebAppsListConfigurationsOptions) *WebAppsListConfigurationsPager {
	return &WebAppsListConfigurationsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listConfigurationsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListConfigurationsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SiteConfigResourceCollection.NextLink)
		},
	}
}

// listConfigurationsCreateRequest creates the ListConfigurations request.
func (client *WebAppsClient) listConfigurationsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConfigurationsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationsHandleResponse handles the ListConfigurations response.
func (client *WebAppsClient) listConfigurationsHandleResponse(resp *http.Response) (WebAppsListConfigurationsResponse, error) {
	result := WebAppsListConfigurationsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResourceCollection); err != nil {
		return WebAppsListConfigurationsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listConfigurationsHandleError handles the ListConfigurations error response.
func (client *WebAppsClient) listConfigurationsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListConfigurationsSlot - Description for List the configurations of an app
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConfigurationsSlot(resourceGroupName string, name string, slot string, options *WebAppsListConfigurationsSlotOptions) *WebAppsListConfigurationsSlotPager {
	return &WebAppsListConfigurationsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listConfigurationsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListConfigurationsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SiteConfigResourceCollection.NextLink)
		},
	}
}

// listConfigurationsSlotCreateRequest creates the ListConfigurationsSlot request.
func (client *WebAppsClient) listConfigurationsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConfigurationsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listConfigurationsSlotHandleResponse handles the ListConfigurationsSlot response.
func (client *WebAppsClient) listConfigurationsSlotHandleResponse(resp *http.Response) (WebAppsListConfigurationsSlotResponse, error) {
	result := WebAppsListConfigurationsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResourceCollection); err != nil {
		return WebAppsListConfigurationsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listConfigurationsSlotHandleError handles the ListConfigurationsSlot error response.
func (client *WebAppsClient) listConfigurationsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListConnectionStrings - Description for Gets the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConnectionStrings(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConnectionStringsOptions) (WebAppsListConnectionStringsResponse, error) {
	req, err := client.listConnectionStringsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListConnectionStringsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListConnectionStringsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListConnectionStringsResponse{}, client.listConnectionStringsHandleError(resp)
	}
	return client.listConnectionStringsHandleResponse(resp)
}

// listConnectionStringsCreateRequest creates the ListConnectionStrings request.
func (client *WebAppsClient) listConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListConnectionStringsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listConnectionStringsHandleResponse handles the ListConnectionStrings response.
func (client *WebAppsClient) listConnectionStringsHandleResponse(resp *http.Response) (WebAppsListConnectionStringsResponse, error) {
	result := WebAppsListConnectionStringsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsListConnectionStringsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listConnectionStringsHandleError handles the ListConnectionStrings error response.
func (client *WebAppsClient) listConnectionStringsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListConnectionStringsSlot - Description for Gets the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConnectionStringsSlotOptions) (WebAppsListConnectionStringsSlotResponse, error) {
	req, err := client.listConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListConnectionStringsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListConnectionStringsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListConnectionStringsSlotResponse{}, client.listConnectionStringsSlotHandleError(resp)
	}
	return client.listConnectionStringsSlotHandleResponse(resp)
}

// listConnectionStringsSlotCreateRequest creates the ListConnectionStringsSlot request.
func (client *WebAppsClient) listConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListConnectionStringsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listConnectionStringsSlotHandleResponse handles the ListConnectionStringsSlot response.
func (client *WebAppsClient) listConnectionStringsSlotHandleResponse(resp *http.Response) (WebAppsListConnectionStringsSlotResponse, error) {
	result := WebAppsListConnectionStringsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsListConnectionStringsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listConnectionStringsSlotHandleError handles the ListConnectionStringsSlot error response.
func (client *WebAppsClient) listConnectionStringsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListContinuousWebJobs - Description for List continuous web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListContinuousWebJobs(resourceGroupName string, name string, options *WebAppsListContinuousWebJobsOptions) *WebAppsListContinuousWebJobsPager {
	return &WebAppsListContinuousWebJobsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listContinuousWebJobsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListContinuousWebJobsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ContinuousWebJobCollection.NextLink)
		},
	}
}

// listContinuousWebJobsCreateRequest creates the ListContinuousWebJobs request.
func (client *WebAppsClient) listContinuousWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListContinuousWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listContinuousWebJobsHandleResponse handles the ListContinuousWebJobs response.
func (client *WebAppsClient) listContinuousWebJobsHandleResponse(resp *http.Response) (WebAppsListContinuousWebJobsResponse, error) {
	result := WebAppsListContinuousWebJobsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJobCollection); err != nil {
		return WebAppsListContinuousWebJobsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listContinuousWebJobsHandleError handles the ListContinuousWebJobs error response.
func (client *WebAppsClient) listContinuousWebJobsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListContinuousWebJobsSlot - Description for List continuous web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListContinuousWebJobsSlot(resourceGroupName string, name string, slot string, options *WebAppsListContinuousWebJobsSlotOptions) *WebAppsListContinuousWebJobsSlotPager {
	return &WebAppsListContinuousWebJobsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listContinuousWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListContinuousWebJobsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ContinuousWebJobCollection.NextLink)
		},
	}
}

// listContinuousWebJobsSlotCreateRequest creates the ListContinuousWebJobsSlot request.
func (client *WebAppsClient) listContinuousWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListContinuousWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listContinuousWebJobsSlotHandleResponse handles the ListContinuousWebJobsSlot response.
func (client *WebAppsClient) listContinuousWebJobsSlotHandleResponse(resp *http.Response) (WebAppsListContinuousWebJobsSlotResponse, error) {
	result := WebAppsListContinuousWebJobsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ContinuousWebJobCollection); err != nil {
		return WebAppsListContinuousWebJobsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listContinuousWebJobsSlotHandleError handles the ListContinuousWebJobsSlot error response.
func (client *WebAppsClient) listContinuousWebJobsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDeploymentLog - Description for List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeploymentLog(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsListDeploymentLogOptions) (WebAppsListDeploymentLogResponse, error) {
	req, err := client.listDeploymentLogCreateRequest(ctx, resourceGroupName, name, id, options)
	if err != nil {
		return WebAppsListDeploymentLogResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListDeploymentLogResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListDeploymentLogResponse{}, client.listDeploymentLogHandleError(resp)
	}
	return client.listDeploymentLogHandleResponse(resp)
}

// listDeploymentLogCreateRequest creates the ListDeploymentLog request.
func (client *WebAppsClient) listDeploymentLogCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, options *WebAppsListDeploymentLogOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentLogHandleResponse handles the ListDeploymentLog response.
func (client *WebAppsClient) listDeploymentLogHandleResponse(resp *http.Response) (WebAppsListDeploymentLogResponse, error) {
	result := WebAppsListDeploymentLogResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsListDeploymentLogResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDeploymentLogHandleError handles the ListDeploymentLog error response.
func (client *WebAppsClient) listDeploymentLogHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDeploymentLogSlot - Description for List deployment log for specific deployment for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeploymentLogSlot(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsListDeploymentLogSlotOptions) (WebAppsListDeploymentLogSlotResponse, error) {
	req, err := client.listDeploymentLogSlotCreateRequest(ctx, resourceGroupName, name, id, slot, options)
	if err != nil {
		return WebAppsListDeploymentLogSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListDeploymentLogSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListDeploymentLogSlotResponse{}, client.listDeploymentLogSlotHandleError(resp)
	}
	return client.listDeploymentLogSlotHandleResponse(resp)
}

// listDeploymentLogSlotCreateRequest creates the ListDeploymentLogSlot request.
func (client *WebAppsClient) listDeploymentLogSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, id string, slot string, options *WebAppsListDeploymentLogSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments/{id}/log"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if id == "" {
		return nil, errors.New("parameter id cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{id}", url.PathEscape(id))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentLogSlotHandleResponse handles the ListDeploymentLogSlot response.
func (client *WebAppsClient) listDeploymentLogSlotHandleResponse(resp *http.Response) (WebAppsListDeploymentLogSlotResponse, error) {
	result := WebAppsListDeploymentLogSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Deployment); err != nil {
		return WebAppsListDeploymentLogSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDeploymentLogSlotHandleError handles the ListDeploymentLogSlot error response.
func (client *WebAppsClient) listDeploymentLogSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDeployments - Description for List deployments for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeployments(resourceGroupName string, name string, options *WebAppsListDeploymentsOptions) *WebAppsListDeploymentsPager {
	return &WebAppsListDeploymentsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDeploymentsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListDeploymentsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DeploymentCollection.NextLink)
		},
	}
}

// listDeploymentsCreateRequest creates the ListDeployments request.
func (client *WebAppsClient) listDeploymentsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListDeploymentsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsHandleResponse handles the ListDeployments response.
func (client *WebAppsClient) listDeploymentsHandleResponse(resp *http.Response) (WebAppsListDeploymentsResponse, error) {
	result := WebAppsListDeploymentsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentCollection); err != nil {
		return WebAppsListDeploymentsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDeploymentsHandleError handles the ListDeployments error response.
func (client *WebAppsClient) listDeploymentsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDeploymentsSlot - Description for List deployments for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDeploymentsSlot(resourceGroupName string, name string, slot string, options *WebAppsListDeploymentsSlotOptions) *WebAppsListDeploymentsSlotPager {
	return &WebAppsListDeploymentsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDeploymentsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListDeploymentsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.DeploymentCollection.NextLink)
		},
	}
}

// listDeploymentsSlotCreateRequest creates the ListDeploymentsSlot request.
func (client *WebAppsClient) listDeploymentsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListDeploymentsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/deployments"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDeploymentsSlotHandleResponse handles the ListDeploymentsSlot response.
func (client *WebAppsClient) listDeploymentsSlotHandleResponse(resp *http.Response) (WebAppsListDeploymentsSlotResponse, error) {
	result := WebAppsListDeploymentsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeploymentCollection); err != nil {
		return WebAppsListDeploymentsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDeploymentsSlotHandleError handles the ListDeploymentsSlot error response.
func (client *WebAppsClient) listDeploymentsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDomainOwnershipIdentifiers - Description for Lists ownership identifiers for domain associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDomainOwnershipIdentifiers(resourceGroupName string, name string, options *WebAppsListDomainOwnershipIdentifiersOptions) *WebAppsListDomainOwnershipIdentifiersPager {
	return &WebAppsListDomainOwnershipIdentifiersPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDomainOwnershipIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListDomainOwnershipIdentifiersResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.IdentifierCollection.NextLink)
		},
	}
}

// listDomainOwnershipIdentifiersCreateRequest creates the ListDomainOwnershipIdentifiers request.
func (client *WebAppsClient) listDomainOwnershipIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListDomainOwnershipIdentifiersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDomainOwnershipIdentifiersHandleResponse handles the ListDomainOwnershipIdentifiers response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersHandleResponse(resp *http.Response) (WebAppsListDomainOwnershipIdentifiersResponse, error) {
	result := WebAppsListDomainOwnershipIdentifiersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return WebAppsListDomainOwnershipIdentifiersResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDomainOwnershipIdentifiersHandleError handles the ListDomainOwnershipIdentifiers error response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListDomainOwnershipIdentifiersSlot - Description for Lists ownership identifiers for domain associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListDomainOwnershipIdentifiersSlot(resourceGroupName string, name string, slot string, options *WebAppsListDomainOwnershipIdentifiersSlotOptions) *WebAppsListDomainOwnershipIdentifiersSlotPager {
	return &WebAppsListDomainOwnershipIdentifiersSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listDomainOwnershipIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListDomainOwnershipIdentifiersSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.IdentifierCollection.NextLink)
		},
	}
}

// listDomainOwnershipIdentifiersSlotCreateRequest creates the ListDomainOwnershipIdentifiersSlot request.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListDomainOwnershipIdentifiersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listDomainOwnershipIdentifiersSlotHandleResponse handles the ListDomainOwnershipIdentifiersSlot response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotHandleResponse(resp *http.Response) (WebAppsListDomainOwnershipIdentifiersSlotResponse, error) {
	result := WebAppsListDomainOwnershipIdentifiersSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.IdentifierCollection); err != nil {
		return WebAppsListDomainOwnershipIdentifiersSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listDomainOwnershipIdentifiersSlotHandleError handles the ListDomainOwnershipIdentifiersSlot error response.
func (client *WebAppsClient) listDomainOwnershipIdentifiersSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListFunctionKeys - Description for Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionKeys(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionKeysOptions) (WebAppsListFunctionKeysResponse, error) {
	req, err := client.listFunctionKeysCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsListFunctionKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListFunctionKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListFunctionKeysResponse{}, client.listFunctionKeysHandleError(resp)
	}
	return client.listFunctionKeysHandleResponse(resp)
}

// listFunctionKeysCreateRequest creates the ListFunctionKeys request.
func (client *WebAppsClient) listFunctionKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionKeysHandleResponse handles the ListFunctionKeys response.
func (client *WebAppsClient) listFunctionKeysHandleResponse(resp *http.Response) (WebAppsListFunctionKeysResponse, error) {
	result := WebAppsListFunctionKeysResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsListFunctionKeysResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listFunctionKeysHandleError handles the ListFunctionKeys error response.
func (client *WebAppsClient) listFunctionKeysHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListFunctionKeysSlot - Description for Get function keys for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionKeysSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionKeysSlotOptions) (WebAppsListFunctionKeysSlotResponse, error) {
	req, err := client.listFunctionKeysSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsListFunctionKeysSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListFunctionKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListFunctionKeysSlotResponse{}, client.listFunctionKeysSlotHandleError(resp)
	}
	return client.listFunctionKeysSlotHandleResponse(resp)
}

// listFunctionKeysSlotCreateRequest creates the ListFunctionKeysSlot request.
func (client *WebAppsClient) listFunctionKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionKeysSlotHandleResponse handles the ListFunctionKeysSlot response.
func (client *WebAppsClient) listFunctionKeysSlotHandleResponse(resp *http.Response) (WebAppsListFunctionKeysSlotResponse, error) {
	result := WebAppsListFunctionKeysSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsListFunctionKeysSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listFunctionKeysSlotHandleError handles the ListFunctionKeysSlot error response.
func (client *WebAppsClient) listFunctionKeysSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListFunctionSecrets - Description for Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionSecrets(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionSecretsOptions) (WebAppsListFunctionSecretsResponse, error) {
	req, err := client.listFunctionSecretsCreateRequest(ctx, resourceGroupName, name, functionName, options)
	if err != nil {
		return WebAppsListFunctionSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListFunctionSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListFunctionSecretsResponse{}, client.listFunctionSecretsHandleError(resp)
	}
	return client.listFunctionSecretsHandleResponse(resp)
}

// listFunctionSecretsCreateRequest creates the ListFunctionSecrets request.
func (client *WebAppsClient) listFunctionSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, options *WebAppsListFunctionSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionSecretsHandleResponse handles the ListFunctionSecrets response.
func (client *WebAppsClient) listFunctionSecretsHandleResponse(resp *http.Response) (WebAppsListFunctionSecretsResponse, error) {
	result := WebAppsListFunctionSecretsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsListFunctionSecretsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listFunctionSecretsHandleError handles the ListFunctionSecrets error response.
func (client *WebAppsClient) listFunctionSecretsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListFunctionSecretsSlot - Description for Get function secrets for a function in a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctionSecretsSlot(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionSecretsSlotOptions) (WebAppsListFunctionSecretsSlotResponse, error) {
	req, err := client.listFunctionSecretsSlotCreateRequest(ctx, resourceGroupName, name, functionName, slot, options)
	if err != nil {
		return WebAppsListFunctionSecretsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListFunctionSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListFunctionSecretsSlotResponse{}, client.listFunctionSecretsSlotHandleError(resp)
	}
	return client.listFunctionSecretsSlotHandleResponse(resp)
}

// listFunctionSecretsSlotCreateRequest creates the ListFunctionSecretsSlot request.
func (client *WebAppsClient) listFunctionSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, functionName string, slot string, options *WebAppsListFunctionSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions/{functionName}/listsecrets"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if functionName == "" {
		return nil, errors.New("parameter functionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{functionName}", url.PathEscape(functionName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionSecretsSlotHandleResponse handles the ListFunctionSecretsSlot response.
func (client *WebAppsClient) listFunctionSecretsSlotHandleResponse(resp *http.Response) (WebAppsListFunctionSecretsSlotResponse, error) {
	result := WebAppsListFunctionSecretsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsListFunctionSecretsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listFunctionSecretsSlotHandleError handles the ListFunctionSecretsSlot error response.
func (client *WebAppsClient) listFunctionSecretsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListFunctions - Description for List the functions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListFunctions(resourceGroupName string, name string, options *WebAppsListFunctionsOptions) *WebAppsListFunctionsPager {
	return &WebAppsListFunctionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listFunctionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListFunctionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.FunctionEnvelopeCollection.NextLink)
		},
	}
}

// listFunctionsCreateRequest creates the ListFunctions request.
func (client *WebAppsClient) listFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFunctionsHandleResponse handles the ListFunctions response.
func (client *WebAppsClient) listFunctionsHandleResponse(resp *http.Response) (WebAppsListFunctionsResponse, error) {
	result := WebAppsListFunctionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelopeCollection); err != nil {
		return WebAppsListFunctionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listFunctionsHandleError handles the ListFunctions error response.
func (client *WebAppsClient) listFunctionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListHostKeys - Description for Get host secrets for a function app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostKeys(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHostKeysOptions) (WebAppsListHostKeysResponse, error) {
	req, err := client.listHostKeysCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListHostKeysResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListHostKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListHostKeysResponse{}, client.listHostKeysHandleError(resp)
	}
	return client.listHostKeysHandleResponse(resp)
}

// listHostKeysCreateRequest creates the ListHostKeys request.
func (client *WebAppsClient) listHostKeysCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHostKeysOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHostKeysHandleResponse handles the ListHostKeys response.
func (client *WebAppsClient) listHostKeysHandleResponse(resp *http.Response) (WebAppsListHostKeysResponse, error) {
	result := WebAppsListHostKeysResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostKeys); err != nil {
		return WebAppsListHostKeysResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHostKeysHandleError handles the ListHostKeys error response.
func (client *WebAppsClient) listHostKeysHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHostKeysSlot - Description for Get host secrets for a function app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostKeysSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHostKeysSlotOptions) (WebAppsListHostKeysSlotResponse, error) {
	req, err := client.listHostKeysSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListHostKeysSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListHostKeysSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListHostKeysSlotResponse{}, client.listHostKeysSlotHandleError(resp)
	}
	return client.listHostKeysSlotHandleResponse(resp)
}

// listHostKeysSlotCreateRequest creates the ListHostKeysSlot request.
func (client *WebAppsClient) listHostKeysSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHostKeysSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listkeys"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHostKeysSlotHandleResponse handles the ListHostKeysSlot response.
func (client *WebAppsClient) listHostKeysSlotHandleResponse(resp *http.Response) (WebAppsListHostKeysSlotResponse, error) {
	result := WebAppsListHostKeysSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostKeys); err != nil {
		return WebAppsListHostKeysSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHostKeysSlotHandleError handles the ListHostKeysSlot error response.
func (client *WebAppsClient) listHostKeysSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHostNameBindings - Description for Get hostname bindings for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostNameBindings(resourceGroupName string, name string, options *WebAppsListHostNameBindingsOptions) *WebAppsListHostNameBindingsPager {
	return &WebAppsListHostNameBindingsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listHostNameBindingsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListHostNameBindingsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.HostNameBindingCollection.NextLink)
		},
	}
}

// listHostNameBindingsCreateRequest creates the ListHostNameBindings request.
func (client *WebAppsClient) listHostNameBindingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHostNameBindingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHostNameBindingsHandleResponse handles the ListHostNameBindings response.
func (client *WebAppsClient) listHostNameBindingsHandleResponse(resp *http.Response) (WebAppsListHostNameBindingsResponse, error) {
	result := WebAppsListHostNameBindingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBindingCollection); err != nil {
		return WebAppsListHostNameBindingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHostNameBindingsHandleError handles the ListHostNameBindings error response.
func (client *WebAppsClient) listHostNameBindingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHostNameBindingsSlot - Description for Get hostname bindings for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHostNameBindingsSlot(resourceGroupName string, name string, slot string, options *WebAppsListHostNameBindingsSlotOptions) *WebAppsListHostNameBindingsSlotPager {
	return &WebAppsListHostNameBindingsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listHostNameBindingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListHostNameBindingsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.HostNameBindingCollection.NextLink)
		},
	}
}

// listHostNameBindingsSlotCreateRequest creates the ListHostNameBindingsSlot request.
func (client *WebAppsClient) listHostNameBindingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHostNameBindingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hostNameBindings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHostNameBindingsSlotHandleResponse handles the ListHostNameBindingsSlot response.
func (client *WebAppsClient) listHostNameBindingsSlotHandleResponse(resp *http.Response) (WebAppsListHostNameBindingsSlotResponse, error) {
	result := WebAppsListHostNameBindingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HostNameBindingCollection); err != nil {
		return WebAppsListHostNameBindingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHostNameBindingsSlotHandleError handles the ListHostNameBindingsSlot error response.
func (client *WebAppsClient) listHostNameBindingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHybridConnections - Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHybridConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHybridConnectionsOptions) (WebAppsListHybridConnectionsResponse, error) {
	req, err := client.listHybridConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListHybridConnectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListHybridConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListHybridConnectionsResponse{}, client.listHybridConnectionsHandleError(resp)
	}
	return client.listHybridConnectionsHandleResponse(resp)
}

// listHybridConnectionsCreateRequest creates the ListHybridConnections request.
func (client *WebAppsClient) listHybridConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListHybridConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHybridConnectionsHandleResponse handles the ListHybridConnections response.
func (client *WebAppsClient) listHybridConnectionsHandleResponse(resp *http.Response) (WebAppsListHybridConnectionsResponse, error) {
	result := WebAppsListHybridConnectionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsListHybridConnectionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHybridConnectionsHandleError handles the ListHybridConnections error response.
func (client *WebAppsClient) listHybridConnectionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListHybridConnectionsSlot - Description for Retrieves all Service Bus Hybrid Connections used by this Web App.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListHybridConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHybridConnectionsSlotOptions) (WebAppsListHybridConnectionsSlotResponse, error) {
	req, err := client.listHybridConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListHybridConnectionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListHybridConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListHybridConnectionsSlotResponse{}, client.listHybridConnectionsSlotHandleError(resp)
	}
	return client.listHybridConnectionsSlotHandleResponse(resp)
}

// listHybridConnectionsSlotCreateRequest creates the ListHybridConnectionsSlot request.
func (client *WebAppsClient) listHybridConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListHybridConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionRelays"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHybridConnectionsSlotHandleResponse handles the ListHybridConnectionsSlot response.
func (client *WebAppsClient) listHybridConnectionsSlotHandleResponse(resp *http.Response) (WebAppsListHybridConnectionsSlotResponse, error) {
	result := WebAppsListHybridConnectionsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsListHybridConnectionsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listHybridConnectionsSlotHandleError handles the ListHybridConnectionsSlot error response.
func (client *WebAppsClient) listHybridConnectionsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListInstanceFunctionsSlot - Description for List the functions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceFunctionsSlot(resourceGroupName string, name string, slot string, options *WebAppsListInstanceFunctionsSlotOptions) *WebAppsListInstanceFunctionsSlotPager {
	return &WebAppsListInstanceFunctionsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceFunctionsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.FunctionEnvelopeCollection.NextLink)
		},
	}
}

// listInstanceFunctionsSlotCreateRequest creates the ListInstanceFunctionsSlot request.
func (client *WebAppsClient) listInstanceFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListInstanceFunctionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/functions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceFunctionsSlotHandleResponse handles the ListInstanceFunctionsSlot response.
func (client *WebAppsClient) listInstanceFunctionsSlotHandleResponse(resp *http.Response) (WebAppsListInstanceFunctionsSlotResponse, error) {
	result := WebAppsListInstanceFunctionsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionEnvelopeCollection); err != nil {
		return WebAppsListInstanceFunctionsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceFunctionsSlotHandleError handles the ListInstanceFunctionsSlot error response.
func (client *WebAppsClient) listInstanceFunctionsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListInstanceIdentifiers - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceIdentifiers(resourceGroupName string, name string, options *WebAppsListInstanceIdentifiersOptions) *WebAppsListInstanceIdentifiersPager {
	return &WebAppsListInstanceIdentifiersPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceIdentifiersCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceIdentifiersResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppInstanceStatusCollection.NextLink)
		},
	}
}

// listInstanceIdentifiersCreateRequest creates the ListInstanceIdentifiers request.
func (client *WebAppsClient) listInstanceIdentifiersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListInstanceIdentifiersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceIdentifiersHandleResponse handles the ListInstanceIdentifiers response.
func (client *WebAppsClient) listInstanceIdentifiersHandleResponse(resp *http.Response) (WebAppsListInstanceIdentifiersResponse, error) {
	result := WebAppsListInstanceIdentifiersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppInstanceStatusCollection); err != nil {
		return WebAppsListInstanceIdentifiersResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceIdentifiersHandleError handles the ListInstanceIdentifiers error response.
func (client *WebAppsClient) listInstanceIdentifiersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListInstanceIdentifiersSlot - Description for Gets all scale-out instances of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceIdentifiersSlot(resourceGroupName string, name string, slot string, options *WebAppsListInstanceIdentifiersSlotOptions) *WebAppsListInstanceIdentifiersSlotPager {
	return &WebAppsListInstanceIdentifiersSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceIdentifiersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceIdentifiersSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppInstanceStatusCollection.NextLink)
		},
	}
}

// listInstanceIdentifiersSlotCreateRequest creates the ListInstanceIdentifiersSlot request.
func (client *WebAppsClient) listInstanceIdentifiersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListInstanceIdentifiersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceIdentifiersSlotHandleResponse handles the ListInstanceIdentifiersSlot response.
func (client *WebAppsClient) listInstanceIdentifiersSlotHandleResponse(resp *http.Response) (WebAppsListInstanceIdentifiersSlotResponse, error) {
	result := WebAppsListInstanceIdentifiersSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppInstanceStatusCollection); err != nil {
		return WebAppsListInstanceIdentifiersSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceIdentifiersSlotHandleError handles the ListInstanceIdentifiersSlot error response.
func (client *WebAppsClient) listInstanceIdentifiersSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListInstanceProcessModules - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessModules(resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessModulesOptions) *WebAppsListInstanceProcessModulesPager {
	return &WebAppsListInstanceProcessModulesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceProcessModulesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
	}
}

// listInstanceProcessModulesCreateRequest creates the ListInstanceProcessModules request.
func (client *WebAppsClient) listInstanceProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessModulesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessModulesHandleResponse handles the ListInstanceProcessModules response.
func (client *WebAppsClient) listInstanceProcessModulesHandleResponse(resp *http.Response) (WebAppsListInstanceProcessModulesResponse, error) {
	result := WebAppsListInstanceProcessModulesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsListInstanceProcessModulesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceProcessModulesHandleError handles the ListInstanceProcessModules error response.
func (client *WebAppsClient) listInstanceProcessModulesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListInstanceProcessModulesSlot - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessModulesSlot(resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessModulesSlotOptions) *WebAppsListInstanceProcessModulesSlotPager {
	return &WebAppsListInstanceProcessModulesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceProcessModulesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
	}
}

// listInstanceProcessModulesSlotCreateRequest creates the ListInstanceProcessModulesSlot request.
func (client *WebAppsClient) listInstanceProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessModulesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessModulesSlotHandleResponse handles the ListInstanceProcessModulesSlot response.
func (client *WebAppsClient) listInstanceProcessModulesSlotHandleResponse(resp *http.Response) (WebAppsListInstanceProcessModulesSlotResponse, error) {
	result := WebAppsListInstanceProcessModulesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsListInstanceProcessModulesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceProcessModulesSlotHandleError handles the ListInstanceProcessModulesSlot error response.
func (client *WebAppsClient) listInstanceProcessModulesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListInstanceProcessThreads - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessThreads(resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessThreadsOptions) *WebAppsListInstanceProcessThreadsPager {
	return &WebAppsListInstanceProcessThreadsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, instanceID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceProcessThreadsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
	}
}

// listInstanceProcessThreadsCreateRequest creates the ListInstanceProcessThreads request.
func (client *WebAppsClient) listInstanceProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, instanceID string, options *WebAppsListInstanceProcessThreadsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessThreadsHandleResponse handles the ListInstanceProcessThreads response.
func (client *WebAppsClient) listInstanceProcessThreadsHandleResponse(resp *http.Response) (WebAppsListInstanceProcessThreadsResponse, error) {
	result := WebAppsListInstanceProcessThreadsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsListInstanceProcessThreadsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceProcessThreadsHandleError handles the ListInstanceProcessThreads error response.
func (client *WebAppsClient) listInstanceProcessThreadsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListInstanceProcessThreadsSlot - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessThreadsSlot(resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessThreadsSlotOptions) *WebAppsListInstanceProcessThreadsSlotPager {
	return &WebAppsListInstanceProcessThreadsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, instanceID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceProcessThreadsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
	}
}

// listInstanceProcessThreadsSlotCreateRequest creates the ListInstanceProcessThreadsSlot request.
func (client *WebAppsClient) listInstanceProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, instanceID string, options *WebAppsListInstanceProcessThreadsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessThreadsSlotHandleResponse handles the ListInstanceProcessThreadsSlot response.
func (client *WebAppsClient) listInstanceProcessThreadsSlotHandleResponse(resp *http.Response) (WebAppsListInstanceProcessThreadsSlotResponse, error) {
	result := WebAppsListInstanceProcessThreadsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsListInstanceProcessThreadsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceProcessThreadsSlotHandleError handles the ListInstanceProcessThreadsSlot error response.
func (client *WebAppsClient) listInstanceProcessThreadsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListInstanceProcesses - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcesses(resourceGroupName string, name string, instanceID string, options *WebAppsListInstanceProcessesOptions) *WebAppsListInstanceProcessesPager {
	return &WebAppsListInstanceProcessesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceProcessesCreateRequest(ctx, resourceGroupName, name, instanceID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceProcessesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
	}
}

// listInstanceProcessesCreateRequest creates the ListInstanceProcesses request.
func (client *WebAppsClient) listInstanceProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, instanceID string, options *WebAppsListInstanceProcessesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessesHandleResponse handles the ListInstanceProcesses response.
func (client *WebAppsClient) listInstanceProcessesHandleResponse(resp *http.Response) (WebAppsListInstanceProcessesResponse, error) {
	result := WebAppsListInstanceProcessesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsListInstanceProcessesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceProcessesHandleError handles the ListInstanceProcesses error response.
func (client *WebAppsClient) listInstanceProcessesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListInstanceProcessesSlot - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web
// site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListInstanceProcessesSlot(resourceGroupName string, name string, slot string, instanceID string, options *WebAppsListInstanceProcessesSlotOptions) *WebAppsListInstanceProcessesSlotPager {
	return &WebAppsListInstanceProcessesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listInstanceProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, instanceID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListInstanceProcessesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
	}
}

// listInstanceProcessesSlotCreateRequest creates the ListInstanceProcessesSlot request.
func (client *WebAppsClient) listInstanceProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, instanceID string, options *WebAppsListInstanceProcessesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/instances/{instanceId}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if instanceID == "" {
		return nil, errors.New("parameter instanceID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{instanceId}", url.PathEscape(instanceID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listInstanceProcessesSlotHandleResponse handles the ListInstanceProcessesSlot response.
func (client *WebAppsClient) listInstanceProcessesSlotHandleResponse(resp *http.Response) (WebAppsListInstanceProcessesSlotResponse, error) {
	result := WebAppsListInstanceProcessesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsListInstanceProcessesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listInstanceProcessesSlotHandleError handles the ListInstanceProcessesSlot error response.
func (client *WebAppsClient) listInstanceProcessesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListMetadata - Description for Gets the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListMetadata(ctx context.Context, resourceGroupName string, name string, options *WebAppsListMetadataOptions) (WebAppsListMetadataResponse, error) {
	req, err := client.listMetadataCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListMetadataResponse{}, client.listMetadataHandleError(resp)
	}
	return client.listMetadataHandleResponse(resp)
}

// listMetadataCreateRequest creates the ListMetadata request.
func (client *WebAppsClient) listMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListMetadataOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetadataHandleResponse handles the ListMetadata response.
func (client *WebAppsClient) listMetadataHandleResponse(resp *http.Response) (WebAppsListMetadataResponse, error) {
	result := WebAppsListMetadataResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsListMetadataResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMetadataHandleError handles the ListMetadata error response.
func (client *WebAppsClient) listMetadataHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListMetadataSlot - Description for Gets the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListMetadataSlotOptions) (WebAppsListMetadataSlotResponse, error) {
	req, err := client.listMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListMetadataSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListMetadataSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListMetadataSlotResponse{}, client.listMetadataSlotHandleError(resp)
	}
	return client.listMetadataSlotHandleResponse(resp)
}

// listMetadataSlotCreateRequest creates the ListMetadataSlot request.
func (client *WebAppsClient) listMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListMetadataSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetadataSlotHandleResponse handles the ListMetadataSlot response.
func (client *WebAppsClient) listMetadataSlotHandleResponse(resp *http.Response) (WebAppsListMetadataSlotResponse, error) {
	result := WebAppsListMetadataSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsListMetadataSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listMetadataSlotHandleError handles the ListMetadataSlot error response.
func (client *WebAppsClient) listMetadataSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListNetworkFeatures - Description for Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListNetworkFeatures(ctx context.Context, resourceGroupName string, name string, view string, options *WebAppsListNetworkFeaturesOptions) (WebAppsListNetworkFeaturesResponse, error) {
	req, err := client.listNetworkFeaturesCreateRequest(ctx, resourceGroupName, name, view, options)
	if err != nil {
		return WebAppsListNetworkFeaturesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListNetworkFeaturesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListNetworkFeaturesResponse{}, client.listNetworkFeaturesHandleError(resp)
	}
	return client.listNetworkFeaturesHandleResponse(resp)
}

// listNetworkFeaturesCreateRequest creates the ListNetworkFeatures request.
func (client *WebAppsClient) listNetworkFeaturesCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, options *WebAppsListNetworkFeaturesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listNetworkFeaturesHandleResponse handles the ListNetworkFeatures response.
func (client *WebAppsClient) listNetworkFeaturesHandleResponse(resp *http.Response) (WebAppsListNetworkFeaturesResponse, error) {
	result := WebAppsListNetworkFeaturesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkFeatures); err != nil {
		return WebAppsListNetworkFeaturesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listNetworkFeaturesHandleError handles the ListNetworkFeatures error response.
func (client *WebAppsClient) listNetworkFeaturesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListNetworkFeaturesSlot - Description for Gets all network features used by the app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListNetworkFeaturesSlot(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *WebAppsListNetworkFeaturesSlotOptions) (WebAppsListNetworkFeaturesSlotResponse, error) {
	req, err := client.listNetworkFeaturesSlotCreateRequest(ctx, resourceGroupName, name, view, slot, options)
	if err != nil {
		return WebAppsListNetworkFeaturesSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListNetworkFeaturesSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListNetworkFeaturesSlotResponse{}, client.listNetworkFeaturesSlotHandleError(resp)
	}
	return client.listNetworkFeaturesSlotHandleResponse(resp)
}

// listNetworkFeaturesSlotCreateRequest creates the ListNetworkFeaturesSlot request.
func (client *WebAppsClient) listNetworkFeaturesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, view string, slot string, options *WebAppsListNetworkFeaturesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkFeatures/{view}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if view == "" {
		return nil, errors.New("parameter view cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{view}", url.PathEscape(view))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listNetworkFeaturesSlotHandleResponse handles the ListNetworkFeaturesSlot response.
func (client *WebAppsClient) listNetworkFeaturesSlotHandleResponse(resp *http.Response) (WebAppsListNetworkFeaturesSlotResponse, error) {
	result := WebAppsListNetworkFeaturesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.NetworkFeatures); err != nil {
		return WebAppsListNetworkFeaturesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listNetworkFeaturesSlotHandleError handles the ListNetworkFeaturesSlot error response.
func (client *WebAppsClient) listNetworkFeaturesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListPerfMonCounters - Description for Gets perfmon counters for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPerfMonCounters(resourceGroupName string, name string, options *WebAppsListPerfMonCountersOptions) *WebAppsListPerfMonCountersPager {
	return &WebAppsListPerfMonCountersPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listPerfMonCountersCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListPerfMonCountersResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PerfMonCounterCollection.NextLink)
		},
	}
}

// listPerfMonCountersCreateRequest creates the ListPerfMonCounters request.
func (client *WebAppsClient) listPerfMonCountersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPerfMonCountersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPerfMonCountersHandleResponse handles the ListPerfMonCounters response.
func (client *WebAppsClient) listPerfMonCountersHandleResponse(resp *http.Response) (WebAppsListPerfMonCountersResponse, error) {
	result := WebAppsListPerfMonCountersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PerfMonCounterCollection); err != nil {
		return WebAppsListPerfMonCountersResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPerfMonCountersHandleError handles the ListPerfMonCounters error response.
func (client *WebAppsClient) listPerfMonCountersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPerfMonCountersSlot - Description for Gets perfmon counters for web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPerfMonCountersSlot(resourceGroupName string, name string, slot string, options *WebAppsListPerfMonCountersSlotOptions) *WebAppsListPerfMonCountersSlotPager {
	return &WebAppsListPerfMonCountersSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listPerfMonCountersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListPerfMonCountersSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PerfMonCounterCollection.NextLink)
		},
	}
}

// listPerfMonCountersSlotCreateRequest creates the ListPerfMonCountersSlot request.
func (client *WebAppsClient) listPerfMonCountersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPerfMonCountersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/perfcounters"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPerfMonCountersSlotHandleResponse handles the ListPerfMonCountersSlot response.
func (client *WebAppsClient) listPerfMonCountersSlotHandleResponse(resp *http.Response) (WebAppsListPerfMonCountersSlotResponse, error) {
	result := WebAppsListPerfMonCountersSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PerfMonCounterCollection); err != nil {
		return WebAppsListPerfMonCountersSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPerfMonCountersSlotHandleError handles the ListPerfMonCountersSlot error response.
func (client *WebAppsClient) listPerfMonCountersSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPremierAddOns - Description for Gets the premier add-ons of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPremierAddOns(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPremierAddOnsOptions) (WebAppsListPremierAddOnsResponse, error) {
	req, err := client.listPremierAddOnsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListPremierAddOnsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListPremierAddOnsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListPremierAddOnsResponse{}, client.listPremierAddOnsHandleError(resp)
	}
	return client.listPremierAddOnsHandleResponse(resp)
}

// listPremierAddOnsCreateRequest creates the ListPremierAddOns request.
func (client *WebAppsClient) listPremierAddOnsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPremierAddOnsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPremierAddOnsHandleResponse handles the ListPremierAddOns response.
func (client *WebAppsClient) listPremierAddOnsHandleResponse(resp *http.Response) (WebAppsListPremierAddOnsResponse, error) {
	result := WebAppsListPremierAddOnsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsListPremierAddOnsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPremierAddOnsHandleError handles the ListPremierAddOns error response.
func (client *WebAppsClient) listPremierAddOnsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPremierAddOnsSlot - Description for Gets the premier add-ons of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPremierAddOnsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPremierAddOnsSlotOptions) (WebAppsListPremierAddOnsSlotResponse, error) {
	req, err := client.listPremierAddOnsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListPremierAddOnsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListPremierAddOnsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListPremierAddOnsSlotResponse{}, client.listPremierAddOnsSlotHandleError(resp)
	}
	return client.listPremierAddOnsSlotHandleResponse(resp)
}

// listPremierAddOnsSlotCreateRequest creates the ListPremierAddOnsSlot request.
func (client *WebAppsClient) listPremierAddOnsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPremierAddOnsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPremierAddOnsSlotHandleResponse handles the ListPremierAddOnsSlot response.
func (client *WebAppsClient) listPremierAddOnsSlotHandleResponse(resp *http.Response) (WebAppsListPremierAddOnsSlotResponse, error) {
	result := WebAppsListPremierAddOnsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsListPremierAddOnsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPremierAddOnsSlotHandleError handles the ListPremierAddOnsSlot error response.
func (client *WebAppsClient) listPremierAddOnsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListProcessModules - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessModules(resourceGroupName string, name string, processID string, options *WebAppsListProcessModulesOptions) *WebAppsListProcessModulesPager {
	return &WebAppsListProcessModulesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listProcessModulesCreateRequest(ctx, resourceGroupName, name, processID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListProcessModulesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
	}
}

// listProcessModulesCreateRequest creates the ListProcessModules request.
func (client *WebAppsClient) listProcessModulesCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsListProcessModulesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessModulesHandleResponse handles the ListProcessModules response.
func (client *WebAppsClient) listProcessModulesHandleResponse(resp *http.Response) (WebAppsListProcessModulesResponse, error) {
	result := WebAppsListProcessModulesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsListProcessModulesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listProcessModulesHandleError handles the ListProcessModules error response.
func (client *WebAppsClient) listProcessModulesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListProcessModulesSlot - Description for List module information for a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessModulesSlot(resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessModulesSlotOptions) *WebAppsListProcessModulesSlotPager {
	return &WebAppsListProcessModulesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listProcessModulesSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListProcessModulesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessModuleInfoCollection.NextLink)
		},
	}
}

// listProcessModulesSlotCreateRequest creates the ListProcessModulesSlot request.
func (client *WebAppsClient) listProcessModulesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessModulesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/modules"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessModulesSlotHandleResponse handles the ListProcessModulesSlot response.
func (client *WebAppsClient) listProcessModulesSlotHandleResponse(resp *http.Response) (WebAppsListProcessModulesSlotResponse, error) {
	result := WebAppsListProcessModulesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessModuleInfoCollection); err != nil {
		return WebAppsListProcessModulesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listProcessModulesSlotHandleError handles the ListProcessModulesSlot error response.
func (client *WebAppsClient) listProcessModulesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListProcessThreads - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessThreads(resourceGroupName string, name string, processID string, options *WebAppsListProcessThreadsOptions) *WebAppsListProcessThreadsPager {
	return &WebAppsListProcessThreadsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listProcessThreadsCreateRequest(ctx, resourceGroupName, name, processID, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListProcessThreadsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
	}
}

// listProcessThreadsCreateRequest creates the ListProcessThreads request.
func (client *WebAppsClient) listProcessThreadsCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, options *WebAppsListProcessThreadsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessThreadsHandleResponse handles the ListProcessThreads response.
func (client *WebAppsClient) listProcessThreadsHandleResponse(resp *http.Response) (WebAppsListProcessThreadsResponse, error) {
	result := WebAppsListProcessThreadsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsListProcessThreadsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listProcessThreadsHandleError handles the ListProcessThreads error response.
func (client *WebAppsClient) listProcessThreadsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListProcessThreadsSlot - Description for List the threads in a process by its ID for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessThreadsSlot(resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessThreadsSlotOptions) *WebAppsListProcessThreadsSlotPager {
	return &WebAppsListProcessThreadsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listProcessThreadsSlotCreateRequest(ctx, resourceGroupName, name, processID, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListProcessThreadsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessThreadInfoCollection.NextLink)
		},
	}
}

// listProcessThreadsSlotCreateRequest creates the ListProcessThreadsSlot request.
func (client *WebAppsClient) listProcessThreadsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, processID string, slot string, options *WebAppsListProcessThreadsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes/{processId}/threads"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if processID == "" {
		return nil, errors.New("parameter processID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{processId}", url.PathEscape(processID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessThreadsSlotHandleResponse handles the ListProcessThreadsSlot response.
func (client *WebAppsClient) listProcessThreadsSlotHandleResponse(resp *http.Response) (WebAppsListProcessThreadsSlotResponse, error) {
	result := WebAppsListProcessThreadsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessThreadInfoCollection); err != nil {
		return WebAppsListProcessThreadsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listProcessThreadsSlotHandleError handles the ListProcessThreadsSlot error response.
func (client *WebAppsClient) listProcessThreadsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListProcesses - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcesses(resourceGroupName string, name string, options *WebAppsListProcessesOptions) *WebAppsListProcessesPager {
	return &WebAppsListProcessesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listProcessesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListProcessesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
	}
}

// listProcessesCreateRequest creates the ListProcesses request.
func (client *WebAppsClient) listProcessesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListProcessesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessesHandleResponse handles the ListProcesses response.
func (client *WebAppsClient) listProcessesHandleResponse(resp *http.Response) (WebAppsListProcessesResponse, error) {
	result := WebAppsListProcessesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsListProcessesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listProcessesHandleError handles the ListProcesses error response.
func (client *WebAppsClient) listProcessesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListProcessesSlot - Description for Get list of processes for a web site, or a deployment slot, or for a specific scaled-out instance in a web site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListProcessesSlot(resourceGroupName string, name string, slot string, options *WebAppsListProcessesSlotOptions) *WebAppsListProcessesSlotPager {
	return &WebAppsListProcessesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listProcessesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListProcessesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.ProcessInfoCollection.NextLink)
		},
	}
}

// listProcessesSlotCreateRequest creates the ListProcessesSlot request.
func (client *WebAppsClient) listProcessesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListProcessesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/processes"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listProcessesSlotHandleResponse handles the ListProcessesSlot response.
func (client *WebAppsClient) listProcessesSlotHandleResponse(resp *http.Response) (WebAppsListProcessesSlotResponse, error) {
	result := WebAppsListProcessesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ProcessInfoCollection); err != nil {
		return WebAppsListProcessesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listProcessesSlotHandleError handles the ListProcessesSlot error response.
func (client *WebAppsClient) listProcessesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListPublicCertificates - Description for Get public certificates for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublicCertificates(resourceGroupName string, name string, options *WebAppsListPublicCertificatesOptions) *WebAppsListPublicCertificatesPager {
	return &WebAppsListPublicCertificatesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listPublicCertificatesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListPublicCertificatesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PublicCertificateCollection.NextLink)
		},
	}
}

// listPublicCertificatesCreateRequest creates the ListPublicCertificates request.
func (client *WebAppsClient) listPublicCertificatesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListPublicCertificatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPublicCertificatesHandleResponse handles the ListPublicCertificates response.
func (client *WebAppsClient) listPublicCertificatesHandleResponse(resp *http.Response) (WebAppsListPublicCertificatesResponse, error) {
	result := WebAppsListPublicCertificatesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificateCollection); err != nil {
		return WebAppsListPublicCertificatesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPublicCertificatesHandleError handles the ListPublicCertificates error response.
func (client *WebAppsClient) listPublicCertificatesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPublicCertificatesSlot - Description for Get public certificates for an app or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublicCertificatesSlot(resourceGroupName string, name string, slot string, options *WebAppsListPublicCertificatesSlotOptions) *WebAppsListPublicCertificatesSlotPager {
	return &WebAppsListPublicCertificatesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listPublicCertificatesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListPublicCertificatesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.PublicCertificateCollection.NextLink)
		},
	}
}

// listPublicCertificatesSlotCreateRequest creates the ListPublicCertificatesSlot request.
func (client *WebAppsClient) listPublicCertificatesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListPublicCertificatesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publicCertificates"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPublicCertificatesSlotHandleResponse handles the ListPublicCertificatesSlot response.
func (client *WebAppsClient) listPublicCertificatesSlotHandleResponse(resp *http.Response) (WebAppsListPublicCertificatesSlotResponse, error) {
	result := WebAppsListPublicCertificatesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicCertificateCollection); err != nil {
		return WebAppsListPublicCertificatesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listPublicCertificatesSlotHandleError handles the ListPublicCertificatesSlot error response.
func (client *WebAppsClient) listPublicCertificatesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginListPublishingCredentials - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginListPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginListPublishingCredentialsOptions) (WebAppsListPublishingCredentialsPollerResponse, error) {
	resp, err := client.listPublishingCredentials(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListPublishingCredentialsPollerResponse{}, err
	}
	result := WebAppsListPublishingCredentialsPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.ListPublishingCredentials", "", resp, client.pl, client.listPublishingCredentialsHandleError)
	if err != nil {
		return WebAppsListPublishingCredentialsPollerResponse{}, err
	}
	result.Poller = &WebAppsListPublishingCredentialsPoller{
		pt: pt,
	}
	return result, nil
}

// ListPublishingCredentials - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) listPublishingCredentials(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginListPublishingCredentialsOptions) (*http.Response, error) {
	req, err := client.listPublishingCredentialsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, client.listPublishingCredentialsHandleError(resp)
	}
	return resp, nil
}

// listPublishingCredentialsCreateRequest creates the ListPublishingCredentials request.
func (client *WebAppsClient) listPublishingCredentialsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginListPublishingCredentialsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPublishingCredentialsHandleError handles the ListPublishingCredentials error response.
func (client *WebAppsClient) listPublishingCredentialsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginListPublishingCredentialsSlot - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginListPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginListPublishingCredentialsSlotOptions) (WebAppsListPublishingCredentialsSlotPollerResponse, error) {
	resp, err := client.listPublishingCredentialsSlot(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListPublishingCredentialsSlotPollerResponse{}, err
	}
	result := WebAppsListPublishingCredentialsSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.ListPublishingCredentialsSlot", "", resp, client.pl, client.listPublishingCredentialsSlotHandleError)
	if err != nil {
		return WebAppsListPublishingCredentialsSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsListPublishingCredentialsSlotPoller{
		pt: pt,
	}
	return result, nil
}

// ListPublishingCredentialsSlot - Description for Gets the Git/FTP publishing credentials of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) listPublishingCredentialsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginListPublishingCredentialsSlotOptions) (*http.Response, error) {
	req, err := client.listPublishingCredentialsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, client.listPublishingCredentialsSlotHandleError(resp)
	}
	return resp, nil
}

// listPublishingCredentialsSlotCreateRequest creates the ListPublishingCredentialsSlot request.
func (client *WebAppsClient) listPublishingCredentialsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginListPublishingCredentialsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/publishingcredentials/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listPublishingCredentialsSlotHandleError handles the ListPublishingCredentialsSlot error response.
func (client *WebAppsClient) listPublishingCredentialsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPublishingProfileXMLWithSecrets - Description for Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublishingProfileXMLWithSecrets(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsOptions) (WebAppsListPublishingProfileXMLWithSecretsResponse, error) {
	req, err := client.listPublishingProfileXMLWithSecretsCreateRequest(ctx, resourceGroupName, name, publishingProfileOptions, options)
	if err != nil {
		return WebAppsListPublishingProfileXMLWithSecretsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListPublishingProfileXMLWithSecretsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListPublishingProfileXMLWithSecretsResponse{}, client.listPublishingProfileXMLWithSecretsHandleError(resp)
	}
	return WebAppsListPublishingProfileXMLWithSecretsResponse{RawResponse: resp}, nil
}

// listPublishingProfileXMLWithSecretsCreateRequest creates the ListPublishingProfileXMLWithSecrets request.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsCreateRequest(ctx context.Context, resourceGroupName string, name string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/xml")
	return req, runtime.MarshalAsJSON(req, publishingProfileOptions)
}

// listPublishingProfileXMLWithSecretsHandleError handles the ListPublishingProfileXMLWithSecrets error response.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListPublishingProfileXMLWithSecretsSlot - Description for Gets the publishing profile for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListPublishingProfileXMLWithSecretsSlot(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsSlotOptions) (WebAppsListPublishingProfileXMLWithSecretsSlotResponse, error) {
	req, err := client.listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx, resourceGroupName, name, slot, publishingProfileOptions, options)
	if err != nil {
		return WebAppsListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListPublishingProfileXMLWithSecretsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListPublishingProfileXMLWithSecretsSlotResponse{}, client.listPublishingProfileXMLWithSecretsSlotHandleError(resp)
	}
	return WebAppsListPublishingProfileXMLWithSecretsSlotResponse{RawResponse: resp}, nil
}

// listPublishingProfileXMLWithSecretsSlotCreateRequest creates the ListPublishingProfileXMLWithSecretsSlot request.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, publishingProfileOptions CsmPublishingProfileOptions, options *WebAppsListPublishingProfileXMLWithSecretsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/publishxml"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	req.Raw().Header.Set("Accept", "application/xml")
	return req, runtime.MarshalAsJSON(req, publishingProfileOptions)
}

// listPublishingProfileXMLWithSecretsSlotHandleError handles the ListPublishingProfileXMLWithSecretsSlot error response.
func (client *WebAppsClient) listPublishingProfileXMLWithSecretsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListRelayServiceConnections - Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListRelayServiceConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsListRelayServiceConnectionsOptions) (WebAppsListRelayServiceConnectionsResponse, error) {
	req, err := client.listRelayServiceConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListRelayServiceConnectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListRelayServiceConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListRelayServiceConnectionsResponse{}, client.listRelayServiceConnectionsHandleError(resp)
	}
	return client.listRelayServiceConnectionsHandleResponse(resp)
}

// listRelayServiceConnectionsCreateRequest creates the ListRelayServiceConnections request.
func (client *WebAppsClient) listRelayServiceConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListRelayServiceConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listRelayServiceConnectionsHandleResponse handles the ListRelayServiceConnections response.
func (client *WebAppsClient) listRelayServiceConnectionsHandleResponse(resp *http.Response) (WebAppsListRelayServiceConnectionsResponse, error) {
	result := WebAppsListRelayServiceConnectionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsListRelayServiceConnectionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listRelayServiceConnectionsHandleError handles the ListRelayServiceConnections error response.
func (client *WebAppsClient) listRelayServiceConnectionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListRelayServiceConnectionsSlot - Description for Gets hybrid connections configured for an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListRelayServiceConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListRelayServiceConnectionsSlotOptions) (WebAppsListRelayServiceConnectionsSlotResponse, error) {
	req, err := client.listRelayServiceConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListRelayServiceConnectionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListRelayServiceConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListRelayServiceConnectionsSlotResponse{}, client.listRelayServiceConnectionsSlotHandleError(resp)
	}
	return client.listRelayServiceConnectionsSlotHandleResponse(resp)
}

// listRelayServiceConnectionsSlotCreateRequest creates the ListRelayServiceConnectionsSlot request.
func (client *WebAppsClient) listRelayServiceConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListRelayServiceConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listRelayServiceConnectionsSlotHandleResponse handles the ListRelayServiceConnectionsSlot response.
func (client *WebAppsClient) listRelayServiceConnectionsSlotHandleResponse(resp *http.Response) (WebAppsListRelayServiceConnectionsSlotResponse, error) {
	result := WebAppsListRelayServiceConnectionsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsListRelayServiceConnectionsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listRelayServiceConnectionsSlotHandleError handles the ListRelayServiceConnectionsSlot error response.
func (client *WebAppsClient) listRelayServiceConnectionsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteBackups - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteBackups(resourceGroupName string, name string, options *WebAppsListSiteBackupsOptions) *WebAppsListSiteBackupsPager {
	return &WebAppsListSiteBackupsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteBackupsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSiteBackupsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
	}
}

// listSiteBackupsCreateRequest creates the ListSiteBackups request.
func (client *WebAppsClient) listSiteBackupsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSiteBackupsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listbackups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteBackupsHandleResponse handles the ListSiteBackups response.
func (client *WebAppsClient) listSiteBackupsHandleResponse(resp *http.Response) (WebAppsListSiteBackupsResponse, error) {
	result := WebAppsListSiteBackupsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsListSiteBackupsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteBackupsHandleError handles the ListSiteBackups error response.
func (client *WebAppsClient) listSiteBackupsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteBackupsSlot - Description for Gets existing backups of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteBackupsSlot(resourceGroupName string, name string, slot string, options *WebAppsListSiteBackupsSlotOptions) *WebAppsListSiteBackupsSlotPager {
	return &WebAppsListSiteBackupsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteBackupsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSiteBackupsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.BackupItemCollection.NextLink)
		},
	}
}

// listSiteBackupsSlotCreateRequest creates the ListSiteBackupsSlot request.
func (client *WebAppsClient) listSiteBackupsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSiteBackupsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listbackups"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteBackupsSlotHandleResponse handles the ListSiteBackupsSlot response.
func (client *WebAppsClient) listSiteBackupsSlotHandleResponse(resp *http.Response) (WebAppsListSiteBackupsSlotResponse, error) {
	result := WebAppsListSiteBackupsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupItemCollection); err != nil {
		return WebAppsListSiteBackupsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteBackupsSlotHandleError handles the ListSiteBackupsSlot error response.
func (client *WebAppsClient) listSiteBackupsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSiteExtensions - Description for Get list of siteextensions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteExtensions(resourceGroupName string, name string, options *WebAppsListSiteExtensionsOptions) *WebAppsListSiteExtensionsPager {
	return &WebAppsListSiteExtensionsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteExtensionsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSiteExtensionsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SiteExtensionInfoCollection.NextLink)
		},
	}
}

// listSiteExtensionsCreateRequest creates the ListSiteExtensions request.
func (client *WebAppsClient) listSiteExtensionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSiteExtensionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteExtensionsHandleResponse handles the ListSiteExtensions response.
func (client *WebAppsClient) listSiteExtensionsHandleResponse(resp *http.Response) (WebAppsListSiteExtensionsResponse, error) {
	result := WebAppsListSiteExtensionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfoCollection); err != nil {
		return WebAppsListSiteExtensionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteExtensionsHandleError handles the ListSiteExtensions error response.
func (client *WebAppsClient) listSiteExtensionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListSiteExtensionsSlot - Description for Get list of siteextensions for a web site, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSiteExtensionsSlot(resourceGroupName string, name string, slot string, options *WebAppsListSiteExtensionsSlotOptions) *WebAppsListSiteExtensionsSlotPager {
	return &WebAppsListSiteExtensionsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSiteExtensionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSiteExtensionsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SiteExtensionInfoCollection.NextLink)
		},
	}
}

// listSiteExtensionsSlotCreateRequest creates the ListSiteExtensionsSlot request.
func (client *WebAppsClient) listSiteExtensionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSiteExtensionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/siteextensions"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSiteExtensionsSlotHandleResponse handles the ListSiteExtensionsSlot response.
func (client *WebAppsClient) listSiteExtensionsSlotHandleResponse(resp *http.Response) (WebAppsListSiteExtensionsSlotResponse, error) {
	result := WebAppsListSiteExtensionsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteExtensionInfoCollection); err != nil {
		return WebAppsListSiteExtensionsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSiteExtensionsSlotHandleError handles the ListSiteExtensionsSlot error response.
func (client *WebAppsClient) listSiteExtensionsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListSitePushSettings - Description for Gets the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSitePushSettings(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSitePushSettingsOptions) (WebAppsListSitePushSettingsResponse, error) {
	req, err := client.listSitePushSettingsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListSitePushSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSitePushSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListSitePushSettingsResponse{}, client.listSitePushSettingsHandleError(resp)
	}
	return client.listSitePushSettingsHandleResponse(resp)
}

// listSitePushSettingsCreateRequest creates the ListSitePushSettings request.
func (client *WebAppsClient) listSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSitePushSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSitePushSettingsHandleResponse handles the ListSitePushSettings response.
func (client *WebAppsClient) listSitePushSettingsHandleResponse(resp *http.Response) (WebAppsListSitePushSettingsResponse, error) {
	result := WebAppsListSitePushSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsListSitePushSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSitePushSettingsHandleError handles the ListSitePushSettings error response.
func (client *WebAppsClient) listSitePushSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSitePushSettingsSlot - Description for Gets the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSitePushSettingsSlotOptions) (WebAppsListSitePushSettingsSlotResponse, error) {
	req, err := client.listSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListSitePushSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSitePushSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListSitePushSettingsSlotResponse{}, client.listSitePushSettingsSlotHandleError(resp)
	}
	return client.listSitePushSettingsSlotHandleResponse(resp)
}

// listSitePushSettingsSlotCreateRequest creates the ListSitePushSettingsSlot request.
func (client *WebAppsClient) listSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSitePushSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings/list"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSitePushSettingsSlotHandleResponse handles the ListSitePushSettingsSlot response.
func (client *WebAppsClient) listSitePushSettingsSlotHandleResponse(resp *http.Response) (WebAppsListSitePushSettingsSlotResponse, error) {
	result := WebAppsListSitePushSettingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsListSitePushSettingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSitePushSettingsSlotHandleError handles the ListSitePushSettingsSlot error response.
func (client *WebAppsClient) listSitePushSettingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSlotConfigurationNames - Description for Gets the names of app settings and connection strings that stick to the slot (not swapped).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSlotConfigurationNamesOptions) (WebAppsListSlotConfigurationNamesResponse, error) {
	req, err := client.listSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListSlotConfigurationNamesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSlotConfigurationNamesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListSlotConfigurationNamesResponse{}, client.listSlotConfigurationNamesHandleError(resp)
	}
	return client.listSlotConfigurationNamesHandleResponse(resp)
}

// listSlotConfigurationNamesCreateRequest creates the ListSlotConfigurationNames request.
func (client *WebAppsClient) listSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSlotConfigurationNamesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSlotConfigurationNamesHandleResponse handles the ListSlotConfigurationNames response.
func (client *WebAppsClient) listSlotConfigurationNamesHandleResponse(resp *http.Response) (WebAppsListSlotConfigurationNamesResponse, error) {
	result := WebAppsListSlotConfigurationNamesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotConfigNamesResource); err != nil {
		return WebAppsListSlotConfigurationNamesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSlotConfigurationNamesHandleError handles the ListSlotConfigurationNames error response.
func (client *WebAppsClient) listSlotConfigurationNamesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSlotDifferencesFromProduction - Description for Get the difference in configuration settings between two web app slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlotDifferencesFromProduction(resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesFromProductionOptions) *WebAppsListSlotDifferencesFromProductionPager {
	return &WebAppsListSlotDifferencesFromProductionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSlotDifferencesFromProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSlotDifferencesFromProductionResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SlotDifferenceCollection.NextLink)
		},
	}
}

// listSlotDifferencesFromProductionCreateRequest creates the ListSlotDifferencesFromProduction request.
func (client *WebAppsClient) listSlotDifferencesFromProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesFromProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// listSlotDifferencesFromProductionHandleResponse handles the ListSlotDifferencesFromProduction response.
func (client *WebAppsClient) listSlotDifferencesFromProductionHandleResponse(resp *http.Response) (WebAppsListSlotDifferencesFromProductionResponse, error) {
	result := WebAppsListSlotDifferencesFromProductionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotDifferenceCollection); err != nil {
		return WebAppsListSlotDifferencesFromProductionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSlotDifferencesFromProductionHandleError handles the ListSlotDifferencesFromProduction error response.
func (client *WebAppsClient) listSlotDifferencesFromProductionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSlotDifferencesSlot - Description for Get the difference in configuration settings between two web app slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlotDifferencesSlot(resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesSlotOptions) *WebAppsListSlotDifferencesSlotPager {
	return &WebAppsListSlotDifferencesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSlotDifferencesSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSlotDifferencesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SlotDifferenceCollection.NextLink)
		},
	}
}

// listSlotDifferencesSlotCreateRequest creates the ListSlotDifferencesSlot request.
func (client *WebAppsClient) listSlotDifferencesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsListSlotDifferencesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsdiffs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// listSlotDifferencesSlotHandleResponse handles the ListSlotDifferencesSlot response.
func (client *WebAppsClient) listSlotDifferencesSlotHandleResponse(resp *http.Response) (WebAppsListSlotDifferencesSlotResponse, error) {
	result := WebAppsListSlotDifferencesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotDifferenceCollection); err != nil {
		return WebAppsListSlotDifferencesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSlotDifferencesSlotHandleError handles the ListSlotDifferencesSlot error response.
func (client *WebAppsClient) listSlotDifferencesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSlots - Description for Gets an app's deployment slots.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSlots(resourceGroupName string, name string, options *WebAppsListSlotsOptions) *WebAppsListSlotsPager {
	return &WebAppsListSlotsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSlotsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSlotsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebAppCollection.NextLink)
		},
	}
}

// listSlotsCreateRequest creates the ListSlots request.
func (client *WebAppsClient) listSlotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSlotsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSlotsHandleResponse handles the ListSlots response.
func (client *WebAppsClient) listSlotsHandleResponse(resp *http.Response) (WebAppsListSlotsResponse, error) {
	result := WebAppsListSlotsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebAppCollection); err != nil {
		return WebAppsListSlotsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSlotsHandleError handles the ListSlots error response.
func (client *WebAppsClient) listSlotsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSnapshots - Description for Returns all Snapshots to the user.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshots(resourceGroupName string, name string, options *WebAppsListSnapshotsOptions) *WebAppsListSnapshotsPager {
	return &WebAppsListSnapshotsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSnapshotsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSnapshotsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
	}
}

// listSnapshotsCreateRequest creates the ListSnapshots request.
func (client *WebAppsClient) listSnapshotsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSnapshotsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsHandleResponse handles the ListSnapshots response.
func (client *WebAppsClient) listSnapshotsHandleResponse(resp *http.Response) (WebAppsListSnapshotsResponse, error) {
	result := WebAppsListSnapshotsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsListSnapshotsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSnapshotsHandleError handles the ListSnapshots error response.
func (client *WebAppsClient) listSnapshotsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSnapshotsFromDRSecondary - Description for Returns all Snapshots to the user from DRSecondary endpoint.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshotsFromDRSecondary(resourceGroupName string, name string, options *WebAppsListSnapshotsFromDRSecondaryOptions) *WebAppsListSnapshotsFromDRSecondaryPager {
	return &WebAppsListSnapshotsFromDRSecondaryPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSnapshotsFromDRSecondaryCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSnapshotsFromDRSecondaryResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
	}
}

// listSnapshotsFromDRSecondaryCreateRequest creates the ListSnapshotsFromDRSecondary request.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSnapshotsFromDRSecondaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsFromDRSecondaryHandleResponse handles the ListSnapshotsFromDRSecondary response.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryHandleResponse(resp *http.Response) (WebAppsListSnapshotsFromDRSecondaryResponse, error) {
	result := WebAppsListSnapshotsFromDRSecondaryResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsListSnapshotsFromDRSecondaryResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSnapshotsFromDRSecondaryHandleError handles the ListSnapshotsFromDRSecondary error response.
func (client *WebAppsClient) listSnapshotsFromDRSecondaryHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSnapshotsFromDRSecondarySlot - Description for Returns all Snapshots to the user from DRSecondary endpoint.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshotsFromDRSecondarySlot(resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsFromDRSecondarySlotOptions) *WebAppsListSnapshotsFromDRSecondarySlotPager {
	return &WebAppsListSnapshotsFromDRSecondarySlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSnapshotsFromDRSecondarySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSnapshotsFromDRSecondarySlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
	}
}

// listSnapshotsFromDRSecondarySlotCreateRequest creates the ListSnapshotsFromDRSecondarySlot request.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsFromDRSecondarySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshotsdr"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsFromDRSecondarySlotHandleResponse handles the ListSnapshotsFromDRSecondarySlot response.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotHandleResponse(resp *http.Response) (WebAppsListSnapshotsFromDRSecondarySlotResponse, error) {
	result := WebAppsListSnapshotsFromDRSecondarySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsListSnapshotsFromDRSecondarySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSnapshotsFromDRSecondarySlotHandleError handles the ListSnapshotsFromDRSecondarySlot error response.
func (client *WebAppsClient) listSnapshotsFromDRSecondarySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSnapshotsSlot - Description for Returns all Snapshots to the user.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSnapshotsSlot(resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsSlotOptions) *WebAppsListSnapshotsSlotPager {
	return &WebAppsListSnapshotsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listSnapshotsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListSnapshotsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.SnapshotCollection.NextLink)
		},
	}
}

// listSnapshotsSlotCreateRequest creates the ListSnapshotsSlot request.
func (client *WebAppsClient) listSnapshotsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSnapshotsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/snapshots"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSnapshotsSlotHandleResponse handles the ListSnapshotsSlot response.
func (client *WebAppsClient) listSnapshotsSlotHandleResponse(resp *http.Response) (WebAppsListSnapshotsSlotResponse, error) {
	result := WebAppsListSnapshotsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SnapshotCollection); err != nil {
		return WebAppsListSnapshotsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSnapshotsSlotHandleError handles the ListSnapshotsSlot error response.
func (client *WebAppsClient) listSnapshotsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSyncFunctionTriggers - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncFunctionTriggersOptions) (WebAppsListSyncFunctionTriggersResponse, error) {
	req, err := client.listSyncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListSyncFunctionTriggersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSyncFunctionTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListSyncFunctionTriggersResponse{}, client.listSyncFunctionTriggersHandleError(resp)
	}
	return client.listSyncFunctionTriggersHandleResponse(resp)
}

// listSyncFunctionTriggersCreateRequest creates the ListSyncFunctionTriggers request.
func (client *WebAppsClient) listSyncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncFunctionTriggersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncFunctionTriggersHandleResponse handles the ListSyncFunctionTriggers response.
func (client *WebAppsClient) listSyncFunctionTriggersHandleResponse(resp *http.Response) (WebAppsListSyncFunctionTriggersResponse, error) {
	result := WebAppsListSyncFunctionTriggersResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsListSyncFunctionTriggersResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSyncFunctionTriggersHandleError handles the ListSyncFunctionTriggers error response.
func (client *WebAppsClient) listSyncFunctionTriggersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSyncFunctionTriggersSlot - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncFunctionTriggersSlotOptions) (WebAppsListSyncFunctionTriggersSlotResponse, error) {
	req, err := client.listSyncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListSyncFunctionTriggersSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSyncFunctionTriggersSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListSyncFunctionTriggersSlotResponse{}, client.listSyncFunctionTriggersSlotHandleError(resp)
	}
	return client.listSyncFunctionTriggersSlotHandleResponse(resp)
}

// listSyncFunctionTriggersSlotCreateRequest creates the ListSyncFunctionTriggersSlot request.
func (client *WebAppsClient) listSyncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncFunctionTriggersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/listsyncfunctiontriggerstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncFunctionTriggersSlotHandleResponse handles the ListSyncFunctionTriggersSlot response.
func (client *WebAppsClient) listSyncFunctionTriggersSlotHandleResponse(resp *http.Response) (WebAppsListSyncFunctionTriggersSlotResponse, error) {
	result := WebAppsListSyncFunctionTriggersSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FunctionSecrets); err != nil {
		return WebAppsListSyncFunctionTriggersSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listSyncFunctionTriggersSlotHandleError handles the ListSyncFunctionTriggersSlot error response.
func (client *WebAppsClient) listSyncFunctionTriggersSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSyncStatus - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncStatus(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncStatusOptions) (WebAppsListSyncStatusResponse, error) {
	req, err := client.listSyncStatusCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListSyncStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSyncStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsListSyncStatusResponse{}, client.listSyncStatusHandleError(resp)
	}
	return WebAppsListSyncStatusResponse{RawResponse: resp}, nil
}

// listSyncStatusCreateRequest creates the ListSyncStatus request.
func (client *WebAppsClient) listSyncStatusCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListSyncStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncStatusHandleError handles the ListSyncStatus error response.
func (client *WebAppsClient) listSyncStatusHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListSyncStatusSlot - Description for This is to allow calling via powershell and ARM template.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListSyncStatusSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncStatusSlotOptions) (WebAppsListSyncStatusSlotResponse, error) {
	req, err := client.listSyncStatusSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListSyncStatusSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListSyncStatusSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsListSyncStatusSlotResponse{}, client.listSyncStatusSlotHandleError(resp)
	}
	return WebAppsListSyncStatusSlotResponse{RawResponse: resp}, nil
}

// listSyncStatusSlotCreateRequest creates the ListSyncStatusSlot request.
func (client *WebAppsClient) listSyncStatusSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListSyncStatusSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/listsyncstatus"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listSyncStatusSlotHandleError handles the ListSyncStatusSlot error response.
func (client *WebAppsClient) listSyncStatusSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListTriggeredWebJobHistory - Description for List a triggered web job's history for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobHistory(resourceGroupName string, name string, webJobName string, options *WebAppsListTriggeredWebJobHistoryOptions) *WebAppsListTriggeredWebJobHistoryPager {
	return &WebAppsListTriggeredWebJobHistoryPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listTriggeredWebJobHistoryCreateRequest(ctx, resourceGroupName, name, webJobName, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListTriggeredWebJobHistoryResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.TriggeredJobHistoryCollection.NextLink)
		},
	}
}

// listTriggeredWebJobHistoryCreateRequest creates the ListTriggeredWebJobHistory request.
func (client *WebAppsClient) listTriggeredWebJobHistoryCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsListTriggeredWebJobHistoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobHistoryHandleResponse handles the ListTriggeredWebJobHistory response.
func (client *WebAppsClient) listTriggeredWebJobHistoryHandleResponse(resp *http.Response) (WebAppsListTriggeredWebJobHistoryResponse, error) {
	result := WebAppsListTriggeredWebJobHistoryResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistoryCollection); err != nil {
		return WebAppsListTriggeredWebJobHistoryResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listTriggeredWebJobHistoryHandleError handles the ListTriggeredWebJobHistory error response.
func (client *WebAppsClient) listTriggeredWebJobHistoryHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListTriggeredWebJobHistorySlot - Description for List a triggered web job's history for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobHistorySlot(resourceGroupName string, name string, webJobName string, slot string, options *WebAppsListTriggeredWebJobHistorySlotOptions) *WebAppsListTriggeredWebJobHistorySlotPager {
	return &WebAppsListTriggeredWebJobHistorySlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listTriggeredWebJobHistorySlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListTriggeredWebJobHistorySlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.TriggeredJobHistoryCollection.NextLink)
		},
	}
}

// listTriggeredWebJobHistorySlotCreateRequest creates the ListTriggeredWebJobHistorySlot request.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsListTriggeredWebJobHistorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/history"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobHistorySlotHandleResponse handles the ListTriggeredWebJobHistorySlot response.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotHandleResponse(resp *http.Response) (WebAppsListTriggeredWebJobHistorySlotResponse, error) {
	result := WebAppsListTriggeredWebJobHistorySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredJobHistoryCollection); err != nil {
		return WebAppsListTriggeredWebJobHistorySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listTriggeredWebJobHistorySlotHandleError handles the ListTriggeredWebJobHistorySlot error response.
func (client *WebAppsClient) listTriggeredWebJobHistorySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// ListTriggeredWebJobs - Description for List triggered web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobs(resourceGroupName string, name string, options *WebAppsListTriggeredWebJobsOptions) *WebAppsListTriggeredWebJobsPager {
	return &WebAppsListTriggeredWebJobsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listTriggeredWebJobsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListTriggeredWebJobsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.TriggeredWebJobCollection.NextLink)
		},
	}
}

// listTriggeredWebJobsCreateRequest creates the ListTriggeredWebJobs request.
func (client *WebAppsClient) listTriggeredWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListTriggeredWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobsHandleResponse handles the ListTriggeredWebJobs response.
func (client *WebAppsClient) listTriggeredWebJobsHandleResponse(resp *http.Response) (WebAppsListTriggeredWebJobsResponse, error) {
	result := WebAppsListTriggeredWebJobsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJobCollection); err != nil {
		return WebAppsListTriggeredWebJobsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listTriggeredWebJobsHandleError handles the ListTriggeredWebJobs error response.
func (client *WebAppsClient) listTriggeredWebJobsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListTriggeredWebJobsSlot - Description for List triggered web jobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListTriggeredWebJobsSlot(resourceGroupName string, name string, slot string, options *WebAppsListTriggeredWebJobsSlotOptions) *WebAppsListTriggeredWebJobsSlotPager {
	return &WebAppsListTriggeredWebJobsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listTriggeredWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListTriggeredWebJobsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.TriggeredWebJobCollection.NextLink)
		},
	}
}

// listTriggeredWebJobsSlotCreateRequest creates the ListTriggeredWebJobsSlot request.
func (client *WebAppsClient) listTriggeredWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListTriggeredWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listTriggeredWebJobsSlotHandleResponse handles the ListTriggeredWebJobsSlot response.
func (client *WebAppsClient) listTriggeredWebJobsSlotHandleResponse(resp *http.Response) (WebAppsListTriggeredWebJobsSlotResponse, error) {
	result := WebAppsListTriggeredWebJobsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.TriggeredWebJobCollection); err != nil {
		return WebAppsListTriggeredWebJobsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listTriggeredWebJobsSlotHandleError handles the ListTriggeredWebJobsSlot error response.
func (client *WebAppsClient) listTriggeredWebJobsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListUsages - Description for Gets the quota usage information of an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListUsages(resourceGroupName string, name string, options *WebAppsListUsagesOptions) *WebAppsListUsagesPager {
	return &WebAppsListUsagesPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listUsagesCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListUsagesResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CsmUsageQuotaCollection.NextLink)
		},
	}
}

// listUsagesCreateRequest creates the ListUsages request.
func (client *WebAppsClient) listUsagesCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListUsagesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listUsagesHandleResponse handles the ListUsages response.
func (client *WebAppsClient) listUsagesHandleResponse(resp *http.Response) (WebAppsListUsagesResponse, error) {
	result := WebAppsListUsagesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return WebAppsListUsagesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listUsagesHandleError handles the ListUsages error response.
func (client *WebAppsClient) listUsagesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListUsagesSlot - Description for Gets the quota usage information of an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListUsagesSlot(resourceGroupName string, name string, slot string, options *WebAppsListUsagesSlotOptions) *WebAppsListUsagesSlotPager {
	return &WebAppsListUsagesSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listUsagesSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListUsagesSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.CsmUsageQuotaCollection.NextLink)
		},
	}
}

// listUsagesSlotCreateRequest creates the ListUsagesSlot request.
func (client *WebAppsClient) listUsagesSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListUsagesSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/usages"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.Raw().URL.RawQuery}
	if options != nil && options.Filter != nil {
		unencodedParams = append(unencodedParams, "$filter="+*options.Filter)
	}
	req.Raw().URL.RawQuery = strings.Join(unencodedParams, "&")
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listUsagesSlotHandleResponse handles the ListUsagesSlot response.
func (client *WebAppsClient) listUsagesSlotHandleResponse(resp *http.Response) (WebAppsListUsagesSlotResponse, error) {
	result := WebAppsListUsagesSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmUsageQuotaCollection); err != nil {
		return WebAppsListUsagesSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listUsagesSlotHandleError handles the ListUsagesSlot error response.
func (client *WebAppsClient) listUsagesSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListVnetConnections - Description for Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListVnetConnections(ctx context.Context, resourceGroupName string, name string, options *WebAppsListVnetConnectionsOptions) (WebAppsListVnetConnectionsResponse, error) {
	req, err := client.listVnetConnectionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsListVnetConnectionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListVnetConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListVnetConnectionsResponse{}, client.listVnetConnectionsHandleError(resp)
	}
	return client.listVnetConnectionsHandleResponse(resp)
}

// listVnetConnectionsCreateRequest creates the ListVnetConnections request.
func (client *WebAppsClient) listVnetConnectionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListVnetConnectionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listVnetConnectionsHandleResponse handles the ListVnetConnections response.
func (client *WebAppsClient) listVnetConnectionsHandleResponse(resp *http.Response) (WebAppsListVnetConnectionsResponse, error) {
	result := WebAppsListVnetConnectionsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResourceArray); err != nil {
		return WebAppsListVnetConnectionsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listVnetConnectionsHandleError handles the ListVnetConnections error response.
func (client *WebAppsClient) listVnetConnectionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListVnetConnectionsSlot - Description for Gets the virtual networks the app (or deployment slot) is connected to.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListVnetConnectionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListVnetConnectionsSlotOptions) (WebAppsListVnetConnectionsSlotResponse, error) {
	req, err := client.listVnetConnectionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsListVnetConnectionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsListVnetConnectionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsListVnetConnectionsSlotResponse{}, client.listVnetConnectionsSlotHandleError(resp)
	}
	return client.listVnetConnectionsSlotHandleResponse(resp)
}

// listVnetConnectionsSlotCreateRequest creates the ListVnetConnectionsSlot request.
func (client *WebAppsClient) listVnetConnectionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListVnetConnectionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listVnetConnectionsSlotHandleResponse handles the ListVnetConnectionsSlot response.
func (client *WebAppsClient) listVnetConnectionsSlotHandleResponse(resp *http.Response) (WebAppsListVnetConnectionsSlotResponse, error) {
	result := WebAppsListVnetConnectionsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResourceArray); err != nil {
		return WebAppsListVnetConnectionsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listVnetConnectionsSlotHandleError handles the ListVnetConnectionsSlot error response.
func (client *WebAppsClient) listVnetConnectionsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWebJobs - Description for List webjobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListWebJobs(resourceGroupName string, name string, options *WebAppsListWebJobsOptions) *WebAppsListWebJobsPager {
	return &WebAppsListWebJobsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebJobsCreateRequest(ctx, resourceGroupName, name, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListWebJobsResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebJobCollection.NextLink)
		},
	}
}

// listWebJobsCreateRequest creates the ListWebJobs request.
func (client *WebAppsClient) listWebJobsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsListWebJobsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebJobsHandleResponse handles the ListWebJobs response.
func (client *WebAppsClient) listWebJobsHandleResponse(resp *http.Response) (WebAppsListWebJobsResponse, error) {
	result := WebAppsListWebJobsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJobCollection); err != nil {
		return WebAppsListWebJobsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWebJobsHandleError handles the ListWebJobs error response.
func (client *WebAppsClient) listWebJobsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ListWebJobsSlot - Description for List webjobs for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ListWebJobsSlot(resourceGroupName string, name string, slot string, options *WebAppsListWebJobsSlotOptions) *WebAppsListWebJobsSlotPager {
	return &WebAppsListWebJobsSlotPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listWebJobsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
		},
		advancer: func(ctx context.Context, resp WebAppsListWebJobsSlotResponse) (*policy.Request, error) {
			return runtime.NewRequest(ctx, http.MethodGet, *resp.WebJobCollection.NextLink)
		},
	}
}

// listWebJobsSlotCreateRequest creates the ListWebJobsSlot request.
func (client *WebAppsClient) listWebJobsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsListWebJobsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/webjobs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listWebJobsSlotHandleResponse handles the ListWebJobsSlot response.
func (client *WebAppsClient) listWebJobsSlotHandleResponse(resp *http.Response) (WebAppsListWebJobsSlotResponse, error) {
	result := WebAppsListWebJobsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.WebJobCollection); err != nil {
		return WebAppsListWebJobsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// listWebJobsSlotHandleError handles the ListWebJobsSlot error response.
func (client *WebAppsClient) listWebJobsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateMySQL - Description for Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginMigrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsBeginMigrateMySQLOptions) (WebAppsMigrateMySQLPollerResponse, error) {
	resp, err := client.migrateMySQL(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
	if err != nil {
		return WebAppsMigrateMySQLPollerResponse{}, err
	}
	result := WebAppsMigrateMySQLPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.MigrateMySQL", "", resp, client.pl, client.migrateMySQLHandleError)
	if err != nil {
		return WebAppsMigrateMySQLPollerResponse{}, err
	}
	result.Poller = &WebAppsMigrateMySQLPoller{
		pt: pt,
	}
	return result, nil
}

// MigrateMySQL - Description for Migrates a local (in-app) MySql database to a remote MySql database.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) migrateMySQL(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsBeginMigrateMySQLOptions) (*http.Response, error) {
	req, err := client.migrateMySQLCreateRequest(ctx, resourceGroupName, name, migrationRequestEnvelope, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, client.migrateMySQLHandleError(resp)
	}
	return resp, nil
}

// migrateMySQLCreateRequest creates the MigrateMySQL request.
func (client *WebAppsClient) migrateMySQLCreateRequest(ctx context.Context, resourceGroupName string, name string, migrationRequestEnvelope MigrateMySQLRequest, options *WebAppsBeginMigrateMySQLOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migratemysql"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, migrationRequestEnvelope)
}

// migrateMySQLHandleError handles the MigrateMySQL error response.
func (client *WebAppsClient) migrateMySQLHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginMigrateStorage - Description for Restores a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginMigrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsBeginMigrateStorageOptions) (WebAppsMigrateStoragePollerResponse, error) {
	resp, err := client.migrateStorage(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
	if err != nil {
		return WebAppsMigrateStoragePollerResponse{}, err
	}
	result := WebAppsMigrateStoragePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.MigrateStorage", "", resp, client.pl, client.migrateStorageHandleError)
	if err != nil {
		return WebAppsMigrateStoragePollerResponse{}, err
	}
	result.Poller = &WebAppsMigrateStoragePoller{
		pt: pt,
	}
	return result, nil
}

// MigrateStorage - Description for Restores a web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) migrateStorage(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsBeginMigrateStorageOptions) (*http.Response, error) {
	req, err := client.migrateStorageCreateRequest(ctx, subscriptionName, resourceGroupName, name, migrationOptions, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return nil, client.migrateStorageHandleError(resp)
	}
	return resp, nil
}

// migrateStorageCreateRequest creates the MigrateStorage request.
func (client *WebAppsClient) migrateStorageCreateRequest(ctx context.Context, subscriptionName string, resourceGroupName string, name string, migrationOptions StorageMigrationOptions, options *WebAppsBeginMigrateStorageOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/migrate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("subscriptionName", subscriptionName)
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, migrationOptions)
}

// migrateStorageHandleError handles the MigrateStorage error response.
func (client *WebAppsClient) migrateStorageHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutPrivateAccessVnet - Description for Sets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) PutPrivateAccessVnet(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetOptions) (WebAppsPutPrivateAccessVnetResponse, error) {
	req, err := client.putPrivateAccessVnetCreateRequest(ctx, resourceGroupName, name, access, options)
	if err != nil {
		return WebAppsPutPrivateAccessVnetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsPutPrivateAccessVnetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsPutPrivateAccessVnetResponse{}, client.putPrivateAccessVnetHandleError(resp)
	}
	return client.putPrivateAccessVnetHandleResponse(resp)
}

// putPrivateAccessVnetCreateRequest creates the PutPrivateAccessVnet request.
func (client *WebAppsClient) putPrivateAccessVnetCreateRequest(ctx context.Context, resourceGroupName string, name string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, access)
}

// putPrivateAccessVnetHandleResponse handles the PutPrivateAccessVnet response.
func (client *WebAppsClient) putPrivateAccessVnetHandleResponse(resp *http.Response) (WebAppsPutPrivateAccessVnetResponse, error) {
	result := WebAppsPutPrivateAccessVnetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsPutPrivateAccessVnetResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// putPrivateAccessVnetHandleError handles the PutPrivateAccessVnet error response.
func (client *WebAppsClient) putPrivateAccessVnetHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// PutPrivateAccessVnetSlot - Description for Sets data around private site access enablement and authorized Virtual Networks that can access the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) PutPrivateAccessVnetSlot(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetSlotOptions) (WebAppsPutPrivateAccessVnetSlotResponse, error) {
	req, err := client.putPrivateAccessVnetSlotCreateRequest(ctx, resourceGroupName, name, slot, access, options)
	if err != nil {
		return WebAppsPutPrivateAccessVnetSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsPutPrivateAccessVnetSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsPutPrivateAccessVnetSlotResponse{}, client.putPrivateAccessVnetSlotHandleError(resp)
	}
	return client.putPrivateAccessVnetSlotHandleResponse(resp)
}

// putPrivateAccessVnetSlotCreateRequest creates the PutPrivateAccessVnetSlot request.
func (client *WebAppsClient) putPrivateAccessVnetSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, access PrivateAccess, options *WebAppsPutPrivateAccessVnetSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/privateAccess/virtualNetworks"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, access)
}

// putPrivateAccessVnetSlotHandleResponse handles the PutPrivateAccessVnetSlot response.
func (client *WebAppsClient) putPrivateAccessVnetSlotHandleResponse(resp *http.Response) (WebAppsPutPrivateAccessVnetSlotResponse, error) {
	result := WebAppsPutPrivateAccessVnetSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PrivateAccess); err != nil {
		return WebAppsPutPrivateAccessVnetSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// putPrivateAccessVnetSlotHandleError handles the PutPrivateAccessVnetSlot error response.
func (client *WebAppsClient) putPrivateAccessVnetSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RecoverSiteConfigurationSnapshot - Description for Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RecoverSiteConfigurationSnapshot(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsRecoverSiteConfigurationSnapshotOptions) (WebAppsRecoverSiteConfigurationSnapshotResponse, error) {
	req, err := client.recoverSiteConfigurationSnapshotCreateRequest(ctx, resourceGroupName, name, snapshotID, options)
	if err != nil {
		return WebAppsRecoverSiteConfigurationSnapshotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsRecoverSiteConfigurationSnapshotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsRecoverSiteConfigurationSnapshotResponse{}, client.recoverSiteConfigurationSnapshotHandleError(resp)
	}
	return WebAppsRecoverSiteConfigurationSnapshotResponse{RawResponse: resp}, nil
}

// recoverSiteConfigurationSnapshotCreateRequest creates the RecoverSiteConfigurationSnapshot request.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, options *WebAppsRecoverSiteConfigurationSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// recoverSiteConfigurationSnapshotHandleError handles the RecoverSiteConfigurationSnapshot error response.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RecoverSiteConfigurationSnapshotSlot - Description for Reverts the configuration of an app to a previous snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RecoverSiteConfigurationSnapshotSlot(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsRecoverSiteConfigurationSnapshotSlotOptions) (WebAppsRecoverSiteConfigurationSnapshotSlotResponse, error) {
	req, err := client.recoverSiteConfigurationSnapshotSlotCreateRequest(ctx, resourceGroupName, name, snapshotID, slot, options)
	if err != nil {
		return WebAppsRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsRecoverSiteConfigurationSnapshotSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsRecoverSiteConfigurationSnapshotSlotResponse{}, client.recoverSiteConfigurationSnapshotSlotHandleError(resp)
	}
	return WebAppsRecoverSiteConfigurationSnapshotSlotResponse{RawResponse: resp}, nil
}

// recoverSiteConfigurationSnapshotSlotCreateRequest creates the RecoverSiteConfigurationSnapshotSlot request.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, snapshotID string, slot string, options *WebAppsRecoverSiteConfigurationSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web/snapshots/{snapshotId}/recover"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if snapshotID == "" {
		return nil, errors.New("parameter snapshotID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{snapshotId}", url.PathEscape(snapshotID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// recoverSiteConfigurationSnapshotSlotHandleError handles the RecoverSiteConfigurationSnapshotSlot error response.
func (client *WebAppsClient) recoverSiteConfigurationSnapshotSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ResetProductionSlotConfig - Description for Resets the configuration settings of the current slot if they were previously modified by calling the API
// with POST.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ResetProductionSlotConfig(ctx context.Context, resourceGroupName string, name string, options *WebAppsResetProductionSlotConfigOptions) (WebAppsResetProductionSlotConfigResponse, error) {
	req, err := client.resetProductionSlotConfigCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsResetProductionSlotConfigResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsResetProductionSlotConfigResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsResetProductionSlotConfigResponse{}, client.resetProductionSlotConfigHandleError(resp)
	}
	return WebAppsResetProductionSlotConfigResponse{RawResponse: resp}, nil
}

// resetProductionSlotConfigCreateRequest creates the ResetProductionSlotConfig request.
func (client *WebAppsClient) resetProductionSlotConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsResetProductionSlotConfigOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resetProductionSlotConfigHandleError handles the ResetProductionSlotConfig error response.
func (client *WebAppsClient) resetProductionSlotConfigHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// ResetSlotConfigurationSlot - Description for Resets the configuration settings of the current slot if they were previously modified by calling the API
// with POST.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) ResetSlotConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsResetSlotConfigurationSlotOptions) (WebAppsResetSlotConfigurationSlotResponse, error) {
	req, err := client.resetSlotConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsResetSlotConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsResetSlotConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsResetSlotConfigurationSlotResponse{}, client.resetSlotConfigurationSlotHandleError(resp)
	}
	return WebAppsResetSlotConfigurationSlotResponse{RawResponse: resp}, nil
}

// resetSlotConfigurationSlotCreateRequest creates the ResetSlotConfigurationSlot request.
func (client *WebAppsClient) resetSlotConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsResetSlotConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/resetSlotConfig"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// resetSlotConfigurationSlotHandleError handles the ResetSlotConfigurationSlot error response.
func (client *WebAppsClient) resetSlotConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Restart - Description for Restarts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Restart(ctx context.Context, resourceGroupName string, name string, options *WebAppsRestartOptions) (WebAppsRestartResponse, error) {
	req, err := client.restartCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsRestartResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsRestartResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsRestartResponse{}, client.restartHandleError(resp)
	}
	return WebAppsRestartResponse{RawResponse: resp}, nil
}

// restartCreateRequest creates the Restart request.
func (client *WebAppsClient) restartCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsRestartOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// restartHandleError handles the Restart error response.
func (client *WebAppsClient) restartHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RestartSlot - Description for Restarts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RestartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsRestartSlotOptions) (WebAppsRestartSlotResponse, error) {
	req, err := client.restartSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsRestartSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsRestartSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsRestartSlotResponse{}, client.restartSlotHandleError(resp)
	}
	return WebAppsRestartSlotResponse{RawResponse: resp}, nil
}

// restartSlotCreateRequest creates the RestartSlot request.
func (client *WebAppsClient) restartSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsRestartSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restart"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SoftRestart != nil {
		reqQP.Set("softRestart", strconv.FormatBool(*options.SoftRestart))
	}
	if options != nil && options.Synchronous != nil {
		reqQP.Set("synchronous", strconv.FormatBool(*options.Synchronous))
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// restartSlotHandleError handles the RestartSlot error response.
func (client *WebAppsClient) restartSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestore - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsBeginRestoreOptions) (WebAppsRestorePollerResponse, error) {
	resp, err := client.restore(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return WebAppsRestorePollerResponse{}, err
	}
	result := WebAppsRestorePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.Restore", "", resp, client.pl, client.restoreHandleError)
	if err != nil {
		return WebAppsRestorePollerResponse{}, err
	}
	result.Poller = &WebAppsRestorePoller{
		pt: pt,
	}
	return result, nil
}

// Restore - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restore(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsBeginRestoreOptions) (*http.Response, error) {
	req, err := client.restoreCreateRequest(ctx, resourceGroupName, name, backupID, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreHandleError(resp)
	}
	return resp, nil
}

// restoreCreateRequest creates the Restore request.
func (client *WebAppsClient) restoreCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, request RestoreRequest, options *WebAppsBeginRestoreOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// restoreHandleError handles the Restore error response.
func (client *WebAppsClient) restoreHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreFromBackupBlob - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobOptions) (WebAppsRestoreFromBackupBlobPollerResponse, error) {
	resp, err := client.restoreFromBackupBlob(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsRestoreFromBackupBlobPollerResponse{}, err
	}
	result := WebAppsRestoreFromBackupBlobPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreFromBackupBlob", "", resp, client.pl, client.restoreFromBackupBlobHandleError)
	if err != nil {
		return WebAppsRestoreFromBackupBlobPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreFromBackupBlobPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreFromBackupBlob - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromBackupBlob(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobOptions) (*http.Response, error) {
	req, err := client.restoreFromBackupBlobCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromBackupBlobHandleError(resp)
	}
	return resp, nil
}

// restoreFromBackupBlobCreateRequest creates the RestoreFromBackupBlob request.
func (client *WebAppsClient) restoreFromBackupBlobCreateRequest(ctx context.Context, resourceGroupName string, name string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// restoreFromBackupBlobHandleError handles the RestoreFromBackupBlob error response.
func (client *WebAppsClient) restoreFromBackupBlobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreFromBackupBlobSlot - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobSlotOptions) (WebAppsRestoreFromBackupBlobSlotPollerResponse, error) {
	resp, err := client.restoreFromBackupBlobSlot(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsRestoreFromBackupBlobSlotPollerResponse{}, err
	}
	result := WebAppsRestoreFromBackupBlobSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreFromBackupBlobSlot", "", resp, client.pl, client.restoreFromBackupBlobSlotHandleError)
	if err != nil {
		return WebAppsRestoreFromBackupBlobSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreFromBackupBlobSlotPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreFromBackupBlobSlot - Description for Restores an app from a backup blob in Azure Storage.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromBackupBlobSlot(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobSlotOptions) (*http.Response, error) {
	req, err := client.restoreFromBackupBlobSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromBackupBlobSlotHandleError(resp)
	}
	return resp, nil
}

// restoreFromBackupBlobSlotCreateRequest creates the RestoreFromBackupBlobSlot request.
func (client *WebAppsClient) restoreFromBackupBlobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request RestoreRequest, options *WebAppsBeginRestoreFromBackupBlobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromBackupBlob"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// restoreFromBackupBlobSlotHandleError handles the RestoreFromBackupBlobSlot error response.
func (client *WebAppsClient) restoreFromBackupBlobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreFromDeletedApp - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppOptions) (WebAppsRestoreFromDeletedAppPollerResponse, error) {
	resp, err := client.restoreFromDeletedApp(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return WebAppsRestoreFromDeletedAppPollerResponse{}, err
	}
	result := WebAppsRestoreFromDeletedAppPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreFromDeletedApp", "", resp, client.pl, client.restoreFromDeletedAppHandleError)
	if err != nil {
		return WebAppsRestoreFromDeletedAppPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreFromDeletedAppPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreFromDeletedApp - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromDeletedApp(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppOptions) (*http.Response, error) {
	req, err := client.restoreFromDeletedAppCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromDeletedAppHandleError(resp)
	}
	return resp, nil
}

// restoreFromDeletedAppCreateRequest creates the RestoreFromDeletedApp request.
func (client *WebAppsClient) restoreFromDeletedAppCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// restoreFromDeletedAppHandleError handles the RestoreFromDeletedApp error response.
func (client *WebAppsClient) restoreFromDeletedAppHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreFromDeletedAppSlot - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppSlotOptions) (WebAppsRestoreFromDeletedAppSlotPollerResponse, error) {
	resp, err := client.restoreFromDeletedAppSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return WebAppsRestoreFromDeletedAppSlotPollerResponse{}, err
	}
	result := WebAppsRestoreFromDeletedAppSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreFromDeletedAppSlot", "", resp, client.pl, client.restoreFromDeletedAppSlotHandleError)
	if err != nil {
		return WebAppsRestoreFromDeletedAppSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreFromDeletedAppSlotPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreFromDeletedAppSlot - Description for Restores a deleted web app to this web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreFromDeletedAppSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppSlotOptions) (*http.Response, error) {
	req, err := client.restoreFromDeletedAppSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreFromDeletedAppSlotHandleError(resp)
	}
	return resp, nil
}

// restoreFromDeletedAppSlotCreateRequest creates the RestoreFromDeletedAppSlot request.
func (client *WebAppsClient) restoreFromDeletedAppSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest DeletedAppRestoreRequest, options *WebAppsBeginRestoreFromDeletedAppSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreFromDeletedApp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// restoreFromDeletedAppSlotHandleError handles the RestoreFromDeletedAppSlot error response.
func (client *WebAppsClient) restoreFromDeletedAppSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreSlot - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsBeginRestoreSlotOptions) (WebAppsRestoreSlotPollerResponse, error) {
	resp, err := client.restoreSlot(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return WebAppsRestoreSlotPollerResponse{}, err
	}
	result := WebAppsRestoreSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreSlot", "", resp, client.pl, client.restoreSlotHandleError)
	if err != nil {
		return WebAppsRestoreSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreSlotPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreSlot - Description for Restores a specific backup to another app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreSlot(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsBeginRestoreSlotOptions) (*http.Response, error) {
	req, err := client.restoreSlotCreateRequest(ctx, resourceGroupName, name, backupID, slot, request, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreSlotHandleError(resp)
	}
	return resp, nil
}

// restoreSlotCreateRequest creates the RestoreSlot request.
func (client *WebAppsClient) restoreSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, backupID string, slot string, request RestoreRequest, options *WebAppsBeginRestoreSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/backups/{backupId}/restore"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if backupID == "" {
		return nil, errors.New("parameter backupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{backupId}", url.PathEscape(backupID))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// restoreSlotHandleError handles the RestoreSlot error response.
func (client *WebAppsClient) restoreSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreSnapshot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotOptions) (WebAppsRestoreSnapshotPollerResponse, error) {
	resp, err := client.restoreSnapshot(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return WebAppsRestoreSnapshotPollerResponse{}, err
	}
	result := WebAppsRestoreSnapshotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreSnapshot", "", resp, client.pl, client.restoreSnapshotHandleError)
	if err != nil {
		return WebAppsRestoreSnapshotPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreSnapshotPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreSnapshot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreSnapshot(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotOptions) (*http.Response, error) {
	req, err := client.restoreSnapshotCreateRequest(ctx, resourceGroupName, name, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreSnapshotHandleError(resp)
	}
	return resp, nil
}

// restoreSnapshotCreateRequest creates the RestoreSnapshot request.
func (client *WebAppsClient) restoreSnapshotCreateRequest(ctx context.Context, resourceGroupName string, name string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// restoreSnapshotHandleError handles the RestoreSnapshot error response.
func (client *WebAppsClient) restoreSnapshotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginRestoreSnapshotSlot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginRestoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotSlotOptions) (WebAppsRestoreSnapshotSlotPollerResponse, error) {
	resp, err := client.restoreSnapshotSlot(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return WebAppsRestoreSnapshotSlotPollerResponse{}, err
	}
	result := WebAppsRestoreSnapshotSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.RestoreSnapshotSlot", "", resp, client.pl, client.restoreSnapshotSlotHandleError)
	if err != nil {
		return WebAppsRestoreSnapshotSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsRestoreSnapshotSlotPoller{
		pt: pt,
	}
	return result, nil
}

// RestoreSnapshotSlot - Description for Restores a web app from a snapshot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) restoreSnapshotSlot(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotSlotOptions) (*http.Response, error) {
	req, err := client.restoreSnapshotSlotCreateRequest(ctx, resourceGroupName, name, slot, restoreRequest, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.restoreSnapshotSlotHandleError(resp)
	}
	return resp, nil
}

// restoreSnapshotSlotCreateRequest creates the RestoreSnapshotSlot request.
func (client *WebAppsClient) restoreSnapshotSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, restoreRequest SnapshotRestoreRequest, options *WebAppsBeginRestoreSnapshotSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/restoreSnapshot"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, restoreRequest)
}

// restoreSnapshotSlotHandleError handles the RestoreSnapshotSlot error response.
func (client *WebAppsClient) restoreSnapshotSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// RunTriggeredWebJob - Description for Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RunTriggeredWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsRunTriggeredWebJobOptions) (WebAppsRunTriggeredWebJobResponse, error) {
	req, err := client.runTriggeredWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsRunTriggeredWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsRunTriggeredWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsRunTriggeredWebJobResponse{}, client.runTriggeredWebJobHandleError(resp)
	}
	return WebAppsRunTriggeredWebJobResponse{RawResponse: resp}, nil
}

// runTriggeredWebJobCreateRequest creates the RunTriggeredWebJob request.
func (client *WebAppsClient) runTriggeredWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsRunTriggeredWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// runTriggeredWebJobHandleError handles the RunTriggeredWebJob error response.
func (client *WebAppsClient) runTriggeredWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// RunTriggeredWebJobSlot - Description for Run a triggered web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) RunTriggeredWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsRunTriggeredWebJobSlotOptions) (WebAppsRunTriggeredWebJobSlotResponse, error) {
	req, err := client.runTriggeredWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsRunTriggeredWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsRunTriggeredWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsRunTriggeredWebJobSlotResponse{}, client.runTriggeredWebJobSlotHandleError(resp)
	}
	return WebAppsRunTriggeredWebJobSlotResponse{RawResponse: resp}, nil
}

// runTriggeredWebJobSlotCreateRequest creates the RunTriggeredWebJobSlot request.
func (client *WebAppsClient) runTriggeredWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsRunTriggeredWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/triggeredwebjobs/{webJobName}/run"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// runTriggeredWebJobSlotHandleError handles the RunTriggeredWebJobSlot error response.
func (client *WebAppsClient) runTriggeredWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// Start - Description for Starts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Start(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartOptions) (WebAppsStartResponse, error) {
	req, err := client.startCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStartResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStartResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStartResponse{}, client.startHandleError(resp)
	}
	return WebAppsStartResponse{RawResponse: resp}, nil
}

// startCreateRequest creates the Start request.
func (client *WebAppsClient) startCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startHandleError handles the Start error response.
func (client *WebAppsClient) startHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StartContinuousWebJob - Description for Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStartContinuousWebJobOptions) (WebAppsStartContinuousWebJobResponse, error) {
	req, err := client.startContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsStartContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStartContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStartContinuousWebJobResponse{}, client.startContinuousWebJobHandleError(resp)
	}
	return WebAppsStartContinuousWebJobResponse{RawResponse: resp}, nil
}

// startContinuousWebJobCreateRequest creates the StartContinuousWebJob request.
func (client *WebAppsClient) startContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStartContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startContinuousWebJobHandleError handles the StartContinuousWebJob error response.
func (client *WebAppsClient) startContinuousWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// StartContinuousWebJobSlot - Description for Start a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStartContinuousWebJobSlotOptions) (WebAppsStartContinuousWebJobSlotResponse, error) {
	req, err := client.startContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsStartContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStartContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStartContinuousWebJobSlotResponse{}, client.startContinuousWebJobSlotHandleError(resp)
	}
	return WebAppsStartContinuousWebJobSlotResponse{RawResponse: resp}, nil
}

// startContinuousWebJobSlotCreateRequest creates the StartContinuousWebJobSlot request.
func (client *WebAppsClient) startContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStartContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startContinuousWebJobSlotHandleError handles the StartContinuousWebJobSlot error response.
func (client *WebAppsClient) startContinuousWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// BeginStartNetworkTrace - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartNetworkTraceOptions) (WebAppsStartNetworkTracePollerResponse, error) {
	resp, err := client.startNetworkTrace(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStartNetworkTracePollerResponse{}, err
	}
	result := WebAppsStartNetworkTracePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.StartNetworkTrace", "", resp, client.pl, client.startNetworkTraceHandleError)
	if err != nil {
		return WebAppsStartNetworkTracePollerResponse{}, err
	}
	result.Poller = &WebAppsStartNetworkTracePoller{
		pt: pt,
	}
	return result, nil
}

// StartNetworkTrace - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartNetworkTraceOptions) (*http.Response, error) {
	req, err := client.startNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.startNetworkTraceHandleError(resp)
	}
	return resp, nil
}

// startNetworkTraceCreateRequest creates the StartNetworkTrace request.
func (client *WebAppsClient) startNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startNetworkTraceHandleError handles the StartNetworkTrace error response.
func (client *WebAppsClient) startNetworkTraceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginStartNetworkTraceSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartNetworkTraceSlotOptions) (WebAppsStartNetworkTraceSlotPollerResponse, error) {
	resp, err := client.startNetworkTraceSlot(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStartNetworkTraceSlotPollerResponse{}, err
	}
	result := WebAppsStartNetworkTraceSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.StartNetworkTraceSlot", "", resp, client.pl, client.startNetworkTraceSlotHandleError)
	if err != nil {
		return WebAppsStartNetworkTraceSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsStartNetworkTraceSlotPoller{
		pt: pt,
	}
	return result, nil
}

// StartNetworkTraceSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartNetworkTraceSlotOptions) (*http.Response, error) {
	req, err := client.startNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.startNetworkTraceSlotHandleError(resp)
	}
	return resp, nil
}

// startNetworkTraceSlotCreateRequest creates the StartNetworkTraceSlot request.
func (client *WebAppsClient) startNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/startNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startNetworkTraceSlotHandleError handles the StartNetworkTraceSlot error response.
func (client *WebAppsClient) startNetworkTraceSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StartSlot - Description for Starts an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartSlotOptions) (WebAppsStartSlotResponse, error) {
	req, err := client.startSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStartSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStartSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStartSlotResponse{}, client.startSlotHandleError(resp)
	}
	return WebAppsStartSlotResponse{RawResponse: resp}, nil
}

// startSlotCreateRequest creates the StartSlot request.
func (client *WebAppsClient) startSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startSlotHandleError handles the StartSlot error response.
func (client *WebAppsClient) startSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StartWebSiteNetworkTrace - Description for Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartWebSiteNetworkTraceOptions) (WebAppsStartWebSiteNetworkTraceResponse, error) {
	req, err := client.startWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStartWebSiteNetworkTraceResponse{}, client.startWebSiteNetworkTraceHandleError(resp)
	}
	return client.startWebSiteNetworkTraceHandleResponse(resp)
}

// startWebSiteNetworkTraceCreateRequest creates the StartWebSiteNetworkTrace request.
func (client *WebAppsClient) startWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStartWebSiteNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceHandleResponse handles the StartWebSiteNetworkTrace response.
func (client *WebAppsClient) startWebSiteNetworkTraceHandleResponse(resp *http.Response) (WebAppsStartWebSiteNetworkTraceResponse, error) {
	result := WebAppsStartWebSiteNetworkTraceResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsStartWebSiteNetworkTraceResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// startWebSiteNetworkTraceHandleError handles the StartWebSiteNetworkTrace error response.
func (client *WebAppsClient) startWebSiteNetworkTraceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginStartWebSiteNetworkTraceOperation - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartWebSiteNetworkTraceOperationOptions) (WebAppsStartWebSiteNetworkTraceOperationPollerResponse, error) {
	resp, err := client.startWebSiteNetworkTraceOperation(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceOperationPollerResponse{}, err
	}
	result := WebAppsStartWebSiteNetworkTraceOperationPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.StartWebSiteNetworkTraceOperation", "", resp, client.pl, client.startWebSiteNetworkTraceOperationHandleError)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceOperationPollerResponse{}, err
	}
	result.Poller = &WebAppsStartWebSiteNetworkTraceOperationPoller{
		pt: pt,
	}
	return result, nil
}

// StartWebSiteNetworkTraceOperation - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startWebSiteNetworkTraceOperation(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartWebSiteNetworkTraceOperationOptions) (*http.Response, error) {
	req, err := client.startWebSiteNetworkTraceOperationCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.startWebSiteNetworkTraceOperationHandleError(resp)
	}
	return resp, nil
}

// startWebSiteNetworkTraceOperationCreateRequest creates the StartWebSiteNetworkTraceOperation request.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsBeginStartWebSiteNetworkTraceOperationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceOperationHandleError handles the StartWebSiteNetworkTraceOperation error response.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginStartWebSiteNetworkTraceOperationSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginStartWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartWebSiteNetworkTraceOperationSlotOptions) (WebAppsStartWebSiteNetworkTraceOperationSlotPollerResponse, error) {
	resp, err := client.startWebSiteNetworkTraceOperationSlot(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceOperationSlotPollerResponse{}, err
	}
	result := WebAppsStartWebSiteNetworkTraceOperationSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.StartWebSiteNetworkTraceOperationSlot", "", resp, client.pl, client.startWebSiteNetworkTraceOperationSlotHandleError)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceOperationSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsStartWebSiteNetworkTraceOperationSlotPoller{
		pt: pt,
	}
	return result, nil
}

// StartWebSiteNetworkTraceOperationSlot - Description for Start capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartWebSiteNetworkTraceOperationSlotOptions) (*http.Response, error) {
	req, err := client.startWebSiteNetworkTraceOperationSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.startWebSiteNetworkTraceOperationSlotHandleError(resp)
	}
	return resp, nil
}

// startWebSiteNetworkTraceOperationSlotCreateRequest creates the StartWebSiteNetworkTraceOperationSlot request.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsBeginStartWebSiteNetworkTraceOperationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/startOperation"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceOperationSlotHandleError handles the StartWebSiteNetworkTraceOperationSlot error response.
func (client *WebAppsClient) startWebSiteNetworkTraceOperationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StartWebSiteNetworkTraceSlot - Description for Start capturing network packets for the site (To be deprecated).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StartWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartWebSiteNetworkTraceSlotOptions) (WebAppsStartWebSiteNetworkTraceSlotResponse, error) {
	req, err := client.startWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStartWebSiteNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStartWebSiteNetworkTraceSlotResponse{}, client.startWebSiteNetworkTraceSlotHandleError(resp)
	}
	return client.startWebSiteNetworkTraceSlotHandleResponse(resp)
}

// startWebSiteNetworkTraceSlotCreateRequest creates the StartWebSiteNetworkTraceSlot request.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStartWebSiteNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/start"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.DurationInSeconds != nil {
		reqQP.Set("durationInSeconds", strconv.FormatInt(int64(*options.DurationInSeconds), 10))
	}
	if options != nil && options.MaxFrameLength != nil {
		reqQP.Set("maxFrameLength", strconv.FormatInt(int64(*options.MaxFrameLength), 10))
	}
	if options != nil && options.SasURL != nil {
		reqQP.Set("sasUrl", *options.SasURL)
	}
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// startWebSiteNetworkTraceSlotHandleResponse handles the StartWebSiteNetworkTraceSlot response.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotHandleResponse(resp *http.Response) (WebAppsStartWebSiteNetworkTraceSlotResponse, error) {
	result := WebAppsStartWebSiteNetworkTraceSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return WebAppsStartWebSiteNetworkTraceSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// startWebSiteNetworkTraceSlotHandleError handles the StartWebSiteNetworkTraceSlot error response.
func (client *WebAppsClient) startWebSiteNetworkTraceSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Stop - Description for Stops an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Stop(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopOptions) (WebAppsStopResponse, error) {
	req, err := client.stopCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStopResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStopResponse{}, client.stopHandleError(resp)
	}
	return WebAppsStopResponse{RawResponse: resp}, nil
}

// stopCreateRequest creates the Stop request.
func (client *WebAppsClient) stopCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopHandleError handles the Stop error response.
func (client *WebAppsClient) stopHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StopContinuousWebJob - Description for Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopContinuousWebJob(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStopContinuousWebJobOptions) (WebAppsStopContinuousWebJobResponse, error) {
	req, err := client.stopContinuousWebJobCreateRequest(ctx, resourceGroupName, name, webJobName, options)
	if err != nil {
		return WebAppsStopContinuousWebJobResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopContinuousWebJobResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStopContinuousWebJobResponse{}, client.stopContinuousWebJobHandleError(resp)
	}
	return WebAppsStopContinuousWebJobResponse{RawResponse: resp}, nil
}

// stopContinuousWebJobCreateRequest creates the StopContinuousWebJob request.
func (client *WebAppsClient) stopContinuousWebJobCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, options *WebAppsStopContinuousWebJobOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopContinuousWebJobHandleError handles the StopContinuousWebJob error response.
func (client *WebAppsClient) stopContinuousWebJobHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// StopContinuousWebJobSlot - Description for Stop a continuous web job for an app, or a deployment slot.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopContinuousWebJobSlot(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStopContinuousWebJobSlotOptions) (WebAppsStopContinuousWebJobSlotResponse, error) {
	req, err := client.stopContinuousWebJobSlotCreateRequest(ctx, resourceGroupName, name, webJobName, slot, options)
	if err != nil {
		return WebAppsStopContinuousWebJobSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopContinuousWebJobSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStopContinuousWebJobSlotResponse{}, client.stopContinuousWebJobSlotHandleError(resp)
	}
	return WebAppsStopContinuousWebJobSlotResponse{RawResponse: resp}, nil
}

// stopContinuousWebJobSlotCreateRequest creates the StopContinuousWebJobSlot request.
func (client *WebAppsClient) stopContinuousWebJobSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, webJobName string, slot string, options *WebAppsStopContinuousWebJobSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/continuouswebjobs/{webJobName}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if webJobName == "" {
		return nil, errors.New("parameter webJobName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{webJobName}", url.PathEscape(webJobName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopContinuousWebJobSlotHandleError handles the StopContinuousWebJobSlot error response.
func (client *WebAppsClient) stopContinuousWebJobSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	switch resp.StatusCode {
	case http.StatusNotFound:
		if len(body) == 0 {
			return runtime.NewResponseError(errors.New(resp.Status), resp)
		}
		return runtime.NewResponseError(errors.New(string(body)), resp)
	default:
		errType := DefaultErrorResponse{raw: string(body)}
		if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
			return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
		}
		return runtime.NewResponseError(&errType, resp)
	}
}

// StopNetworkTrace - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopNetworkTraceOptions) (WebAppsStopNetworkTraceResponse, error) {
	req, err := client.stopNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStopNetworkTraceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsStopNetworkTraceResponse{}, client.stopNetworkTraceHandleError(resp)
	}
	return WebAppsStopNetworkTraceResponse{RawResponse: resp}, nil
}

// stopNetworkTraceCreateRequest creates the StopNetworkTrace request.
func (client *WebAppsClient) stopNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopNetworkTraceHandleError handles the StopNetworkTrace error response.
func (client *WebAppsClient) stopNetworkTraceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StopNetworkTraceSlot - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopNetworkTraceSlotOptions) (WebAppsStopNetworkTraceSlotResponse, error) {
	req, err := client.stopNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStopNetworkTraceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsStopNetworkTraceSlotResponse{}, client.stopNetworkTraceSlotHandleError(resp)
	}
	return WebAppsStopNetworkTraceSlotResponse{RawResponse: resp}, nil
}

// stopNetworkTraceSlotCreateRequest creates the StopNetworkTraceSlot request.
func (client *WebAppsClient) stopNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stopNetworkTrace"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopNetworkTraceSlotHandleError handles the StopNetworkTraceSlot error response.
func (client *WebAppsClient) stopNetworkTraceSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StopSlot - Description for Stops an app (or deployment slot, if specified).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopSlotOptions) (WebAppsStopSlotResponse, error) {
	req, err := client.stopSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStopSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsStopSlotResponse{}, client.stopSlotHandleError(resp)
	}
	return WebAppsStopSlotResponse{RawResponse: resp}, nil
}

// stopSlotCreateRequest creates the StopSlot request.
func (client *WebAppsClient) stopSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopSlotHandleError handles the StopSlot error response.
func (client *WebAppsClient) stopSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StopWebSiteNetworkTrace - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopWebSiteNetworkTrace(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopWebSiteNetworkTraceOptions) (WebAppsStopWebSiteNetworkTraceResponse, error) {
	req, err := client.stopWebSiteNetworkTraceCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsStopWebSiteNetworkTraceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopWebSiteNetworkTraceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsStopWebSiteNetworkTraceResponse{}, client.stopWebSiteNetworkTraceHandleError(resp)
	}
	return WebAppsStopWebSiteNetworkTraceResponse{RawResponse: resp}, nil
}

// stopWebSiteNetworkTraceCreateRequest creates the StopWebSiteNetworkTrace request.
func (client *WebAppsClient) stopWebSiteNetworkTraceCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsStopWebSiteNetworkTraceOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopWebSiteNetworkTraceHandleError handles the StopWebSiteNetworkTrace error response.
func (client *WebAppsClient) stopWebSiteNetworkTraceHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// StopWebSiteNetworkTraceSlot - Description for Stop ongoing capturing network packets for the site.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) StopWebSiteNetworkTraceSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopWebSiteNetworkTraceSlotOptions) (WebAppsStopWebSiteNetworkTraceSlotResponse, error) {
	req, err := client.stopWebSiteNetworkTraceSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsStopWebSiteNetworkTraceSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsStopWebSiteNetworkTraceSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return WebAppsStopWebSiteNetworkTraceSlotResponse{}, client.stopWebSiteNetworkTraceSlotHandleError(resp)
	}
	return WebAppsStopWebSiteNetworkTraceSlotResponse{RawResponse: resp}, nil
}

// stopWebSiteNetworkTraceSlotCreateRequest creates the StopWebSiteNetworkTraceSlot request.
func (client *WebAppsClient) stopWebSiteNetworkTraceSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsStopWebSiteNetworkTraceSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkTrace/stop"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// stopWebSiteNetworkTraceSlotHandleError handles the StopWebSiteNetworkTraceSlot error response.
func (client *WebAppsClient) stopWebSiteNetworkTraceSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginSwapSlot - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginSwapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotOptions) (WebAppsSwapSlotPollerResponse, error) {
	resp, err := client.swapSlot(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return WebAppsSwapSlotPollerResponse{}, err
	}
	result := WebAppsSwapSlotPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.SwapSlot", "", resp, client.pl, client.swapSlotHandleError)
	if err != nil {
		return WebAppsSwapSlotPollerResponse{}, err
	}
	result.Poller = &WebAppsSwapSlotPoller{
		pt: pt,
	}
	return result, nil
}

// SwapSlot - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) swapSlot(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotOptions) (*http.Response, error) {
	req, err := client.swapSlotCreateRequest(ctx, resourceGroupName, name, slot, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.swapSlotHandleError(resp)
	}
	return resp, nil
}

// swapSlotCreateRequest creates the SwapSlot request.
func (client *WebAppsClient) swapSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// swapSlotHandleError handles the SwapSlot error response.
func (client *WebAppsClient) swapSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// BeginSwapSlotWithProduction - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) BeginSwapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotWithProductionOptions) (WebAppsSwapSlotWithProductionPollerResponse, error) {
	resp, err := client.swapSlotWithProduction(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return WebAppsSwapSlotWithProductionPollerResponse{}, err
	}
	result := WebAppsSwapSlotWithProductionPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("WebAppsClient.SwapSlotWithProduction", "", resp, client.pl, client.swapSlotWithProductionHandleError)
	if err != nil {
		return WebAppsSwapSlotWithProductionPollerResponse{}, err
	}
	result.Poller = &WebAppsSwapSlotWithProductionPoller{
		pt: pt,
	}
	return result, nil
}

// SwapSlotWithProduction - Description for Swaps two deployment slots of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) swapSlotWithProduction(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotWithProductionOptions) (*http.Response, error) {
	req, err := client.swapSlotWithProductionCreateRequest(ctx, resourceGroupName, name, slotSwapEntity, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, client.swapSlotWithProductionHandleError(resp)
	}
	return resp, nil
}

// swapSlotWithProductionCreateRequest creates the SwapSlotWithProduction request.
func (client *WebAppsClient) swapSlotWithProductionCreateRequest(ctx context.Context, resourceGroupName string, name string, slotSwapEntity CsmSlotEntity, options *WebAppsBeginSwapSlotWithProductionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slotsswap"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotSwapEntity)
}

// swapSlotWithProductionHandleError handles the SwapSlotWithProduction error response.
func (client *WebAppsClient) swapSlotWithProductionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SyncFunctionTriggers - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctionTriggers(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionTriggersOptions) (WebAppsSyncFunctionTriggersResponse, error) {
	req, err := client.syncFunctionTriggersCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsSyncFunctionTriggersResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsSyncFunctionTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsSyncFunctionTriggersResponse{}, client.syncFunctionTriggersHandleError(resp)
	}
	return WebAppsSyncFunctionTriggersResponse{RawResponse: resp}, nil
}

// syncFunctionTriggersCreateRequest creates the SyncFunctionTriggers request.
func (client *WebAppsClient) syncFunctionTriggersCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionTriggersOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionTriggersHandleError handles the SyncFunctionTriggers error response.
func (client *WebAppsClient) syncFunctionTriggersHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SyncFunctionTriggersSlot - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctionTriggersSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionTriggersSlotOptions) (WebAppsSyncFunctionTriggersSlotResponse, error) {
	req, err := client.syncFunctionTriggersSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsSyncFunctionTriggersSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsSyncFunctionTriggersSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsSyncFunctionTriggersSlotResponse{}, client.syncFunctionTriggersSlotHandleError(resp)
	}
	return WebAppsSyncFunctionTriggersSlotResponse{RawResponse: resp}, nil
}

// syncFunctionTriggersSlotCreateRequest creates the SyncFunctionTriggersSlot request.
func (client *WebAppsClient) syncFunctionTriggersSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionTriggersSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/syncfunctiontriggers"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionTriggersSlotHandleError handles the SyncFunctionTriggersSlot error response.
func (client *WebAppsClient) syncFunctionTriggersSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SyncFunctions - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctions(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionsOptions) (WebAppsSyncFunctionsResponse, error) {
	req, err := client.syncFunctionsCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsSyncFunctionsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsSyncFunctionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsSyncFunctionsResponse{}, client.syncFunctionsHandleError(resp)
	}
	return WebAppsSyncFunctionsResponse{RawResponse: resp}, nil
}

// syncFunctionsCreateRequest creates the SyncFunctions request.
func (client *WebAppsClient) syncFunctionsCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncFunctionsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionsHandleError handles the SyncFunctions error response.
func (client *WebAppsClient) syncFunctionsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SyncFunctionsSlot - Description for Syncs function trigger metadata to the management database
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncFunctionsSlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionsSlotOptions) (WebAppsSyncFunctionsSlotResponse, error) {
	req, err := client.syncFunctionsSlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsSyncFunctionsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsSyncFunctionsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return WebAppsSyncFunctionsSlotResponse{}, client.syncFunctionsSlotHandleError(resp)
	}
	return WebAppsSyncFunctionsSlotResponse{RawResponse: resp}, nil
}

// syncFunctionsSlotCreateRequest creates the SyncFunctionsSlot request.
func (client *WebAppsClient) syncFunctionsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncFunctionsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/host/default/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// syncFunctionsSlotHandleError handles the SyncFunctionsSlot error response.
func (client *WebAppsClient) syncFunctionsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SyncRepository - Description for Sync web app repository.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncRepository(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncRepositoryOptions) (WebAppsSyncRepositoryResponse, error) {
	req, err := client.syncRepositoryCreateRequest(ctx, resourceGroupName, name, options)
	if err != nil {
		return WebAppsSyncRepositoryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsSyncRepositoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsSyncRepositoryResponse{}, client.syncRepositoryHandleError(resp)
	}
	return WebAppsSyncRepositoryResponse{RawResponse: resp}, nil
}

// syncRepositoryCreateRequest creates the SyncRepository request.
func (client *WebAppsClient) syncRepositoryCreateRequest(ctx context.Context, resourceGroupName string, name string, options *WebAppsSyncRepositoryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// syncRepositoryHandleError handles the SyncRepository error response.
func (client *WebAppsClient) syncRepositoryHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// SyncRepositorySlot - Description for Sync web app repository.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) SyncRepositorySlot(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncRepositorySlotOptions) (WebAppsSyncRepositorySlotResponse, error) {
	req, err := client.syncRepositorySlotCreateRequest(ctx, resourceGroupName, name, slot, options)
	if err != nil {
		return WebAppsSyncRepositorySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsSyncRepositorySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsSyncRepositorySlotResponse{}, client.syncRepositorySlotHandleError(resp)
	}
	return WebAppsSyncRepositorySlotResponse{RawResponse: resp}, nil
}

// syncRepositorySlotCreateRequest creates the SyncRepositorySlot request.
func (client *WebAppsClient) syncRepositorySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, options *WebAppsSyncRepositorySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sync"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// syncRepositorySlotHandleError handles the SyncRepositorySlot error response.
func (client *WebAppsClient) syncRepositorySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// Update - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) Update(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *WebAppsUpdateOptions) (WebAppsUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, name, siteEnvelope, options)
	if err != nil {
		return WebAppsUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsUpdateResponse{}, client.updateHandleError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *WebAppsClient) updateCreateRequest(ctx context.Context, resourceGroupName string, name string, siteEnvelope SitePatchResource, options *WebAppsUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// updateHandleResponse handles the Update response.
func (client *WebAppsClient) updateHandleResponse(resp *http.Response) (WebAppsUpdateResponse, error) {
	result := WebAppsUpdateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsUpdateResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateHandleError handles the Update error response.
func (client *WebAppsClient) updateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateApplicationSettings - Description for Replaces the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateApplicationSettings(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsOptions) (WebAppsUpdateApplicationSettingsResponse, error) {
	req, err := client.updateApplicationSettingsCreateRequest(ctx, resourceGroupName, name, appSettings, options)
	if err != nil {
		return WebAppsUpdateApplicationSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateApplicationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateApplicationSettingsResponse{}, client.updateApplicationSettingsHandleError(resp)
	}
	return client.updateApplicationSettingsHandleResponse(resp)
}

// updateApplicationSettingsCreateRequest creates the UpdateApplicationSettings request.
func (client *WebAppsClient) updateApplicationSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// updateApplicationSettingsHandleResponse handles the UpdateApplicationSettings response.
func (client *WebAppsClient) updateApplicationSettingsHandleResponse(resp *http.Response) (WebAppsUpdateApplicationSettingsResponse, error) {
	result := WebAppsUpdateApplicationSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsUpdateApplicationSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateApplicationSettingsHandleError handles the UpdateApplicationSettings error response.
func (client *WebAppsClient) updateApplicationSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateApplicationSettingsSlot - Description for Replaces the application settings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateApplicationSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsSlotOptions) (WebAppsUpdateApplicationSettingsSlotResponse, error) {
	req, err := client.updateApplicationSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, appSettings, options)
	if err != nil {
		return WebAppsUpdateApplicationSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateApplicationSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateApplicationSettingsSlotResponse{}, client.updateApplicationSettingsSlotHandleError(resp)
	}
	return client.updateApplicationSettingsSlotHandleResponse(resp)
}

// updateApplicationSettingsSlotCreateRequest creates the UpdateApplicationSettingsSlot request.
func (client *WebAppsClient) updateApplicationSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, appSettings StringDictionary, options *WebAppsUpdateApplicationSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/appsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, appSettings)
}

// updateApplicationSettingsSlotHandleResponse handles the UpdateApplicationSettingsSlot response.
func (client *WebAppsClient) updateApplicationSettingsSlotHandleResponse(resp *http.Response) (WebAppsUpdateApplicationSettingsSlotResponse, error) {
	result := WebAppsUpdateApplicationSettingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsUpdateApplicationSettingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateApplicationSettingsSlotHandleError handles the UpdateApplicationSettingsSlot error response.
func (client *WebAppsClient) updateApplicationSettingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAuthSettings - Description for Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettings(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsOptions) (WebAppsUpdateAuthSettingsResponse, error) {
	req, err := client.updateAuthSettingsCreateRequest(ctx, resourceGroupName, name, siteAuthSettings, options)
	if err != nil {
		return WebAppsUpdateAuthSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateAuthSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateAuthSettingsResponse{}, client.updateAuthSettingsHandleError(resp)
	}
	return client.updateAuthSettingsHandleResponse(resp)
}

// updateAuthSettingsCreateRequest creates the UpdateAuthSettings request.
func (client *WebAppsClient) updateAuthSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteAuthSettings)
}

// updateAuthSettingsHandleResponse handles the UpdateAuthSettings response.
func (client *WebAppsClient) updateAuthSettingsHandleResponse(resp *http.Response) (WebAppsUpdateAuthSettingsResponse, error) {
	result := WebAppsUpdateAuthSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsUpdateAuthSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAuthSettingsHandleError handles the UpdateAuthSettings error response.
func (client *WebAppsClient) updateAuthSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAuthSettingsSlot - Description for Updates the Authentication / Authorization settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsSlotOptions) (WebAppsUpdateAuthSettingsSlotResponse, error) {
	req, err := client.updateAuthSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettings, options)
	if err != nil {
		return WebAppsUpdateAuthSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateAuthSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateAuthSettingsSlotResponse{}, client.updateAuthSettingsSlotHandleError(resp)
	}
	return client.updateAuthSettingsSlotHandleResponse(resp)
}

// updateAuthSettingsSlotCreateRequest creates the UpdateAuthSettingsSlot request.
func (client *WebAppsClient) updateAuthSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettings SiteAuthSettings, options *WebAppsUpdateAuthSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteAuthSettings)
}

// updateAuthSettingsSlotHandleResponse handles the UpdateAuthSettingsSlot response.
func (client *WebAppsClient) updateAuthSettingsSlotHandleResponse(resp *http.Response) (WebAppsUpdateAuthSettingsSlotResponse, error) {
	result := WebAppsUpdateAuthSettingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettings); err != nil {
		return WebAppsUpdateAuthSettingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAuthSettingsSlotHandleError handles the UpdateAuthSettingsSlot error response.
func (client *WebAppsClient) updateAuthSettingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAuthSettingsV2 - Description for Updates site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettingsV2(ctx context.Context, resourceGroupName string, name string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2Options) (WebAppsUpdateAuthSettingsV2Response, error) {
	req, err := client.updateAuthSettingsV2CreateRequest(ctx, resourceGroupName, name, siteAuthSettingsV2, options)
	if err != nil {
		return WebAppsUpdateAuthSettingsV2Response{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateAuthSettingsV2Response{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateAuthSettingsV2Response{}, client.updateAuthSettingsV2HandleError(resp)
	}
	return client.updateAuthSettingsV2HandleResponse(resp)
}

// updateAuthSettingsV2CreateRequest creates the UpdateAuthSettingsV2 request.
func (client *WebAppsClient) updateAuthSettingsV2CreateRequest(ctx context.Context, resourceGroupName string, name string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2Options) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteAuthSettingsV2)
}

// updateAuthSettingsV2HandleResponse handles the UpdateAuthSettingsV2 response.
func (client *WebAppsClient) updateAuthSettingsV2HandleResponse(resp *http.Response) (WebAppsUpdateAuthSettingsV2Response, error) {
	result := WebAppsUpdateAuthSettingsV2Response{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsUpdateAuthSettingsV2Response{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAuthSettingsV2HandleError handles the UpdateAuthSettingsV2 error response.
func (client *WebAppsClient) updateAuthSettingsV2HandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAuthSettingsV2Slot - Description for Updates site's Authentication / Authorization settings for apps via the V2 format
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAuthSettingsV2Slot(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2SlotOptions) (WebAppsUpdateAuthSettingsV2SlotResponse, error) {
	req, err := client.updateAuthSettingsV2SlotCreateRequest(ctx, resourceGroupName, name, slot, siteAuthSettingsV2, options)
	if err != nil {
		return WebAppsUpdateAuthSettingsV2SlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateAuthSettingsV2SlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateAuthSettingsV2SlotResponse{}, client.updateAuthSettingsV2SlotHandleError(resp)
	}
	return client.updateAuthSettingsV2SlotHandleResponse(resp)
}

// updateAuthSettingsV2SlotCreateRequest creates the UpdateAuthSettingsV2Slot request.
func (client *WebAppsClient) updateAuthSettingsV2SlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteAuthSettingsV2 SiteAuthSettingsV2, options *WebAppsUpdateAuthSettingsV2SlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/authsettingsV2"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteAuthSettingsV2)
}

// updateAuthSettingsV2SlotHandleResponse handles the UpdateAuthSettingsV2Slot response.
func (client *WebAppsClient) updateAuthSettingsV2SlotHandleResponse(resp *http.Response) (WebAppsUpdateAuthSettingsV2SlotResponse, error) {
	result := WebAppsUpdateAuthSettingsV2SlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteAuthSettingsV2); err != nil {
		return WebAppsUpdateAuthSettingsV2SlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAuthSettingsV2SlotHandleError handles the UpdateAuthSettingsV2Slot error response.
func (client *WebAppsClient) updateAuthSettingsV2SlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAzureStorageAccounts - Description for Updates the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAzureStorageAccounts(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsOptions) (WebAppsUpdateAzureStorageAccountsResponse, error) {
	req, err := client.updateAzureStorageAccountsCreateRequest(ctx, resourceGroupName, name, azureStorageAccounts, options)
	if err != nil {
		return WebAppsUpdateAzureStorageAccountsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateAzureStorageAccountsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateAzureStorageAccountsResponse{}, client.updateAzureStorageAccountsHandleError(resp)
	}
	return client.updateAzureStorageAccountsHandleResponse(resp)
}

// updateAzureStorageAccountsCreateRequest creates the UpdateAzureStorageAccounts request.
func (client *WebAppsClient) updateAzureStorageAccountsCreateRequest(ctx context.Context, resourceGroupName string, name string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, azureStorageAccounts)
}

// updateAzureStorageAccountsHandleResponse handles the UpdateAzureStorageAccounts response.
func (client *WebAppsClient) updateAzureStorageAccountsHandleResponse(resp *http.Response) (WebAppsUpdateAzureStorageAccountsResponse, error) {
	result := WebAppsUpdateAzureStorageAccountsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsUpdateAzureStorageAccountsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAzureStorageAccountsHandleError handles the UpdateAzureStorageAccounts error response.
func (client *WebAppsClient) updateAzureStorageAccountsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateAzureStorageAccountsSlot - Description for Updates the Azure storage account configurations of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateAzureStorageAccountsSlot(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsSlotOptions) (WebAppsUpdateAzureStorageAccountsSlotResponse, error) {
	req, err := client.updateAzureStorageAccountsSlotCreateRequest(ctx, resourceGroupName, name, slot, azureStorageAccounts, options)
	if err != nil {
		return WebAppsUpdateAzureStorageAccountsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateAzureStorageAccountsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateAzureStorageAccountsSlotResponse{}, client.updateAzureStorageAccountsSlotHandleError(resp)
	}
	return client.updateAzureStorageAccountsSlotHandleResponse(resp)
}

// updateAzureStorageAccountsSlotCreateRequest creates the UpdateAzureStorageAccountsSlot request.
func (client *WebAppsClient) updateAzureStorageAccountsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, azureStorageAccounts AzureStoragePropertyDictionaryResource, options *WebAppsUpdateAzureStorageAccountsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/azurestorageaccounts"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, azureStorageAccounts)
}

// updateAzureStorageAccountsSlotHandleResponse handles the UpdateAzureStorageAccountsSlot response.
func (client *WebAppsClient) updateAzureStorageAccountsSlotHandleResponse(resp *http.Response) (WebAppsUpdateAzureStorageAccountsSlotResponse, error) {
	result := WebAppsUpdateAzureStorageAccountsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.AzureStoragePropertyDictionaryResource); err != nil {
		return WebAppsUpdateAzureStorageAccountsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateAzureStorageAccountsSlotHandleError handles the UpdateAzureStorageAccountsSlot error response.
func (client *WebAppsClient) updateAzureStorageAccountsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateBackupConfiguration - Description for Updates the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateBackupConfiguration(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsUpdateBackupConfigurationOptions) (WebAppsUpdateBackupConfigurationResponse, error) {
	req, err := client.updateBackupConfigurationCreateRequest(ctx, resourceGroupName, name, request, options)
	if err != nil {
		return WebAppsUpdateBackupConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateBackupConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateBackupConfigurationResponse{}, client.updateBackupConfigurationHandleError(resp)
	}
	return client.updateBackupConfigurationHandleResponse(resp)
}

// updateBackupConfigurationCreateRequest creates the UpdateBackupConfiguration request.
func (client *WebAppsClient) updateBackupConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, request BackupRequest, options *WebAppsUpdateBackupConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// updateBackupConfigurationHandleResponse handles the UpdateBackupConfiguration response.
func (client *WebAppsClient) updateBackupConfigurationHandleResponse(resp *http.Response) (WebAppsUpdateBackupConfigurationResponse, error) {
	result := WebAppsUpdateBackupConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsUpdateBackupConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateBackupConfigurationHandleError handles the UpdateBackupConfiguration error response.
func (client *WebAppsClient) updateBackupConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateBackupConfigurationSlot - Description for Updates the backup configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateBackupConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsUpdateBackupConfigurationSlotOptions) (WebAppsUpdateBackupConfigurationSlotResponse, error) {
	req, err := client.updateBackupConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, request, options)
	if err != nil {
		return WebAppsUpdateBackupConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateBackupConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateBackupConfigurationSlotResponse{}, client.updateBackupConfigurationSlotHandleError(resp)
	}
	return client.updateBackupConfigurationSlotHandleResponse(resp)
}

// updateBackupConfigurationSlotCreateRequest creates the UpdateBackupConfigurationSlot request.
func (client *WebAppsClient) updateBackupConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, request BackupRequest, options *WebAppsUpdateBackupConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/backup"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, request)
}

// updateBackupConfigurationSlotHandleResponse handles the UpdateBackupConfigurationSlot response.
func (client *WebAppsClient) updateBackupConfigurationSlotHandleResponse(resp *http.Response) (WebAppsUpdateBackupConfigurationSlotResponse, error) {
	result := WebAppsUpdateBackupConfigurationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.BackupRequest); err != nil {
		return WebAppsUpdateBackupConfigurationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateBackupConfigurationSlotHandleError handles the UpdateBackupConfigurationSlot error response.
func (client *WebAppsClient) updateBackupConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateConfiguration - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConfiguration(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationOptions) (WebAppsUpdateConfigurationResponse, error) {
	req, err := client.updateConfigurationCreateRequest(ctx, resourceGroupName, name, siteConfig, options)
	if err != nil {
		return WebAppsUpdateConfigurationResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateConfigurationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateConfigurationResponse{}, client.updateConfigurationHandleError(resp)
	}
	return client.updateConfigurationHandleResponse(resp)
}

// updateConfigurationCreateRequest creates the UpdateConfiguration request.
func (client *WebAppsClient) updateConfigurationCreateRequest(ctx context.Context, resourceGroupName string, name string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// updateConfigurationHandleResponse handles the UpdateConfiguration response.
func (client *WebAppsClient) updateConfigurationHandleResponse(resp *http.Response) (WebAppsUpdateConfigurationResponse, error) {
	result := WebAppsUpdateConfigurationResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsUpdateConfigurationResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateConfigurationHandleError handles the UpdateConfiguration error response.
func (client *WebAppsClient) updateConfigurationHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateConfigurationSlot - Description for Updates the configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConfigurationSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationSlotOptions) (WebAppsUpdateConfigurationSlotResponse, error) {
	req, err := client.updateConfigurationSlotCreateRequest(ctx, resourceGroupName, name, slot, siteConfig, options)
	if err != nil {
		return WebAppsUpdateConfigurationSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateConfigurationSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateConfigurationSlotResponse{}, client.updateConfigurationSlotHandleError(resp)
	}
	return client.updateConfigurationSlotHandleResponse(resp)
}

// updateConfigurationSlotCreateRequest creates the UpdateConfigurationSlot request.
func (client *WebAppsClient) updateConfigurationSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteConfig SiteConfigResource, options *WebAppsUpdateConfigurationSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteConfig)
}

// updateConfigurationSlotHandleResponse handles the UpdateConfigurationSlot response.
func (client *WebAppsClient) updateConfigurationSlotHandleResponse(resp *http.Response) (WebAppsUpdateConfigurationSlotResponse, error) {
	result := WebAppsUpdateConfigurationSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteConfigResource); err != nil {
		return WebAppsUpdateConfigurationSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateConfigurationSlotHandleError handles the UpdateConfigurationSlot error response.
func (client *WebAppsClient) updateConfigurationSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateConnectionStrings - Description for Replaces the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConnectionStrings(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsOptions) (WebAppsUpdateConnectionStringsResponse, error) {
	req, err := client.updateConnectionStringsCreateRequest(ctx, resourceGroupName, name, connectionStrings, options)
	if err != nil {
		return WebAppsUpdateConnectionStringsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateConnectionStringsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateConnectionStringsResponse{}, client.updateConnectionStringsHandleError(resp)
	}
	return client.updateConnectionStringsHandleResponse(resp)
}

// updateConnectionStringsCreateRequest creates the UpdateConnectionStrings request.
func (client *WebAppsClient) updateConnectionStringsCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionStrings)
}

// updateConnectionStringsHandleResponse handles the UpdateConnectionStrings response.
func (client *WebAppsClient) updateConnectionStringsHandleResponse(resp *http.Response) (WebAppsUpdateConnectionStringsResponse, error) {
	result := WebAppsUpdateConnectionStringsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsUpdateConnectionStringsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateConnectionStringsHandleError handles the UpdateConnectionStrings error response.
func (client *WebAppsClient) updateConnectionStringsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateConnectionStringsSlot - Description for Replaces the connection strings of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateConnectionStringsSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsSlotOptions) (WebAppsUpdateConnectionStringsSlotResponse, error) {
	req, err := client.updateConnectionStringsSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionStrings, options)
	if err != nil {
		return WebAppsUpdateConnectionStringsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateConnectionStringsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateConnectionStringsSlotResponse{}, client.updateConnectionStringsSlotHandleError(resp)
	}
	return client.updateConnectionStringsSlotHandleResponse(resp)
}

// updateConnectionStringsSlotCreateRequest creates the UpdateConnectionStringsSlot request.
func (client *WebAppsClient) updateConnectionStringsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionStrings ConnectionStringDictionary, options *WebAppsUpdateConnectionStringsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/connectionstrings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionStrings)
}

// updateConnectionStringsSlotHandleResponse handles the UpdateConnectionStringsSlot response.
func (client *WebAppsClient) updateConnectionStringsSlotHandleResponse(resp *http.Response) (WebAppsUpdateConnectionStringsSlotResponse, error) {
	result := WebAppsUpdateConnectionStringsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ConnectionStringDictionary); err != nil {
		return WebAppsUpdateConnectionStringsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateConnectionStringsSlotHandleError handles the UpdateConnectionStringsSlot error response.
func (client *WebAppsClient) updateConnectionStringsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateDiagnosticLogsConfig - Description for Updates the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDiagnosticLogsConfig(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigOptions) (WebAppsUpdateDiagnosticLogsConfigResponse, error) {
	req, err := client.updateDiagnosticLogsConfigCreateRequest(ctx, resourceGroupName, name, siteLogsConfig, options)
	if err != nil {
		return WebAppsUpdateDiagnosticLogsConfigResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateDiagnosticLogsConfigResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateDiagnosticLogsConfigResponse{}, client.updateDiagnosticLogsConfigHandleError(resp)
	}
	return client.updateDiagnosticLogsConfigHandleResponse(resp)
}

// updateDiagnosticLogsConfigCreateRequest creates the UpdateDiagnosticLogsConfig request.
func (client *WebAppsClient) updateDiagnosticLogsConfigCreateRequest(ctx context.Context, resourceGroupName string, name string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteLogsConfig)
}

// updateDiagnosticLogsConfigHandleResponse handles the UpdateDiagnosticLogsConfig response.
func (client *WebAppsClient) updateDiagnosticLogsConfigHandleResponse(resp *http.Response) (WebAppsUpdateDiagnosticLogsConfigResponse, error) {
	result := WebAppsUpdateDiagnosticLogsConfigResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsUpdateDiagnosticLogsConfigResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateDiagnosticLogsConfigHandleError handles the UpdateDiagnosticLogsConfig error response.
func (client *WebAppsClient) updateDiagnosticLogsConfigHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateDiagnosticLogsConfigSlot - Description for Updates the logging configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDiagnosticLogsConfigSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigSlotOptions) (WebAppsUpdateDiagnosticLogsConfigSlotResponse, error) {
	req, err := client.updateDiagnosticLogsConfigSlotCreateRequest(ctx, resourceGroupName, name, slot, siteLogsConfig, options)
	if err != nil {
		return WebAppsUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateDiagnosticLogsConfigSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateDiagnosticLogsConfigSlotResponse{}, client.updateDiagnosticLogsConfigSlotHandleError(resp)
	}
	return client.updateDiagnosticLogsConfigSlotHandleResponse(resp)
}

// updateDiagnosticLogsConfigSlotCreateRequest creates the UpdateDiagnosticLogsConfigSlot request.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteLogsConfig SiteLogsConfig, options *WebAppsUpdateDiagnosticLogsConfigSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/logs"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteLogsConfig)
}

// updateDiagnosticLogsConfigSlotHandleResponse handles the UpdateDiagnosticLogsConfigSlot response.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotHandleResponse(resp *http.Response) (WebAppsUpdateDiagnosticLogsConfigSlotResponse, error) {
	result := WebAppsUpdateDiagnosticLogsConfigSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteLogsConfig); err != nil {
		return WebAppsUpdateDiagnosticLogsConfigSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateDiagnosticLogsConfigSlotHandleError handles the UpdateDiagnosticLogsConfigSlot error response.
func (client *WebAppsClient) updateDiagnosticLogsConfigSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateDomainOwnershipIdentifier - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDomainOwnershipIdentifier(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierOptions) (WebAppsUpdateDomainOwnershipIdentifierResponse, error) {
	req, err := client.updateDomainOwnershipIdentifierCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsUpdateDomainOwnershipIdentifierResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateDomainOwnershipIdentifierResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateDomainOwnershipIdentifierResponse{}, client.updateDomainOwnershipIdentifierHandleError(resp)
	}
	return client.updateDomainOwnershipIdentifierHandleResponse(resp)
}

// updateDomainOwnershipIdentifierCreateRequest creates the UpdateDomainOwnershipIdentifier request.
func (client *WebAppsClient) updateDomainOwnershipIdentifierCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// updateDomainOwnershipIdentifierHandleResponse handles the UpdateDomainOwnershipIdentifier response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierHandleResponse(resp *http.Response) (WebAppsUpdateDomainOwnershipIdentifierResponse, error) {
	result := WebAppsUpdateDomainOwnershipIdentifierResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsUpdateDomainOwnershipIdentifierResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateDomainOwnershipIdentifierHandleError handles the UpdateDomainOwnershipIdentifier error response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateDomainOwnershipIdentifierSlot - Description for Creates a domain ownership identifier for web app, or updates an existing ownership identifier.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateDomainOwnershipIdentifierSlot(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierSlotOptions) (WebAppsUpdateDomainOwnershipIdentifierSlotResponse, error) {
	req, err := client.updateDomainOwnershipIdentifierSlotCreateRequest(ctx, resourceGroupName, name, domainOwnershipIdentifierName, slot, domainOwnershipIdentifier, options)
	if err != nil {
		return WebAppsUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateDomainOwnershipIdentifierSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateDomainOwnershipIdentifierSlotResponse{}, client.updateDomainOwnershipIdentifierSlotHandleError(resp)
	}
	return client.updateDomainOwnershipIdentifierSlotHandleResponse(resp)
}

// updateDomainOwnershipIdentifierSlotCreateRequest creates the UpdateDomainOwnershipIdentifierSlot request.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, domainOwnershipIdentifierName string, slot string, domainOwnershipIdentifier Identifier, options *WebAppsUpdateDomainOwnershipIdentifierSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/domainOwnershipIdentifiers/{domainOwnershipIdentifierName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if domainOwnershipIdentifierName == "" {
		return nil, errors.New("parameter domainOwnershipIdentifierName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{domainOwnershipIdentifierName}", url.PathEscape(domainOwnershipIdentifierName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, domainOwnershipIdentifier)
}

// updateDomainOwnershipIdentifierSlotHandleResponse handles the UpdateDomainOwnershipIdentifierSlot response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotHandleResponse(resp *http.Response) (WebAppsUpdateDomainOwnershipIdentifierSlotResponse, error) {
	result := WebAppsUpdateDomainOwnershipIdentifierSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Identifier); err != nil {
		return WebAppsUpdateDomainOwnershipIdentifierSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateDomainOwnershipIdentifierSlotHandleError handles the UpdateDomainOwnershipIdentifierSlot error response.
func (client *WebAppsClient) updateDomainOwnershipIdentifierSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateFtpAllowed - Description for Updates whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateFtpAllowed(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedOptions) (WebAppsUpdateFtpAllowedResponse, error) {
	req, err := client.updateFtpAllowedCreateRequest(ctx, resourceGroupName, name, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsUpdateFtpAllowedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateFtpAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateFtpAllowedResponse{}, client.updateFtpAllowedHandleError(resp)
	}
	return client.updateFtpAllowedHandleResponse(resp)
}

// updateFtpAllowedCreateRequest creates the UpdateFtpAllowed request.
func (client *WebAppsClient) updateFtpAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity)
}

// updateFtpAllowedHandleResponse handles the UpdateFtpAllowed response.
func (client *WebAppsClient) updateFtpAllowedHandleResponse(resp *http.Response) (WebAppsUpdateFtpAllowedResponse, error) {
	result := WebAppsUpdateFtpAllowedResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsUpdateFtpAllowedResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateFtpAllowedHandleError handles the UpdateFtpAllowed error response.
func (client *WebAppsClient) updateFtpAllowedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateFtpAllowedSlot - Description for Updates whether FTP is allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateFtpAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedSlotOptions) (WebAppsUpdateFtpAllowedSlotResponse, error) {
	req, err := client.updateFtpAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsUpdateFtpAllowedSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateFtpAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateFtpAllowedSlotResponse{}, client.updateFtpAllowedSlotHandleError(resp)
	}
	return client.updateFtpAllowedSlotHandleResponse(resp)
}

// updateFtpAllowedSlotCreateRequest creates the UpdateFtpAllowedSlot request.
func (client *WebAppsClient) updateFtpAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateFtpAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/ftp"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity)
}

// updateFtpAllowedSlotHandleResponse handles the UpdateFtpAllowedSlot response.
func (client *WebAppsClient) updateFtpAllowedSlotHandleResponse(resp *http.Response) (WebAppsUpdateFtpAllowedSlotResponse, error) {
	result := WebAppsUpdateFtpAllowedSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsUpdateFtpAllowedSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateFtpAllowedSlotHandleError handles the UpdateFtpAllowedSlot error response.
func (client *WebAppsClient) updateFtpAllowedSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateHybridConnection - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateHybridConnection(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionOptions) (WebAppsUpdateHybridConnectionResponse, error) {
	req, err := client.updateHybridConnectionCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateHybridConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateHybridConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateHybridConnectionResponse{}, client.updateHybridConnectionHandleError(resp)
	}
	return client.updateHybridConnectionHandleResponse(resp)
}

// updateHybridConnectionCreateRequest creates the UpdateHybridConnection request.
func (client *WebAppsClient) updateHybridConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateHybridConnectionHandleResponse handles the UpdateHybridConnection response.
func (client *WebAppsClient) updateHybridConnectionHandleResponse(resp *http.Response) (WebAppsUpdateHybridConnectionResponse, error) {
	result := WebAppsUpdateHybridConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsUpdateHybridConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateHybridConnectionHandleError handles the UpdateHybridConnection error response.
func (client *WebAppsClient) updateHybridConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateHybridConnectionSlot - Description for Creates a new Hybrid Connection using a Service Bus relay.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateHybridConnectionSlot(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionSlotOptions) (WebAppsUpdateHybridConnectionSlotResponse, error) {
	req, err := client.updateHybridConnectionSlotCreateRequest(ctx, resourceGroupName, name, namespaceName, relayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateHybridConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateHybridConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateHybridConnectionSlotResponse{}, client.updateHybridConnectionSlotHandleError(resp)
	}
	return client.updateHybridConnectionSlotHandleResponse(resp)
}

// updateHybridConnectionSlotCreateRequest creates the UpdateHybridConnectionSlot request.
func (client *WebAppsClient) updateHybridConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, namespaceName string, relayName string, slot string, connectionEnvelope HybridConnection, options *WebAppsUpdateHybridConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridConnectionNamespaces/{namespaceName}/relays/{relayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if namespaceName == "" {
		return nil, errors.New("parameter namespaceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{namespaceName}", url.PathEscape(namespaceName))
	if relayName == "" {
		return nil, errors.New("parameter relayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{relayName}", url.PathEscape(relayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateHybridConnectionSlotHandleResponse handles the UpdateHybridConnectionSlot response.
func (client *WebAppsClient) updateHybridConnectionSlotHandleResponse(resp *http.Response) (WebAppsUpdateHybridConnectionSlotResponse, error) {
	result := WebAppsUpdateHybridConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.HybridConnection); err != nil {
		return WebAppsUpdateHybridConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateHybridConnectionSlotHandleError handles the UpdateHybridConnectionSlot error response.
func (client *WebAppsClient) updateHybridConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateMetadata - Description for Replaces the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateMetadata(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *WebAppsUpdateMetadataOptions) (WebAppsUpdateMetadataResponse, error) {
	req, err := client.updateMetadataCreateRequest(ctx, resourceGroupName, name, metadata, options)
	if err != nil {
		return WebAppsUpdateMetadataResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateMetadataResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateMetadataResponse{}, client.updateMetadataHandleError(resp)
	}
	return client.updateMetadataHandleResponse(resp)
}

// updateMetadataCreateRequest creates the UpdateMetadata request.
func (client *WebAppsClient) updateMetadataCreateRequest(ctx context.Context, resourceGroupName string, name string, metadata StringDictionary, options *WebAppsUpdateMetadataOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, metadata)
}

// updateMetadataHandleResponse handles the UpdateMetadata response.
func (client *WebAppsClient) updateMetadataHandleResponse(resp *http.Response) (WebAppsUpdateMetadataResponse, error) {
	result := WebAppsUpdateMetadataResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsUpdateMetadataResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateMetadataHandleError handles the UpdateMetadata error response.
func (client *WebAppsClient) updateMetadataHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateMetadataSlot - Description for Replaces the metadata of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateMetadataSlot(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *WebAppsUpdateMetadataSlotOptions) (WebAppsUpdateMetadataSlotResponse, error) {
	req, err := client.updateMetadataSlotCreateRequest(ctx, resourceGroupName, name, slot, metadata, options)
	if err != nil {
		return WebAppsUpdateMetadataSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateMetadataSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateMetadataSlotResponse{}, client.updateMetadataSlotHandleError(resp)
	}
	return client.updateMetadataSlotHandleResponse(resp)
}

// updateMetadataSlotCreateRequest creates the UpdateMetadataSlot request.
func (client *WebAppsClient) updateMetadataSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, metadata StringDictionary, options *WebAppsUpdateMetadataSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/metadata"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, metadata)
}

// updateMetadataSlotHandleResponse handles the UpdateMetadataSlot response.
func (client *WebAppsClient) updateMetadataSlotHandleResponse(resp *http.Response) (WebAppsUpdateMetadataSlotResponse, error) {
	result := WebAppsUpdateMetadataSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.StringDictionary); err != nil {
		return WebAppsUpdateMetadataSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateMetadataSlotHandleError handles the UpdateMetadataSlot error response.
func (client *WebAppsClient) updateMetadataSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdatePremierAddOn - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdatePremierAddOn(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnOptions) (WebAppsUpdatePremierAddOnResponse, error) {
	req, err := client.updatePremierAddOnCreateRequest(ctx, resourceGroupName, name, premierAddOnName, premierAddOn, options)
	if err != nil {
		return WebAppsUpdatePremierAddOnResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdatePremierAddOnResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdatePremierAddOnResponse{}, client.updatePremierAddOnHandleError(resp)
	}
	return client.updatePremierAddOnHandleResponse(resp)
}

// updatePremierAddOnCreateRequest creates the UpdatePremierAddOn request.
func (client *WebAppsClient) updatePremierAddOnCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// updatePremierAddOnHandleResponse handles the UpdatePremierAddOn response.
func (client *WebAppsClient) updatePremierAddOnHandleResponse(resp *http.Response) (WebAppsUpdatePremierAddOnResponse, error) {
	result := WebAppsUpdatePremierAddOnResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsUpdatePremierAddOnResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updatePremierAddOnHandleError handles the UpdatePremierAddOn error response.
func (client *WebAppsClient) updatePremierAddOnHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdatePremierAddOnSlot - Description for Updates a named add-on of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdatePremierAddOnSlot(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnSlotOptions) (WebAppsUpdatePremierAddOnSlotResponse, error) {
	req, err := client.updatePremierAddOnSlotCreateRequest(ctx, resourceGroupName, name, premierAddOnName, slot, premierAddOn, options)
	if err != nil {
		return WebAppsUpdatePremierAddOnSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdatePremierAddOnSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdatePremierAddOnSlotResponse{}, client.updatePremierAddOnSlotHandleError(resp)
	}
	return client.updatePremierAddOnSlotHandleResponse(resp)
}

// updatePremierAddOnSlotCreateRequest creates the UpdatePremierAddOnSlot request.
func (client *WebAppsClient) updatePremierAddOnSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, premierAddOnName string, slot string, premierAddOn PremierAddOnPatchResource, options *WebAppsUpdatePremierAddOnSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/premieraddons/{premierAddOnName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if premierAddOnName == "" {
		return nil, errors.New("parameter premierAddOnName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{premierAddOnName}", url.PathEscape(premierAddOnName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, premierAddOn)
}

// updatePremierAddOnSlotHandleResponse handles the UpdatePremierAddOnSlot response.
func (client *WebAppsClient) updatePremierAddOnSlotHandleResponse(resp *http.Response) (WebAppsUpdatePremierAddOnSlotResponse, error) {
	result := WebAppsUpdatePremierAddOnSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PremierAddOn); err != nil {
		return WebAppsUpdatePremierAddOnSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updatePremierAddOnSlotHandleError handles the UpdatePremierAddOnSlot error response.
func (client *WebAppsClient) updatePremierAddOnSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateRelayServiceConnection - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateRelayServiceConnection(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionOptions) (WebAppsUpdateRelayServiceConnectionResponse, error) {
	req, err := client.updateRelayServiceConnectionCreateRequest(ctx, resourceGroupName, name, entityName, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateRelayServiceConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateRelayServiceConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateRelayServiceConnectionResponse{}, client.updateRelayServiceConnectionHandleError(resp)
	}
	return client.updateRelayServiceConnectionHandleResponse(resp)
}

// updateRelayServiceConnectionCreateRequest creates the UpdateRelayServiceConnection request.
func (client *WebAppsClient) updateRelayServiceConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateRelayServiceConnectionHandleResponse handles the UpdateRelayServiceConnection response.
func (client *WebAppsClient) updateRelayServiceConnectionHandleResponse(resp *http.Response) (WebAppsUpdateRelayServiceConnectionResponse, error) {
	result := WebAppsUpdateRelayServiceConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsUpdateRelayServiceConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateRelayServiceConnectionHandleError handles the UpdateRelayServiceConnection error response.
func (client *WebAppsClient) updateRelayServiceConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateRelayServiceConnectionSlot - Description for Creates a new hybrid connection configuration (PUT), or updates an existing one (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateRelayServiceConnectionSlot(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionSlotOptions) (WebAppsUpdateRelayServiceConnectionSlotResponse, error) {
	req, err := client.updateRelayServiceConnectionSlotCreateRequest(ctx, resourceGroupName, name, entityName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateRelayServiceConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateRelayServiceConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateRelayServiceConnectionSlotResponse{}, client.updateRelayServiceConnectionSlotHandleError(resp)
	}
	return client.updateRelayServiceConnectionSlotHandleResponse(resp)
}

// updateRelayServiceConnectionSlotCreateRequest creates the UpdateRelayServiceConnectionSlot request.
func (client *WebAppsClient) updateRelayServiceConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, entityName string, slot string, connectionEnvelope RelayServiceConnectionEntity, options *WebAppsUpdateRelayServiceConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/hybridconnection/{entityName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if entityName == "" {
		return nil, errors.New("parameter entityName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{entityName}", url.PathEscape(entityName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateRelayServiceConnectionSlotHandleResponse handles the UpdateRelayServiceConnectionSlot response.
func (client *WebAppsClient) updateRelayServiceConnectionSlotHandleResponse(resp *http.Response) (WebAppsUpdateRelayServiceConnectionSlotResponse, error) {
	result := WebAppsUpdateRelayServiceConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.RelayServiceConnectionEntity); err != nil {
		return WebAppsUpdateRelayServiceConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateRelayServiceConnectionSlotHandleError handles the UpdateRelayServiceConnectionSlot error response.
func (client *WebAppsClient) updateRelayServiceConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateScmAllowed - Description for Updates whether user publishing credentials are allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateScmAllowed(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedOptions) (WebAppsUpdateScmAllowedResponse, error) {
	req, err := client.updateScmAllowedCreateRequest(ctx, resourceGroupName, name, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsUpdateScmAllowedResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateScmAllowedResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateScmAllowedResponse{}, client.updateScmAllowedHandleError(resp)
	}
	return client.updateScmAllowedHandleResponse(resp)
}

// updateScmAllowedCreateRequest creates the UpdateScmAllowed request.
func (client *WebAppsClient) updateScmAllowedCreateRequest(ctx context.Context, resourceGroupName string, name string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity)
}

// updateScmAllowedHandleResponse handles the UpdateScmAllowed response.
func (client *WebAppsClient) updateScmAllowedHandleResponse(resp *http.Response) (WebAppsUpdateScmAllowedResponse, error) {
	result := WebAppsUpdateScmAllowedResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsUpdateScmAllowedResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateScmAllowedHandleError handles the UpdateScmAllowed error response.
func (client *WebAppsClient) updateScmAllowedHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateScmAllowedSlot - Description for Updates whether user publishing credentials are allowed on the site or not.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateScmAllowedSlot(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedSlotOptions) (WebAppsUpdateScmAllowedSlotResponse, error) {
	req, err := client.updateScmAllowedSlotCreateRequest(ctx, resourceGroupName, name, slot, csmPublishingAccessPoliciesEntity, options)
	if err != nil {
		return WebAppsUpdateScmAllowedSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateScmAllowedSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateScmAllowedSlotResponse{}, client.updateScmAllowedSlotHandleError(resp)
	}
	return client.updateScmAllowedSlotHandleResponse(resp)
}

// updateScmAllowedSlotCreateRequest creates the UpdateScmAllowedSlot request.
func (client *WebAppsClient) updateScmAllowedSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, csmPublishingAccessPoliciesEntity CsmPublishingCredentialsPoliciesEntity, options *WebAppsUpdateScmAllowedSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/basicPublishingCredentialsPolicies/scm"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, csmPublishingAccessPoliciesEntity)
}

// updateScmAllowedSlotHandleResponse handles the UpdateScmAllowedSlot response.
func (client *WebAppsClient) updateScmAllowedSlotHandleResponse(resp *http.Response) (WebAppsUpdateScmAllowedSlotResponse, error) {
	result := WebAppsUpdateScmAllowedSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.CsmPublishingCredentialsPoliciesEntity); err != nil {
		return WebAppsUpdateScmAllowedSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateScmAllowedSlotHandleError handles the UpdateScmAllowedSlot error response.
func (client *WebAppsClient) updateScmAllowedSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSitePushSettings - Description for Updates the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSitePushSettings(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsOptions) (WebAppsUpdateSitePushSettingsResponse, error) {
	req, err := client.updateSitePushSettingsCreateRequest(ctx, resourceGroupName, name, pushSettings, options)
	if err != nil {
		return WebAppsUpdateSitePushSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSitePushSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateSitePushSettingsResponse{}, client.updateSitePushSettingsHandleError(resp)
	}
	return client.updateSitePushSettingsHandleResponse(resp)
}

// updateSitePushSettingsCreateRequest creates the UpdateSitePushSettings request.
func (client *WebAppsClient) updateSitePushSettingsCreateRequest(ctx context.Context, resourceGroupName string, name string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, pushSettings)
}

// updateSitePushSettingsHandleResponse handles the UpdateSitePushSettings response.
func (client *WebAppsClient) updateSitePushSettingsHandleResponse(resp *http.Response) (WebAppsUpdateSitePushSettingsResponse, error) {
	result := WebAppsUpdateSitePushSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsUpdateSitePushSettingsResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSitePushSettingsHandleError handles the UpdateSitePushSettings error response.
func (client *WebAppsClient) updateSitePushSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSitePushSettingsSlot - Description for Updates the Push settings associated with web app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSitePushSettingsSlot(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsSlotOptions) (WebAppsUpdateSitePushSettingsSlotResponse, error) {
	req, err := client.updateSitePushSettingsSlotCreateRequest(ctx, resourceGroupName, name, slot, pushSettings, options)
	if err != nil {
		return WebAppsUpdateSitePushSettingsSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSitePushSettingsSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateSitePushSettingsSlotResponse{}, client.updateSitePushSettingsSlotHandleError(resp)
	}
	return client.updateSitePushSettingsSlotHandleResponse(resp)
}

// updateSitePushSettingsSlotCreateRequest creates the UpdateSitePushSettingsSlot request.
func (client *WebAppsClient) updateSitePushSettingsSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, pushSettings PushSettings, options *WebAppsUpdateSitePushSettingsSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/config/pushsettings"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, pushSettings)
}

// updateSitePushSettingsSlotHandleResponse handles the UpdateSitePushSettingsSlot response.
func (client *WebAppsClient) updateSitePushSettingsSlotHandleResponse(resp *http.Response) (WebAppsUpdateSitePushSettingsSlotResponse, error) {
	result := WebAppsUpdateSitePushSettingsSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PushSettings); err != nil {
		return WebAppsUpdateSitePushSettingsSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSitePushSettingsSlotHandleError handles the UpdateSitePushSettingsSlot error response.
func (client *WebAppsClient) updateSitePushSettingsSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSlot - Description for Creates a new web, mobile, or API app in an existing resource group, or updates an existing app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *WebAppsUpdateSlotOptions) (WebAppsUpdateSlotResponse, error) {
	req, err := client.updateSlotCreateRequest(ctx, resourceGroupName, name, slot, siteEnvelope, options)
	if err != nil {
		return WebAppsUpdateSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return WebAppsUpdateSlotResponse{}, client.updateSlotHandleError(resp)
	}
	return client.updateSlotHandleResponse(resp)
}

// updateSlotCreateRequest creates the UpdateSlot request.
func (client *WebAppsClient) updateSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteEnvelope SitePatchResource, options *WebAppsUpdateSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteEnvelope)
}

// updateSlotHandleResponse handles the UpdateSlot response.
func (client *WebAppsClient) updateSlotHandleResponse(resp *http.Response) (WebAppsUpdateSlotResponse, error) {
	result := WebAppsUpdateSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Site); err != nil {
		return WebAppsUpdateSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSlotHandleError handles the UpdateSlot error response.
func (client *WebAppsClient) updateSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSlotConfigurationNames - Description for Updates the names of application settings and connection string that remain with the slot during swap
// operation.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSlotConfigurationNames(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *WebAppsUpdateSlotConfigurationNamesOptions) (WebAppsUpdateSlotConfigurationNamesResponse, error) {
	req, err := client.updateSlotConfigurationNamesCreateRequest(ctx, resourceGroupName, name, slotConfigNames, options)
	if err != nil {
		return WebAppsUpdateSlotConfigurationNamesResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSlotConfigurationNamesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateSlotConfigurationNamesResponse{}, client.updateSlotConfigurationNamesHandleError(resp)
	}
	return client.updateSlotConfigurationNamesHandleResponse(resp)
}

// updateSlotConfigurationNamesCreateRequest creates the UpdateSlotConfigurationNames request.
func (client *WebAppsClient) updateSlotConfigurationNamesCreateRequest(ctx context.Context, resourceGroupName string, name string, slotConfigNames SlotConfigNamesResource, options *WebAppsUpdateSlotConfigurationNamesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/config/slotConfigNames"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, slotConfigNames)
}

// updateSlotConfigurationNamesHandleResponse handles the UpdateSlotConfigurationNames response.
func (client *WebAppsClient) updateSlotConfigurationNamesHandleResponse(resp *http.Response) (WebAppsUpdateSlotConfigurationNamesResponse, error) {
	result := WebAppsUpdateSlotConfigurationNamesResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SlotConfigNamesResource); err != nil {
		return WebAppsUpdateSlotConfigurationNamesResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSlotConfigurationNamesHandleError handles the UpdateSlotConfigurationNames error response.
func (client *WebAppsClient) updateSlotConfigurationNamesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSourceControl - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSourceControl(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlOptions) (WebAppsUpdateSourceControlResponse, error) {
	req, err := client.updateSourceControlCreateRequest(ctx, resourceGroupName, name, siteSourceControl, options)
	if err != nil {
		return WebAppsUpdateSourceControlResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSourceControlResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return WebAppsUpdateSourceControlResponse{}, client.updateSourceControlHandleError(resp)
	}
	return client.updateSourceControlHandleResponse(resp)
}

// updateSourceControlCreateRequest creates the UpdateSourceControl request.
func (client *WebAppsClient) updateSourceControlCreateRequest(ctx context.Context, resourceGroupName string, name string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// updateSourceControlHandleResponse handles the UpdateSourceControl response.
func (client *WebAppsClient) updateSourceControlHandleResponse(resp *http.Response) (WebAppsUpdateSourceControlResponse, error) {
	result := WebAppsUpdateSourceControlResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsUpdateSourceControlResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSourceControlHandleError handles the UpdateSourceControl error response.
func (client *WebAppsClient) updateSourceControlHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSourceControlSlot - Description for Updates the source control configuration of an app.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSourceControlSlot(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlSlotOptions) (WebAppsUpdateSourceControlSlotResponse, error) {
	req, err := client.updateSourceControlSlotCreateRequest(ctx, resourceGroupName, name, slot, siteSourceControl, options)
	if err != nil {
		return WebAppsUpdateSourceControlSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSourceControlSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted) {
		return WebAppsUpdateSourceControlSlotResponse{}, client.updateSourceControlSlotHandleError(resp)
	}
	return client.updateSourceControlSlotHandleResponse(resp)
}

// updateSourceControlSlotCreateRequest creates the UpdateSourceControlSlot request.
func (client *WebAppsClient) updateSourceControlSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, siteSourceControl SiteSourceControl, options *WebAppsUpdateSourceControlSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/sourcecontrols/web"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, siteSourceControl)
}

// updateSourceControlSlotHandleResponse handles the UpdateSourceControlSlot response.
func (client *WebAppsClient) updateSourceControlSlotHandleResponse(resp *http.Response) (WebAppsUpdateSourceControlSlotResponse, error) {
	result := WebAppsUpdateSourceControlSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SiteSourceControl); err != nil {
		return WebAppsUpdateSourceControlSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSourceControlSlotHandleError handles the UpdateSourceControlSlot error response.
func (client *WebAppsClient) updateSourceControlSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSwiftVirtualNetworkConnectionWithCheck - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSwiftVirtualNetworkConnectionWithCheck(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	req, err := client.updateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx, resourceGroupName, name, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, client.updateSwiftVirtualNetworkConnectionWithCheckHandleError(resp)
	}
	return client.updateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp)
}

// updateSwiftVirtualNetworkConnectionWithCheckCreateRequest creates the UpdateSwiftVirtualNetworkConnectionWithCheck request.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckCreateRequest(ctx context.Context, resourceGroupName string, name string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateSwiftVirtualNetworkConnectionWithCheckHandleResponse handles the UpdateSwiftVirtualNetworkConnectionWithCheck response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckHandleResponse(resp *http.Response) (WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse, error) {
	result := WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSwiftVirtualNetworkConnectionWithCheckHandleError handles the UpdateSwiftVirtualNetworkConnectionWithCheck error response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateSwiftVirtualNetworkConnectionWithCheckSlot - Description for Integrates this Web App with a Virtual Network. This requires that 1) "swiftSupported"
// is true when doing a GET against this resource, and 2) that the target Subnet has already been
// delegated, and is not in use by another App Service Plan other than the one this App is in.
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateSwiftVirtualNetworkConnectionWithCheckSlot(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	req, err := client.updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx, resourceGroupName, name, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, client.updateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp)
	}
	return client.updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp)
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest creates the UpdateSwiftVirtualNetworkConnectionWithCheckSlot request.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, slot string, connectionEnvelope SwiftVirtualNetwork, options *WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/networkConfig/virtualNetwork"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse handles the UpdateSwiftVirtualNetworkConnectionWithCheckSlot response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotHandleResponse(resp *http.Response) (WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse, error) {
	result := WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SwiftVirtualNetwork); err != nil {
		return WebAppsUpdateSwiftVirtualNetworkConnectionWithCheckSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateSwiftVirtualNetworkConnectionWithCheckSlotHandleError handles the UpdateSwiftVirtualNetworkConnectionWithCheckSlot error response.
func (client *WebAppsClient) updateSwiftVirtualNetworkConnectionWithCheckSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateVnetConnection - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnection(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsUpdateVnetConnectionOptions) (WebAppsUpdateVnetConnectionResponse, error) {
	req, err := client.updateVnetConnectionCreateRequest(ctx, resourceGroupName, name, vnetName, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateVnetConnectionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateVnetConnectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateVnetConnectionResponse{}, client.updateVnetConnectionHandleError(resp)
	}
	return client.updateVnetConnectionHandleResponse(resp)
}

// updateVnetConnectionCreateRequest creates the UpdateVnetConnection request.
func (client *WebAppsClient) updateVnetConnectionCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, connectionEnvelope VnetInfoResource, options *WebAppsUpdateVnetConnectionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionHandleResponse handles the UpdateVnetConnection response.
func (client *WebAppsClient) updateVnetConnectionHandleResponse(resp *http.Response) (WebAppsUpdateVnetConnectionResponse, error) {
	result := WebAppsUpdateVnetConnectionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsUpdateVnetConnectionResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateVnetConnectionHandleError handles the UpdateVnetConnection error response.
func (client *WebAppsClient) updateVnetConnectionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateVnetConnectionGateway - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnectionGateway(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewayOptions) (WebAppsUpdateVnetConnectionGatewayResponse, error) {
	req, err := client.updateVnetConnectionGatewayCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateVnetConnectionGatewayResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateVnetConnectionGatewayResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateVnetConnectionGatewayResponse{}, client.updateVnetConnectionGatewayHandleError(resp)
	}
	return client.updateVnetConnectionGatewayHandleResponse(resp)
}

// updateVnetConnectionGatewayCreateRequest creates the UpdateVnetConnectionGateway request.
func (client *WebAppsClient) updateVnetConnectionGatewayCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewayOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionGatewayHandleResponse handles the UpdateVnetConnectionGateway response.
func (client *WebAppsClient) updateVnetConnectionGatewayHandleResponse(resp *http.Response) (WebAppsUpdateVnetConnectionGatewayResponse, error) {
	result := WebAppsUpdateVnetConnectionGatewayResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsUpdateVnetConnectionGatewayResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateVnetConnectionGatewayHandleError handles the UpdateVnetConnectionGateway error response.
func (client *WebAppsClient) updateVnetConnectionGatewayHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateVnetConnectionGatewaySlot - Description for Adds a gateway to a connected Virtual Network (PUT) or updates it (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnectionGatewaySlot(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewaySlotOptions) (WebAppsUpdateVnetConnectionGatewaySlotResponse, error) {
	req, err := client.updateVnetConnectionGatewaySlotCreateRequest(ctx, resourceGroupName, name, vnetName, gatewayName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateVnetConnectionGatewaySlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateVnetConnectionGatewaySlotResponse{}, client.updateVnetConnectionGatewaySlotHandleError(resp)
	}
	return client.updateVnetConnectionGatewaySlotHandleResponse(resp)
}

// updateVnetConnectionGatewaySlotCreateRequest creates the UpdateVnetConnectionGatewaySlot request.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, gatewayName string, slot string, connectionEnvelope VnetGateway, options *WebAppsUpdateVnetConnectionGatewaySlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}/gateways/{gatewayName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if gatewayName == "" {
		return nil, errors.New("parameter gatewayName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{gatewayName}", url.PathEscape(gatewayName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionGatewaySlotHandleResponse handles the UpdateVnetConnectionGatewaySlot response.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotHandleResponse(resp *http.Response) (WebAppsUpdateVnetConnectionGatewaySlotResponse, error) {
	result := WebAppsUpdateVnetConnectionGatewaySlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetGateway); err != nil {
		return WebAppsUpdateVnetConnectionGatewaySlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateVnetConnectionGatewaySlotHandleError handles the UpdateVnetConnectionGatewaySlot error response.
func (client *WebAppsClient) updateVnetConnectionGatewaySlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}

// UpdateVnetConnectionSlot - Description for Adds a Virtual Network connection to an app or slot (PUT) or updates the connection properties (PATCH).
// If the operation fails it returns the *DefaultErrorResponse error type.
func (client *WebAppsClient) UpdateVnetConnectionSlot(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsUpdateVnetConnectionSlotOptions) (WebAppsUpdateVnetConnectionSlotResponse, error) {
	req, err := client.updateVnetConnectionSlotCreateRequest(ctx, resourceGroupName, name, vnetName, slot, connectionEnvelope, options)
	if err != nil {
		return WebAppsUpdateVnetConnectionSlotResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return WebAppsUpdateVnetConnectionSlotResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return WebAppsUpdateVnetConnectionSlotResponse{}, client.updateVnetConnectionSlotHandleError(resp)
	}
	return client.updateVnetConnectionSlotHandleResponse(resp)
}

// updateVnetConnectionSlotCreateRequest creates the UpdateVnetConnectionSlot request.
func (client *WebAppsClient) updateVnetConnectionSlotCreateRequest(ctx context.Context, resourceGroupName string, name string, vnetName string, slot string, connectionEnvelope VnetInfoResource, options *WebAppsUpdateVnetConnectionSlotOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{name}/slots/{slot}/virtualNetworkConnections/{vnetName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if name == "" {
		return nil, errors.New("parameter name cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{name}", url.PathEscape(name))
	if vnetName == "" {
		return nil, errors.New("parameter vnetName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{vnetName}", url.PathEscape(vnetName))
	if slot == "" {
		return nil, errors.New("parameter slot cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{slot}", url.PathEscape(slot))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2021-02-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, connectionEnvelope)
}

// updateVnetConnectionSlotHandleResponse handles the UpdateVnetConnectionSlot response.
func (client *WebAppsClient) updateVnetConnectionSlotHandleResponse(resp *http.Response) (WebAppsUpdateVnetConnectionSlotResponse, error) {
	result := WebAppsUpdateVnetConnectionSlotResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.VnetInfoResource); err != nil {
		return WebAppsUpdateVnetConnectionSlotResponse{}, runtime.NewResponseError(err, resp)
	}
	return result, nil
}

// updateVnetConnectionSlotHandleError handles the UpdateVnetConnectionSlot error response.
func (client *WebAppsClient) updateVnetConnectionSlotHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	errType := DefaultErrorResponse{raw: string(body)}
	if err := runtime.UnmarshalAsJSON(resp, &errType); err != nil {
		return runtime.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp)
	}
	return runtime.NewResponseError(&errType, resp)
}
