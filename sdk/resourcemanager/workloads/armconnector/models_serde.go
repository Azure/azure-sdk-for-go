//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armconnector

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type ACSSBackupConnection.
func (a ACSSBackupConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ACSSBackupConnection.
func (a *ACSSBackupConnection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &a.ID)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &a.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &a.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &a.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &a.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &a.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &a.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ACSSBackupConnectionList.
func (a ACSSBackupConnectionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ACSSBackupConnectionList.
func (a *ACSSBackupConnectionList) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &a.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &a.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ACSSBackupConnectionProperties.
func (a ACSSBackupConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupData", a.BackupData)
	populate(objectMap, "errors", a.Errors)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ACSSBackupConnectionProperties.
func (a *ACSSBackupConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupData":
			a.BackupData, err = unmarshalBackupDataClassification(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, "Errors", &a.Errors)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &a.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureIaaSVMProtectionPolicy.
func (a AzureIaaSVMProtectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["backupManagementType"] = "AzureIaasVM"
	populate(objectMap, "instantRPDetails", a.InstantRPDetails)
	populate(objectMap, "instantRpRetentionRangeInDays", a.InstantRpRetentionRangeInDays)
	populate(objectMap, "policyType", a.PolicyType)
	populate(objectMap, "protectedItemsCount", a.ProtectedItemsCount)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "retentionPolicy", a.RetentionPolicy)
	populate(objectMap, "schedulePolicy", a.SchedulePolicy)
	populate(objectMap, "tieringPolicy", a.TieringPolicy)
	populate(objectMap, "timeZone", a.TimeZone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureIaaSVMProtectionPolicy.
func (a *AzureIaaSVMProtectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "instantRPDetails":
			err = unpopulate(val, "InstantRPDetails", &a.InstantRPDetails)
			delete(rawMsg, key)
		case "instantRpRetentionRangeInDays":
			err = unpopulate(val, "InstantRpRetentionRangeInDays", &a.InstantRpRetentionRangeInDays)
			delete(rawMsg, key)
		case "policyType":
			err = unpopulate(val, "PolicyType", &a.PolicyType)
			delete(rawMsg, key)
		case "protectedItemsCount":
			err = unpopulate(val, "ProtectedItemsCount", &a.ProtectedItemsCount)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "retentionPolicy":
			a.RetentionPolicy, err = unmarshalRetentionPolicyClassification(val)
			delete(rawMsg, key)
		case "schedulePolicy":
			a.SchedulePolicy, err = unmarshalSchedulePolicyClassification(val)
			delete(rawMsg, key)
		case "tieringPolicy":
			err = unpopulate(val, "TieringPolicy", &a.TieringPolicy)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &a.TimeZone)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureVMWorkloadProtectionPolicy.
func (a AzureVMWorkloadProtectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["backupManagementType"] = "AzureWorkload"
	populate(objectMap, "makePolicyConsistent", a.MakePolicyConsistent)
	populate(objectMap, "protectedItemsCount", a.ProtectedItemsCount)
	populate(objectMap, "resourceGuardOperationRequests", a.ResourceGuardOperationRequests)
	populate(objectMap, "settings", a.Settings)
	populate(objectMap, "subProtectionPolicy", a.SubProtectionPolicy)
	populate(objectMap, "workLoadType", a.WorkLoadType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureVMWorkloadProtectionPolicy.
func (a *AzureVMWorkloadProtectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &a.BackupManagementType)
			delete(rawMsg, key)
		case "makePolicyConsistent":
			err = unpopulate(val, "MakePolicyConsistent", &a.MakePolicyConsistent)
			delete(rawMsg, key)
		case "protectedItemsCount":
			err = unpopulate(val, "ProtectedItemsCount", &a.ProtectedItemsCount)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &a.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		case "settings":
			err = unpopulate(val, "Settings", &a.Settings)
			delete(rawMsg, key)
		case "subProtectionPolicy":
			err = unpopulate(val, "SubProtectionPolicy", &a.SubProtectionPolicy)
			delete(rawMsg, key)
		case "workLoadType":
			err = unpopulate(val, "WorkLoadType", &a.WorkLoadType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupData.
func (b BackupData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["backupType"] = b.BackupType
	populate(objectMap, "recoveryServicesVault", b.RecoveryServicesVault)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupData.
func (b *BackupData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupType":
			err = unpopulate(val, "BackupType", &b.BackupType)
			delete(rawMsg, key)
		case "recoveryServicesVault":
			b.RecoveryServicesVault, err = unmarshalRecoveryServicesVaultPropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Connector.
func (c Connector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "identity", c.Identity)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Connector.
func (c *Connector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "identity":
			err = unpopulate(val, "Identity", &c.Identity)
			delete(rawMsg, key)
		case "location":
			err = unpopulate(val, "Location", &c.Location)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &c.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, "SystemData", &c.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &c.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DBBackupPolicyProperties.
func (d DBBackupPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DBBackupPolicyProperties.
func (d *DBBackupPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DailyRetentionFormat.
func (d DailyRetentionFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "daysOfTheMonth", d.DaysOfTheMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DailyRetentionFormat.
func (d *DailyRetentionFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "daysOfTheMonth":
			err = unpopulate(val, "DaysOfTheMonth", &d.DaysOfTheMonth)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DailyRetentionSchedule.
func (d DailyRetentionSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "retentionDuration", d.RetentionDuration)
	aux := make([]*timeRFC3339, len(d.RetentionTimes), len(d.RetentionTimes))
	for i := 0; i < len(d.RetentionTimes); i++ {
		aux[i] = (*timeRFC3339)(d.RetentionTimes[i])
	}
	populate(objectMap, "retentionTimes", aux)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DailyRetentionSchedule.
func (d *DailyRetentionSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retentionDuration":
			err = unpopulate(val, "RetentionDuration", &d.RetentionDuration)
			delete(rawMsg, key)
		case "retentionTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "RetentionTimes", &aux)
			for _, au := range aux {
				d.RetentionTimes = append(d.RetentionTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DailySchedule.
func (d DailySchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	aux := make([]*timeRFC3339, len(d.ScheduleRunTimes), len(d.ScheduleRunTimes))
	for i := 0; i < len(d.ScheduleRunTimes); i++ {
		aux[i] = (*timeRFC3339)(d.ScheduleRunTimes[i])
	}
	populate(objectMap, "scheduleRunTimes", aux)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DailySchedule.
func (d *DailySchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scheduleRunTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "ScheduleRunTimes", &aux)
			for _, au := range aux {
				d.ScheduleRunTimes = append(d.ScheduleRunTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Day.
func (d Day) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "date", d.Date)
	populate(objectMap, "isLast", d.IsLast)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Day.
func (d *Day) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "date":
			err = unpopulate(val, "Date", &d.Date)
			delete(rawMsg, key)
		case "isLast":
			err = unpopulate(val, "IsLast", &d.IsLast)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskExclusionProperties.
func (d DiskExclusionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "diskLunList", d.DiskLunList)
	populate(objectMap, "isInclusionList", d.IsInclusionList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskExclusionProperties.
func (d *DiskExclusionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "diskLunList":
			err = unpopulate(val, "DiskLunList", &d.DiskLunList)
			delete(rawMsg, key)
		case "isInclusionList":
			err = unpopulate(val, "IsInclusionList", &d.IsInclusionList)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDefinition.
func (e ErrorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDefinition.
func (e *ErrorDefinition) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExistingRecoveryServicesVault.
func (e ExistingRecoveryServicesVault) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	objectMap["vaultType"] = VaultTypeExisting
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExistingRecoveryServicesVault.
func (e *ExistingRecoveryServicesVault) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "vaultType":
			err = unpopulate(val, "VaultType", &e.VaultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HanaBackupData.
func (h HanaBackupData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupPolicy", h.BackupPolicy)
	objectMap["backupType"] = BackupTypeHANA
	populate(objectMap, "dbInstanceSnapshotBackupPolicy", h.DbInstanceSnapshotBackupPolicy)
	populate(objectMap, "hdbuserstoreKeyName", h.HdbuserstoreKeyName)
	populate(objectMap, "instanceNumber", h.InstanceNumber)
	populate(objectMap, "recoveryServicesVault", h.RecoveryServicesVault)
	populate(objectMap, "sslConfiguration", h.SSLConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HanaBackupData.
func (h *HanaBackupData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupPolicy":
			err = unpopulate(val, "BackupPolicy", &h.BackupPolicy)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, "BackupType", &h.BackupType)
			delete(rawMsg, key)
		case "dbInstanceSnapshotBackupPolicy":
			err = unpopulate(val, "DbInstanceSnapshotBackupPolicy", &h.DbInstanceSnapshotBackupPolicy)
			delete(rawMsg, key)
		case "hdbuserstoreKeyName":
			err = unpopulate(val, "HdbuserstoreKeyName", &h.HdbuserstoreKeyName)
			delete(rawMsg, key)
		case "instanceNumber":
			err = unpopulate(val, "InstanceNumber", &h.InstanceNumber)
			delete(rawMsg, key)
		case "recoveryServicesVault":
			h.RecoveryServicesVault, err = unmarshalRecoveryServicesVaultPropertiesClassification(val)
			delete(rawMsg, key)
		case "sslConfiguration":
			err = unpopulate(val, "SSLConfiguration", &h.SSLConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HourlySchedule.
func (h HourlySchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "interval", h.Interval)
	populate(objectMap, "scheduleWindowDuration", h.ScheduleWindowDuration)
	populateTimeRFC3339(objectMap, "scheduleWindowStartTime", h.ScheduleWindowStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HourlySchedule.
func (h *HourlySchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "interval":
			err = unpopulate(val, "Interval", &h.Interval)
			delete(rawMsg, key)
		case "scheduleWindowDuration":
			err = unpopulate(val, "ScheduleWindowDuration", &h.ScheduleWindowDuration)
			delete(rawMsg, key)
		case "scheduleWindowStartTime":
			err = unpopulateTimeRFC3339(val, "ScheduleWindowStartTime", &h.ScheduleWindowStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstantRPAdditionalDetails.
func (i InstantRPAdditionalDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureBackupRGNamePrefix", i.AzureBackupRGNamePrefix)
	populate(objectMap, "azureBackupRGNameSuffix", i.AzureBackupRGNameSuffix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstantRPAdditionalDetails.
func (i *InstantRPAdditionalDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureBackupRGNamePrefix":
			err = unpopulate(val, "AzureBackupRGNamePrefix", &i.AzureBackupRGNamePrefix)
			delete(rawMsg, key)
		case "azureBackupRGNameSuffix":
			err = unpopulate(val, "AzureBackupRGNameSuffix", &i.AzureBackupRGNameSuffix)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type List.
func (l List) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", l.NextLink)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type List.
func (l *List) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &l.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LogSchedulePolicy.
func (l LogSchedulePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scheduleFrequencyInMins", l.ScheduleFrequencyInMins)
	objectMap["schedulePolicyType"] = "LogSchedulePolicy"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LogSchedulePolicy.
func (l *LogSchedulePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scheduleFrequencyInMins":
			err = unpopulate(val, "ScheduleFrequencyInMins", &l.ScheduleFrequencyInMins)
			delete(rawMsg, key)
		case "schedulePolicyType":
			err = unpopulate(val, "SchedulePolicyType", &l.SchedulePolicyType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LongTermRetentionPolicy.
func (l LongTermRetentionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dailySchedule", l.DailySchedule)
	populate(objectMap, "monthlySchedule", l.MonthlySchedule)
	objectMap["retentionPolicyType"] = "LongTermRetentionPolicy"
	populate(objectMap, "weeklySchedule", l.WeeklySchedule)
	populate(objectMap, "yearlySchedule", l.YearlySchedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LongTermRetentionPolicy.
func (l *LongTermRetentionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dailySchedule":
			err = unpopulate(val, "DailySchedule", &l.DailySchedule)
			delete(rawMsg, key)
		case "monthlySchedule":
			err = unpopulate(val, "MonthlySchedule", &l.MonthlySchedule)
			delete(rawMsg, key)
		case "retentionPolicyType":
			err = unpopulate(val, "RetentionPolicyType", &l.RetentionPolicyType)
			delete(rawMsg, key)
		case "weeklySchedule":
			err = unpopulate(val, "WeeklySchedule", &l.WeeklySchedule)
			delete(rawMsg, key)
		case "yearlySchedule":
			err = unpopulate(val, "YearlySchedule", &l.YearlySchedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LongTermSchedulePolicy.
func (l LongTermSchedulePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["schedulePolicyType"] = "LongTermSchedulePolicy"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LongTermSchedulePolicy.
func (l *LongTermSchedulePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schedulePolicyType":
			err = unpopulate(val, "SchedulePolicyType", &l.SchedulePolicyType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedRGConfiguration.
func (m ManagedRGConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedRGConfiguration.
func (m *ManagedRGConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MonthlyRetentionSchedule.
func (m MonthlyRetentionSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "retentionDuration", m.RetentionDuration)
	populate(objectMap, "retentionScheduleDaily", m.RetentionScheduleDaily)
	populate(objectMap, "retentionScheduleFormatType", m.RetentionScheduleFormatType)
	populate(objectMap, "retentionScheduleWeekly", m.RetentionScheduleWeekly)
	aux := make([]*timeRFC3339, len(m.RetentionTimes), len(m.RetentionTimes))
	for i := 0; i < len(m.RetentionTimes); i++ {
		aux[i] = (*timeRFC3339)(m.RetentionTimes[i])
	}
	populate(objectMap, "retentionTimes", aux)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MonthlyRetentionSchedule.
func (m *MonthlyRetentionSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retentionDuration":
			err = unpopulate(val, "RetentionDuration", &m.RetentionDuration)
			delete(rawMsg, key)
		case "retentionScheduleDaily":
			err = unpopulate(val, "RetentionScheduleDaily", &m.RetentionScheduleDaily)
			delete(rawMsg, key)
		case "retentionScheduleFormatType":
			err = unpopulate(val, "RetentionScheduleFormatType", &m.RetentionScheduleFormatType)
			delete(rawMsg, key)
		case "retentionScheduleWeekly":
			err = unpopulate(val, "RetentionScheduleWeekly", &m.RetentionScheduleWeekly)
			delete(rawMsg, key)
		case "retentionTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "RetentionTimes", &aux)
			for _, au := range aux {
				m.RetentionTimes = append(m.RetentionTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NewRecoveryServicesVault.
func (n NewRecoveryServicesVault) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "resourceGroup", n.ResourceGroup)
	objectMap["vaultType"] = VaultTypeNew
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NewRecoveryServicesVault.
func (n *NewRecoveryServicesVault) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "resourceGroup":
			err = unpopulate(val, "ResourceGroup", &n.ResourceGroup)
			delete(rawMsg, key)
		case "vaultType":
			err = unpopulate(val, "VaultType", &n.VaultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
			err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
			err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
			err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
			err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
			err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
			err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
			err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
			err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
			err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
			err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Properties.
func (p Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "errors", p.Errors)
	populate(objectMap, "managedResourceGroupConfiguration", p.ManagedResourceGroupConfiguration)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "sourceResourceId", p.SourceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Properties.
func (p *Properties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errors":
			err = unpopulate(val, "Errors", &p.Errors)
			delete(rawMsg, key)
		case "managedResourceGroupConfiguration":
			err = unpopulate(val, "ManagedResourceGroupConfiguration", &p.ManagedResourceGroupConfiguration)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, "ProvisioningState", &p.ProvisioningState)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, "SourceResourceID", &p.SourceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectionPolicy.
func (p ProtectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["backupManagementType"] = p.BackupManagementType
	populate(objectMap, "protectedItemsCount", p.ProtectedItemsCount)
	populate(objectMap, "resourceGuardOperationRequests", p.ResourceGuardOperationRequests)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectionPolicy.
func (p *ProtectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupManagementType":
			err = unpopulate(val, "BackupManagementType", &p.BackupManagementType)
			delete(rawMsg, key)
		case "protectedItemsCount":
			err = unpopulate(val, "ProtectedItemsCount", &p.ProtectedItemsCount)
			delete(rawMsg, key)
		case "resourceGuardOperationRequests":
			err = unpopulate(val, "ResourceGuardOperationRequests", &p.ResourceGuardOperationRequests)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecoveryServicesVaultProperties.
func (r RecoveryServicesVaultProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["vaultType"] = r.VaultType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecoveryServicesVaultProperties.
func (r *RecoveryServicesVaultProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "vaultType":
			err = unpopulate(val, "VaultType", &r.VaultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RetentionDuration.
func (r RetentionDuration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", r.Count)
	populate(objectMap, "durationType", r.DurationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RetentionDuration.
func (r *RetentionDuration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
			err = unpopulate(val, "Count", &r.Count)
			delete(rawMsg, key)
		case "durationType":
			err = unpopulate(val, "DurationType", &r.DurationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RetentionPolicy.
func (r RetentionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["retentionPolicyType"] = r.RetentionPolicyType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RetentionPolicy.
func (r *RetentionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retentionPolicyType":
			err = unpopulate(val, "RetentionPolicyType", &r.RetentionPolicyType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SQLBackupData.
func (s SQLBackupData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupPolicy", s.BackupPolicy)
	objectMap["backupType"] = BackupTypeSQL
	populate(objectMap, "recoveryServicesVault", s.RecoveryServicesVault)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLBackupData.
func (s *SQLBackupData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupPolicy":
			err = unpopulate(val, "BackupPolicy", &s.BackupPolicy)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, "BackupType", &s.BackupType)
			delete(rawMsg, key)
		case "recoveryServicesVault":
			s.RecoveryServicesVault, err = unmarshalRecoveryServicesVaultPropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SSLConfiguration.
func (s SSLConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sslCryptoProvider", s.SSLCryptoProvider)
	populate(objectMap, "sslHostNameInCertificate", s.SSLHostNameInCertificate)
	populate(objectMap, "sslKeyStore", s.SSLKeyStore)
	populate(objectMap, "sslTrustStore", s.SSLTrustStore)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SSLConfiguration.
func (s *SSLConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sslCryptoProvider":
			err = unpopulate(val, "SSLCryptoProvider", &s.SSLCryptoProvider)
			delete(rawMsg, key)
		case "sslHostNameInCertificate":
			err = unpopulate(val, "SSLHostNameInCertificate", &s.SSLHostNameInCertificate)
			delete(rawMsg, key)
		case "sslKeyStore":
			err = unpopulate(val, "SSLKeyStore", &s.SSLKeyStore)
			delete(rawMsg, key)
		case "sslTrustStore":
			err = unpopulate(val, "SSLTrustStore", &s.SSLTrustStore)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SchedulePolicy.
func (s SchedulePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["schedulePolicyType"] = s.SchedulePolicyType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SchedulePolicy.
func (s *SchedulePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "schedulePolicyType":
			err = unpopulate(val, "SchedulePolicyType", &s.SchedulePolicyType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Settings.
func (s Settings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isCompression", s.IsCompression)
	populate(objectMap, "issqlcompression", s.Issqlcompression)
	populate(objectMap, "timeZone", s.TimeZone)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Settings.
func (s *Settings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isCompression":
			err = unpopulate(val, "IsCompression", &s.IsCompression)
			delete(rawMsg, key)
		case "issqlcompression":
			err = unpopulate(val, "Issqlcompression", &s.Issqlcompression)
			delete(rawMsg, key)
		case "timeZone":
			err = unpopulate(val, "TimeZone", &s.TimeZone)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SimpleRetentionPolicy.
func (s SimpleRetentionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "retentionDuration", s.RetentionDuration)
	objectMap["retentionPolicyType"] = "SimpleRetentionPolicy"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SimpleRetentionPolicy.
func (s *SimpleRetentionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retentionDuration":
			err = unpopulate(val, "RetentionDuration", &s.RetentionDuration)
			delete(rawMsg, key)
		case "retentionPolicyType":
			err = unpopulate(val, "RetentionPolicyType", &s.RetentionPolicyType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SimpleSchedulePolicy.
func (s SimpleSchedulePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hourlySchedule", s.HourlySchedule)
	objectMap["schedulePolicyType"] = "SimpleSchedulePolicy"
	populate(objectMap, "scheduleRunDays", s.ScheduleRunDays)
	populate(objectMap, "scheduleRunFrequency", s.ScheduleRunFrequency)
	aux := make([]*timeRFC3339, len(s.ScheduleRunTimes), len(s.ScheduleRunTimes))
	for i := 0; i < len(s.ScheduleRunTimes); i++ {
		aux[i] = (*timeRFC3339)(s.ScheduleRunTimes[i])
	}
	populate(objectMap, "scheduleRunTimes", aux)
	populate(objectMap, "scheduleWeeklyFrequency", s.ScheduleWeeklyFrequency)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SimpleSchedulePolicy.
func (s *SimpleSchedulePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hourlySchedule":
			err = unpopulate(val, "HourlySchedule", &s.HourlySchedule)
			delete(rawMsg, key)
		case "schedulePolicyType":
			err = unpopulate(val, "SchedulePolicyType", &s.SchedulePolicyType)
			delete(rawMsg, key)
		case "scheduleRunDays":
			err = unpopulate(val, "ScheduleRunDays", &s.ScheduleRunDays)
			delete(rawMsg, key)
		case "scheduleRunFrequency":
			err = unpopulate(val, "ScheduleRunFrequency", &s.ScheduleRunFrequency)
			delete(rawMsg, key)
		case "scheduleRunTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "ScheduleRunTimes", &aux)
			for _, au := range aux {
				s.ScheduleRunTimes = append(s.ScheduleRunTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		case "scheduleWeeklyFrequency":
			err = unpopulate(val, "ScheduleWeeklyFrequency", &s.ScheduleWeeklyFrequency)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SimpleSchedulePolicyV2.
func (s SimpleSchedulePolicyV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dailySchedule", s.DailySchedule)
	populate(objectMap, "hourlySchedule", s.HourlySchedule)
	objectMap["schedulePolicyType"] = "SimpleSchedulePolicyV2"
	populate(objectMap, "scheduleRunFrequency", s.ScheduleRunFrequency)
	populate(objectMap, "weeklySchedule", s.WeeklySchedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SimpleSchedulePolicyV2.
func (s *SimpleSchedulePolicyV2) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dailySchedule":
			err = unpopulate(val, "DailySchedule", &s.DailySchedule)
			delete(rawMsg, key)
		case "hourlySchedule":
			err = unpopulate(val, "HourlySchedule", &s.HourlySchedule)
			delete(rawMsg, key)
		case "schedulePolicyType":
			err = unpopulate(val, "SchedulePolicyType", &s.SchedulePolicyType)
			delete(rawMsg, key)
		case "scheduleRunFrequency":
			err = unpopulate(val, "ScheduleRunFrequency", &s.ScheduleRunFrequency)
			delete(rawMsg, key)
		case "weeklySchedule":
			err = unpopulate(val, "WeeklySchedule", &s.WeeklySchedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SnapshotBackupAdditionalDetails.
func (s SnapshotBackupAdditionalDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instantRPDetails", s.InstantRPDetails)
	populate(objectMap, "instantRpRetentionRangeInDays", s.InstantRpRetentionRangeInDays)
	populate(objectMap, "userAssignedManagedIdentityDetails", s.UserAssignedManagedIdentityDetails)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnapshotBackupAdditionalDetails.
func (s *SnapshotBackupAdditionalDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instantRPDetails":
			err = unpopulate(val, "InstantRPDetails", &s.InstantRPDetails)
			delete(rawMsg, key)
		case "instantRpRetentionRangeInDays":
			err = unpopulate(val, "InstantRpRetentionRangeInDays", &s.InstantRpRetentionRangeInDays)
			delete(rawMsg, key)
		case "userAssignedManagedIdentityDetails":
			err = unpopulate(val, "UserAssignedManagedIdentityDetails", &s.UserAssignedManagedIdentityDetails)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SubProtectionPolicy.
func (s SubProtectionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "policyType", s.PolicyType)
	populate(objectMap, "retentionPolicy", s.RetentionPolicy)
	populate(objectMap, "schedulePolicy", s.SchedulePolicy)
	populate(objectMap, "snapshotBackupAdditionalDetails", s.SnapshotBackupAdditionalDetails)
	populate(objectMap, "tieringPolicy", s.TieringPolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubProtectionPolicy.
func (s *SubProtectionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "policyType":
			err = unpopulate(val, "PolicyType", &s.PolicyType)
			delete(rawMsg, key)
		case "retentionPolicy":
			s.RetentionPolicy, err = unmarshalRetentionPolicyClassification(val)
			delete(rawMsg, key)
		case "schedulePolicy":
			s.SchedulePolicy, err = unmarshalSchedulePolicyClassification(val)
			delete(rawMsg, key)
		case "snapshotBackupAdditionalDetails":
			err = unpopulate(val, "SnapshotBackupAdditionalDetails", &s.SnapshotBackupAdditionalDetails)
			delete(rawMsg, key)
		case "tieringPolicy":
			err = unpopulate(val, "TieringPolicy", &s.TieringPolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TieringPolicy.
func (t TieringPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "duration", t.Duration)
	populate(objectMap, "durationType", t.DurationType)
	populate(objectMap, "tieringMode", t.TieringMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TieringPolicy.
func (t *TieringPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "duration":
			err = unpopulate(val, "Duration", &t.Duration)
			delete(rawMsg, key)
		case "durationType":
			err = unpopulate(val, "DurationType", &t.DurationType)
			delete(rawMsg, key)
		case "tieringMode":
			err = unpopulate(val, "TieringMode", &t.TieringMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateACSSBackupConnectionRequest.
func (u UpdateACSSBackupConnectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateACSSBackupConnectionRequest.
func (u *UpdateACSSBackupConnectionRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "tags":
			err = unpopulate(val, "Tags", &u.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateConnectorRequest.
func (u UpdateConnectorRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", u.Identity)
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdateConnectorRequest.
func (u *UpdateConnectorRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
			err = unpopulate(val, "Identity", &u.Identity)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, "Tags", &u.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentityProperties.
func (u UserAssignedIdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentityProperties.
func (u *UserAssignedIdentityProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
			err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedManagedIdentityDetails.
func (u UserAssignedManagedIdentityDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identityArmId", u.IdentityArmID)
	populate(objectMap, "identityName", u.IdentityName)
	populate(objectMap, "userAssignedIdentityProperties", u.UserAssignedIdentityProperties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedManagedIdentityDetails.
func (u *UserAssignedManagedIdentityDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identityArmId":
			err = unpopulate(val, "IdentityArmID", &u.IdentityArmID)
			delete(rawMsg, key)
		case "identityName":
			err = unpopulate(val, "IdentityName", &u.IdentityName)
			delete(rawMsg, key)
		case "userAssignedIdentityProperties":
			err = unpopulate(val, "UserAssignedIdentityProperties", &u.UserAssignedIdentityProperties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedServiceIdentity.
func (u UserAssignedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", u.Type)
	populate(objectMap, "userAssignedIdentities", u.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedServiceIdentity.
func (u *UserAssignedServiceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, "Type", &u.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
			err = unpopulate(val, "UserAssignedIdentities", &u.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMBackupData.
func (v VMBackupData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backupPolicy", v.BackupPolicy)
	objectMap["backupType"] = BackupTypeVM
	populate(objectMap, "diskExclusionProperties", v.DiskExclusionProperties)
	populate(objectMap, "recoveryServicesVault", v.RecoveryServicesVault)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMBackupData.
func (v *VMBackupData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupPolicy":
			err = unpopulate(val, "BackupPolicy", &v.BackupPolicy)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, "BackupType", &v.BackupType)
			delete(rawMsg, key)
		case "diskExclusionProperties":
			err = unpopulate(val, "DiskExclusionProperties", &v.DiskExclusionProperties)
			delete(rawMsg, key)
		case "recoveryServicesVault":
			v.RecoveryServicesVault, err = unmarshalRecoveryServicesVaultPropertiesClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMBackupPolicyProperties.
func (v VMBackupPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMBackupPolicyProperties.
func (v *VMBackupPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
			err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, "Properties", &v.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WeeklyRetentionFormat.
func (w WeeklyRetentionFormat) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "daysOfTheWeek", w.DaysOfTheWeek)
	populate(objectMap, "weeksOfTheMonth", w.WeeksOfTheMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WeeklyRetentionFormat.
func (w *WeeklyRetentionFormat) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "daysOfTheWeek":
			err = unpopulate(val, "DaysOfTheWeek", &w.DaysOfTheWeek)
			delete(rawMsg, key)
		case "weeksOfTheMonth":
			err = unpopulate(val, "WeeksOfTheMonth", &w.WeeksOfTheMonth)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WeeklyRetentionSchedule.
func (w WeeklyRetentionSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "daysOfTheWeek", w.DaysOfTheWeek)
	populate(objectMap, "retentionDuration", w.RetentionDuration)
	aux := make([]*timeRFC3339, len(w.RetentionTimes), len(w.RetentionTimes))
	for i := 0; i < len(w.RetentionTimes); i++ {
		aux[i] = (*timeRFC3339)(w.RetentionTimes[i])
	}
	populate(objectMap, "retentionTimes", aux)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WeeklyRetentionSchedule.
func (w *WeeklyRetentionSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "daysOfTheWeek":
			err = unpopulate(val, "DaysOfTheWeek", &w.DaysOfTheWeek)
			delete(rawMsg, key)
		case "retentionDuration":
			err = unpopulate(val, "RetentionDuration", &w.RetentionDuration)
			delete(rawMsg, key)
		case "retentionTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "RetentionTimes", &aux)
			for _, au := range aux {
				w.RetentionTimes = append(w.RetentionTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WeeklySchedule.
func (w WeeklySchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "scheduleRunDays", w.ScheduleRunDays)
	aux := make([]*timeRFC3339, len(w.ScheduleRunTimes), len(w.ScheduleRunTimes))
	for i := 0; i < len(w.ScheduleRunTimes); i++ {
		aux[i] = (*timeRFC3339)(w.ScheduleRunTimes[i])
	}
	populate(objectMap, "scheduleRunTimes", aux)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WeeklySchedule.
func (w *WeeklySchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "scheduleRunDays":
			err = unpopulate(val, "ScheduleRunDays", &w.ScheduleRunDays)
			delete(rawMsg, key)
		case "scheduleRunTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "ScheduleRunTimes", &aux)
			for _, au := range aux {
				w.ScheduleRunTimes = append(w.ScheduleRunTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type YearlyRetentionSchedule.
func (y YearlyRetentionSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "monthsOfYear", y.MonthsOfYear)
	populate(objectMap, "retentionDuration", y.RetentionDuration)
	populate(objectMap, "retentionScheduleDaily", y.RetentionScheduleDaily)
	populate(objectMap, "retentionScheduleFormatType", y.RetentionScheduleFormatType)
	populate(objectMap, "retentionScheduleWeekly", y.RetentionScheduleWeekly)
	aux := make([]*timeRFC3339, len(y.RetentionTimes), len(y.RetentionTimes))
	for i := 0; i < len(y.RetentionTimes); i++ {
		aux[i] = (*timeRFC3339)(y.RetentionTimes[i])
	}
	populate(objectMap, "retentionTimes", aux)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type YearlyRetentionSchedule.
func (y *YearlyRetentionSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", y, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "monthsOfYear":
			err = unpopulate(val, "MonthsOfYear", &y.MonthsOfYear)
			delete(rawMsg, key)
		case "retentionDuration":
			err = unpopulate(val, "RetentionDuration", &y.RetentionDuration)
			delete(rawMsg, key)
		case "retentionScheduleDaily":
			err = unpopulate(val, "RetentionScheduleDaily", &y.RetentionScheduleDaily)
			delete(rawMsg, key)
		case "retentionScheduleFormatType":
			err = unpopulate(val, "RetentionScheduleFormatType", &y.RetentionScheduleFormatType)
			delete(rawMsg, key)
		case "retentionScheduleWeekly":
			err = unpopulate(val, "RetentionScheduleWeekly", &y.RetentionScheduleWeekly)
			delete(rawMsg, key)
		case "retentionTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "RetentionTimes", &aux)
			for _, au := range aux {
				y.RetentionTimes = append(y.RetentionTimes, (*time.Time)(au))
			}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", y, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}
