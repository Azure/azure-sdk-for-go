// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/armcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// DeploymentsClient contains the methods for the Deployments group.
// Don't use this type directly, use NewDeploymentsClient() instead.
type DeploymentsClient struct {
	con            *armcore.Connection
	subscriptionID string
}

// NewDeploymentsClient creates a new instance of DeploymentsClient with the specified values.
func NewDeploymentsClient(con *armcore.Connection, subscriptionID string) *DeploymentsClient {
	return &DeploymentsClient{con: con, subscriptionID: subscriptionID}
}

// CalculateTemplateHash - Calculate the hash of the given template.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CalculateTemplateHash(ctx context.Context, templateParam interface{}, options *DeploymentsCalculateTemplateHashOptions) (TemplateHashResultResponse, error) {
	req, err := client.calculateTemplateHashCreateRequest(ctx, templateParam, options)
	if err != nil {
		return TemplateHashResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TemplateHashResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TemplateHashResultResponse{}, client.calculateTemplateHashHandleError(resp)
	}
	return client.calculateTemplateHashHandleResponse(resp)
}

// calculateTemplateHashCreateRequest creates the CalculateTemplateHash request.
func (client *DeploymentsClient) calculateTemplateHashCreateRequest(ctx context.Context, templateParam interface{}, options *DeploymentsCalculateTemplateHashOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/calculateTemplateHash"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(templateParam)
}

// calculateTemplateHashHandleResponse handles the CalculateTemplateHash response.
func (client *DeploymentsClient) calculateTemplateHashHandleResponse(resp *azcore.Response) (TemplateHashResultResponse, error) {
	var val *TemplateHashResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TemplateHashResultResponse{}, err
	}
	return TemplateHashResultResponse{RawResponse: resp.Response, TemplateHashResult: val}, nil
}

// calculateTemplateHashHandleError handles the CalculateTemplateHash error response.
func (client *DeploymentsClient) calculateTemplateHashHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Cancel - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState is
// set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resource group partially deployed.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) Cancel(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*http.Response, error) {
	req, err := client.cancelCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelHandleError(resp)
	}
	return resp.Response, nil
}

// cancelCreateRequest creates the Cancel request.
func (client *DeploymentsClient) cancelCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCancelOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// cancelHandleError handles the Cancel error response.
func (client *DeploymentsClient) cancelHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CancelAtManagementGroupScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the
// provisioningState is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CancelAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*http.Response, error) {
	req, err := client.cancelAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelAtManagementGroupScopeHandleError(resp)
	}
	return resp.Response, nil
}

// cancelAtManagementGroupScopeCreateRequest creates the CancelAtManagementGroupScope request.
func (client *DeploymentsClient) cancelAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, options *DeploymentsCancelAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtManagementGroupScopeHandleError handles the CancelAtManagementGroupScope error response.
func (client *DeploymentsClient) cancelAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CancelAtScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
// is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CancelAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsCancelAtScopeOptions) (*http.Response, error) {
	req, err := client.cancelAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelAtScopeHandleError(resp)
	}
	return resp.Response, nil
}

// cancelAtScopeCreateRequest creates the CancelAtScope request.
func (client *DeploymentsClient) cancelAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsCancelAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtScopeHandleError handles the CancelAtScope error response.
func (client *DeploymentsClient) cancelAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CancelAtSubscriptionScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
// is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CancelAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*http.Response, error) {
	req, err := client.cancelAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelAtSubscriptionScopeHandleError(resp)
	}
	return resp.Response, nil
}

// cancelAtSubscriptionScopeCreateRequest creates the CancelAtSubscriptionScope request.
func (client *DeploymentsClient) cancelAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCancelAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtSubscriptionScopeHandleError handles the CancelAtSubscriptionScope error response.
func (client *DeploymentsClient) cancelAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CancelAtTenantScope - You can cancel a deployment only if the provisioningState is Accepted or Running. After the deployment is canceled, the provisioningState
// is set to Canceled. Canceling a template deployment stops the
// currently running template deployment and leaves the resources partially deployed.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CancelAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsCancelAtTenantScopeOptions) (*http.Response, error) {
	req, err := client.cancelAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.cancelAtTenantScopeHandleError(resp)
	}
	return resp.Response, nil
}

// cancelAtTenantScopeCreateRequest creates the CancelAtTenantScope request.
func (client *DeploymentsClient) cancelAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCancelAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/cancel"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// cancelAtTenantScopeHandleError handles the CancelAtTenantScope error response.
func (client *DeploymentsClient) cancelAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CheckExistence - Checks whether the deployment exists.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CheckExistence(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (BooleanResponse, error) {
	req, err := client.checkExistenceCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return BooleanResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BooleanResponse{}, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return BooleanResponse{}, client.checkExistenceHandleError(resp)
	}
}

// checkExistenceCreateRequest creates the CheckExistence request.
func (client *DeploymentsClient) checkExistenceCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsCheckExistenceOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// checkExistenceHandleError handles the CheckExistence error response.
func (client *DeploymentsClient) checkExistenceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CheckExistenceAtManagementGroupScope - Checks whether the deployment exists.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CheckExistenceAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (BooleanResponse, error) {
	req, err := client.checkExistenceAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return BooleanResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BooleanResponse{}, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return BooleanResponse{}, client.checkExistenceAtManagementGroupScopeHandleError(resp)
	}
}

// checkExistenceAtManagementGroupScopeCreateRequest creates the CheckExistenceAtManagementGroupScope request.
func (client *DeploymentsClient) checkExistenceAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, options *DeploymentsCheckExistenceAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// checkExistenceAtManagementGroupScopeHandleError handles the CheckExistenceAtManagementGroupScope error response.
func (client *DeploymentsClient) checkExistenceAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CheckExistenceAtScope - Checks whether the deployment exists.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CheckExistenceAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsCheckExistenceAtScopeOptions) (BooleanResponse, error) {
	req, err := client.checkExistenceAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return BooleanResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BooleanResponse{}, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return BooleanResponse{}, client.checkExistenceAtScopeHandleError(resp)
	}
}

// checkExistenceAtScopeCreateRequest creates the CheckExistenceAtScope request.
func (client *DeploymentsClient) checkExistenceAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsCheckExistenceAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// checkExistenceAtScopeHandleError handles the CheckExistenceAtScope error response.
func (client *DeploymentsClient) checkExistenceAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CheckExistenceAtSubscriptionScope - Checks whether the deployment exists.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CheckExistenceAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (BooleanResponse, error) {
	req, err := client.checkExistenceAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return BooleanResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BooleanResponse{}, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return BooleanResponse{}, client.checkExistenceAtSubscriptionScopeHandleError(resp)
	}
}

// checkExistenceAtSubscriptionScopeCreateRequest creates the CheckExistenceAtSubscriptionScope request.
func (client *DeploymentsClient) checkExistenceAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// checkExistenceAtSubscriptionScopeHandleError handles the CheckExistenceAtSubscriptionScope error response.
func (client *DeploymentsClient) checkExistenceAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// CheckExistenceAtTenantScope - Checks whether the deployment exists.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) CheckExistenceAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtTenantScopeOptions) (BooleanResponse, error) {
	req, err := client.checkExistenceAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return BooleanResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BooleanResponse{}, err
	}
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		return BooleanResponse{RawResponse: resp.Response, Success: true}, nil
	} else if resp.StatusCode >= 400 && resp.StatusCode < 500 {
		return BooleanResponse{RawResponse: resp.Response, Success: false}, nil
	} else {
		return BooleanResponse{}, client.checkExistenceAtTenantScopeHandleError(resp)
	}
}

// checkExistenceAtTenantScopeCreateRequest creates the CheckExistenceAtTenantScope request.
func (client *DeploymentsClient) checkExistenceAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsCheckExistenceAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodHead, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// checkExistenceAtTenantScopeHandleError handles the CheckExistenceAtTenantScope error response.
func (client *DeploymentsClient) checkExistenceAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginCreateOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateOptions) (DeploymentExtendedPollerResponse, error) {
	resp, err := client.createOrUpdate(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdate", "", resp, client.createOrUpdateHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdate creates a new DeploymentExtendedPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentExtendedPoller.ResumeToken().
func (client *DeploymentsClient) ResumeCreateOrUpdate(ctx context.Context, token string) (DeploymentExtendedPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdate", token, client.createOrUpdateHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdate - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) createOrUpdate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createOrUpdateHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *DeploymentsClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *DeploymentsClient) createOrUpdateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginCreateOrUpdateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginCreateOrUpdateAtManagementGroupScopeOptions) (DeploymentExtendedPollerResponse, error) {
	resp, err := client.createOrUpdateAtManagementGroupScope(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", "", resp, client.createOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateAtManagementGroupScope creates a new DeploymentExtendedPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentExtendedPoller.ResumeToken().
func (client *DeploymentsClient) ResumeCreateOrUpdateAtManagementGroupScope(ctx context.Context, token string) (DeploymentExtendedPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtManagementGroupScope", token, client.createOrUpdateAtManagementGroupScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateAtManagementGroupScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) createOrUpdateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginCreateOrUpdateAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createOrUpdateAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateAtManagementGroupScopeCreateRequest creates the CreateOrUpdateAtManagementGroupScope request.
func (client *DeploymentsClient) createOrUpdateAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginCreateOrUpdateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateAtManagementGroupScopeHandleError handles the CreateOrUpdateAtManagementGroupScope error response.
func (client *DeploymentsClient) createOrUpdateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateAtScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginCreateOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateAtScopeOptions) (DeploymentExtendedPollerResponse, error) {
	resp, err := client.createOrUpdateAtScope(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtScope", "", resp, client.createOrUpdateAtScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateAtScope creates a new DeploymentExtendedPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentExtendedPoller.ResumeToken().
func (client *DeploymentsClient) ResumeCreateOrUpdateAtScope(ctx context.Context, token string) (DeploymentExtendedPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtScope", token, client.createOrUpdateAtScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateAtScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) createOrUpdateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateAtScopeOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateAtScopeCreateRequest(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createOrUpdateAtScopeHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateAtScopeCreateRequest creates the CreateOrUpdateAtScope request.
func (client *DeploymentsClient) createOrUpdateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateAtScopeHandleError handles the CreateOrUpdateAtScope error response.
func (client *DeploymentsClient) createOrUpdateAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginCreateOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateAtSubscriptionScopeOptions) (DeploymentExtendedPollerResponse, error) {
	resp, err := client.createOrUpdateAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", "", resp, client.createOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateAtSubscriptionScope creates a new DeploymentExtendedPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentExtendedPoller.ResumeToken().
func (client *DeploymentsClient) ResumeCreateOrUpdateAtSubscriptionScope(ctx context.Context, token string) (DeploymentExtendedPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtSubscriptionScope", token, client.createOrUpdateAtSubscriptionScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateAtSubscriptionScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) createOrUpdateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createOrUpdateAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateAtSubscriptionScopeCreateRequest creates the CreateOrUpdateAtSubscriptionScope request.
func (client *DeploymentsClient) createOrUpdateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsBeginCreateOrUpdateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateAtSubscriptionScopeHandleError handles the CreateOrUpdateAtSubscriptionScope error response.
func (client *DeploymentsClient) createOrUpdateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginCreateOrUpdateAtTenantScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginCreateOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginCreateOrUpdateAtTenantScopeOptions) (DeploymentExtendedPollerResponse, error) {
	resp, err := client.createOrUpdateAtTenantScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.CreateOrUpdateAtTenantScope", "", resp, client.createOrUpdateAtTenantScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeCreateOrUpdateAtTenantScope creates a new DeploymentExtendedPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentExtendedPoller.ResumeToken().
func (client *DeploymentsClient) ResumeCreateOrUpdateAtTenantScope(ctx context.Context, token string) (DeploymentExtendedPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.CreateOrUpdateAtTenantScope", token, client.createOrUpdateAtTenantScopeHandleError)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	poller := &deploymentExtendedPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentExtendedPollerResponse{}, err
	}
	result := DeploymentExtendedPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentExtendedResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// CreateOrUpdateAtTenantScope - You can provide the template and parameters directly in the request or link to JSON files.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) createOrUpdateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginCreateOrUpdateAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.createOrUpdateAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createOrUpdateAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// createOrUpdateAtTenantScopeCreateRequest creates the CreateOrUpdateAtTenantScope request.
func (client *DeploymentsClient) createOrUpdateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginCreateOrUpdateAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// createOrUpdateAtTenantScopeHandleError handles the CreateOrUpdateAtTenantScope error response.
func (client *DeploymentsClient) createOrUpdateAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDelete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations.
// Deleting a template deployment does not affect the state
// of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location
// response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process
// finishes, the URI in the Location header returns a
// status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginDelete(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsBeginDeleteOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteOperation(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.Delete", "", resp, client.deleteHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDelete creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *DeploymentsClient) ResumeDelete(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.Delete", token, client.deleteHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Delete - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations.
// Deleting a template deployment does not affect the state
// of the resource group. This is an asynchronous operation that returns a status of 202 until the template deployment is successfully deleted. The Location
// response header contains the URI that is used
// to obtain the status of the process. While the process is running, a call to the URI in the Location header returns a status of 202. When the process
// finishes, the URI in the Location header returns a
// status of 204 on success. If the asynchronous request failed, the URI in the Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) deleteOperation(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsBeginDeleteOptions) (*azcore.Response, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp, nil
}

// deleteCreateRequest creates the Delete request.
func (client *DeploymentsClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsBeginDeleteOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *DeploymentsClient) deleteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
// deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginDeleteAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *DeploymentsBeginDeleteAtManagementGroupScopeOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAtManagementGroupScope(ctx, groupID, deploymentName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtManagementGroupScope", "", resp, client.deleteAtManagementGroupScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAtManagementGroupScope creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *DeploymentsClient) ResumeDeleteAtManagementGroupScope(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtManagementGroupScope", token, client.deleteAtManagementGroupScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAtManagementGroupScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
// deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) deleteAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *DeploymentsBeginDeleteAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.deleteAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// deleteAtManagementGroupScopeCreateRequest creates the DeleteAtManagementGroupScope request.
func (client *DeploymentsClient) deleteAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, options *DeploymentsBeginDeleteAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtManagementGroupScopeHandleError handles the DeleteAtManagementGroupScope error response.
func (client *DeploymentsClient) deleteAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAtScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment
// operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginDeleteAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsBeginDeleteAtScopeOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAtScope(ctx, scope, deploymentName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtScope", "", resp, client.deleteAtScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAtScope creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *DeploymentsClient) ResumeDeleteAtScope(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtScope", token, client.deleteAtScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAtScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment operations.
// This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) deleteAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsBeginDeleteAtScopeOptions) (*azcore.Response, error) {
	req, err := client.deleteAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAtScopeHandleError(resp)
	}
	return resp, nil
}

// deleteAtScopeCreateRequest creates the DeleteAtScope request.
func (client *DeploymentsClient) deleteAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsBeginDeleteAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtScopeHandleError handles the DeleteAtScope error response.
func (client *DeploymentsClient) deleteAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
// deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginDeleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsBeginDeleteAtSubscriptionScopeOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAtSubscriptionScope(ctx, deploymentName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtSubscriptionScope", "", resp, client.deleteAtSubscriptionScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAtSubscriptionScope creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *DeploymentsClient) ResumeDeleteAtSubscriptionScope(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtSubscriptionScope", token, client.deleteAtSubscriptionScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAtSubscriptionScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated
// deployment operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) deleteAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsBeginDeleteAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.deleteAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// deleteAtSubscriptionScopeCreateRequest creates the DeleteAtSubscriptionScope request.
func (client *DeploymentsClient) deleteAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsBeginDeleteAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtSubscriptionScopeHandleError handles the DeleteAtSubscriptionScope error response.
func (client *DeploymentsClient) deleteAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginDeleteAtTenantScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment
// operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginDeleteAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsBeginDeleteAtTenantScopeOptions) (HTTPPollerResponse, error) {
	resp, err := client.deleteAtTenantScope(ctx, deploymentName, options)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.DeleteAtTenantScope", "", resp, client.deleteAtTenantScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeDeleteAtTenantScope creates a new HTTPPoller from the specified resume token.
// token - The value must come from a previous call to HTTPPoller.ResumeToken().
func (client *DeploymentsClient) ResumeDeleteAtTenantScope(ctx context.Context, token string) (HTTPPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.DeleteAtTenantScope", token, client.deleteAtTenantScopeHandleError)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	poller := &httpPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return HTTPPollerResponse{}, err
	}
	result := HTTPPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (*http.Response, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// DeleteAtTenantScope - A template deployment that is currently running cannot be deleted. Deleting a template deployment removes the associated deployment
// operations. This is an asynchronous operation that returns a status
// of 202 until the template deployment is successfully deleted. The Location response header contains the URI that is used to obtain the status of the
// process. While the process is running, a call to
// the URI in the Location header returns a status of 202. When the process finishes, the URI in the Location header returns a status of 204 on success.
// If the asynchronous request failed, the URI in the
// Location header returns an error-level status code.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) deleteAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsBeginDeleteAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.deleteAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// deleteAtTenantScopeCreateRequest creates the DeleteAtTenantScope request.
func (client *DeploymentsClient) deleteAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsBeginDeleteAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteAtTenantScopeHandleError handles the DeleteAtTenantScope error response.
func (client *DeploymentsClient) deleteAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ExportTemplate - Exports the template used for specified deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ExportTemplate(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExportResultResponse{}, client.exportTemplateHandleError(resp)
	}
	return client.exportTemplateHandleResponse(resp)
}

// exportTemplateCreateRequest creates the ExportTemplate request.
func (client *DeploymentsClient) exportTemplateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsExportTemplateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// exportTemplateHandleResponse handles the ExportTemplate response.
func (client *DeploymentsClient) exportTemplateHandleResponse(resp *azcore.Response) (DeploymentExportResultResponse, error) {
	var val *DeploymentExportResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExportResultResponse{}, err
	}
	return DeploymentExportResultResponse{RawResponse: resp.Response, DeploymentExportResult: val}, nil
}

// exportTemplateHandleError handles the ExportTemplate error response.
func (client *DeploymentsClient) exportTemplateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ExportTemplateAtManagementGroupScope - Exports the template used for specified deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ExportTemplateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExportResultResponse{}, client.exportTemplateAtManagementGroupScopeHandleError(resp)
	}
	return client.exportTemplateAtManagementGroupScopeHandleResponse(resp)
}

// exportTemplateAtManagementGroupScopeCreateRequest creates the ExportTemplateAtManagementGroupScope request.
func (client *DeploymentsClient) exportTemplateAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, options *DeploymentsExportTemplateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// exportTemplateAtManagementGroupScopeHandleResponse handles the ExportTemplateAtManagementGroupScope response.
func (client *DeploymentsClient) exportTemplateAtManagementGroupScopeHandleResponse(resp *azcore.Response) (DeploymentExportResultResponse, error) {
	var val *DeploymentExportResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExportResultResponse{}, err
	}
	return DeploymentExportResultResponse{RawResponse: resp.Response, DeploymentExportResult: val}, nil
}

// exportTemplateAtManagementGroupScopeHandleError handles the ExportTemplateAtManagementGroupScope error response.
func (client *DeploymentsClient) exportTemplateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ExportTemplateAtScope - Exports the template used for specified deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ExportTemplateAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsExportTemplateAtScopeOptions) (DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExportResultResponse{}, client.exportTemplateAtScopeHandleError(resp)
	}
	return client.exportTemplateAtScopeHandleResponse(resp)
}

// exportTemplateAtScopeCreateRequest creates the ExportTemplateAtScope request.
func (client *DeploymentsClient) exportTemplateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsExportTemplateAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// exportTemplateAtScopeHandleResponse handles the ExportTemplateAtScope response.
func (client *DeploymentsClient) exportTemplateAtScopeHandleResponse(resp *azcore.Response) (DeploymentExportResultResponse, error) {
	var val *DeploymentExportResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExportResultResponse{}, err
	}
	return DeploymentExportResultResponse{RawResponse: resp.Response, DeploymentExportResult: val}, nil
}

// exportTemplateAtScopeHandleError handles the ExportTemplateAtScope error response.
func (client *DeploymentsClient) exportTemplateAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ExportTemplateAtSubscriptionScope - Exports the template used for specified deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ExportTemplateAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExportResultResponse{}, client.exportTemplateAtSubscriptionScopeHandleError(resp)
	}
	return client.exportTemplateAtSubscriptionScopeHandleResponse(resp)
}

// exportTemplateAtSubscriptionScopeCreateRequest creates the ExportTemplateAtSubscriptionScope request.
func (client *DeploymentsClient) exportTemplateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// exportTemplateAtSubscriptionScopeHandleResponse handles the ExportTemplateAtSubscriptionScope response.
func (client *DeploymentsClient) exportTemplateAtSubscriptionScopeHandleResponse(resp *azcore.Response) (DeploymentExportResultResponse, error) {
	var val *DeploymentExportResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExportResultResponse{}, err
	}
	return DeploymentExportResultResponse{RawResponse: resp.Response, DeploymentExportResult: val}, nil
}

// exportTemplateAtSubscriptionScopeHandleError handles the ExportTemplateAtSubscriptionScope error response.
func (client *DeploymentsClient) exportTemplateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ExportTemplateAtTenantScope - Exports the template used for specified deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ExportTemplateAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtTenantScopeOptions) (DeploymentExportResultResponse, error) {
	req, err := client.exportTemplateAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExportResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExportResultResponse{}, client.exportTemplateAtTenantScopeHandleError(resp)
	}
	return client.exportTemplateAtTenantScopeHandleResponse(resp)
}

// exportTemplateAtTenantScopeCreateRequest creates the ExportTemplateAtTenantScope request.
func (client *DeploymentsClient) exportTemplateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsExportTemplateAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/exportTemplate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// exportTemplateAtTenantScopeHandleResponse handles the ExportTemplateAtTenantScope response.
func (client *DeploymentsClient) exportTemplateAtTenantScopeHandleResponse(resp *azcore.Response) (DeploymentExportResultResponse, error) {
	var val *DeploymentExportResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExportResultResponse{}, err
	}
	return DeploymentExportResultResponse{RawResponse: resp.Response, DeploymentExportResult: val}, nil
}

// exportTemplateAtTenantScopeHandleError handles the ExportTemplateAtTenantScope error response.
func (client *DeploymentsClient) exportTemplateAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Get - Gets a deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) Get(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (DeploymentExtendedResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, deploymentName, options)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExtendedResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *DeploymentsClient) getCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, options *DeploymentsGetOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *DeploymentsClient) getHandleResponse(resp *azcore.Response) (DeploymentExtendedResponse, error) {
	var val *DeploymentExtended
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExtendedResponse{}, err
	}
	return DeploymentExtendedResponse{RawResponse: resp.Response, DeploymentExtended: val}, nil
}

// getHandleError handles the Get error response.
func (client *DeploymentsClient) getHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAtManagementGroupScope - Gets a deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) GetAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (DeploymentExtendedResponse, error) {
	req, err := client.getAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, options)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExtendedResponse{}, client.getAtManagementGroupScopeHandleError(resp)
	}
	return client.getAtManagementGroupScopeHandleResponse(resp)
}

// getAtManagementGroupScopeCreateRequest creates the GetAtManagementGroupScope request.
func (client *DeploymentsClient) getAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, options *DeploymentsGetAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAtManagementGroupScopeHandleResponse handles the GetAtManagementGroupScope response.
func (client *DeploymentsClient) getAtManagementGroupScopeHandleResponse(resp *azcore.Response) (DeploymentExtendedResponse, error) {
	var val *DeploymentExtended
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExtendedResponse{}, err
	}
	return DeploymentExtendedResponse{RawResponse: resp.Response, DeploymentExtended: val}, nil
}

// getAtManagementGroupScopeHandleError handles the GetAtManagementGroupScope error response.
func (client *DeploymentsClient) getAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAtScope - Gets a deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) GetAtScope(ctx context.Context, scope string, deploymentName string, options *DeploymentsGetAtScopeOptions) (DeploymentExtendedResponse, error) {
	req, err := client.getAtScopeCreateRequest(ctx, scope, deploymentName, options)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExtendedResponse{}, client.getAtScopeHandleError(resp)
	}
	return client.getAtScopeHandleResponse(resp)
}

// getAtScopeCreateRequest creates the GetAtScope request.
func (client *DeploymentsClient) getAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, options *DeploymentsGetAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAtScopeHandleResponse handles the GetAtScope response.
func (client *DeploymentsClient) getAtScopeHandleResponse(resp *azcore.Response) (DeploymentExtendedResponse, error) {
	var val *DeploymentExtended
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExtendedResponse{}, err
	}
	return DeploymentExtendedResponse{RawResponse: resp.Response, DeploymentExtended: val}, nil
}

// getAtScopeHandleError handles the GetAtScope error response.
func (client *DeploymentsClient) getAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAtSubscriptionScope - Gets a deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) GetAtSubscriptionScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (DeploymentExtendedResponse, error) {
	req, err := client.getAtSubscriptionScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExtendedResponse{}, client.getAtSubscriptionScopeHandleError(resp)
	}
	return client.getAtSubscriptionScopeHandleResponse(resp)
}

// getAtSubscriptionScopeCreateRequest creates the GetAtSubscriptionScope request.
func (client *DeploymentsClient) getAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsGetAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAtSubscriptionScopeHandleResponse handles the GetAtSubscriptionScope response.
func (client *DeploymentsClient) getAtSubscriptionScopeHandleResponse(resp *azcore.Response) (DeploymentExtendedResponse, error) {
	var val *DeploymentExtended
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExtendedResponse{}, err
	}
	return DeploymentExtendedResponse{RawResponse: resp.Response, DeploymentExtended: val}, nil
}

// getAtSubscriptionScopeHandleError handles the GetAtSubscriptionScope error response.
func (client *DeploymentsClient) getAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAtTenantScope - Gets a deployment.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) GetAtTenantScope(ctx context.Context, deploymentName string, options *DeploymentsGetAtTenantScopeOptions) (DeploymentExtendedResponse, error) {
	req, err := client.getAtTenantScopeCreateRequest(ctx, deploymentName, options)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DeploymentExtendedResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DeploymentExtendedResponse{}, client.getAtTenantScopeHandleError(resp)
	}
	return client.getAtTenantScopeHandleResponse(resp)
}

// getAtTenantScopeCreateRequest creates the GetAtTenantScope request.
func (client *DeploymentsClient) getAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, options *DeploymentsGetAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getAtTenantScopeHandleResponse handles the GetAtTenantScope response.
func (client *DeploymentsClient) getAtTenantScopeHandleResponse(resp *azcore.Response) (DeploymentExtendedResponse, error) {
	var val *DeploymentExtended
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentExtendedResponse{}, err
	}
	return DeploymentExtendedResponse{RawResponse: resp.Response, DeploymentExtended: val}, nil
}

// getAtTenantScopeHandleError handles the GetAtTenantScope error response.
func (client *DeploymentsClient) getAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAtManagementGroupScope - Get all the deployments for a management group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ListAtManagementGroupScope(groupID string, options *DeploymentsListAtManagementGroupScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listAtManagementGroupScopeCreateRequest(ctx, groupID, options)
		},
		responder: client.listAtManagementGroupScopeHandleResponse,
		errorer:   client.listAtManagementGroupScopeHandleError,
		advancer: func(ctx context.Context, resp DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listAtManagementGroupScopeCreateRequest creates the ListAtManagementGroupScope request.
func (client *DeploymentsClient) listAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, options *DeploymentsListAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAtManagementGroupScopeHandleResponse handles the ListAtManagementGroupScope response.
func (client *DeploymentsClient) listAtManagementGroupScopeHandleResponse(resp *azcore.Response) (DeploymentListResultResponse, error) {
	var val *DeploymentListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentListResultResponse{}, err
	}
	return DeploymentListResultResponse{RawResponse: resp.Response, DeploymentListResult: val}, nil
}

// listAtManagementGroupScopeHandleError handles the ListAtManagementGroupScope error response.
func (client *DeploymentsClient) listAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAtScope - Get all the deployments at the given scope.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ListAtScope(scope string, options *DeploymentsListAtScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listAtScopeCreateRequest(ctx, scope, options)
		},
		responder: client.listAtScopeHandleResponse,
		errorer:   client.listAtScopeHandleError,
		advancer: func(ctx context.Context, resp DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listAtScopeCreateRequest creates the ListAtScope request.
func (client *DeploymentsClient) listAtScopeCreateRequest(ctx context.Context, scope string, options *DeploymentsListAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAtScopeHandleResponse handles the ListAtScope response.
func (client *DeploymentsClient) listAtScopeHandleResponse(resp *azcore.Response) (DeploymentListResultResponse, error) {
	var val *DeploymentListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentListResultResponse{}, err
	}
	return DeploymentListResultResponse{RawResponse: resp.Response, DeploymentListResult: val}, nil
}

// listAtScopeHandleError handles the ListAtScope error response.
func (client *DeploymentsClient) listAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAtSubscriptionScope - Get all the deployments for a subscription.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ListAtSubscriptionScope(options *DeploymentsListAtSubscriptionScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listAtSubscriptionScopeCreateRequest(ctx, options)
		},
		responder: client.listAtSubscriptionScopeHandleResponse,
		errorer:   client.listAtSubscriptionScopeHandleError,
		advancer: func(ctx context.Context, resp DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listAtSubscriptionScopeCreateRequest creates the ListAtSubscriptionScope request.
func (client *DeploymentsClient) listAtSubscriptionScopeCreateRequest(ctx context.Context, options *DeploymentsListAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAtSubscriptionScopeHandleResponse handles the ListAtSubscriptionScope response.
func (client *DeploymentsClient) listAtSubscriptionScopeHandleResponse(resp *azcore.Response) (DeploymentListResultResponse, error) {
	var val *DeploymentListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentListResultResponse{}, err
	}
	return DeploymentListResultResponse{RawResponse: resp.Response, DeploymentListResult: val}, nil
}

// listAtSubscriptionScopeHandleError handles the ListAtSubscriptionScope error response.
func (client *DeploymentsClient) listAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListAtTenantScope - Get all the deployments at the tenant scope.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ListAtTenantScope(options *DeploymentsListAtTenantScopeOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listAtTenantScopeCreateRequest(ctx, options)
		},
		responder: client.listAtTenantScopeHandleResponse,
		errorer:   client.listAtTenantScopeHandleError,
		advancer: func(ctx context.Context, resp DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listAtTenantScopeCreateRequest creates the ListAtTenantScope request.
func (client *DeploymentsClient) listAtTenantScopeCreateRequest(ctx context.Context, options *DeploymentsListAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listAtTenantScopeHandleResponse handles the ListAtTenantScope response.
func (client *DeploymentsClient) listAtTenantScopeHandleResponse(resp *azcore.Response) (DeploymentListResultResponse, error) {
	var val *DeploymentListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentListResultResponse{}, err
	}
	return DeploymentListResultResponse{RawResponse: resp.Response, DeploymentListResult: val}, nil
}

// listAtTenantScopeHandleError handles the ListAtTenantScope error response.
func (client *DeploymentsClient) listAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListByResourceGroup - Get all the deployments for a resource group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) ListByResourceGroup(resourceGroupName string, options *DeploymentsListByResourceGroupOptions) DeploymentListResultPager {
	return &deploymentListResultPager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
		},
		responder: client.listByResourceGroupHandleResponse,
		errorer:   client.listByResourceGroupHandleError,
		advancer: func(ctx context.Context, resp DeploymentListResultResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.DeploymentListResult.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *DeploymentsClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *DeploymentsListByResourceGroupOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *DeploymentsClient) listByResourceGroupHandleResponse(resp *azcore.Response) (DeploymentListResultResponse, error) {
	var val *DeploymentListResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DeploymentListResultResponse{}, err
	}
	return DeploymentListResultResponse{RawResponse: resp.Response, DeploymentListResult: val}, nil
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *DeploymentsClient) listByResourceGroupHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginValidate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginValidate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateOptions) (DeploymentValidateResultPollerResponse, error) {
	resp, err := client.validate(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.Validate", "", resp, client.validateHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeValidate creates a new DeploymentValidateResultPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentValidateResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeValidate(ctx context.Context, token string) (DeploymentValidateResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.Validate", token, client.validateHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// Validate - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) validate(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateOptions) (*azcore.Response, error) {
	req, err := client.validateCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.validateHandleError(resp)
	}
	return resp, nil
}

// validateCreateRequest creates the Validate request.
func (client *DeploymentsClient) validateCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// validateHandleError handles the Validate error response.
func (client *DeploymentsClient) validateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginValidateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginValidateAtManagementGroupScopeOptions) (DeploymentValidateResultPollerResponse, error) {
	resp, err := client.validateAtManagementGroupScope(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtManagementGroupScope", "", resp, client.validateAtManagementGroupScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeValidateAtManagementGroupScope creates a new DeploymentValidateResultPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentValidateResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeValidateAtManagementGroupScope(ctx context.Context, token string) (DeploymentValidateResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtManagementGroupScope", token, client.validateAtManagementGroupScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ValidateAtManagementGroupScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) validateAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginValidateAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.validateAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.validateAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// validateAtManagementGroupScopeCreateRequest creates the ValidateAtManagementGroupScope request.
func (client *DeploymentsClient) validateAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginValidateAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// validateAtManagementGroupScopeHandleError handles the ValidateAtManagementGroupScope error response.
func (client *DeploymentsClient) validateAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginValidateAtScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginValidateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateAtScopeOptions) (DeploymentValidateResultPollerResponse, error) {
	resp, err := client.validateAtScope(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtScope", "", resp, client.validateAtScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeValidateAtScope creates a new DeploymentValidateResultPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentValidateResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeValidateAtScope(ctx context.Context, token string) (DeploymentValidateResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtScope", token, client.validateAtScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ValidateAtScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) validateAtScope(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateAtScopeOptions) (*azcore.Response, error) {
	req, err := client.validateAtScopeCreateRequest(ctx, scope, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.validateAtScopeHandleError(resp)
	}
	return resp, nil
}

// validateAtScopeCreateRequest creates the ValidateAtScope request.
func (client *DeploymentsClient) validateAtScopeCreateRequest(ctx context.Context, scope string, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateAtScopeOptions) (*azcore.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if scope == "" {
		return nil, errors.New("parameter scope cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{scope}", scope)
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// validateAtScopeHandleError handles the ValidateAtScope error response.
func (client *DeploymentsClient) validateAtScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginValidateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateAtSubscriptionScopeOptions) (DeploymentValidateResultPollerResponse, error) {
	resp, err := client.validateAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtSubscriptionScope", "", resp, client.validateAtSubscriptionScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeValidateAtSubscriptionScope creates a new DeploymentValidateResultPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentValidateResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeValidateAtSubscriptionScope(ctx context.Context, token string) (DeploymentValidateResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtSubscriptionScope", token, client.validateAtSubscriptionScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ValidateAtSubscriptionScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) validateAtSubscriptionScope(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.validateAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.validateAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// validateAtSubscriptionScopeCreateRequest creates the ValidateAtSubscriptionScope request.
func (client *DeploymentsClient) validateAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters Deployment, options *DeploymentsBeginValidateAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// validateAtSubscriptionScopeHandleError handles the ValidateAtSubscriptionScope error response.
func (client *DeploymentsClient) validateAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginValidateAtTenantScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginValidateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginValidateAtTenantScopeOptions) (DeploymentValidateResultPollerResponse, error) {
	resp, err := client.validateAtTenantScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.ValidateAtTenantScope", "", resp, client.validateAtTenantScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeValidateAtTenantScope creates a new DeploymentValidateResultPoller from the specified resume token.
// token - The value must come from a previous call to DeploymentValidateResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeValidateAtTenantScope(ctx context.Context, token string) (DeploymentValidateResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.ValidateAtTenantScope", token, client.validateAtTenantScopeHandleError)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	poller := &deploymentValidateResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return DeploymentValidateResultPollerResponse{}, err
	}
	result := DeploymentValidateResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (DeploymentValidateResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ValidateAtTenantScope - Validates whether the specified template is syntactically correct and will be accepted by Azure Resource Manager..
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) validateAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginValidateAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.validateAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest) {
		return nil, client.validateAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// validateAtTenantScopeCreateRequest creates the ValidateAtTenantScope request.
func (client *DeploymentsClient) validateAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeployment, options *DeploymentsBeginValidateAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/validate"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// validateAtTenantScopeHandleError handles the ValidateAtTenantScope error response.
func (client *DeploymentsClient) validateAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginWhatIf - Returns changes that will be made by the deployment if executed at the scope of the resource group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginWhatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsBeginWhatIfOptions) (WhatIfOperationResultPollerResponse, error) {
	resp, err := client.whatIf(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIf", "location", resp, client.whatIfHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeWhatIf creates a new WhatIfOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to WhatIfOperationResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeWhatIf(ctx context.Context, token string) (WhatIfOperationResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIf", token, client.whatIfHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// WhatIf - Returns changes that will be made by the deployment if executed at the scope of the resource group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) whatIf(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsBeginWhatIfOptions) (*azcore.Response, error) {
	req, err := client.whatIfCreateRequest(ctx, resourceGroupName, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.whatIfHandleError(resp)
	}
	return resp, nil
}

// whatIfCreateRequest creates the WhatIf request.
func (client *DeploymentsClient) whatIfCreateRequest(ctx context.Context, resourceGroupName string, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsBeginWhatIfOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// whatIfHandleError handles the WhatIf error response.
func (client *DeploymentsClient) whatIfHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginWhatIfAtManagementGroupScope - Returns changes that will be made by the deployment if executed at the scope of the management group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginWhatIfAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsBeginWhatIfAtManagementGroupScopeOptions) (WhatIfOperationResultPollerResponse, error) {
	resp, err := client.whatIfAtManagementGroupScope(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIfAtManagementGroupScope", "location", resp, client.whatIfAtManagementGroupScopeHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeWhatIfAtManagementGroupScope creates a new WhatIfOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to WhatIfOperationResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeWhatIfAtManagementGroupScope(ctx context.Context, token string) (WhatIfOperationResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtManagementGroupScope", token, client.whatIfAtManagementGroupScopeHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// WhatIfAtManagementGroupScope - Returns changes that will be made by the deployment if executed at the scope of the management group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) whatIfAtManagementGroupScope(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsBeginWhatIfAtManagementGroupScopeOptions) (*azcore.Response, error) {
	req, err := client.whatIfAtManagementGroupScopeCreateRequest(ctx, groupID, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.whatIfAtManagementGroupScopeHandleError(resp)
	}
	return resp, nil
}

// whatIfAtManagementGroupScopeCreateRequest creates the WhatIfAtManagementGroupScope request.
func (client *DeploymentsClient) whatIfAtManagementGroupScopeCreateRequest(ctx context.Context, groupID string, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsBeginWhatIfAtManagementGroupScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Management/managementGroups/{groupId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if groupID == "" {
		return nil, errors.New("parameter groupID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{groupId}", url.PathEscape(groupID))
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// whatIfAtManagementGroupScopeHandleError handles the WhatIfAtManagementGroupScope error response.
func (client *DeploymentsClient) whatIfAtManagementGroupScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginWhatIfAtSubscriptionScope - Returns changes that will be made by the deployment if executed at the scope of the subscription.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginWhatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsBeginWhatIfAtSubscriptionScopeOptions) (WhatIfOperationResultPollerResponse, error) {
	resp, err := client.whatIfAtSubscriptionScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIfAtSubscriptionScope", "location", resp, client.whatIfAtSubscriptionScopeHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeWhatIfAtSubscriptionScope creates a new WhatIfOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to WhatIfOperationResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeWhatIfAtSubscriptionScope(ctx context.Context, token string) (WhatIfOperationResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtSubscriptionScope", token, client.whatIfAtSubscriptionScopeHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// WhatIfAtSubscriptionScope - Returns changes that will be made by the deployment if executed at the scope of the subscription.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) whatIfAtSubscriptionScope(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsBeginWhatIfAtSubscriptionScopeOptions) (*azcore.Response, error) {
	req, err := client.whatIfAtSubscriptionScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.whatIfAtSubscriptionScopeHandleError(resp)
	}
	return resp, nil
}

// whatIfAtSubscriptionScopeCreateRequest creates the WhatIfAtSubscriptionScope request.
func (client *DeploymentsClient) whatIfAtSubscriptionScopeCreateRequest(ctx context.Context, deploymentName string, parameters DeploymentWhatIf, options *DeploymentsBeginWhatIfAtSubscriptionScopeOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// whatIfAtSubscriptionScopeHandleError handles the WhatIfAtSubscriptionScope error response.
func (client *DeploymentsClient) whatIfAtSubscriptionScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginWhatIfAtTenantScope - Returns changes that will be made by the deployment if executed at the scope of the tenant group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) BeginWhatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsBeginWhatIfAtTenantScopeOptions) (WhatIfOperationResultPollerResponse, error) {
	resp, err := client.whatIfAtTenantScope(ctx, deploymentName, parameters, options)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := armcore.NewPoller("DeploymentsClient.WhatIfAtTenantScope", "location", resp, client.whatIfAtTenantScopeHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeWhatIfAtTenantScope creates a new WhatIfOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to WhatIfOperationResultPoller.ResumeToken().
func (client *DeploymentsClient) ResumeWhatIfAtTenantScope(ctx context.Context, token string) (WhatIfOperationResultPollerResponse, error) {
	pt, err := armcore.NewPollerFromResumeToken("DeploymentsClient.WhatIfAtTenantScope", token, client.whatIfAtTenantScopeHandleError)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	poller := &whatIfOperationResultPoller{
		pipeline: client.con.Pipeline(),
		pt:       pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return WhatIfOperationResultPollerResponse{}, err
	}
	result := WhatIfOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (WhatIfOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// WhatIfAtTenantScope - Returns changes that will be made by the deployment if executed at the scope of the tenant group.
// If the operation fails it returns the *CloudError error type.
func (client *DeploymentsClient) whatIfAtTenantScope(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsBeginWhatIfAtTenantScopeOptions) (*azcore.Response, error) {
	req, err := client.whatIfAtTenantScopeCreateRequest(ctx, deploymentName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.whatIfAtTenantScopeHandleError(resp)
	}
	return resp, nil
}

// whatIfAtTenantScopeCreateRequest creates the WhatIfAtTenantScope request.
func (client *DeploymentsClient) whatIfAtTenantScopeCreateRequest(ctx context.Context, deploymentName string, parameters ScopedDeploymentWhatIf, options *DeploymentsBeginWhatIfAtTenantScopeOptions) (*azcore.Request, error) {
	urlPath := "/providers/Microsoft.Resources/deployments/{deploymentName}/whatIf"
	if deploymentName == "" {
		return nil, errors.New("parameter deploymentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deploymentName}", url.PathEscape(deploymentName))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2021-04-01")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(parameters)
}

// whatIfAtTenantScopeHandleError handles the WhatIfAtTenantScope error response.
func (client *DeploymentsClient) whatIfAtTenantScopeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := CloudError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
