//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// DO NOT EDIT.

package rbac

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strings"
)

// Client contains the methods for the Client group.
// Don't use this type directly, use NewClient() instead.
type Client struct {
	endpoint string
	pl       runtime.Pipeline
}

// CreateOrUpdateRoleDefinition - Creates or updates a custom role definition.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.4
// scope - The scope of the role definition to create or update. Managed HSM only supports '/'.
// roleDefinitionName - The name of the role definition to create or update. It can be any valid GUID.
// parameters - Parameters for the role definition.
// options - ClientCreateOrUpdateRoleDefinitionOptions contains the optional parameters for the Client.CreateOrUpdateRoleDefinition
// method.
func (client *Client) CreateOrUpdateRoleDefinition(ctx context.Context, scope RoleScope, roleDefinitionName string, parameters RoleDefinitionCreateParameters, options *ClientCreateOrUpdateRoleDefinitionOptions) (ClientCreateOrUpdateRoleDefinitionResponse, error) {
	req, err := client.createOrUpdateRoleDefinitionCreateRequest(ctx, scope, roleDefinitionName, parameters, options)
	if err != nil {
		return ClientCreateOrUpdateRoleDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateOrUpdateRoleDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ClientCreateOrUpdateRoleDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.createOrUpdateRoleDefinitionHandleResponse(resp)
}

// createOrUpdateRoleDefinitionCreateRequest creates the CreateOrUpdateRoleDefinition request.
func (client *Client) createOrUpdateRoleDefinitionCreateRequest(ctx context.Context, scope RoleScope, roleDefinitionName string, parameters RoleDefinitionCreateParameters, options *ClientCreateOrUpdateRoleDefinitionOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	if roleDefinitionName == "" {
		return nil, errors.New("parameter roleDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{roleDefinitionName}", url.PathEscape(roleDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateRoleDefinitionHandleResponse handles the CreateOrUpdateRoleDefinition response.
func (client *Client) createOrUpdateRoleDefinitionHandleResponse(resp *http.Response) (ClientCreateOrUpdateRoleDefinitionResponse, error) {
	result := ClientCreateOrUpdateRoleDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleDefinition); err != nil {
		return ClientCreateOrUpdateRoleDefinitionResponse{}, err
	}
	return result, nil
}

// CreateRoleAssignment - Creates a role assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.4
// scope - The scope of the role assignment to create.
// roleAssignmentName - The name of the role assignment to create. It can be any valid GUID.
// parameters - Parameters for the role assignment.
// options - ClientCreateRoleAssignmentOptions contains the optional parameters for the Client.CreateRoleAssignment method.
func (client *Client) CreateRoleAssignment(ctx context.Context, scope RoleScope, roleAssignmentName string, parameters RoleAssignmentCreateParameters, options *ClientCreateRoleAssignmentOptions) (ClientCreateRoleAssignmentResponse, error) {
	req, err := client.createRoleAssignmentCreateRequest(ctx, scope, roleAssignmentName, parameters, options)
	if err != nil {
		return ClientCreateRoleAssignmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientCreateRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusCreated) {
		return ClientCreateRoleAssignmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.createRoleAssignmentHandleResponse(resp)
}

// createRoleAssignmentCreateRequest creates the CreateRoleAssignment request.
func (client *Client) createRoleAssignmentCreateRequest(ctx context.Context, scope RoleScope, roleAssignmentName string, parameters RoleAssignmentCreateParameters, options *ClientCreateRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	if roleAssignmentName == "" {
		return nil, errors.New("parameter roleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{roleAssignmentName}", url.PathEscape(roleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createRoleAssignmentHandleResponse handles the CreateRoleAssignment response.
func (client *Client) createRoleAssignmentHandleResponse(resp *http.Response) (ClientCreateRoleAssignmentResponse, error) {
	result := ClientCreateRoleAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleAssignment); err != nil {
		return ClientCreateRoleAssignmentResponse{}, err
	}
	return result, nil
}

// DeleteRoleAssignment - Deletes a role assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.4
// scope - The scope of the role assignment to delete.
// roleAssignmentName - The name of the role assignment to delete.
// options - ClientDeleteRoleAssignmentOptions contains the optional parameters for the Client.DeleteRoleAssignment method.
func (client *Client) DeleteRoleAssignment(ctx context.Context, scope RoleScope, roleAssignmentName string, options *ClientDeleteRoleAssignmentOptions) (ClientDeleteRoleAssignmentResponse, error) {
	req, err := client.deleteRoleAssignmentCreateRequest(ctx, scope, roleAssignmentName, options)
	if err != nil {
		return ClientDeleteRoleAssignmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteRoleAssignmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteRoleAssignmentHandleResponse(resp)
}

// deleteRoleAssignmentCreateRequest creates the DeleteRoleAssignment request.
func (client *Client) deleteRoleAssignmentCreateRequest(ctx context.Context, scope RoleScope, roleAssignmentName string, options *ClientDeleteRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	if roleAssignmentName == "" {
		return nil, errors.New("parameter roleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{roleAssignmentName}", url.PathEscape(roleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteRoleAssignmentHandleResponse handles the DeleteRoleAssignment response.
func (client *Client) deleteRoleAssignmentHandleResponse(resp *http.Response) (ClientDeleteRoleAssignmentResponse, error) {
	result := ClientDeleteRoleAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleAssignment); err != nil {
		return ClientDeleteRoleAssignmentResponse{}, err
	}
	return result, nil
}

// DeleteRoleDefinition - Deletes a custom role definition.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.4
// scope - The scope of the role definition to delete. Managed HSM only supports '/'.
// roleDefinitionName - The name (GUID) of the role definition to delete.
// options - ClientDeleteRoleDefinitionOptions contains the optional parameters for the Client.DeleteRoleDefinition method.
func (client *Client) DeleteRoleDefinition(ctx context.Context, scope RoleScope, roleDefinitionName string, options *ClientDeleteRoleDefinitionOptions) (ClientDeleteRoleDefinitionResponse, error) {
	req, err := client.deleteRoleDefinitionCreateRequest(ctx, scope, roleDefinitionName, options)
	if err != nil {
		return ClientDeleteRoleDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientDeleteRoleDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientDeleteRoleDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.deleteRoleDefinitionHandleResponse(resp)
}

// deleteRoleDefinitionCreateRequest creates the DeleteRoleDefinition request.
func (client *Client) deleteRoleDefinitionCreateRequest(ctx context.Context, scope RoleScope, roleDefinitionName string, options *ClientDeleteRoleDefinitionOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	if roleDefinitionName == "" {
		return nil, errors.New("parameter roleDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{roleDefinitionName}", url.PathEscape(roleDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteRoleDefinitionHandleResponse handles the DeleteRoleDefinition response.
func (client *Client) deleteRoleDefinitionHandleResponse(resp *http.Response) (ClientDeleteRoleDefinitionResponse, error) {
	result := ClientDeleteRoleDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleDefinition); err != nil {
		return ClientDeleteRoleDefinitionResponse{}, err
	}
	return result, nil
}

// GetRoleAssignment - Get the specified role assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.4
// scope - The scope of the role assignment.
// roleAssignmentName - The name of the role assignment to get.
// options - ClientGetRoleAssignmentOptions contains the optional parameters for the Client.GetRoleAssignment method.
func (client *Client) GetRoleAssignment(ctx context.Context, scope RoleScope, roleAssignmentName string, options *ClientGetRoleAssignmentOptions) (ClientGetRoleAssignmentResponse, error) {
	req, err := client.getRoleAssignmentCreateRequest(ctx, scope, roleAssignmentName, options)
	if err != nil {
		return ClientGetRoleAssignmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetRoleAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetRoleAssignmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRoleAssignmentHandleResponse(resp)
}

// getRoleAssignmentCreateRequest creates the GetRoleAssignment request.
func (client *Client) getRoleAssignmentCreateRequest(ctx context.Context, scope RoleScope, roleAssignmentName string, options *ClientGetRoleAssignmentOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	if roleAssignmentName == "" {
		return nil, errors.New("parameter roleAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{roleAssignmentName}", url.PathEscape(roleAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRoleAssignmentHandleResponse handles the GetRoleAssignment response.
func (client *Client) getRoleAssignmentHandleResponse(resp *http.Response) (ClientGetRoleAssignmentResponse, error) {
	result := ClientGetRoleAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleAssignment); err != nil {
		return ClientGetRoleAssignmentResponse{}, err
	}
	return result, nil
}

// GetRoleDefinition - Get the specified role definition.
// If the operation fails it returns an *azcore.ResponseError type.
// Generated from API version 7.4
// scope - The scope of the role definition to get. Managed HSM only supports '/'.
// roleDefinitionName - The name of the role definition to get.
// options - ClientGetRoleDefinitionOptions contains the optional parameters for the Client.GetRoleDefinition method.
func (client *Client) GetRoleDefinition(ctx context.Context, scope RoleScope, roleDefinitionName string, options *ClientGetRoleDefinitionOptions) (ClientGetRoleDefinitionResponse, error) {
	req, err := client.getRoleDefinitionCreateRequest(ctx, scope, roleDefinitionName, options)
	if err != nil {
		return ClientGetRoleDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ClientGetRoleDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ClientGetRoleDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.getRoleDefinitionHandleResponse(resp)
}

// getRoleDefinitionCreateRequest creates the GetRoleDefinition request.
func (client *Client) getRoleDefinitionCreateRequest(ctx context.Context, scope RoleScope, roleDefinitionName string, options *ClientGetRoleDefinitionOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionName}"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	if roleDefinitionName == "" {
		return nil, errors.New("parameter roleDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{roleDefinitionName}", url.PathEscape(roleDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getRoleDefinitionHandleResponse handles the GetRoleDefinition response.
func (client *Client) getRoleDefinitionHandleResponse(resp *http.Response) (ClientGetRoleDefinitionResponse, error) {
	result := ClientGetRoleDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleDefinition); err != nil {
		return ClientGetRoleDefinitionResponse{}, err
	}
	return result, nil
}

// NewListRoleAssignmentsPager - Gets role assignments for a scope.
// Generated from API version 7.4
// scope - The scope of the role assignments.
// options - ClientListRoleAssignmentsOptions contains the optional parameters for the Client.ListRoleAssignments method.
func (client *Client) NewListRoleAssignmentsPager(scope RoleScope, options *ClientListRoleAssignmentsOptions) *runtime.Pager[ClientListRoleAssignmentsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListRoleAssignmentsResponse]{
		More: func(page ClientListRoleAssignmentsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListRoleAssignmentsResponse) (ClientListRoleAssignmentsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listRoleAssignmentsCreateRequest(ctx, scope, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientListRoleAssignmentsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientListRoleAssignmentsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientListRoleAssignmentsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listRoleAssignmentsHandleResponse(resp)
		},
	})
}

// listRoleAssignmentsCreateRequest creates the ListRoleAssignments request.
func (client *Client) listRoleAssignmentsCreateRequest(ctx context.Context, scope RoleScope, options *ClientListRoleAssignmentsOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleAssignments"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRoleAssignmentsHandleResponse handles the ListRoleAssignments response.
func (client *Client) listRoleAssignmentsHandleResponse(resp *http.Response) (ClientListRoleAssignmentsResponse, error) {
	result := ClientListRoleAssignmentsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleAssignmentListResult); err != nil {
		return ClientListRoleAssignmentsResponse{}, err
	}
	return result, nil
}

// NewListRoleDefinitionsPager - Get all role definitions that are applicable at scope and above.
// Generated from API version 7.4
// scope - The scope of the role definition.
// options - ClientListRoleDefinitionsOptions contains the optional parameters for the Client.ListRoleDefinitions method.
func (client *Client) NewListRoleDefinitionsPager(scope RoleScope, options *ClientListRoleDefinitionsOptions) *runtime.Pager[ClientListRoleDefinitionsResponse] {
	return runtime.NewPager(runtime.PagingHandler[ClientListRoleDefinitionsResponse]{
		More: func(page ClientListRoleDefinitionsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *ClientListRoleDefinitionsResponse) (ClientListRoleDefinitionsResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listRoleDefinitionsCreateRequest(ctx, scope, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.NextLink)
			}
			if err != nil {
				return ClientListRoleDefinitionsResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return ClientListRoleDefinitionsResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return ClientListRoleDefinitionsResponse{}, runtime.NewResponseError(resp)
			}
			return client.listRoleDefinitionsHandleResponse(resp)
		},
	})
}

// listRoleDefinitionsCreateRequest creates the ListRoleDefinitions request.
func (client *Client) listRoleDefinitionsCreateRequest(ctx context.Context, scope RoleScope, options *ClientListRoleDefinitionsOptions) (*policy.Request, error) {
	urlPath := "/{scope}/providers/Microsoft.Authorization/roleDefinitions"
	urlPath = strings.ReplaceAll(urlPath, "{scope}", string(scope))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.endpoint, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "7.4")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listRoleDefinitionsHandleResponse handles the ListRoleDefinitions response.
func (client *Client) listRoleDefinitionsHandleResponse(resp *http.Response) (ClientListRoleDefinitionsResponse, error) {
	result := ClientListRoleDefinitionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RoleDefinitionListResult); err != nil {
		return ClientListRoleDefinitionsResponse{}, err
	}
	return result, nil
}
