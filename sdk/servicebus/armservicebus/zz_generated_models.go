// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicebus

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccessKeys - Namespace/ServiceBus Connection String
type AccessKeys struct {
	// READ-ONLY; Primary connection string of the alias if GEO DR is enabled
	AliasPrimaryConnectionString *string `json:"aliasPrimaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; Secondary connection string of the alias if GEO DR is enabled
	AliasSecondaryConnectionString *string `json:"aliasSecondaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; A string that describes the authorization rule.
	KeyName *string `json:"keyName,omitempty" azure:"ro"`

	// READ-ONLY; Primary connection string of the created namespace authorization rule.
	PrimaryConnectionString *string `json:"primaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; A base64-encoded 256-bit primary key for signing and validating the SAS token.
	PrimaryKey *string `json:"primaryKey,omitempty" azure:"ro"`

	// READ-ONLY; Secondary connection string of the created namespace authorization rule.
	SecondaryConnectionString *string `json:"secondaryConnectionString,omitempty" azure:"ro"`

	// READ-ONLY; A base64-encoded 256-bit primary key for signing and validating the SAS token.
	SecondaryKey *string `json:"secondaryKey,omitempty" azure:"ro"`
}

// Action - Represents the filter actions which are allowed for the transformation of a message that have been matched by a filter expression.
type Action struct {
	// This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
	CompatibilityLevel *int32 `json:"compatibilityLevel,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// SQL expression. e.g. MyProperty='ABC'
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// ArmDisasterRecovery - Single item in List or Get Alias(Disaster Recovery configuration) operation
type ArmDisasterRecovery struct {
	Resource
	// Properties required to the Create Or Update Alias(Disaster Recovery configurations)
	Properties *ArmDisasterRecoveryProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmDisasterRecovery.
func (a ArmDisasterRecovery) MarshalJSON() ([]byte, error) {
	objectMap := a.Resource.marshalInternal()
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// ArmDisasterRecoveryListResult - The result of the List Alias(Disaster Recovery configuration) operation.
type ArmDisasterRecoveryListResult struct {
	// List of Alias(Disaster Recovery configurations)
	Value []*ArmDisasterRecovery `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if Value contains incomplete list of Alias(Disaster Recovery configuration)
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ArmDisasterRecoveryListResult.
func (a ArmDisasterRecoveryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// ArmDisasterRecoveryProperties - Properties required to the Create Or Update Alias(Disaster Recovery configurations)
type ArmDisasterRecoveryProperties struct {
	// Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
	AlternateName *string `json:"alternateName,omitempty"`

	// ARM Id of the Primary/Secondary eventhub namespace name, which is part of GEO DR pairing
	PartnerNamespace *string `json:"partnerNamespace,omitempty"`

	// READ-ONLY; Number of entities pending to be replicated.
	PendingReplicationOperationsCount *int64 `json:"pendingReplicationOperationsCount,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the Alias(Disaster Recovery configuration) - possible values 'Accepted' or 'Succeeded' or 'Failed'
	ProvisioningState *ProvisioningStateDR `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; role of namespace in GEO DR - possible values 'Primary' or 'PrimaryNotReplicating' or 'Secondary'
	Role *RoleDisasterRecovery `json:"role,omitempty" azure:"ro"`
}

// CaptureDescription - Properties to configure capture description for eventhub
type CaptureDescription struct {
	// Properties of Destination where capture will be stored. (Storage Account, Blob Names)
	Destination *Destination `json:"destination,omitempty"`

	// A value that indicates whether capture description is enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// Enumerates the possible values for the encoding format of capture description.
	Encoding *EncodingCaptureDescription `json:"encoding,omitempty"`

	// The time window allows you to set the frequency with which the capture to Azure Blobs will happen, value should between 60 to 900 seconds
	IntervalInSeconds *int32 `json:"intervalInSeconds,omitempty"`

	// The size window defines the amount of data built up in your Event Hub before an capture operation, value should be between 10485760 and 524288000 bytes
	SizeLimitInBytes *int32 `json:"sizeLimitInBytes,omitempty"`
}

// CheckNameAvailability - Description of a Check Name availability request properties.
type CheckNameAvailability struct {
	// REQUIRED; The Name to check the namespace name availability and The namespace name can contain only letters, numbers, and hyphens. The namespace must
	// start with a letter, and it must end with a letter or
	// number.
	Name *string `json:"name,omitempty"`
}

// CheckNameAvailabilityResult - Description of a Check Name availability request properties.
type CheckNameAvailabilityResult struct {
	// Value indicating namespace is availability, true if the namespace is available; otherwise, false.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason for unavailability of a namespace.
	Reason *UnavailableReason `json:"reason,omitempty"`

	// READ-ONLY; The detailed info regarding the reason associated with the namespace.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ConnectionState information.
type ConnectionState struct {
	// Description of the connection state.
	Description *string `json:"description,omitempty"`

	// Status of the connection.
	Status *PrivateLinkConnectionStatus `json:"status,omitempty"`
}

// CorrelationFilter - Represents the correlation filter expression.
type CorrelationFilter struct {
	// Content type of the message.
	ContentType *string `json:"contentType,omitempty"`

	// Identifier of the correlation.
	CorrelationID *string `json:"correlationId,omitempty"`

	// Application specific label.
	Label *string `json:"label,omitempty"`

	// Identifier of the message.
	MessageID *string `json:"messageId,omitempty"`

	// dictionary object for custom filters
	Properties map[string]*string `json:"properties,omitempty"`

	// Address of the queue to reply to.
	ReplyTo *string `json:"replyTo,omitempty"`

	// Session identifier to reply to.
	ReplyToSessionID *string `json:"replyToSessionId,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// Session identifier.
	SessionID *string `json:"sessionId,omitempty"`

	// Address to send to.
	To *string `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CorrelationFilter.
func (c CorrelationFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentType", c.ContentType)
	populate(objectMap, "correlationId", c.CorrelationID)
	populate(objectMap, "label", c.Label)
	populate(objectMap, "messageId", c.MessageID)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "replyTo", c.ReplyTo)
	populate(objectMap, "replyToSessionId", c.ReplyToSessionID)
	populate(objectMap, "requiresPreprocessing", c.RequiresPreprocessing)
	populate(objectMap, "sessionId", c.SessionID)
	populate(objectMap, "to", c.To)
	return json.Marshal(objectMap)
}

// Destination - Capture storage details for capture description
type Destination struct {
	// Name for capture destination
	Name *string `json:"name,omitempty"`

	// Properties describing the storage account, blob container and archive name format for capture destination
	Properties *DestinationProperties `json:"properties,omitempty"`
}

// DestinationProperties - Properties describing the storage account, blob container and archive name format for capture destination
type DestinationProperties struct {
	// Blob naming convention for archive, e.g. {Namespace}/{EventHub}/{PartitionId}/{Year}/{Month}/{Day}/{Hour}/{Minute}/{Second}. Here all the parameters
	// (Namespace,EventHub .. etc) are mandatory
	// irrespective of order
	ArchiveNameFormat *string `json:"archiveNameFormat,omitempty"`

	// Blob container Name
	BlobContainer *string `json:"blobContainer,omitempty"`

	// Resource id of the storage account to be used to create the blobs
	StorageAccountResourceID *string `json:"storageAccountResourceId,omitempty"`
}

// DisasterRecoveryConfigsBreakPairingOptions contains the optional parameters for the DisasterRecoveryConfigs.BreakPairing method.
type DisasterRecoveryConfigsBreakPairingOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsCheckNameAvailabilityOptions contains the optional parameters for the DisasterRecoveryConfigs.CheckNameAvailability method.
type DisasterRecoveryConfigsCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsCreateOrUpdateOptions contains the optional parameters for the DisasterRecoveryConfigs.CreateOrUpdate method.
type DisasterRecoveryConfigsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsDeleteOptions contains the optional parameters for the DisasterRecoveryConfigs.Delete method.
type DisasterRecoveryConfigsDeleteOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsFailOverOptions contains the optional parameters for the DisasterRecoveryConfigs.FailOver method.
type DisasterRecoveryConfigsFailOverOptions struct {
	// Parameters required to create an Alias(Disaster Recovery configuration)
	Parameters *FailoverProperties
}

// DisasterRecoveryConfigsGetAuthorizationRuleOptions contains the optional parameters for the DisasterRecoveryConfigs.GetAuthorizationRule method.
type DisasterRecoveryConfigsGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsGetOptions contains the optional parameters for the DisasterRecoveryConfigs.Get method.
type DisasterRecoveryConfigsGetOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsListAuthorizationRulesOptions contains the optional parameters for the DisasterRecoveryConfigs.ListAuthorizationRules method.
type DisasterRecoveryConfigsListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsListKeysOptions contains the optional parameters for the DisasterRecoveryConfigs.ListKeys method.
type DisasterRecoveryConfigsListKeysOptions struct {
	// placeholder for future optional parameters
}

// DisasterRecoveryConfigsListOptions contains the optional parameters for the DisasterRecoveryConfigs.List method.
type DisasterRecoveryConfigsListOptions struct {
	// placeholder for future optional parameters
}

// Encryption - Properties to configure Encryption
type Encryption struct {
	// Enumerates the possible value of keySource for Encryption
	KeySource *string `json:"keySource,omitempty"`

	// Properties of KeyVault
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorResponse - The resource management error response.
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorResponseError `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// ErrorResponseError - The error object.
type ErrorResponseError struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorResponse `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponseError.
func (e ErrorResponseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// EventHubListResult - The result of the List EventHubs operation.
type EventHubListResult struct {
	// Result of the List EventHubs operation.
	Value []*Eventhub `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if Value contains incomplete list of EventHubs.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventHubListResult.
func (e EventHubListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", e.NextLink)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// EventHubsListByNamespaceOptions contains the optional parameters for the EventHubs.ListByNamespace method.
type EventHubsListByNamespaceOptions struct {
	// placeholder for future optional parameters
}

// Eventhub - Single item in List or Get Event Hub operation
type Eventhub struct {
	Resource
	// Properties supplied to the Create Or Update Event Hub operation.
	Properties *EventhubProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Eventhub.
func (e Eventhub) MarshalJSON() ([]byte, error) {
	objectMap := e.Resource.marshalInternal()
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// EventhubProperties - Properties supplied to the Create Or Update Event Hub operation.
type EventhubProperties struct {
	// Properties of capture description
	CaptureDescription *CaptureDescription `json:"captureDescription,omitempty"`

	// Number of days to retain the events for this Event Hub, value should be 1 to 7 days
	MessageRetentionInDays *int64 `json:"messageRetentionInDays,omitempty"`

	// Number of partitions created for the Event Hub, allowed values are from 1 to 32 partitions.
	PartitionCount *int64 `json:"partitionCount,omitempty"`

	// Enumerates the possible values for the status of a Event Hub.
	Status *EntityStatus `json:"status,omitempty"`

	// READ-ONLY; Exact time the Event Hub was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Current number of shards on the Event Hub.
	PartitionIDs []*string `json:"partitionIds,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EventhubProperties.
func (e EventhubProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "captureDescription", e.CaptureDescription)
	populate(objectMap, "createdAt", (*timeRFC3339)(e.CreatedAt))
	populate(objectMap, "messageRetentionInDays", e.MessageRetentionInDays)
	populate(objectMap, "partitionCount", e.PartitionCount)
	populate(objectMap, "partitionIds", e.PartitionIDs)
	populate(objectMap, "status", e.Status)
	populate(objectMap, "updatedAt", (*timeRFC3339)(e.UpdatedAt))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EventhubProperties.
func (e *EventhubProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "captureDescription":
			err = unpopulate(val, &e.CaptureDescription)
			delete(rawMsg, key)
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			e.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "messageRetentionInDays":
			err = unpopulate(val, &e.MessageRetentionInDays)
			delete(rawMsg, key)
		case "partitionCount":
			err = unpopulate(val, &e.PartitionCount)
			delete(rawMsg, key)
		case "partitionIds":
			err = unpopulate(val, &e.PartitionIDs)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &e.Status)
			delete(rawMsg, key)
		case "updatedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			e.UpdatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// FailoverProperties - Safe failover is to indicate the service should wait for pending replication to finish before switching to the secondary.
type FailoverProperties struct {
	// Safe failover is to indicate the service should wait for pending replication to finish before switching to the secondary.
	Properties *FailoverPropertiesProperties `json:"properties,omitempty"`
}

// FailoverPropertiesProperties - Safe failover is to indicate the service should wait for pending replication to finish before switching to the secondary.
type FailoverPropertiesProperties struct {
	// Safe failover is to indicate the service should wait for pending replication to finish before switching to the secondary.
	IsSafeFailover *bool `json:"IsSafeFailover,omitempty"`
}

// IPFilterRule - Single item in a List or Get IpFilterRules operation
type IPFilterRule struct {
	Resource
	// Properties supplied to create or update IpFilterRules
	Properties *IPFilterRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPFilterRule.
func (i IPFilterRule) MarshalJSON() ([]byte, error) {
	objectMap := i.Resource.marshalInternal()
	populate(objectMap, "properties", i.Properties)
	return json.Marshal(objectMap)
}

// IPFilterRuleListResult - The response from the List namespace operation.
type IPFilterRuleListResult struct {
	// Link to the next set of results. Not empty if Value contains an incomplete list of IpFilter Rules
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List IpFilter Rules operation.
	Value []*IPFilterRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type IPFilterRuleListResult.
func (i IPFilterRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// IPFilterRuleProperties - Properties supplied to create or update IpFilterRules
type IPFilterRuleProperties struct {
	// The IP Filter Action
	Action *IPAction `json:"action,omitempty"`

	// IP Filter name
	FilterName *string `json:"filterName,omitempty"`

	// IP Mask
	IPMask *string `json:"ipMask,omitempty"`
}

// Identity - Properties to configure Identity for Bring your Own Keys
type Identity struct {
	// ObjectId from the KeyVault
	PrincipalID *string `json:"principalId,omitempty"`

	// TenantId from the KeyVault
	TenantID *string `json:"tenantId,omitempty"`

	// Enumerates the possible value Identity type, which currently supports only 'SystemAssigned'
	Type *string `json:"type,omitempty"`
}

// KeyVaultProperties - Properties to configure keyVault Properties
type KeyVaultProperties struct {
	// Name of the Key from KeyVault
	KeyName *string `json:"keyName,omitempty"`

	// Uri of KeyVault
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`
}

// MessageCountDetails - Message Count Details.
type MessageCountDetails struct {
	// READ-ONLY; Number of active messages in the queue, topic, or subscription.
	ActiveMessageCount *int64 `json:"activeMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages that are dead lettered.
	DeadLetterMessageCount *int64 `json:"deadLetterMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of scheduled messages.
	ScheduledMessageCount *int64 `json:"scheduledMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages transferred into dead letters.
	TransferDeadLetterMessageCount *int64 `json:"transferDeadLetterMessageCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages transferred to another queue, topic, or subscription.
	TransferMessageCount *int64 `json:"transferMessageCount,omitempty" azure:"ro"`
}

// MigrationConfigListResult - The result of the List migrationConfigurations operation.
type MigrationConfigListResult struct {
	// List of Migration Configs
	Value []*MigrationConfigProperties `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if Value contains incomplete list of migrationConfigurations
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationConfigListResult.
func (m MigrationConfigListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MigrationConfigProperties - Single item in List or Get Migration Config operation
type MigrationConfigProperties struct {
	Resource
	// Properties required to the Create Migration Configuration
	Properties *MigrationConfigPropertiesProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationConfigProperties.
func (m MigrationConfigProperties) MarshalJSON() ([]byte, error) {
	objectMap := m.Resource.marshalInternal()
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// MigrationConfigPropertiesProperties - Properties required to the Create Migration Configuration
type MigrationConfigPropertiesProperties struct {
	// REQUIRED; Name to access Standard Namespace after migration
	PostMigrationName *string `json:"postMigrationName,omitempty"`

	// REQUIRED; Existing premium Namespace ARM Id name which has no entities, will be used for migration
	TargetNamespace *string `json:"targetNamespace,omitempty"`

	// READ-ONLY; State in which Standard to Premium Migration is, possible values : Unknown, Reverting, Completing, Initiating, Syncing, Active
	MigrationState *string `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Number of entities pending to be replicated.
	PendingReplicationOperationsCount *int64 `json:"pendingReplicationOperationsCount,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of Migration Configuration
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MigrationConfigsBeginCreateAndStartMigrationOptions contains the optional parameters for the MigrationConfigs.BeginCreateAndStartMigration method.
type MigrationConfigsBeginCreateAndStartMigrationOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsCompleteMigrationOptions contains the optional parameters for the MigrationConfigs.CompleteMigration method.
type MigrationConfigsCompleteMigrationOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsDeleteOptions contains the optional parameters for the MigrationConfigs.Delete method.
type MigrationConfigsDeleteOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsGetOptions contains the optional parameters for the MigrationConfigs.Get method.
type MigrationConfigsGetOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsListOptions contains the optional parameters for the MigrationConfigs.List method.
type MigrationConfigsListOptions struct {
	// placeholder for future optional parameters
}

// MigrationConfigsRevertOptions contains the optional parameters for the MigrationConfigs.Revert method.
type MigrationConfigsRevertOptions struct {
	// placeholder for future optional parameters
}

// NWRuleSetIPRules - Description of NetWorkRuleSet - IpRules resource.
type NWRuleSetIPRules struct {
	// The IP Filter Action
	Action *NetworkRuleIPAction `json:"action,omitempty"`

	// IP Mask
	IPMask *string `json:"ipMask,omitempty"`
}

// NWRuleSetVirtualNetworkRules - Description of VirtualNetworkRules - NetworkRules resource.
type NWRuleSetVirtualNetworkRules struct {
	// Value that indicates whether to ignore missing VNet Service Endpoint
	IgnoreMissingVnetServiceEndpoint *bool `json:"ignoreMissingVnetServiceEndpoint,omitempty"`

	// Subnet properties
	Subnet *Subnet `json:"subnet,omitempty"`
}

// NamespacesBeginCreateOrUpdateOptions contains the optional parameters for the Namespaces.BeginCreateOrUpdate method.
type NamespacesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// NamespacesBeginDeleteOptions contains the optional parameters for the Namespaces.BeginDelete method.
type NamespacesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCheckNameAvailabilityOptions contains the optional parameters for the Namespaces.CheckNameAvailability method.
type NamespacesCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the Namespaces.CreateOrUpdateAuthorizationRule method.
type NamespacesCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCreateOrUpdateIPFilterRuleOptions contains the optional parameters for the Namespaces.CreateOrUpdateIPFilterRule method.
type NamespacesCreateOrUpdateIPFilterRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCreateOrUpdateNetworkRuleSetOptions contains the optional parameters for the Namespaces.CreateOrUpdateNetworkRuleSet method.
type NamespacesCreateOrUpdateNetworkRuleSetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesCreateOrUpdateVirtualNetworkRuleOptions contains the optional parameters for the Namespaces.CreateOrUpdateVirtualNetworkRule method.
type NamespacesCreateOrUpdateVirtualNetworkRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesDeleteAuthorizationRuleOptions contains the optional parameters for the Namespaces.DeleteAuthorizationRule method.
type NamespacesDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesDeleteIPFilterRuleOptions contains the optional parameters for the Namespaces.DeleteIPFilterRule method.
type NamespacesDeleteIPFilterRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesDeleteVirtualNetworkRuleOptions contains the optional parameters for the Namespaces.DeleteVirtualNetworkRule method.
type NamespacesDeleteVirtualNetworkRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetAuthorizationRuleOptions contains the optional parameters for the Namespaces.GetAuthorizationRule method.
type NamespacesGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetIPFilterRuleOptions contains the optional parameters for the Namespaces.GetIPFilterRule method.
type NamespacesGetIPFilterRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetNetworkRuleSetOptions contains the optional parameters for the Namespaces.GetNetworkRuleSet method.
type NamespacesGetNetworkRuleSetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetOptions contains the optional parameters for the Namespaces.Get method.
type NamespacesGetOptions struct {
	// placeholder for future optional parameters
}

// NamespacesGetVirtualNetworkRuleOptions contains the optional parameters for the Namespaces.GetVirtualNetworkRule method.
type NamespacesGetVirtualNetworkRuleOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListAuthorizationRulesOptions contains the optional parameters for the Namespaces.ListAuthorizationRules method.
type NamespacesListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListByResourceGroupOptions contains the optional parameters for the Namespaces.ListByResourceGroup method.
type NamespacesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListIPFilterRulesOptions contains the optional parameters for the Namespaces.ListIPFilterRules method.
type NamespacesListIPFilterRulesOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListKeysOptions contains the optional parameters for the Namespaces.ListKeys method.
type NamespacesListKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListNetworkRuleSetsOptions contains the optional parameters for the Namespaces.ListNetworkRuleSets method.
type NamespacesListNetworkRuleSetsOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListOptions contains the optional parameters for the Namespaces.List method.
type NamespacesListOptions struct {
	// placeholder for future optional parameters
}

// NamespacesListVirtualNetworkRulesOptions contains the optional parameters for the Namespaces.ListVirtualNetworkRules method.
type NamespacesListVirtualNetworkRulesOptions struct {
	// placeholder for future optional parameters
}

// NamespacesMigrateOptions contains the optional parameters for the Namespaces.Migrate method.
type NamespacesMigrateOptions struct {
	// placeholder for future optional parameters
}

// NamespacesRegenerateKeysOptions contains the optional parameters for the Namespaces.RegenerateKeys method.
type NamespacesRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// NamespacesUpdateOptions contains the optional parameters for the Namespaces.Update method.
type NamespacesUpdateOptions struct {
	// placeholder for future optional parameters
}

// NetworkRuleSet - Description of NetworkRuleSet resource.
type NetworkRuleSet struct {
	Resource
	// NetworkRuleSet properties
	Properties *NetworkRuleSetProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSet.
func (n NetworkRuleSet) MarshalJSON() ([]byte, error) {
	objectMap := n.Resource.marshalInternal()
	populate(objectMap, "properties", n.Properties)
	return json.Marshal(objectMap)
}

// NetworkRuleSetListResult - The response of the List NetworkRuleSet operation.
type NetworkRuleSetListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of NetworkRuleSet.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List NetworkRuleSet operation.
	Value []*NetworkRuleSet `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSetListResult.
func (n NetworkRuleSetListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// NetworkRuleSetProperties - NetworkRuleSet properties
type NetworkRuleSetProperties struct {
	// Default Action for Network Rule Set
	DefaultAction *DefaultAction `json:"defaultAction,omitempty"`

	// List of IpRules
	IPRules []*NWRuleSetIPRules `json:"ipRules,omitempty"`

	// List VirtualNetwork Rules
	VirtualNetworkRules []*NWRuleSetVirtualNetworkRules `json:"virtualNetworkRules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkRuleSetProperties.
func (n NetworkRuleSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultAction", n.DefaultAction)
	populate(objectMap, "ipRules", n.IPRules)
	populate(objectMap, "virtualNetworkRules", n.VirtualNetworkRules)
	return json.Marshal(objectMap)
}

// Operation - A ServiceBus REST API operation
type Operation struct {
	// The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty" azure:"ro"`
}

// OperationDisplay - The object that represents the operation.
type OperationDisplay struct {
	// READ-ONLY; Operation type: Read, write, delete, etc.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Service provider: Microsoft.ServiceBus
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Resource on which the operation is performed: Invoice, etc.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OperationListResult - Result of the request to list ServiceBus operations. It contains a list of operations and a URL link to get the next set of results.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of ServiceBus operations supported by the Microsoft.ServiceBus resource provider.
	Value []*Operation `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PremiumMessagingRegions - Premium Messaging Region
type PremiumMessagingRegions struct {
	ResourceNamespacePatch
	Properties *PremiumMessagingRegionsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PremiumMessagingRegions.
func (p PremiumMessagingRegions) MarshalJSON() ([]byte, error) {
	objectMap := p.ResourceNamespacePatch.marshalInternal()
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PremiumMessagingRegionsListOptions contains the optional parameters for the PremiumMessagingRegions.List method.
type PremiumMessagingRegionsListOptions struct {
	// placeholder for future optional parameters
}

// PremiumMessagingRegionsListResult - The response of the List PremiumMessagingRegions operation.
type PremiumMessagingRegionsListResult struct {
	// Result of the List PremiumMessagingRegions type.
	Value []*PremiumMessagingRegions `json:"value,omitempty"`

	// READ-ONLY; Link to the next set of results. Not empty if Value contains incomplete list of PremiumMessagingRegions.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PremiumMessagingRegionsListResult.
func (p PremiumMessagingRegionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

type PremiumMessagingRegionsProperties struct {
	// READ-ONLY; Region code
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Full name of the region
	FullName *string `json:"fullName,omitempty" azure:"ro"`
}

// PrivateEndpoint information.
type PrivateEndpoint struct {
	// The ARM identifier for Private Endpoint.
	ID *string `json:"id,omitempty"`
}

// PrivateEndpointConnection - Properties of the PrivateEndpointConnection.
type PrivateEndpointConnection struct {
	Resource
	// Properties of the PrivateEndpointConnection.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnection.
func (p PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := p.Resource.marshalInternal()
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionListResult - Result of the list of all private endpoint connections operation.
type PrivateEndpointConnectionListResult struct {
	// A link for the next page of private endpoint connection resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private endpoint connection resources.
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the private endpoint connection resource.
type PrivateEndpointConnectionProperties struct {
	// The Private Endpoint resource for this Connection.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`

	// Details about the state of the connection.
	PrivateLinkServiceConnectionState *ConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// Provisioning state of the Private Endpoint Connection.
	ProvisioningState *EndPointProvisioningState `json:"provisioningState,omitempty"`
}

// PrivateEndpointConnectionsBeginDeleteOptions contains the optional parameters for the PrivateEndpointConnections.BeginDelete method.
type PrivateEndpointConnectionsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsCreateOrUpdateOptions contains the optional parameters for the PrivateEndpointConnections.CreateOrUpdate method.
type PrivateEndpointConnectionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsGetOptions contains the optional parameters for the PrivateEndpointConnections.Get method.
type PrivateEndpointConnectionsGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateEndpointConnectionsListOptions contains the optional parameters for the PrivateEndpointConnections.List method.
type PrivateEndpointConnectionsListOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResource - Information of the private link resource.
type PrivateLinkResource struct {
	// Fully qualified identifier of the resource.
	ID *string `json:"id,omitempty"`

	// Name of the resource
	Name *string `json:"name,omitempty"`

	// Properties of the private link resource.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// Type of the resource
	Type *string `json:"type,omitempty"`
}

// PrivateLinkResourceProperties - Properties of PrivateLinkResource
type PrivateLinkResourceProperties struct {
	GroupID *string `json:"groupId,omitempty"`

	// Required Members
	RequiredMembers []*string `json:"requiredMembers,omitempty"`

	// Required Zone Names
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkResourcesGetOptions contains the optional parameters for the PrivateLinkResources.Get method.
type PrivateLinkResourcesGetOptions struct {
	// placeholder for future optional parameters
}

// PrivateLinkResourcesListResult - Result of the List private link resources operation.
type PrivateLinkResourcesListResult struct {
	// A link for the next page of private link resources.
	NextLink *string `json:"nextLink,omitempty"`

	// A collection of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourcesListResult.
func (p PrivateLinkResourcesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// QueuesCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the Queues.CreateOrUpdateAuthorizationRule method.
type QueuesCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// QueuesCreateOrUpdateOptions contains the optional parameters for the Queues.CreateOrUpdate method.
type QueuesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// QueuesDeleteAuthorizationRuleOptions contains the optional parameters for the Queues.DeleteAuthorizationRule method.
type QueuesDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// QueuesDeleteOptions contains the optional parameters for the Queues.Delete method.
type QueuesDeleteOptions struct {
	// placeholder for future optional parameters
}

// QueuesGetAuthorizationRuleOptions contains the optional parameters for the Queues.GetAuthorizationRule method.
type QueuesGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// QueuesGetOptions contains the optional parameters for the Queues.Get method.
type QueuesGetOptions struct {
	// placeholder for future optional parameters
}

// QueuesListAuthorizationRulesOptions contains the optional parameters for the Queues.ListAuthorizationRules method.
type QueuesListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// QueuesListByNamespaceOptions contains the optional parameters for the Queues.ListByNamespace method.
type QueuesListByNamespaceOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink element
	// will include a skip parameter that specifies a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// QueuesListKeysOptions contains the optional parameters for the Queues.ListKeys method.
type QueuesListKeysOptions struct {
	// placeholder for future optional parameters
}

// QueuesRegenerateKeysOptions contains the optional parameters for the Queues.RegenerateKeys method.
type QueuesRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// RegenerateAccessKeyParameters - Parameters supplied to the Regenerate Authorization Rule operation, specifies which key needs to be reset.
type RegenerateAccessKeyParameters struct {
	// REQUIRED; The access key to regenerate.
	KeyType *KeyType `json:"keyType,omitempty"`

	// Optional, if the key value provided, is reset for KeyType value or autogenerate Key value set for keyType
	Key *string `json:"key,omitempty"`
}

// RegionsListBySKUOptions contains the optional parameters for the Regions.ListBySKU method.
type RegionsListBySKUOptions struct {
	// placeholder for future optional parameters
}

// Resource - The Resource definition for other than namespace.
type Resource struct {
	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := r.marshalInternal()
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
	return objectMap
}

// ResourceNamespacePatch - The Resource definition.
type ResourceNamespacePatch struct {
	Resource
	// Resource location
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceNamespacePatch.
func (r ResourceNamespacePatch) MarshalJSON() ([]byte, error) {
	objectMap := r.marshalInternal()
	return json.Marshal(objectMap)
}

func (r ResourceNamespacePatch) marshalInternal() map[string]interface{} {
	objectMap := r.Resource.marshalInternal()
	populate(objectMap, "location", r.Location)
	populate(objectMap, "tags", r.Tags)
	return objectMap
}

// Rule - Description of Rule Resource.
type Rule struct {
	Resource
	// Properties of Rule resource
	Properties *Ruleproperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Rule.
func (r Rule) MarshalJSON() ([]byte, error) {
	objectMap := r.Resource.marshalInternal()
	populate(objectMap, "properties", r.Properties)
	return json.Marshal(objectMap)
}

// RuleListResult - The response of the List rule operation.
type RuleListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of rules
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Rules operation.
	Value []*Rule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleListResult.
func (r RuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// Ruleproperties - Description of Rule Resource.
type Ruleproperties struct {
	// Represents the filter actions which are allowed for the transformation of a message that have been matched by a filter expression.
	Action *Action `json:"action,omitempty"`

	// Properties of correlationFilter
	CorrelationFilter *CorrelationFilter `json:"correlationFilter,omitempty"`

	// Filter type that is evaluated against a BrokeredMessage.
	FilterType *FilterType `json:"filterType,omitempty"`

	// Properties of sqlFilter
	SQLFilter *SQLFilter `json:"sqlFilter,omitempty"`
}

// RulesCreateOrUpdateOptions contains the optional parameters for the Rules.CreateOrUpdate method.
type RulesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// RulesDeleteOptions contains the optional parameters for the Rules.Delete method.
type RulesDeleteOptions struct {
	// placeholder for future optional parameters
}

// RulesGetOptions contains the optional parameters for the Rules.Get method.
type RulesGetOptions struct {
	// placeholder for future optional parameters
}

// RulesListBySubscriptionsOptions contains the optional parameters for the Rules.ListBySubscriptions method.
type RulesListBySubscriptionsOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink element
	// will include a skip parameter that specifies a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// SBAuthorizationRule - Description of a namespace authorization rule.
type SBAuthorizationRule struct {
	Resource
	// AuthorizationRule properties.
	Properties *SBAuthorizationRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBAuthorizationRule.
func (s SBAuthorizationRule) MarshalJSON() ([]byte, error) {
	objectMap := s.Resource.marshalInternal()
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SBAuthorizationRuleListResult - The response to the List Namespace operation.
type SBAuthorizationRuleListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of Authorization Rules.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Authorization Rules operation.
	Value []*SBAuthorizationRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBAuthorizationRuleListResult.
func (s SBAuthorizationRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBAuthorizationRuleProperties - AuthorizationRule properties.
type SBAuthorizationRuleProperties struct {
	// REQUIRED; The rights associated with the rule.
	Rights []*AccessRights `json:"rights,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBAuthorizationRuleProperties.
func (s SBAuthorizationRuleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "rights", s.Rights)
	return json.Marshal(objectMap)
}

// SBNamespace - Description of a namespace resource.
type SBNamespace struct {
	TrackedResource
	// Properties of BYOK Identity description
	Identity *Identity `json:"identity,omitempty"`

	// Properties of the namespace.
	Properties *SBNamespaceProperties `json:"properties,omitempty"`

	// Properties of SKU
	SKU *SBSKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespace.
func (s SBNamespace) MarshalJSON() ([]byte, error) {
	objectMap := s.TrackedResource.marshalInternal()
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	return json.Marshal(objectMap)
}

// SBNamespaceListResult - The response of the List Namespace operation.
type SBNamespaceListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of Namespaces.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Namespace operation.
	Value []*SBNamespace `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceListResult.
func (s SBNamespaceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBNamespaceMigrate - Namespace Migrate Object
type SBNamespaceMigrate struct {
	// REQUIRED; Type of namespaces
	TargetNamespaceType *NameSpaceType `json:"targetNamespaceType,omitempty"`
}

// SBNamespaceProperties - Properties of the namespace.
type SBNamespaceProperties struct {
	// Properties of BYOK Encryption description
	Encryption *Encryption `json:"encryption,omitempty"`

	// Enabling this property creates a Premium Service Bus Namespace in regions supported availability zones.
	ZoneRedundant *bool `json:"zoneRedundant,omitempty"`

	// READ-ONLY; The time the namespace was created
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for Azure Insights metrics
	MetricID *string `json:"metricId,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state of the namespace.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Endpoint you can use to perform Service Bus operations.
	ServiceBusEndpoint *string `json:"serviceBusEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Status of the namespace.
	Status *string `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; The time the namespace was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceProperties.
func (s SBNamespaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "encryption", s.Encryption)
	populate(objectMap, "metricId", s.MetricID)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "serviceBusEndpoint", s.ServiceBusEndpoint)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "updatedAt", (*timeRFC3339)(s.UpdatedAt))
	populate(objectMap, "zoneRedundant", s.ZoneRedundant)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBNamespaceProperties.
func (s *SBNamespaceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &s.Encryption)
			delete(rawMsg, key)
		case "metricId":
			err = unpopulate(val, &s.MetricID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "serviceBusEndpoint":
			err = unpopulate(val, &s.ServiceBusEndpoint)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.UpdatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "zoneRedundant":
			err = unpopulate(val, &s.ZoneRedundant)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBNamespaceUpdateParameters - Description of a namespace resource.
type SBNamespaceUpdateParameters struct {
	ResourceNamespacePatch
	// Properties of BYOK Identity description
	Identity *Identity `json:"identity,omitempty"`

	// Properties of the namespace.
	Properties *SBNamespaceProperties `json:"properties,omitempty"`

	// Properties of SKU
	SKU *SBSKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBNamespaceUpdateParameters.
func (s SBNamespaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := s.ResourceNamespacePatch.marshalInternal()
	populate(objectMap, "identity", s.Identity)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	return json.Marshal(objectMap)
}

// SBQueue - Description of queue Resource.
type SBQueue struct {
	Resource
	// Queue Properties
	Properties *SBQueueProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBQueue.
func (s SBQueue) MarshalJSON() ([]byte, error) {
	objectMap := s.Resource.marshalInternal()
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SBQueueListResult - The response to the List Queues operation.
type SBQueueListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of queues.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Queues operation.
	Value []*SBQueue `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBQueueListResult.
func (s SBQueueListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBQueueProperties - The Queue Properties definition.
type SBQueueProperties struct {
	// ISO 8061 timeSpan idle interval after which the queue is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// A value that indicates whether this queue has dead letter support when a message expires.
	DeadLetteringOnMessageExpiration *bool `json:"deadLetteringOnMessageExpiration,omitempty"`

	// ISO 8601 default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service
	// Bus. This is the default value used when
	// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// A value that indicates whether Express Entities are enabled. An express queue holds a message in memory temporarily before writing it to persistent storage.
	EnableExpress *bool `json:"enableExpress,omitempty"`

	// A value that indicates whether the queue is to be partitioned across multiple message brokers.
	EnablePartitioning *bool `json:"enablePartitioning,omitempty"`

	// Queue/Topic name to forward the Dead Letter message
	ForwardDeadLetteredMessagesTo *string `json:"forwardDeadLetteredMessagesTo,omitempty"`

	// Queue/Topic name to forward the messages
	ForwardTo *string `json:"forwardTo,omitempty"`

	// ISO 8601 timespan duration of a peek-lock; that is, the amount of time that the message is locked for other receivers. The maximum value for LockDuration
	// is 5 minutes; the default value is 1 minute.
	LockDuration *string `json:"lockDuration,omitempty"`

	// The maximum delivery count. A message is automatically deadlettered after this number of deliveries. default value is 10.
	MaxDeliveryCount *int32 `json:"maxDeliveryCount,omitempty"`

	// The maximum size of the queue in megabytes, which is the size of memory allocated for the queue. Default is 1024.
	MaxSizeInMegabytes *int32 `json:"maxSizeInMegabytes,omitempty"`

	// A value indicating if this queue requires duplicate detection.
	RequiresDuplicateDetection *bool `json:"requiresDuplicateDetection,omitempty"`

	// A value that indicates whether the queue supports the concept of sessions.
	RequiresSession *bool `json:"requiresSession,omitempty"`

	// Enumerates the possible values for the status of a messaging entity.
	Status *EntityStatus `json:"status,omitempty"`

	// READ-ONLY; Last time a message was sent, or the last time there was a receive request to this queue.
	AccessedAt *time.Time `json:"accessedAt,omitempty" azure:"ro"`

	// READ-ONLY; Message Count Details.
	CountDetails *MessageCountDetails `json:"countDetails,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; The number of messages in the queue.
	MessageCount *int64 `json:"messageCount,omitempty" azure:"ro"`

	// READ-ONLY; The size of the queue, in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBQueueProperties.
func (s SBQueueProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessedAt", (*timeRFC3339)(s.AccessedAt))
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "countDetails", s.CountDetails)
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "deadLetteringOnMessageExpiration", s.DeadLetteringOnMessageExpiration)
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", s.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "enableExpress", s.EnableExpress)
	populate(objectMap, "enablePartitioning", s.EnablePartitioning)
	populate(objectMap, "forwardDeadLetteredMessagesTo", s.ForwardDeadLetteredMessagesTo)
	populate(objectMap, "forwardTo", s.ForwardTo)
	populate(objectMap, "lockDuration", s.LockDuration)
	populate(objectMap, "maxDeliveryCount", s.MaxDeliveryCount)
	populate(objectMap, "maxSizeInMegabytes", s.MaxSizeInMegabytes)
	populate(objectMap, "messageCount", s.MessageCount)
	populate(objectMap, "requiresDuplicateDetection", s.RequiresDuplicateDetection)
	populate(objectMap, "requiresSession", s.RequiresSession)
	populate(objectMap, "sizeInBytes", s.SizeInBytes)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "updatedAt", (*timeRFC3339)(s.UpdatedAt))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBQueueProperties.
func (s *SBQueueProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.AccessedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "autoDeleteOnIdle":
			err = unpopulate(val, &s.AutoDeleteOnIdle)
			delete(rawMsg, key)
		case "countDetails":
			err = unpopulate(val, &s.CountDetails)
			delete(rawMsg, key)
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "deadLetteringOnMessageExpiration":
			err = unpopulate(val, &s.DeadLetteringOnMessageExpiration)
			delete(rawMsg, key)
		case "defaultMessageTimeToLive":
			err = unpopulate(val, &s.DefaultMessageTimeToLive)
			delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
			err = unpopulate(val, &s.DuplicateDetectionHistoryTimeWindow)
			delete(rawMsg, key)
		case "enableBatchedOperations":
			err = unpopulate(val, &s.EnableBatchedOperations)
			delete(rawMsg, key)
		case "enableExpress":
			err = unpopulate(val, &s.EnableExpress)
			delete(rawMsg, key)
		case "enablePartitioning":
			err = unpopulate(val, &s.EnablePartitioning)
			delete(rawMsg, key)
		case "forwardDeadLetteredMessagesTo":
			err = unpopulate(val, &s.ForwardDeadLetteredMessagesTo)
			delete(rawMsg, key)
		case "forwardTo":
			err = unpopulate(val, &s.ForwardTo)
			delete(rawMsg, key)
		case "lockDuration":
			err = unpopulate(val, &s.LockDuration)
			delete(rawMsg, key)
		case "maxDeliveryCount":
			err = unpopulate(val, &s.MaxDeliveryCount)
			delete(rawMsg, key)
		case "maxSizeInMegabytes":
			err = unpopulate(val, &s.MaxSizeInMegabytes)
			delete(rawMsg, key)
		case "messageCount":
			err = unpopulate(val, &s.MessageCount)
			delete(rawMsg, key)
		case "requiresDuplicateDetection":
			err = unpopulate(val, &s.RequiresDuplicateDetection)
			delete(rawMsg, key)
		case "requiresSession":
			err = unpopulate(val, &s.RequiresSession)
			delete(rawMsg, key)
		case "sizeInBytes":
			err = unpopulate(val, &s.SizeInBytes)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.UpdatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBSKU - SKU of the namespace.
type SBSKU struct {
	// REQUIRED; Name of this SKU.
	Name *SKUName `json:"name,omitempty"`

	// The specified messaging units for the tier. For Premium tier, capacity are 1,2 and 4.
	Capacity *int32 `json:"capacity,omitempty"`

	// The billing tier of this particular SKU.
	Tier *SKUTier `json:"tier,omitempty"`
}

// SBSubscription - Description of subscription resource.
type SBSubscription struct {
	Resource
	// Properties of subscriptions resource.
	Properties *SBSubscriptionProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBSubscription.
func (s SBSubscription) MarshalJSON() ([]byte, error) {
	objectMap := s.Resource.marshalInternal()
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SBSubscriptionListResult - The response to the List Subscriptions operation.
type SBSubscriptionListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of subscriptions.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Subscriptions operation.
	Value []*SBSubscription `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBSubscriptionListResult.
func (s SBSubscriptionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBSubscriptionProperties - Description of Subscription Resource.
type SBSubscriptionProperties struct {
	// ISO 8061 timeSpan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// Value that indicates whether a subscription has dead letter support on filter evaluation exceptions.
	DeadLetteringOnFilterEvaluationExceptions *bool `json:"deadLetteringOnFilterEvaluationExceptions,omitempty"`

	// Value that indicates whether a subscription has dead letter support when a message expires.
	DeadLetteringOnMessageExpiration *bool `json:"deadLetteringOnMessageExpiration,omitempty"`

	// ISO 8061 Default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service
	// Bus. This is the default value used when
	// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// Queue/Topic name to forward the Dead Letter message
	ForwardDeadLetteredMessagesTo *string `json:"forwardDeadLetteredMessagesTo,omitempty"`

	// Queue/Topic name to forward the messages
	ForwardTo *string `json:"forwardTo,omitempty"`

	// ISO 8061 lock duration timespan for the subscription. The default value is 1 minute.
	LockDuration *string `json:"lockDuration,omitempty"`

	// Number of maximum deliveries.
	MaxDeliveryCount *int32 `json:"maxDeliveryCount,omitempty"`

	// Value indicating if a subscription supports the concept of sessions.
	RequiresSession *bool `json:"requiresSession,omitempty"`

	// Enumerates the possible values for the status of a messaging entity.
	Status *EntityStatus `json:"status,omitempty"`

	// READ-ONLY; Last time there was a receive request to this subscription.
	AccessedAt *time.Time `json:"accessedAt,omitempty" azure:"ro"`

	// READ-ONLY; Message count details
	CountDetails *MessageCountDetails `json:"countDetails,omitempty" azure:"ro"`

	// READ-ONLY; Exact time the message was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Number of messages.
	MessageCount *int64 `json:"messageCount,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBSubscriptionProperties.
func (s SBSubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessedAt", (*timeRFC3339)(s.AccessedAt))
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "countDetails", s.CountDetails)
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "deadLetteringOnFilterEvaluationExceptions", s.DeadLetteringOnFilterEvaluationExceptions)
	populate(objectMap, "deadLetteringOnMessageExpiration", s.DeadLetteringOnMessageExpiration)
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", s.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "forwardDeadLetteredMessagesTo", s.ForwardDeadLetteredMessagesTo)
	populate(objectMap, "forwardTo", s.ForwardTo)
	populate(objectMap, "lockDuration", s.LockDuration)
	populate(objectMap, "maxDeliveryCount", s.MaxDeliveryCount)
	populate(objectMap, "messageCount", s.MessageCount)
	populate(objectMap, "requiresSession", s.RequiresSession)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "updatedAt", (*timeRFC3339)(s.UpdatedAt))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBSubscriptionProperties.
func (s *SBSubscriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.AccessedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "autoDeleteOnIdle":
			err = unpopulate(val, &s.AutoDeleteOnIdle)
			delete(rawMsg, key)
		case "countDetails":
			err = unpopulate(val, &s.CountDetails)
			delete(rawMsg, key)
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "deadLetteringOnFilterEvaluationExceptions":
			err = unpopulate(val, &s.DeadLetteringOnFilterEvaluationExceptions)
			delete(rawMsg, key)
		case "deadLetteringOnMessageExpiration":
			err = unpopulate(val, &s.DeadLetteringOnMessageExpiration)
			delete(rawMsg, key)
		case "defaultMessageTimeToLive":
			err = unpopulate(val, &s.DefaultMessageTimeToLive)
			delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
			err = unpopulate(val, &s.DuplicateDetectionHistoryTimeWindow)
			delete(rawMsg, key)
		case "enableBatchedOperations":
			err = unpopulate(val, &s.EnableBatchedOperations)
			delete(rawMsg, key)
		case "forwardDeadLetteredMessagesTo":
			err = unpopulate(val, &s.ForwardDeadLetteredMessagesTo)
			delete(rawMsg, key)
		case "forwardTo":
			err = unpopulate(val, &s.ForwardTo)
			delete(rawMsg, key)
		case "lockDuration":
			err = unpopulate(val, &s.LockDuration)
			delete(rawMsg, key)
		case "maxDeliveryCount":
			err = unpopulate(val, &s.MaxDeliveryCount)
			delete(rawMsg, key)
		case "messageCount":
			err = unpopulate(val, &s.MessageCount)
			delete(rawMsg, key)
		case "requiresSession":
			err = unpopulate(val, &s.RequiresSession)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "updatedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.UpdatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SBTopic - Description of topic resource.
type SBTopic struct {
	Resource
	// Properties of topic resource.
	Properties *SBTopicProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBTopic.
func (s SBTopic) MarshalJSON() ([]byte, error) {
	objectMap := s.Resource.marshalInternal()
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SBTopicListResult - The response to the List Topics operation.
type SBTopicListResult struct {
	// Link to the next set of results. Not empty if Value contains incomplete list of topics.
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List Topics operation.
	Value []*SBTopic `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SBTopicListResult.
func (s SBTopicListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SBTopicProperties - The Topic Properties definition.
type SBTopicProperties struct {
	// ISO 8601 timespan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// ISO 8601 Default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service
	// Bus. This is the default value used when
	// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO8601 timespan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// Value that indicates whether Express Entities are enabled. An express topic holds a message in memory temporarily before writing it to persistent storage.
	EnableExpress *bool `json:"enableExpress,omitempty"`

	// Value that indicates whether the topic to be partitioned across multiple message brokers is enabled.
	EnablePartitioning *bool `json:"enablePartitioning,omitempty"`

	// Maximum size of the topic in megabytes, which is the size of the memory allocated for the topic. Default is 1024.
	MaxSizeInMegabytes *int32 `json:"maxSizeInMegabytes,omitempty"`

	// Value indicating if this topic requires duplicate detection.
	RequiresDuplicateDetection *bool `json:"requiresDuplicateDetection,omitempty"`

	// Enumerates the possible values for the status of a messaging entity.
	Status *EntityStatus `json:"status,omitempty"`

	// Value that indicates whether the topic supports ordering.
	SupportOrdering *bool `json:"supportOrdering,omitempty"`

	// READ-ONLY; Last time the message was sent, or a request was received, for this topic.
	AccessedAt *time.Time `json:"accessedAt,omitempty" azure:"ro"`

	// READ-ONLY; Message count details
	CountDetails *MessageCountDetails `json:"countDetails,omitempty" azure:"ro"`

	// READ-ONLY; Exact time the message was created.
	CreatedAt *time.Time `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; Size of the topic, in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty" azure:"ro"`

	// READ-ONLY; Number of subscriptions.
	SubscriptionCount *int32 `json:"subscriptionCount,omitempty" azure:"ro"`

	// READ-ONLY; The exact time the message was updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SBTopicProperties.
func (s SBTopicProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessedAt", (*timeRFC3339)(s.AccessedAt))
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "countDetails", s.CountDetails)
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", s.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "enableExpress", s.EnableExpress)
	populate(objectMap, "enablePartitioning", s.EnablePartitioning)
	populate(objectMap, "maxSizeInMegabytes", s.MaxSizeInMegabytes)
	populate(objectMap, "requiresDuplicateDetection", s.RequiresDuplicateDetection)
	populate(objectMap, "sizeInBytes", s.SizeInBytes)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "subscriptionCount", s.SubscriptionCount)
	populate(objectMap, "supportOrdering", s.SupportOrdering)
	populate(objectMap, "updatedAt", (*timeRFC3339)(s.UpdatedAt))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SBTopicProperties.
func (s *SBTopicProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.AccessedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "autoDeleteOnIdle":
			err = unpopulate(val, &s.AutoDeleteOnIdle)
			delete(rawMsg, key)
		case "countDetails":
			err = unpopulate(val, &s.CountDetails)
			delete(rawMsg, key)
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "defaultMessageTimeToLive":
			err = unpopulate(val, &s.DefaultMessageTimeToLive)
			delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
			err = unpopulate(val, &s.DuplicateDetectionHistoryTimeWindow)
			delete(rawMsg, key)
		case "enableBatchedOperations":
			err = unpopulate(val, &s.EnableBatchedOperations)
			delete(rawMsg, key)
		case "enableExpress":
			err = unpopulate(val, &s.EnableExpress)
			delete(rawMsg, key)
		case "enablePartitioning":
			err = unpopulate(val, &s.EnablePartitioning)
			delete(rawMsg, key)
		case "maxSizeInMegabytes":
			err = unpopulate(val, &s.MaxSizeInMegabytes)
			delete(rawMsg, key)
		case "requiresDuplicateDetection":
			err = unpopulate(val, &s.RequiresDuplicateDetection)
			delete(rawMsg, key)
		case "sizeInBytes":
			err = unpopulate(val, &s.SizeInBytes)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &s.Status)
			delete(rawMsg, key)
		case "subscriptionCount":
			err = unpopulate(val, &s.SubscriptionCount)
			delete(rawMsg, key)
		case "supportOrdering":
			err = unpopulate(val, &s.SupportOrdering)
			delete(rawMsg, key)
		case "updatedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.UpdatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLFilter - Represents a filter which is a composition of an expression and an action that is executed in the pub/sub pipeline.
type SQLFilter struct {
	// This property is reserved for future use. An integer value showing the compatibility level, currently hard-coded to 20.
	CompatibilityLevel *int32 `json:"compatibilityLevel,omitempty"`

	// Value that indicates whether the rule action requires preprocessing.
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`

	// The SQL expression. e.g. MyProperty='ABC'
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// SQLRuleAction - Represents set of actions written in SQL language-based syntax that is performed against a ServiceBus.Messaging.BrokeredMessage
type SQLRuleAction struct {
	Action
}

// Subnet - Properties supplied for Subnet
type Subnet struct {
	// REQUIRED; Resource ID of Virtual Network Subnet
	ID *string `json:"id,omitempty"`
}

// SubscriptionsCreateOrUpdateOptions contains the optional parameters for the Subscriptions.CreateOrUpdate method.
type SubscriptionsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SubscriptionsDeleteOptions contains the optional parameters for the Subscriptions.Delete method.
type SubscriptionsDeleteOptions struct {
	// placeholder for future optional parameters
}

// SubscriptionsGetOptions contains the optional parameters for the Subscriptions.Get method.
type SubscriptionsGetOptions struct {
	// placeholder for future optional parameters
}

// SubscriptionsListByTopicOptions contains the optional parameters for the Subscriptions.ListByTopic method.
type SubscriptionsListByTopicOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink element
	// will include a skip parameter that specifies a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// TopicsCreateOrUpdateAuthorizationRuleOptions contains the optional parameters for the Topics.CreateOrUpdateAuthorizationRule method.
type TopicsCreateOrUpdateAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// TopicsCreateOrUpdateOptions contains the optional parameters for the Topics.CreateOrUpdate method.
type TopicsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TopicsDeleteAuthorizationRuleOptions contains the optional parameters for the Topics.DeleteAuthorizationRule method.
type TopicsDeleteAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// TopicsDeleteOptions contains the optional parameters for the Topics.Delete method.
type TopicsDeleteOptions struct {
	// placeholder for future optional parameters
}

// TopicsGetAuthorizationRuleOptions contains the optional parameters for the Topics.GetAuthorizationRule method.
type TopicsGetAuthorizationRuleOptions struct {
	// placeholder for future optional parameters
}

// TopicsGetOptions contains the optional parameters for the Topics.Get method.
type TopicsGetOptions struct {
	// placeholder for future optional parameters
}

// TopicsListAuthorizationRulesOptions contains the optional parameters for the Topics.ListAuthorizationRules method.
type TopicsListAuthorizationRulesOptions struct {
	// placeholder for future optional parameters
}

// TopicsListByNamespaceOptions contains the optional parameters for the Topics.ListByNamespace method.
type TopicsListByNamespaceOptions struct {
	// Skip is only used if a previous operation returned a partial result. If a previous response contains a nextLink element, the value of the nextLink element
	// will include a skip parameter that specifies a starting point to use for subsequent calls.
	Skip *int32
	// May be used to limit the number of results to the most recent N usageDetails.
	Top *int32
}

// TopicsListKeysOptions contains the optional parameters for the Topics.ListKeys method.
type TopicsListKeysOptions struct {
	// placeholder for future optional parameters
}

// TopicsRegenerateKeysOptions contains the optional parameters for the Topics.RegenerateKeys method.
type TopicsRegenerateKeysOptions struct {
	// placeholder for future optional parameters
}

// TrackedResource - The Resource definition.
type TrackedResource struct {
	Resource
	// REQUIRED; The Geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := t.marshalInternal()
	return json.Marshal(objectMap)
}

func (t TrackedResource) marshalInternal() map[string]interface{} {
	objectMap := t.Resource.marshalInternal()
	populate(objectMap, "location", t.Location)
	populate(objectMap, "tags", t.Tags)
	return objectMap
}

// VirtualNetworkRule - Single item in a List or Get VirtualNetworkRules operation
type VirtualNetworkRule struct {
	Resource
	// Properties supplied to create or update VirtualNetworkRules
	Properties *VirtualNetworkRuleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkRule.
func (v VirtualNetworkRule) MarshalJSON() ([]byte, error) {
	objectMap := v.Resource.marshalInternal()
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// VirtualNetworkRuleListResult - The response from the List namespace operation.
type VirtualNetworkRuleListResult struct {
	// Link to the next set of results. Not empty if Value contains an incomplete list of VirtualNetwork Rules
	NextLink *string `json:"nextLink,omitempty"`

	// Result of the List VirtualNetwork Rules operation.
	Value []*VirtualNetworkRule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkRuleListResult.
func (v VirtualNetworkRuleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualNetworkRuleProperties - Properties supplied to create or update VirtualNetworkRules
type VirtualNetworkRuleProperties struct {
	// Resource ID of Virtual Network Subnet
	VirtualNetworkSubnetID *string `json:"virtualNetworkSubnetId,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
