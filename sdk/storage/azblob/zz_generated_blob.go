// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

type blobClient struct {
	con            *connection
	pathRenameMode *PathRenameMode
}

// Pipeline returns the pipeline associated with this client.
func (client blobClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// AbortCopyFromURL - The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full
// metadata.
func (client blobClient) AbortCopyFromURL(ctx context.Context, copyId string, blobAbortCopyFromUrlOptions *BlobAbortCopyFromURLOptions, leaseAccessConditions *LeaseAccessConditions) (BlobAbortCopyFromURLResponse, error) {
	req, err := client.abortCopyFromUrlCreateRequest(ctx, copyId, blobAbortCopyFromUrlOptions, leaseAccessConditions)
	if err != nil {
		return BlobAbortCopyFromURLResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobAbortCopyFromURLResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return BlobAbortCopyFromURLResponse{}, client.abortCopyFromUrlHandleError(resp)
	}
	result, err := client.abortCopyFromUrlHandleResponse(resp)
	if err != nil {
		return BlobAbortCopyFromURLResponse{}, err
	}
	return result, nil
}

// abortCopyFromUrlCreateRequest creates the AbortCopyFromURL request.
func (client blobClient) abortCopyFromUrlCreateRequest(ctx context.Context, copyId string, blobAbortCopyFromUrlOptions *BlobAbortCopyFromURLOptions, leaseAccessConditions *LeaseAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "copy")
	query.Set("copyid", copyId)
	if blobAbortCopyFromUrlOptions != nil && blobAbortCopyFromUrlOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobAbortCopyFromUrlOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-copy-action", "abort")
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobAbortCopyFromUrlOptions != nil && blobAbortCopyFromUrlOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobAbortCopyFromUrlOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// abortCopyFromUrlHandleResponse handles the AbortCopyFromURL response.
func (client blobClient) abortCopyFromUrlHandleResponse(resp *azcore.Response) (BlobAbortCopyFromURLResponse, error) {
	result := BlobAbortCopyFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobAbortCopyFromURLResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// abortCopyFromUrlHandleError handles the AbortCopyFromURL error response.
func (client blobClient) abortCopyFromUrlHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// AcquireLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client blobClient) AcquireLease(ctx context.Context, blobAcquireLeaseOptions *BlobAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(ctx, blobAcquireLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return BlobAcquireLeaseResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobAcquireLeaseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlobAcquireLeaseResponse{}, client.acquireLeaseHandleError(resp)
	}
	result, err := client.acquireLeaseHandleResponse(resp)
	if err != nil {
		return BlobAcquireLeaseResponse{}, err
	}
	return result, nil
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client blobClient) acquireLeaseCreateRequest(ctx context.Context, blobAcquireLeaseOptions *BlobAcquireLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "lease")
	if blobAcquireLeaseOptions != nil && blobAcquireLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobAcquireLeaseOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-lease-action", "acquire")
	if blobAcquireLeaseOptions != nil && blobAcquireLeaseOptions.Duration != nil {
		req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*blobAcquireLeaseOptions.Duration), 10))
	}
	if blobAcquireLeaseOptions != nil && blobAcquireLeaseOptions.ProposedLeaseId != nil {
		req.Header.Set("x-ms-proposed-lease-id", *blobAcquireLeaseOptions.ProposedLeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobAcquireLeaseOptions != nil && blobAcquireLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobAcquireLeaseOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client blobClient) acquireLeaseHandleResponse(resp *azcore.Response) (BlobAcquireLeaseResponse, error) {
	result := BlobAcquireLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobAcquireLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobAcquireLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// acquireLeaseHandleError handles the AcquireLease error response.
func (client blobClient) acquireLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// BreakLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client blobClient) BreakLease(ctx context.Context, blobBreakLeaseOptions *BlobBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(ctx, blobBreakLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return BlobBreakLeaseResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobBreakLeaseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return BlobBreakLeaseResponse{}, client.breakLeaseHandleError(resp)
	}
	result, err := client.breakLeaseHandleResponse(resp)
	if err != nil {
		return BlobBreakLeaseResponse{}, err
	}
	return result, nil
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client blobClient) breakLeaseCreateRequest(ctx context.Context, blobBreakLeaseOptions *BlobBreakLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "lease")
	if blobBreakLeaseOptions != nil && blobBreakLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobBreakLeaseOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-lease-action", "break")
	if blobBreakLeaseOptions != nil && blobBreakLeaseOptions.BreakPeriod != nil {
		req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*blobBreakLeaseOptions.BreakPeriod), 10))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobBreakLeaseOptions != nil && blobBreakLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobBreakLeaseOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client blobClient) breakLeaseHandleResponse(resp *azcore.Response) (BlobBreakLeaseResponse, error) {
	result := BlobBreakLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobBreakLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-time"); val != "" {
		leaseTime32, err := strconv.ParseInt(val, 10, 32)
		leaseTime := int32(leaseTime32)
		if err != nil {
			return BlobBreakLeaseResponse{}, err
		}
		result.LeaseTime = &leaseTime
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobBreakLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// breakLeaseHandleError handles the BreakLease error response.
func (client blobClient) breakLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ChangeLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client blobClient) ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, blobChangeLeaseOptions *BlobChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(ctx, leaseId, proposedLeaseId, blobChangeLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return BlobChangeLeaseResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobChangeLeaseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobChangeLeaseResponse{}, client.changeLeaseHandleError(resp)
	}
	result, err := client.changeLeaseHandleResponse(resp)
	if err != nil {
		return BlobChangeLeaseResponse{}, err
	}
	return result, nil
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client blobClient) changeLeaseCreateRequest(ctx context.Context, leaseId string, proposedLeaseId string, blobChangeLeaseOptions *BlobChangeLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "lease")
	if blobChangeLeaseOptions != nil && blobChangeLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobChangeLeaseOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-lease-action", "change")
	req.Header.Set("x-ms-lease-id", leaseId)
	req.Header.Set("x-ms-proposed-lease-id", proposedLeaseId)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobChangeLeaseOptions != nil && blobChangeLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobChangeLeaseOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client blobClient) changeLeaseHandleResponse(resp *azcore.Response) (BlobChangeLeaseResponse, error) {
	result := BlobChangeLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobChangeLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobChangeLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// changeLeaseHandleError handles the ChangeLease error response.
func (client blobClient) changeLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CopyFromURL - The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete.
func (client blobClient) CopyFromURL(ctx context.Context, copySource url.URL, blobCopyFromUrlOptions *BlobCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (BlobCopyFromURLResponse, error) {
	req, err := client.copyFromUrlCreateRequest(ctx, copySource, blobCopyFromUrlOptions, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return BlobCopyFromURLResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobCopyFromURLResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return BlobCopyFromURLResponse{}, client.copyFromUrlHandleError(resp)
	}
	result, err := client.copyFromUrlHandleResponse(resp)
	if err != nil {
		return BlobCopyFromURLResponse{}, err
	}
	return result, nil
}

// copyFromUrlCreateRequest creates the CopyFromURL request.
func (client blobClient) copyFromUrlCreateRequest(ctx context.Context, copySource url.URL, blobCopyFromUrlOptions *BlobCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blobCopyFromUrlOptions != nil && blobCopyFromUrlOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobCopyFromUrlOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-requires-sync", "true")
	if blobCopyFromUrlOptions != nil && blobCopyFromUrlOptions.Metadata != nil {
		for k, v := range *blobCopyFromUrlOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if blobCopyFromUrlOptions != nil && blobCopyFromUrlOptions.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*blobCopyFromUrlOptions.Tier))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-copy-source", copySource.String())
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobCopyFromUrlOptions != nil && blobCopyFromUrlOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobCopyFromUrlOptions.RequestId)
	}
	if blobCopyFromUrlOptions != nil && blobCopyFromUrlOptions.SourceContentMd5 != nil {
		req.Header.Set("x-ms-source-content-md5", base64.StdEncoding.EncodeToString(*blobCopyFromUrlOptions.SourceContentMd5))
	}
	if blobCopyFromUrlOptions != nil && blobCopyFromUrlOptions.BlobTagsString != nil {
		req.Header.Set("x-ms-tags", *blobCopyFromUrlOptions.BlobTagsString)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// copyFromUrlHandleResponse handles the CopyFromURL response.
func (client blobClient) copyFromUrlHandleResponse(resp *azcore.Response) (BlobCopyFromURLResponse, error) {
	result := BlobCopyFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobCopyFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobCopyFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobCopyFromURLResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobCopyFromURLResponse{}, err
		}
		result.ContentCRC64 = &contentCrc64
	}
	return result, nil
}

// copyFromUrlHandleError handles the CopyFromURL error response.
func (client blobClient) copyFromUrlHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// CreateSnapshot - The Create Snapshot operation creates a read-only snapshot of a blob
func (client blobClient) CreateSnapshot(ctx context.Context, blobCreateSnapshotOptions *BlobCreateSnapshotOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (BlobCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(ctx, blobCreateSnapshotOptions, cpkInfo, cpkScopeInfo, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return BlobCreateSnapshotResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobCreateSnapshotResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlobCreateSnapshotResponse{}, client.createSnapshotHandleError(resp)
	}
	result, err := client.createSnapshotHandleResponse(resp)
	if err != nil {
		return BlobCreateSnapshotResponse{}, err
	}
	return result, nil
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client blobClient) createSnapshotCreateRequest(ctx context.Context, blobCreateSnapshotOptions *BlobCreateSnapshotOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "snapshot")
	if blobCreateSnapshotOptions != nil && blobCreateSnapshotOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobCreateSnapshotOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if blobCreateSnapshotOptions != nil && blobCreateSnapshotOptions.Metadata != nil {
		for k, v := range *blobCreateSnapshotOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobCreateSnapshotOptions != nil && blobCreateSnapshotOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobCreateSnapshotOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client blobClient) createSnapshotHandleResponse(resp *azcore.Response) (BlobCreateSnapshotResponse, error) {
	result := BlobCreateSnapshotResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-snapshot"); val != "" {
		result.Snapshot = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobCreateSnapshotResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobCreateSnapshotResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlobCreateSnapshotResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	return result, nil
}

// createSnapshotHandleError handles the CreateSnapshot error response.
func (client blobClient) createSnapshotHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Delete - If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If
// the storage account's soft delete feature is enabled,
// then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot
// for the number of days specified by the
// DeleteRetentionPolicy section of Storage service properties [Set-Blob-Service-Properties.md]. After the specified number of days has passed, the blob's
// data is permanently removed from the storage
// account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify
// the "include=deleted" query parameter to discover
// which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted
// blob or snapshot causes the service to
// return an HTTP status code of 404 (ResourceNotFound).
func (client blobClient) Delete(ctx context.Context, blobDeleteOptions *BlobDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (BlobDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, blobDeleteOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return BlobDeleteResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobDeleteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return BlobDeleteResponse{}, client.deleteHandleError(resp)
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return BlobDeleteResponse{}, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client blobClient) deleteCreateRequest(ctx context.Context, blobDeleteOptions *BlobDeleteOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodDelete, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blobDeleteOptions != nil && blobDeleteOptions.Snapshot != nil {
		query.Set("snapshot", *blobDeleteOptions.Snapshot)
	}
	if blobDeleteOptions != nil && blobDeleteOptions.VersionId != nil {
		query.Set("versionid", *blobDeleteOptions.VersionId)
	}
	if blobDeleteOptions != nil && blobDeleteOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobDeleteOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if blobDeleteOptions != nil && blobDeleteOptions.DeleteSnapshots != nil {
		req.Header.Set("x-ms-delete-snapshots", string(*blobDeleteOptions.DeleteSnapshots))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobDeleteOptions != nil && blobDeleteOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobDeleteOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client blobClient) deleteHandleResponse(resp *azcore.Response) (BlobDeleteResponse, error) {
	result := BlobDeleteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client blobClient) deleteHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Download - The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read
// a snapshot.
func (client blobClient) Download(ctx context.Context, blobDownloadOptions *BlobDownloadOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (BlobDownloadResponse, error) {
	req, err := client.downloadCreateRequest(ctx, blobDownloadOptions, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if err != nil {
		return BlobDownloadResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobDownloadResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusPartialContent) {
		return BlobDownloadResponse{}, client.downloadHandleError(resp)
	}
	result, err := client.downloadHandleResponse(resp)
	if err != nil {
		return BlobDownloadResponse{}, err
	}
	return result, nil
}

// downloadCreateRequest creates the Download request.
func (client blobClient) downloadCreateRequest(ctx context.Context, blobDownloadOptions *BlobDownloadOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blobDownloadOptions != nil && blobDownloadOptions.Snapshot != nil {
		query.Set("snapshot", *blobDownloadOptions.Snapshot)
	}
	if blobDownloadOptions != nil && blobDownloadOptions.VersionId != nil {
		query.Set("versionid", *blobDownloadOptions.VersionId)
	}
	if blobDownloadOptions != nil && blobDownloadOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobDownloadOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.SkipBodyDownload()
	if blobDownloadOptions != nil && blobDownloadOptions.RangeParameter != nil {
		req.Header.Set("x-ms-range", *blobDownloadOptions.RangeParameter)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if blobDownloadOptions != nil && blobDownloadOptions.RangeGetContentMd5 != nil {
		req.Header.Set("x-ms-range-get-content-md5", strconv.FormatBool(*blobDownloadOptions.RangeGetContentMd5))
	}
	if blobDownloadOptions != nil && blobDownloadOptions.RangeGetContentCrc64 != nil {
		req.Header.Set("x-ms-range-get-content-crc64", strconv.FormatBool(*blobDownloadOptions.RangeGetContentCrc64))
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobDownloadOptions != nil && blobDownloadOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobDownloadOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client blobClient) downloadHandleResponse(resp *azcore.Response) (BlobDownloadResponse, error) {
	result := BlobDownloadResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if strings.HasPrefix(hh, "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = &map[string]string{}
			}
			(*result.Metadata)[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-or-policy-id"); val != "" {
		result.ObjectReplicationPolicyID = &val
	}
	for hh := range resp.Header {
		if strings.HasPrefix(hh, "x-ms-or-") {
			if result.Metadata == nil {
				result.Metadata = &map[string]string{}
			}
			(*result.Metadata)[hh[len("x-ms-or-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-blob-content-md5"); val != "" {
		blobContentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.BlobContentMD5 = &blobContentMd5
	}
	if val := resp.Header.Get("x-ms-tag-count"); val != "" {
		tagCount, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.TagCount = &tagCount
	}
	if val := resp.Header.Get("x-ms-blob-sealed"); val != "" {
		isSealed, err := strconv.ParseBool(val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.IsSealed = &isSealed
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobDownloadResponse{}, err
		}
		result.ContentCRC64 = &contentCrc64
	}
	return result, nil
}

// downloadHandleError handles the Download error response.
func (client blobClient) downloadHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetAccessControl - Get the owner, group, permissions, or access control list for a blob.
func (client blobClient) GetAccessControl(ctx context.Context, blobGetAccessControlOptions *BlobGetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (BlobGetAccessControlResponse, error) {
	req, err := client.getAccessControlCreateRequest(ctx, blobGetAccessControlOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return BlobGetAccessControlResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobGetAccessControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobGetAccessControlResponse{}, client.getAccessControlHandleError(resp)
	}
	result, err := client.getAccessControlHandleResponse(resp)
	if err != nil {
		return BlobGetAccessControlResponse{}, err
	}
	return result, nil
}

// getAccessControlCreateRequest creates the GetAccessControl request.
func (client blobClient) getAccessControlCreateRequest(ctx context.Context, blobGetAccessControlOptions *BlobGetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodHead, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("action", "getAccessControl")
	if blobGetAccessControlOptions != nil && blobGetAccessControlOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobGetAccessControlOptions.Timeout), 10))
	}
	if blobGetAccessControlOptions != nil && blobGetAccessControlOptions.Upn != nil {
		query.Set("upn", strconv.FormatBool(*blobGetAccessControlOptions.Upn))
	}
	req.URL.RawQuery = query.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if blobGetAccessControlOptions != nil && blobGetAccessControlOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobGetAccessControlOptions.RequestId)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccessControlHandleResponse handles the GetAccessControl response.
func (client blobClient) getAccessControlHandleResponse(resp *azcore.Response) (BlobGetAccessControlResponse, error) {
	result := BlobGetAccessControlResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetAccessControlResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetAccessControlResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-owner"); val != "" {
		result.Owner = &val
	}
	if val := resp.Header.Get("x-ms-group"); val != "" {
		result.Group = &val
	}
	if val := resp.Header.Get("x-ms-permissions"); val != "" {
		result.Permissions = &val
	}
	if val := resp.Header.Get("x-ms-acl"); val != "" {
		result.ACL = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// getAccessControlHandleError handles the GetAccessControl error response.
func (client blobClient) getAccessControlHandleError(resp *azcore.Response) error {
	var err DataLakeStorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetAccountInfo - Returns the sku name and account kind
func (client blobClient) GetAccountInfo(ctx context.Context, options *BlobGetAccountInfoOptions) (BlobGetAccountInfoResponse, error) {
	req, err := client.getAccountInfoCreateRequest(ctx, options)
	if err != nil {
		return BlobGetAccountInfoResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobGetAccountInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobGetAccountInfoResponse{}, client.getAccountInfoHandleError(resp)
	}
	result, err := client.getAccountInfoHandleResponse(resp)
	if err != nil {
		return BlobGetAccountInfoResponse{}, err
	}
	return result, nil
}

// getAccountInfoCreateRequest creates the GetAccountInfo request.
func (client blobClient) getAccountInfoCreateRequest(ctx context.Context, options *BlobGetAccountInfoOptions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("restype", "account")
	query.Set("comp", "properties")
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-version", "2019-12-12")
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccountInfoHandleResponse handles the GetAccountInfo response.
func (client blobClient) getAccountInfoHandleResponse(resp *azcore.Response) (BlobGetAccountInfoResponse, error) {
	result := BlobGetAccountInfoResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetAccountInfoResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-sku-name"); val != "" {
		result.SKUName = (*SKUName)(&val)
	}
	if val := resp.Header.Get("x-ms-account-kind"); val != "" {
		result.AccountKind = (*AccountKind)(&val)
	}
	return result, nil
}

// getAccountInfoHandleError handles the GetAccountInfo error response.
func (client blobClient) getAccountInfoHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetProperties - The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does
// not return the content of the blob.
func (client blobClient) GetProperties(ctx context.Context, blobGetPropertiesOptions *BlobGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (BlobGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(ctx, blobGetPropertiesOptions, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if err != nil {
		return BlobGetPropertiesResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobGetPropertiesResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobGetPropertiesResponse{}, client.getPropertiesHandleError(resp)
	}
	result, err := client.getPropertiesHandleResponse(resp)
	if err != nil {
		return BlobGetPropertiesResponse{}, err
	}
	return result, nil
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client blobClient) getPropertiesCreateRequest(ctx context.Context, blobGetPropertiesOptions *BlobGetPropertiesOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodHead, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blobGetPropertiesOptions != nil && blobGetPropertiesOptions.Snapshot != nil {
		query.Set("snapshot", *blobGetPropertiesOptions.Snapshot)
	}
	if blobGetPropertiesOptions != nil && blobGetPropertiesOptions.VersionId != nil {
		query.Set("versionid", *blobGetPropertiesOptions.VersionId)
	}
	if blobGetPropertiesOptions != nil && blobGetPropertiesOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobGetPropertiesOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobGetPropertiesOptions != nil && blobGetPropertiesOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobGetPropertiesOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client blobClient) getPropertiesHandleResponse(resp *azcore.Response) (BlobGetPropertiesResponse, error) {
	result := BlobGetPropertiesResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-creation-time"); val != "" {
		creationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.CreationTime = &creationTime
	}
	for hh := range resp.Header {
		if strings.HasPrefix(hh, "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = &map[string]string{}
			}
			(*result.Metadata)[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-or-policy-id"); val != "" {
		result.ObjectReplicationPolicyID = &val
	}
	for hh := range resp.Header {
		if strings.HasPrefix(hh, "x-ms-or-") {
			if result.Metadata == nil {
				result.Metadata = &map[string]string{}
			}
			(*result.Metadata)[hh[len("x-ms-or-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-incremental-copy"); val != "" {
		isIncrementalCopy, err := strconv.ParseBool(val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.IsIncrementalCopy = &isIncrementalCopy
	}
	if val := resp.Header.Get("x-ms-copy-destination-snapshot"); val != "" {
		result.DestinationSnapshot = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-access-tier"); val != "" {
		result.AccessTier = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-inferred"); val != "" {
		accessTierInferred, err := strconv.ParseBool(val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.AccessTierInferred = &accessTierInferred
	}
	if val := resp.Header.Get("x-ms-archive-status"); val != "" {
		result.ArchiveStatus = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-change-time"); val != "" {
		accessTierChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.AccessTierChangeTime = &accessTierChangeTime
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("x-ms-is-current-version"); val != "" {
		isCurrentVersion, err := strconv.ParseBool(val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.IsCurrentVersion = &isCurrentVersion
	}
	if val := resp.Header.Get("x-ms-tag-count"); val != "" {
		tagCount, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.TagCount = &tagCount
	}
	if val := resp.Header.Get("x-ms-expiry-time"); val != "" {
		expiresOn, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.ExpiresOn = &expiresOn
	}
	if val := resp.Header.Get("x-ms-blob-sealed"); val != "" {
		isSealed, err := strconv.ParseBool(val)
		if err != nil {
			return BlobGetPropertiesResponse{}, err
		}
		result.IsSealed = &isSealed
	}
	if val := resp.Header.Get("x-ms-rehydrate-priority"); val != "" {
		result.RehydratePriority = &val
	}
	return result, nil
}

// getPropertiesHandleError handles the GetProperties error response.
func (client blobClient) getPropertiesHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetTags - The Get Tags operation enables users to get the tags associated with a blob.
func (client blobClient) GetTags(ctx context.Context, blobGetTagsOptions *BlobGetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobTagsResponse, error) {
	req, err := client.getTagsCreateRequest(ctx, blobGetTagsOptions, modifiedAccessConditions)
	if err != nil {
		return BlobTagsResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobTagsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobTagsResponse{}, client.getTagsHandleError(resp)
	}
	result, err := client.getTagsHandleResponse(resp)
	if err != nil {
		return BlobTagsResponse{}, err
	}
	return result, nil
}

// getTagsCreateRequest creates the GetTags request.
func (client blobClient) getTagsCreateRequest(ctx context.Context, blobGetTagsOptions *BlobGetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "tags")
	if blobGetTagsOptions != nil && blobGetTagsOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobGetTagsOptions.Timeout), 10))
	}
	if blobGetTagsOptions != nil && blobGetTagsOptions.Snapshot != nil {
		query.Set("snapshot", *blobGetTagsOptions.Snapshot)
	}
	if blobGetTagsOptions != nil && blobGetTagsOptions.VersionId != nil {
		query.Set("versionid", *blobGetTagsOptions.VersionId)
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobGetTagsOptions != nil && blobGetTagsOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobGetTagsOptions.RequestId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getTagsHandleResponse handles the GetTags response.
func (client blobClient) getTagsHandleResponse(resp *azcore.Response) (BlobTagsResponse, error) {
	result := BlobTagsResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobTagsResponse{}, err
		}
		result.Date = &date
	}
	err := resp.UnmarshalAsXML(&result.Tags)
	return result, err
}

// getTagsHandleError handles the GetTags error response.
func (client blobClient) getTagsHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Query - The Query operation enables users to select/project on blob data by providing simple query expressions.
func (client blobClient) Query(ctx context.Context, blobQueryOptions *BlobQueryOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (BlobQueryResponse, error) {
	req, err := client.queryCreateRequest(ctx, blobQueryOptions, leaseAccessConditions, cpkInfo, modifiedAccessConditions)
	if err != nil {
		return BlobQueryResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobQueryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusPartialContent) {
		return BlobQueryResponse{}, client.queryHandleError(resp)
	}
	result, err := client.queryHandleResponse(resp)
	if err != nil {
		return BlobQueryResponse{}, err
	}
	return result, nil
}

// queryCreateRequest creates the Query request.
func (client blobClient) queryCreateRequest(ctx context.Context, blobQueryOptions *BlobQueryOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPost, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "query")
	if blobQueryOptions != nil && blobQueryOptions.Snapshot != nil {
		query.Set("snapshot", *blobQueryOptions.Snapshot)
	}
	if blobQueryOptions != nil && blobQueryOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobQueryOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.SkipBodyDownload()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobQueryOptions != nil && blobQueryOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobQueryOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	if blobQueryOptions != nil {
		return req, req.MarshalAsXML(blobQueryOptions.QueryRequest)
	}
	return req, nil
}

// queryHandleResponse handles the Query response.
func (client blobClient) queryHandleResponse(resp *azcore.Response) (BlobQueryResponse, error) {
	result := BlobQueryResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.LastModified = &lastModified
	}
	for hh := range resp.Header {
		if strings.HasPrefix(hh, "x-ms-meta-") {
			if result.Metadata == nil {
				result.Metadata = &map[string]string{}
			}
			(*result.Metadata)[hh[len("x-ms-meta-"):]] = resp.Header.Get(hh)
		}
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-blob-content-md5"); val != "" {
		blobContentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.BlobContentMD5 = &blobContentMd5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlobQueryResponse{}, err
		}
		result.ContentCRC64 = &contentCrc64
	}
	return result, nil
}

// queryHandleError handles the Query error response.
func (client blobClient) queryHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// ReleaseLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client blobClient) ReleaseLease(ctx context.Context, leaseId string, blobReleaseLeaseOptions *BlobReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(ctx, leaseId, blobReleaseLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return BlobReleaseLeaseResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobReleaseLeaseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobReleaseLeaseResponse{}, client.releaseLeaseHandleError(resp)
	}
	result, err := client.releaseLeaseHandleResponse(resp)
	if err != nil {
		return BlobReleaseLeaseResponse{}, err
	}
	return result, nil
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client blobClient) releaseLeaseCreateRequest(ctx context.Context, leaseId string, blobReleaseLeaseOptions *BlobReleaseLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "lease")
	if blobReleaseLeaseOptions != nil && blobReleaseLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobReleaseLeaseOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-lease-action", "release")
	req.Header.Set("x-ms-lease-id", leaseId)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobReleaseLeaseOptions != nil && blobReleaseLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobReleaseLeaseOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client blobClient) releaseLeaseHandleResponse(resp *azcore.Response) (BlobReleaseLeaseResponse, error) {
	result := BlobReleaseLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobReleaseLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobReleaseLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// releaseLeaseHandleError handles the ReleaseLease error response.
func (client blobClient) releaseLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Rename - Rename a blob/file. By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken. This
// operation supports conditional HTTP requests. For more
// information, see Specifying Conditional Headers for Blob Service Operations [https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations].
// To
// fail if the destination already exists, use a conditional request with If-None-Match: "*".
func (client blobClient) Rename(ctx context.Context, renameSource string, blobRenameOptions *BlobRenameOptions, directoryHttpHeaders *DirectoryHttpHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (BlobRenameResponse, error) {
	req, err := client.renameCreateRequest(ctx, renameSource, blobRenameOptions, directoryHttpHeaders, leaseAccessConditions, modifiedAccessConditions, sourceModifiedAccessConditions)
	if err != nil {
		return BlobRenameResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobRenameResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlobRenameResponse{}, client.renameHandleError(resp)
	}
	result, err := client.renameHandleResponse(resp)
	if err != nil {
		return BlobRenameResponse{}, err
	}
	return result, nil
}

// renameCreateRequest creates the Rename request.
func (client blobClient) renameCreateRequest(ctx context.Context, renameSource string, blobRenameOptions *BlobRenameOptions, directoryHttpHeaders *DirectoryHttpHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blobRenameOptions != nil && blobRenameOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobRenameOptions.Timeout), 10))
	}
	if client.pathRenameMode != nil {
		query.Set("mode", string(*client.pathRenameMode))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-rename-source", renameSource)
	if blobRenameOptions != nil && blobRenameOptions.DirectoryProperties != nil {
		req.Header.Set("x-ms-properties", *blobRenameOptions.DirectoryProperties)
	}
	if blobRenameOptions != nil && blobRenameOptions.PosixPermissions != nil {
		req.Header.Set("x-ms-permissions", *blobRenameOptions.PosixPermissions)
	}
	if blobRenameOptions != nil && blobRenameOptions.PosixUmask != nil {
		req.Header.Set("x-ms-umask", *blobRenameOptions.PosixUmask)
	}
	if directoryHttpHeaders != nil && directoryHttpHeaders.CacheControl != nil {
		req.Header.Set("x-ms-cache-control", *directoryHttpHeaders.CacheControl)
	}
	if directoryHttpHeaders != nil && directoryHttpHeaders.ContentType != nil {
		req.Header.Set("x-ms-content-type", *directoryHttpHeaders.ContentType)
	}
	if directoryHttpHeaders != nil && directoryHttpHeaders.ContentEncoding != nil {
		req.Header.Set("x-ms-content-encoding", *directoryHttpHeaders.ContentEncoding)
	}
	if directoryHttpHeaders != nil && directoryHttpHeaders.ContentLanguage != nil {
		req.Header.Set("x-ms-content-language", *directoryHttpHeaders.ContentLanguage)
	}
	if directoryHttpHeaders != nil && directoryHttpHeaders.ContentDisposition != nil {
		req.Header.Set("x-ms-content-disposition", *directoryHttpHeaders.ContentDisposition)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if blobRenameOptions != nil && blobRenameOptions.SourceLeaseId != nil {
		req.Header.Set("x-ms-source-lease-id", *blobRenameOptions.SourceLeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobRenameOptions != nil && blobRenameOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobRenameOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// renameHandleResponse handles the Rename response.
func (client blobClient) renameHandleResponse(resp *azcore.Response) (BlobRenameResponse, error) {
	result := BlobRenameResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobRenameResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobRenameResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobRenameResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// renameHandleError handles the Rename error response.
func (client blobClient) renameHandleError(resp *azcore.Response) error {
	var err DataLakeStorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// RenewLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client blobClient) RenewLease(ctx context.Context, leaseId string, blobRenewLeaseOptions *BlobRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(ctx, leaseId, blobRenewLeaseOptions, modifiedAccessConditions)
	if err != nil {
		return BlobRenewLeaseResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobRenewLeaseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobRenewLeaseResponse{}, client.renewLeaseHandleError(resp)
	}
	result, err := client.renewLeaseHandleResponse(resp)
	if err != nil {
		return BlobRenewLeaseResponse{}, err
	}
	return result, nil
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client blobClient) renewLeaseCreateRequest(ctx context.Context, leaseId string, blobRenewLeaseOptions *BlobRenewLeaseOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "lease")
	if blobRenewLeaseOptions != nil && blobRenewLeaseOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobRenewLeaseOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-lease-action", "renew")
	req.Header.Set("x-ms-lease-id", leaseId)
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobRenewLeaseOptions != nil && blobRenewLeaseOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobRenewLeaseOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client blobClient) renewLeaseHandleResponse(resp *azcore.Response) (BlobRenewLeaseResponse, error) {
	result := BlobRenewLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobRenewLeaseResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseID = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobRenewLeaseResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// renewLeaseHandleError handles the RenewLease error response.
func (client blobClient) renewLeaseHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// SetAccessControl - Set the owner, group, permissions, or access control list for a blob.
func (client blobClient) SetAccessControl(ctx context.Context, blobSetAccessControlOptions *BlobSetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (BlobSetAccessControlResponse, error) {
	req, err := client.setAccessControlCreateRequest(ctx, blobSetAccessControlOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return BlobSetAccessControlResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobSetAccessControlResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobSetAccessControlResponse{}, client.setAccessControlHandleError(resp)
	}
	result, err := client.setAccessControlHandleResponse(resp)
	if err != nil {
		return BlobSetAccessControlResponse{}, err
	}
	return result, nil
}

// setAccessControlCreateRequest creates the SetAccessControl request.
func (client blobClient) setAccessControlCreateRequest(ctx context.Context, blobSetAccessControlOptions *BlobSetAccessControlOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPatch, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("action", "setAccessControl")
	if blobSetAccessControlOptions != nil && blobSetAccessControlOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobSetAccessControlOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if blobSetAccessControlOptions != nil && blobSetAccessControlOptions.Owner != nil {
		req.Header.Set("x-ms-owner", *blobSetAccessControlOptions.Owner)
	}
	if blobSetAccessControlOptions != nil && blobSetAccessControlOptions.Group != nil {
		req.Header.Set("x-ms-group", *blobSetAccessControlOptions.Group)
	}
	if blobSetAccessControlOptions != nil && blobSetAccessControlOptions.PosixPermissions != nil {
		req.Header.Set("x-ms-permissions", *blobSetAccessControlOptions.PosixPermissions)
	}
	if blobSetAccessControlOptions != nil && blobSetAccessControlOptions.PosixAcl != nil {
		req.Header.Set("x-ms-acl", *blobSetAccessControlOptions.PosixAcl)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if blobSetAccessControlOptions != nil && blobSetAccessControlOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobSetAccessControlOptions.RequestId)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// setAccessControlHandleResponse handles the SetAccessControl response.
func (client blobClient) setAccessControlHandleResponse(resp *azcore.Response) (BlobSetAccessControlResponse, error) {
	result := BlobSetAccessControlResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetAccessControlResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetAccessControlResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// setAccessControlHandleError handles the SetAccessControl error response.
func (client blobClient) setAccessControlHandleError(resp *azcore.Response) error {
	var err DataLakeStorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// SetExpiry - Sets the time a blob will expire and be deleted.
func (client blobClient) SetExpiry(ctx context.Context, expiryOptions BlobExpiryOptions, options *BlobSetExpiryOptions) (BlobSetExpiryResponse, error) {
	req, err := client.setExpiryCreateRequest(ctx, expiryOptions, options)
	if err != nil {
		return BlobSetExpiryResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobSetExpiryResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobSetExpiryResponse{}, client.setExpiryHandleError(resp)
	}
	result, err := client.setExpiryHandleResponse(resp)
	if err != nil {
		return BlobSetExpiryResponse{}, err
	}
	return result, nil
}

// setExpiryCreateRequest creates the SetExpiry request.
func (client blobClient) setExpiryCreateRequest(ctx context.Context, expiryOptions BlobExpiryOptions, options *BlobSetExpiryOptions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "expiry")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	req.Header.Set("x-ms-expiry-option", string(expiryOptions))
	if options != nil && options.ExpiresOn != nil {
		req.Header.Set("x-ms-expiry-time", *options.ExpiresOn)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// setExpiryHandleResponse handles the SetExpiry response.
func (client blobClient) setExpiryHandleResponse(resp *azcore.Response) (BlobSetExpiryResponse, error) {
	result := BlobSetExpiryResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetExpiryResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetExpiryResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setExpiryHandleError handles the SetExpiry error response.
func (client blobClient) setExpiryHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// SetHTTPHeaders - The Set HTTP Headers operation sets system properties on the blob
func (client blobClient) SetHTTPHeaders(ctx context.Context, blobSetHttpHeadersOptions *BlobSetHTTPHeadersOptions, blobHttpHeaders *BlobHttpHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (BlobSetHTTPHeadersResponse, error) {
	req, err := client.setHttpHeadersCreateRequest(ctx, blobSetHttpHeadersOptions, blobHttpHeaders, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return BlobSetHTTPHeadersResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobSetHTTPHeadersResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobSetHTTPHeadersResponse{}, client.setHttpHeadersHandleError(resp)
	}
	result, err := client.setHttpHeadersHandleResponse(resp)
	if err != nil {
		return BlobSetHTTPHeadersResponse{}, err
	}
	return result, nil
}

// setHttpHeadersCreateRequest creates the SetHTTPHeaders request.
func (client blobClient) setHttpHeadersCreateRequest(ctx context.Context, blobSetHttpHeadersOptions *BlobSetHTTPHeadersOptions, blobHttpHeaders *BlobHttpHeaders, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "properties")
	if blobSetHttpHeadersOptions != nil && blobSetHttpHeadersOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobSetHttpHeadersOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if blobHttpHeaders != nil && blobHttpHeaders.BlobCacheControl != nil {
		req.Header.Set("x-ms-blob-cache-control", *blobHttpHeaders.BlobCacheControl)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentType != nil {
		req.Header.Set("x-ms-blob-content-type", *blobHttpHeaders.BlobContentType)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentMd5 != nil {
		req.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(*blobHttpHeaders.BlobContentMd5))
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentEncoding != nil {
		req.Header.Set("x-ms-blob-content-encoding", *blobHttpHeaders.BlobContentEncoding)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentLanguage != nil {
		req.Header.Set("x-ms-blob-content-language", *blobHttpHeaders.BlobContentLanguage)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentDisposition != nil {
		req.Header.Set("x-ms-blob-content-disposition", *blobHttpHeaders.BlobContentDisposition)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobSetHttpHeadersOptions != nil && blobSetHttpHeadersOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobSetHttpHeadersOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// setHttpHeadersHandleResponse handles the SetHTTPHeaders response.
func (client blobClient) setHttpHeadersHandleResponse(resp *azcore.Response) (BlobSetHTTPHeadersResponse, error) {
	result := BlobSetHTTPHeadersResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetHTTPHeadersResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlobSetHTTPHeadersResponse{}, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetHTTPHeadersResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setHttpHeadersHandleError handles the SetHTTPHeaders error response.
func (client blobClient) setHttpHeadersHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// SetMetadata - The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs
func (client blobClient) SetMetadata(ctx context.Context, blobSetMetadataOptions *BlobSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (BlobSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(ctx, blobSetMetadataOptions, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if err != nil {
		return BlobSetMetadataResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobSetMetadataResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobSetMetadataResponse{}, client.setMetadataHandleError(resp)
	}
	result, err := client.setMetadataHandleResponse(resp)
	if err != nil {
		return BlobSetMetadataResponse{}, err
	}
	return result, nil
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client blobClient) setMetadataCreateRequest(ctx context.Context, blobSetMetadataOptions *BlobSetMetadataOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "metadata")
	if blobSetMetadataOptions != nil && blobSetMetadataOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobSetMetadataOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if blobSetMetadataOptions != nil && blobSetMetadataOptions.Metadata != nil {
		for k, v := range *blobSetMetadataOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobSetMetadataOptions != nil && blobSetMetadataOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobSetMetadataOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client blobClient) setMetadataHandleResponse(resp *azcore.Response) (BlobSetMetadataResponse, error) {
	result := BlobSetMetadataResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetMetadataResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetMetadataResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlobSetMetadataResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return result, nil
}

// setMetadataHandleError handles the SetMetadata error response.
func (client blobClient) setMetadataHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// SetTags - The Set Tags operation enables users to set tags on a blob.
func (client blobClient) SetTags(ctx context.Context, blobSetTagsOptions *BlobSetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions) (BlobSetTagsResponse, error) {
	req, err := client.setTagsCreateRequest(ctx, blobSetTagsOptions, modifiedAccessConditions)
	if err != nil {
		return BlobSetTagsResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobSetTagsResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return BlobSetTagsResponse{}, client.setTagsHandleError(resp)
	}
	result, err := client.setTagsHandleResponse(resp)
	if err != nil {
		return BlobSetTagsResponse{}, err
	}
	return result, nil
}

// setTagsCreateRequest creates the SetTags request.
func (client blobClient) setTagsCreateRequest(ctx context.Context, blobSetTagsOptions *BlobSetTagsOptions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "tags")
	if blobSetTagsOptions != nil && blobSetTagsOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobSetTagsOptions.Timeout), 10))
	}
	if blobSetTagsOptions != nil && blobSetTagsOptions.VersionId != nil {
		query.Set("versionid", *blobSetTagsOptions.VersionId)
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobSetTagsOptions != nil && blobSetTagsOptions.TransactionalContentMd5 != nil {
		req.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(*blobSetTagsOptions.TransactionalContentMd5))
	}
	if blobSetTagsOptions != nil && blobSetTagsOptions.TransactionalContentCrc64 != nil {
		req.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(*blobSetTagsOptions.TransactionalContentCrc64))
	}
	if blobSetTagsOptions != nil && blobSetTagsOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobSetTagsOptions.RequestId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("Accept", "application/xml")
	if blobSetTagsOptions != nil {
		return req, req.MarshalAsXML(blobSetTagsOptions.Tags)
	}
	return req, nil
}

// setTagsHandleResponse handles the SetTags response.
func (client blobClient) setTagsHandleResponse(resp *azcore.Response) (BlobSetTagsResponse, error) {
	result := BlobSetTagsResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobSetTagsResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setTagsHandleError handles the SetTags error response.
func (client blobClient) setTagsHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// SetTier - The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in
// a blob storage account (locally redundant storage only). A
// premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive storage type.
// This operation does not update the blob's ETag.
func (client blobClient) SetTier(ctx context.Context, tier AccessTier, blobSetTierOptions *BlobSetTierOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (BlobSetTierResponse, error) {
	req, err := client.setTierCreateRequest(ctx, tier, blobSetTierOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return BlobSetTierResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobSetTierResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return BlobSetTierResponse{}, client.setTierHandleError(resp)
	}
	result, err := client.setTierHandleResponse(resp)
	if err != nil {
		return BlobSetTierResponse{}, err
	}
	return result, nil
}

// setTierCreateRequest creates the SetTier request.
func (client blobClient) setTierCreateRequest(ctx context.Context, tier AccessTier, blobSetTierOptions *BlobSetTierOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "tier")
	if blobSetTierOptions != nil && blobSetTierOptions.Snapshot != nil {
		query.Set("snapshot", *blobSetTierOptions.Snapshot)
	}
	if blobSetTierOptions != nil && blobSetTierOptions.VersionId != nil {
		query.Set("versionid", *blobSetTierOptions.VersionId)
	}
	if blobSetTierOptions != nil && blobSetTierOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobSetTierOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-access-tier", string(tier))
	if blobSetTierOptions != nil && blobSetTierOptions.RehydratePriority != nil {
		req.Header.Set("x-ms-rehydrate-priority", string(*blobSetTierOptions.RehydratePriority))
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobSetTierOptions != nil && blobSetTierOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobSetTierOptions.RequestId)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// setTierHandleResponse handles the SetTier response.
func (client blobClient) setTierHandleResponse(resp *azcore.Response) (BlobSetTierResponse, error) {
	result := BlobSetTierResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return result, nil
}

// setTierHandleError handles the SetTier error response.
func (client blobClient) setTierHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// StartCopyFromURL - The Start Copy From URL operation copies a blob or an internet resource to a new blob.
func (client blobClient) StartCopyFromURL(ctx context.Context, copySource url.URL, blobStartCopyFromUrlOptions *BlobStartCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (BlobStartCopyFromURLResponse, error) {
	req, err := client.startCopyFromUrlCreateRequest(ctx, copySource, blobStartCopyFromUrlOptions, sourceModifiedAccessConditions, modifiedAccessConditions, leaseAccessConditions)
	if err != nil {
		return BlobStartCopyFromURLResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobStartCopyFromURLResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusAccepted) {
		return BlobStartCopyFromURLResponse{}, client.startCopyFromUrlHandleError(resp)
	}
	result, err := client.startCopyFromUrlHandleResponse(resp)
	if err != nil {
		return BlobStartCopyFromURLResponse{}, err
	}
	return result, nil
}

// startCopyFromUrlCreateRequest creates the StartCopyFromURL request.
func (client blobClient) startCopyFromUrlCreateRequest(ctx context.Context, copySource url.URL, blobStartCopyFromUrlOptions *BlobStartCopyFromURLOptions, sourceModifiedAccessConditions *SourceModifiedAccessConditions, modifiedAccessConditions *ModifiedAccessConditions, leaseAccessConditions *LeaseAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blobStartCopyFromUrlOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.Metadata != nil {
		for k, v := range *blobStartCopyFromUrlOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*blobStartCopyFromUrlOptions.Tier))
	}
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.RehydratePriority != nil {
		req.Header.Set("x-ms-rehydrate-priority", string(*blobStartCopyFromUrlOptions.RehydratePriority))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfTags != nil {
		req.Header.Set("x-ms-source-if-tags", *sourceModifiedAccessConditions.SourceIfTags)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-copy-source", copySource.String())
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blobStartCopyFromUrlOptions.RequestId)
	}
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.BlobTagsString != nil {
		req.Header.Set("x-ms-tags", *blobStartCopyFromUrlOptions.BlobTagsString)
	}
	if blobStartCopyFromUrlOptions != nil && blobStartCopyFromUrlOptions.SealBlob != nil {
		req.Header.Set("x-ms-seal-blob", strconv.FormatBool(*blobStartCopyFromUrlOptions.SealBlob))
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// startCopyFromUrlHandleResponse handles the StartCopyFromURL response.
func (client blobClient) startCopyFromUrlHandleResponse(resp *azcore.Response) (BlobStartCopyFromURLResponse, error) {
	result := BlobStartCopyFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobStartCopyFromURLResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobStartCopyFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyID = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	return result, nil
}

// startCopyFromUrlHandleError handles the StartCopyFromURL error response.
func (client blobClient) startCopyFromUrlHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Undelete - Undelete a blob that was previously soft deleted
func (client blobClient) Undelete(ctx context.Context, options *BlobUndeleteOptions) (BlobUndeleteResponse, error) {
	req, err := client.undeleteCreateRequest(ctx, options)
	if err != nil {
		return BlobUndeleteResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlobUndeleteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlobUndeleteResponse{}, client.undeleteHandleError(resp)
	}
	result, err := client.undeleteHandleResponse(resp)
	if err != nil {
		return BlobUndeleteResponse{}, err
	}
	return result, nil
}

// undeleteCreateRequest creates the Undelete request.
func (client blobClient) undeleteCreateRequest(ctx context.Context, options *BlobUndeleteOptions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "undelete")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-version", "2019-12-12")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// undeleteHandleResponse handles the Undelete response.
func (client blobClient) undeleteHandleResponse(resp *azcore.Response) (BlobUndeleteResponse, error) {
	result := BlobUndeleteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlobUndeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// undeleteHandleError handles the Undelete error response.
func (client blobClient) undeleteHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
