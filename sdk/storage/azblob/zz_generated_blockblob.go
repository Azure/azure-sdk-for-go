// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"net/http"
	"net/url"
	"strconv"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

type blockBlobClient struct {
	con *connection
}

// Pipeline returns the pipeline associated with this client.
func (client blockBlobClient) Pipeline() azcore.Pipeline {
	return client.con.Pipeline()
}

// CommitBlockList - The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob. In order to be written as
// part of a blob, a block must have been successfully written to the
// server in a prior Put Block operation. You can call Put Block List to update a blob by uploading only those blocks that have changed, then committing
// the new and existing blocks together. You can do
// this by specifying whether to commit a block from the committed block list or from the uncommitted block list, or to commit the most recently uploaded
// version of the block, whichever list it may
// belong to.
func (client blockBlobClient) CommitBlockList(ctx context.Context, blocks BlockLookupList, blockBlobCommitBlockListOptions *BlockBlobCommitBlockListOptions, blobHttpHeaders *BlobHttpHeaders, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (BlockBlobCommitBlockListResponse, error) {
	req, err := client.commitBlockListCreateRequest(ctx, blocks, blockBlobCommitBlockListOptions, blobHttpHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if err != nil {
		return BlockBlobCommitBlockListResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlockBlobCommitBlockListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlockBlobCommitBlockListResponse{}, client.commitBlockListHandleError(resp)
	}
	result, err := client.commitBlockListHandleResponse(resp)
	if err != nil {
		return BlockBlobCommitBlockListResponse{}, err
	}
	return result, nil
}

// commitBlockListCreateRequest creates the CommitBlockList request.
func (client blockBlobClient) commitBlockListCreateRequest(ctx context.Context, blocks BlockLookupList, blockBlobCommitBlockListOptions *BlockBlobCommitBlockListOptions, blobHttpHeaders *BlobHttpHeaders, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "blocklist")
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blockBlobCommitBlockListOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if blobHttpHeaders != nil && blobHttpHeaders.BlobCacheControl != nil {
		req.Header.Set("x-ms-blob-cache-control", *blobHttpHeaders.BlobCacheControl)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentType != nil {
		req.Header.Set("x-ms-blob-content-type", *blobHttpHeaders.BlobContentType)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentEncoding != nil {
		req.Header.Set("x-ms-blob-content-encoding", *blobHttpHeaders.BlobContentEncoding)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentLanguage != nil {
		req.Header.Set("x-ms-blob-content-language", *blobHttpHeaders.BlobContentLanguage)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentMd5 != nil {
		req.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(*blobHttpHeaders.BlobContentMd5))
	}
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.TransactionalContentMd5 != nil {
		req.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(*blockBlobCommitBlockListOptions.TransactionalContentMd5))
	}
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.TransactionalContentCrc64 != nil {
		req.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(*blockBlobCommitBlockListOptions.TransactionalContentCrc64))
	}
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.Metadata != nil {
		for k, v := range *blockBlobCommitBlockListOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentDisposition != nil {
		req.Header.Set("x-ms-blob-content-disposition", *blobHttpHeaders.BlobContentDisposition)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*blockBlobCommitBlockListOptions.Tier))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blockBlobCommitBlockListOptions.RequestId)
	}
	if blockBlobCommitBlockListOptions != nil && blockBlobCommitBlockListOptions.BlobTagsString != nil {
		req.Header.Set("x-ms-tags", *blockBlobCommitBlockListOptions.BlobTagsString)
	}
	req.Header.Set("Accept", "application/xml")
	return req, req.MarshalAsXML(blocks)
}

// commitBlockListHandleResponse handles the CommitBlockList response.
func (client blockBlobClient) commitBlockListHandleResponse(resp *azcore.Response) (BlockBlobCommitBlockListResponse, error) {
	result := BlockBlobCommitBlockListResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockBlobCommitBlockListResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobCommitBlockListResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobCommitBlockListResponse{}, err
		}
		result.ContentCRC64 = &contentCrc64
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockBlobCommitBlockListResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlockBlobCommitBlockListResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return result, nil
}

// commitBlockListHandleError handles the CommitBlockList error response.
func (client blockBlobClient) commitBlockListHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// GetBlockList - The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block blob
func (client blockBlobClient) GetBlockList(ctx context.Context, listType BlockListType, blockBlobGetBlockListOptions *BlockBlobGetBlockListOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (BlockListResponse, error) {
	req, err := client.getBlockListCreateRequest(ctx, listType, blockBlobGetBlockListOptions, leaseAccessConditions, modifiedAccessConditions)
	if err != nil {
		return BlockListResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlockListResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BlockListResponse{}, client.getBlockListHandleError(resp)
	}
	result, err := client.getBlockListHandleResponse(resp)
	if err != nil {
		return BlockListResponse{}, err
	}
	return result, nil
}

// getBlockListCreateRequest creates the GetBlockList request.
func (client blockBlobClient) getBlockListCreateRequest(ctx context.Context, listType BlockListType, blockBlobGetBlockListOptions *BlockBlobGetBlockListOptions, leaseAccessConditions *LeaseAccessConditions, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodGet, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "blocklist")
	if blockBlobGetBlockListOptions != nil && blockBlobGetBlockListOptions.Snapshot != nil {
		query.Set("snapshot", *blockBlobGetBlockListOptions.Snapshot)
	}
	query.Set("blocklisttype", string(listType))
	if blockBlobGetBlockListOptions != nil && blockBlobGetBlockListOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blockBlobGetBlockListOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blockBlobGetBlockListOptions != nil && blockBlobGetBlockListOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blockBlobGetBlockListOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getBlockListHandleResponse handles the GetBlockList response.
func (client blockBlobClient) getBlockListHandleResponse(resp *azcore.Response) (BlockListResponse, error) {
	result := BlockListResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockListResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("x-ms-blob-content-length"); val != "" {
		blobContentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BlockListResponse{}, err
		}
		result.BlobContentLength = &blobContentLength
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockListResponse{}, err
		}
		result.Date = &date
	}
	err := resp.UnmarshalAsXML(&result.BlockList)
	return result, err
}

// getBlockListHandleError handles the GetBlockList error response.
func (client blockBlobClient) getBlockListHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// StageBlock - The Stage Block operation creates a new block to be committed as part of a blob
func (client blockBlobClient) StageBlock(ctx context.Context, blockId string, contentLength int64, body azcore.ReadSeekCloser, blockBlobStageBlockOptions *BlockBlobStageBlockOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo) (BlockBlobStageBlockResponse, error) {
	req, err := client.stageBlockCreateRequest(ctx, blockId, contentLength, body, blockBlobStageBlockOptions, leaseAccessConditions, cpkInfo, cpkScopeInfo)
	if err != nil {
		return BlockBlobStageBlockResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlockBlobStageBlockResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlockBlobStageBlockResponse{}, client.stageBlockHandleError(resp)
	}
	result, err := client.stageBlockHandleResponse(resp)
	if err != nil {
		return BlockBlobStageBlockResponse{}, err
	}
	return result, nil
}

// stageBlockCreateRequest creates the StageBlock request.
func (client blockBlobClient) stageBlockCreateRequest(ctx context.Context, blockId string, contentLength int64, body azcore.ReadSeekCloser, blockBlobStageBlockOptions *BlockBlobStageBlockOptions, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "block")
	query.Set("blockid", blockId)
	if blockBlobStageBlockOptions != nil && blockBlobStageBlockOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blockBlobStageBlockOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if blockBlobStageBlockOptions != nil && blockBlobStageBlockOptions.TransactionalContentMd5 != nil {
		req.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(*blockBlobStageBlockOptions.TransactionalContentMd5))
	}
	if blockBlobStageBlockOptions != nil && blockBlobStageBlockOptions.TransactionalContentCrc64 != nil {
		req.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(*blockBlobStageBlockOptions.TransactionalContentCrc64))
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blockBlobStageBlockOptions != nil && blockBlobStageBlockOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blockBlobStageBlockOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, req.SetBody(body, "application/octet-stream")
}

// stageBlockHandleResponse handles the StageBlock response.
func (client blockBlobClient) stageBlockHandleResponse(resp *azcore.Response) (BlockBlobStageBlockResponse, error) {
	result := BlockBlobStageBlockResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobStageBlockResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockBlobStageBlockResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobStageBlockResponse{}, err
		}
		result.ContentCRC64 = &contentCrc64
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlockBlobStageBlockResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return result, nil
}

// stageBlockHandleError handles the StageBlock error response.
func (client blockBlobClient) stageBlockHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// StageBlockFromURL - The Stage Block operation creates a new block to be committed as part of a blob where the contents are read from a URL.
func (client blockBlobClient) StageBlockFromURL(ctx context.Context, blockId string, contentLength int64, sourceUrl url.URL, blockBlobStageBlockFromUrlOptions *BlockBlobStageBlockFromURLOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, leaseAccessConditions *LeaseAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (BlockBlobStageBlockFromURLResponse, error) {
	req, err := client.stageBlockFromUrlCreateRequest(ctx, blockId, contentLength, sourceUrl, blockBlobStageBlockFromUrlOptions, cpkInfo, cpkScopeInfo, leaseAccessConditions, sourceModifiedAccessConditions)
	if err != nil {
		return BlockBlobStageBlockFromURLResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlockBlobStageBlockFromURLResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlockBlobStageBlockFromURLResponse{}, client.stageBlockFromUrlHandleError(resp)
	}
	result, err := client.stageBlockFromUrlHandleResponse(resp)
	if err != nil {
		return BlockBlobStageBlockFromURLResponse{}, err
	}
	return result, nil
}

// stageBlockFromUrlCreateRequest creates the StageBlockFromURL request.
func (client blockBlobClient) stageBlockFromUrlCreateRequest(ctx context.Context, blockId string, contentLength int64, sourceUrl url.URL, blockBlobStageBlockFromUrlOptions *BlockBlobStageBlockFromURLOptions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, leaseAccessConditions *LeaseAccessConditions, sourceModifiedAccessConditions *SourceModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	query.Set("comp", "block")
	query.Set("blockid", blockId)
	if blockBlobStageBlockFromUrlOptions != nil && blockBlobStageBlockFromUrlOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blockBlobStageBlockFromUrlOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	req.Header.Set("x-ms-copy-source", sourceUrl.String())
	if blockBlobStageBlockFromUrlOptions != nil && blockBlobStageBlockFromUrlOptions.SourceRange != nil {
		req.Header.Set("x-ms-source-range", *blockBlobStageBlockFromUrlOptions.SourceRange)
	}
	if blockBlobStageBlockFromUrlOptions != nil && blockBlobStageBlockFromUrlOptions.SourceContentMd5 != nil {
		req.Header.Set("x-ms-source-content-md5", base64.StdEncoding.EncodeToString(*blockBlobStageBlockFromUrlOptions.SourceContentMd5))
	}
	if blockBlobStageBlockFromUrlOptions != nil && blockBlobStageBlockFromUrlOptions.SourceContentcrc64 != nil {
		req.Header.Set("x-ms-source-content-crc64", base64.StdEncoding.EncodeToString(*blockBlobStageBlockFromUrlOptions.SourceContentcrc64))
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", sourceModifiedAccessConditions.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", sourceModifiedAccessConditions.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *sourceModifiedAccessConditions.SourceIfMatch)
	}
	if sourceModifiedAccessConditions != nil && sourceModifiedAccessConditions.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *sourceModifiedAccessConditions.SourceIfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blockBlobStageBlockFromUrlOptions != nil && blockBlobStageBlockFromUrlOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blockBlobStageBlockFromUrlOptions.RequestId)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// stageBlockFromUrlHandleResponse handles the StageBlockFromURL response.
func (client blockBlobClient) stageBlockFromUrlHandleResponse(resp *azcore.Response) (BlockBlobStageBlockFromURLResponse, error) {
	result := BlockBlobStageBlockFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobStageBlockFromURLResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobStageBlockFromURLResponse{}, err
		}
		result.ContentCRC64 = &contentCrc64
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockBlobStageBlockFromURLResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlockBlobStageBlockFromURLResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return result, nil
}

// stageBlockFromUrlHandleError handles the StageBlockFromURL error response.
func (client blockBlobClient) stageBlockFromUrlHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}

// Upload - The Upload Block Blob operation updates the content of an existing block blob. Updating an existing block blob overwrites any existing metadata
// on the blob. Partial updates are not supported with Put
// Blob; the content of the existing blob is overwritten with the content of the new blob. To perform a partial update of the content of a block blob, use
// the Put Block List operation.
func (client blockBlobClient) Upload(ctx context.Context, contentLength int64, body azcore.ReadSeekCloser, blockBlobUploadOptions *BlockBlobUploadOptions, blobHttpHeaders *BlobHttpHeaders, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (BlockBlobUploadResponse, error) {
	req, err := client.uploadCreateRequest(ctx, contentLength, body, blockBlobUploadOptions, blobHttpHeaders, leaseAccessConditions, cpkInfo, cpkScopeInfo, modifiedAccessConditions)
	if err != nil {
		return BlockBlobUploadResponse{}, err
	}
	resp, err := client.Pipeline().Do(req)
	if err != nil {
		return BlockBlobUploadResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusCreated) {
		return BlockBlobUploadResponse{}, client.uploadHandleError(resp)
	}
	result, err := client.uploadHandleResponse(resp)
	if err != nil {
		return BlockBlobUploadResponse{}, err
	}
	return result, nil
}

// uploadCreateRequest creates the Upload request.
func (client blockBlobClient) uploadCreateRequest(ctx context.Context, contentLength int64, body azcore.ReadSeekCloser, blockBlobUploadOptions *BlockBlobUploadOptions, blobHttpHeaders *BlobHttpHeaders, leaseAccessConditions *LeaseAccessConditions, cpkInfo *CpkInfo, cpkScopeInfo *CpkScopeInfo, modifiedAccessConditions *ModifiedAccessConditions) (*azcore.Request, error) {
	req, err := azcore.NewRequest(ctx, http.MethodPut, client.con.Endpoint())
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	query := req.URL.Query()
	if blockBlobUploadOptions != nil && blockBlobUploadOptions.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*blockBlobUploadOptions.Timeout), 10))
	}
	req.URL.RawQuery = query.Encode()
	req.Header.Set("x-ms-blob-type", "BlockBlob")
	if blockBlobUploadOptions != nil && blockBlobUploadOptions.TransactionalContentMd5 != nil {
		req.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(*blockBlobUploadOptions.TransactionalContentMd5))
	}
	req.Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentType != nil {
		req.Header.Set("x-ms-blob-content-type", *blobHttpHeaders.BlobContentType)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentEncoding != nil {
		req.Header.Set("x-ms-blob-content-encoding", *blobHttpHeaders.BlobContentEncoding)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentLanguage != nil {
		req.Header.Set("x-ms-blob-content-language", *blobHttpHeaders.BlobContentLanguage)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentMd5 != nil {
		req.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(*blobHttpHeaders.BlobContentMd5))
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobCacheControl != nil {
		req.Header.Set("x-ms-blob-cache-control", *blobHttpHeaders.BlobCacheControl)
	}
	if blockBlobUploadOptions != nil && blockBlobUploadOptions.Metadata != nil {
		for k, v := range *blockBlobUploadOptions.Metadata {
			req.Header.Set("x-ms-meta-"+k, v)
		}
	}
	if leaseAccessConditions != nil && leaseAccessConditions.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *leaseAccessConditions.LeaseId)
	}
	if blobHttpHeaders != nil && blobHttpHeaders.BlobContentDisposition != nil {
		req.Header.Set("x-ms-blob-content-disposition", *blobHttpHeaders.BlobContentDisposition)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *cpkInfo.EncryptionKey)
	}
	if cpkInfo != nil && cpkInfo.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *cpkInfo.EncryptionKeySha256)
	}
	if cpkInfo != nil && cpkInfo.EncryptionAlgorithm != nil {
		req.Header.Set("x-ms-encryption-algorithm", "AES256")
	}
	if cpkScopeInfo != nil && cpkScopeInfo.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *cpkScopeInfo.EncryptionScope)
	}
	if blockBlobUploadOptions != nil && blockBlobUploadOptions.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*blockBlobUploadOptions.Tier))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", modifiedAccessConditions.IfModifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", modifiedAccessConditions.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfMatch != nil {
		req.Header.Set("If-Match", *modifiedAccessConditions.IfMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *modifiedAccessConditions.IfNoneMatch)
	}
	if modifiedAccessConditions != nil && modifiedAccessConditions.IfTags != nil {
		req.Header.Set("x-ms-if-tags", *modifiedAccessConditions.IfTags)
	}
	req.Header.Set("x-ms-version", "2019-12-12")
	if blockBlobUploadOptions != nil && blockBlobUploadOptions.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *blockBlobUploadOptions.RequestId)
	}
	if blockBlobUploadOptions != nil && blockBlobUploadOptions.BlobTagsString != nil {
		req.Header.Set("x-ms-tags", *blockBlobUploadOptions.BlobTagsString)
	}
	req.Header.Set("Accept", "application/xml")
	return req, req.SetBody(body, "application/octet-stream")
}

// uploadHandleResponse handles the Upload response.
func (client blockBlobClient) uploadHandleResponse(resp *azcore.Response) (BlockBlobUploadResponse, error) {
	result := BlockBlobUploadResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockBlobUploadResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return BlockBlobUploadResponse{}, err
		}
		result.ContentMD5 = &contentMd5
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("x-ms-version-id"); val != "" {
		result.VersionID = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BlockBlobUploadResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		isServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return BlockBlobUploadResponse{}, err
		}
		result.IsServerEncrypted = &isServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySHA256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return result, nil
}

// uploadHandleError handles the Upload error response.
func (client blockBlobClient) uploadHandleError(resp *azcore.Response) error {
	var err StorageError
	if err := resp.UnmarshalAsXML(&err); err != nil {
		return err
	}
	return azcore.NewResponseError(&err, resp.Response)
}
