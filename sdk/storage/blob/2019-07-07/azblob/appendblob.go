// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// AppendBlobOperations contains the methods for the AppendBlob group.
type AppendBlobOperations interface {
	// AppendBlock - The Append Block operation commits a new block of data to the end of an existing append blob. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
	AppendBlock(ctx context.Context, contentLength int64, options *AppendBlobAppendBlockOptions) (*AppendBlobAppendBlockResponse, error)
	// AppendBlockFromURL - The Append Block operation commits a new block of data to the end of an existing append blob where the contents are read from a source url. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
	AppendBlockFromURL(ctx context.Context, sourceUrl url.URL, contentLength int64, options *AppendBlobAppendBlockFromURLOptions) (*AppendBlobAppendBlockFromURLResponse, error)
	// Create - The Create Append Blob operation creates a new append blob.
	Create(ctx context.Context, contentLength int64, options *AppendBlobCreateOptions) (*AppendBlobCreateResponse, error)
}

// appendBlobOperations implements the AppendBlobOperations interface.
type appendBlobOperations struct {
	*Client
}

// AppendBlock - The Append Block operation commits a new block of data to the end of an existing append blob. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
func (client *appendBlobOperations) AppendBlock(ctx context.Context, contentLength int64, options *AppendBlobAppendBlockOptions) (*AppendBlobAppendBlockResponse, error) {
	req, err := client.appendBlockCreateRequest(contentLength, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.appendBlockHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// appendBlockCreateRequest creates the AppendBlock request.
func (client *appendBlobOperations) appendBlockCreateRequest(contentLength int64, options *AppendBlobAppendBlockOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "appendblock")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if options != nil && options.TransactionalContentMd5 != nil {
		req.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(*options.TransactionalContentMd5))
	}
	if options != nil && options.TransactionalContentCrc64 != nil {
		req.Header.Set("x-ms-content-crc64", base64.StdEncoding.EncodeToString(*options.TransactionalContentCrc64))
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.MaxSize != nil {
		req.Header.Set("x-ms-blob-condition-maxsize", strconv.FormatInt(*options.MaxSize, 10))
	}
	if options != nil && options.AppendPosition != nil {
		req.Header.Set("x-ms-blob-condition-appendpos", strconv.FormatInt(*options.AppendPosition, 10))
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// appendBlockHandleResponse handles the AppendBlock response.
func (client *appendBlobOperations) appendBlockHandleResponse(resp *azcore.Response) (*AppendBlobAppendBlockResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := AppendBlobAppendBlockResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	contentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("Content-MD5"))
	if err != nil {
		return nil, err
	}
	result.ContentMd5 = &contentMd5
	contentCrc64, err := base64.StdEncoding.DecodeString(resp.Header.Get("x-ms-content-crc64"))
	if err != nil {
		return nil, err
	}
	result.ContentCrc64 = &contentCrc64
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	blobAppendOffset := resp.Header.Get("x-ms-blob-append-offset")
	result.BlobAppendOffset = &blobAppendOffset
	blobCommittedBlockCount32, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-committed-block-count"), 10, 32)
	blobCommittedBlockCount := int32(blobCommittedBlockCount32)
	if err != nil {
		return nil, err
	}
	result.BlobCommittedBlockCount = &blobCommittedBlockCount
	requestServerEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-request-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.RequestServerEncrypted = &requestServerEncrypted
	encryptionKeySha256 := resp.Header.Get("x-ms-encryption-key-sha256")
	result.EncryptionKeySha256 = &encryptionKeySha256
	encryptionScope := resp.Header.Get("x-ms-encryption-scope")
	result.EncryptionScope = &encryptionScope
	return &result, nil
}

// AppendBlockFromURL - The Append Block operation commits a new block of data to the end of an existing append blob where the contents are read from a source url. The Append Block operation is permitted only if the blob was created with x-ms-blob-type set to AppendBlob. Append Block is supported only on version 2015-02-21 version or later.
func (client *appendBlobOperations) AppendBlockFromURL(ctx context.Context, sourceUrl url.URL, contentLength int64, options *AppendBlobAppendBlockFromURLOptions) (*AppendBlobAppendBlockFromURLResponse, error) {
	req, err := client.appendBlockFromUrlCreateRequest(sourceUrl, contentLength, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.appendBlockFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// appendBlockFromUrlCreateRequest creates the AppendBlockFromURL request.
func (client *appendBlobOperations) appendBlockFromUrlCreateRequest(sourceUrl url.URL, contentLength int64, options *AppendBlobAppendBlockFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "appendblock")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-copy-source", sourceUrl.String())
	if options != nil && options.SourceRange != nil {
		req.Header.Set("x-ms-source-range", *options.SourceRange)
	}
	if options != nil && options.SourceContentMd5 != nil {
		req.Header.Set("x-ms-source-content-md5", base64.StdEncoding.EncodeToString(*options.SourceContentMd5))
	}
	if options != nil && options.SourceContentcrc64 != nil {
		req.Header.Set("x-ms-source-content-crc64", base64.StdEncoding.EncodeToString(*options.SourceContentcrc64))
	}
	req.Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if options != nil && options.TransactionalContentMd5 != nil {
		req.Header.Set("Content-MD5", base64.StdEncoding.EncodeToString(*options.TransactionalContentMd5))
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.MaxSize != nil {
		req.Header.Set("x-ms-blob-condition-maxsize", strconv.FormatInt(*options.MaxSize, 10))
	}
	if options != nil && options.AppendPosition != nil {
		req.Header.Set("x-ms-blob-condition-appendpos", strconv.FormatInt(*options.AppendPosition, 10))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// appendBlockFromUrlHandleResponse handles the AppendBlockFromURL response.
func (client *appendBlobOperations) appendBlockFromUrlHandleResponse(resp *azcore.Response) (*AppendBlobAppendBlockFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := AppendBlobAppendBlockFromURLResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	contentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("Content-MD5"))
	if err != nil {
		return nil, err
	}
	result.ContentMd5 = &contentMd5
	contentCrc64, err := base64.StdEncoding.DecodeString(resp.Header.Get("x-ms-content-crc64"))
	if err != nil {
		return nil, err
	}
	result.ContentCrc64 = &contentCrc64
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	blobAppendOffset := resp.Header.Get("x-ms-blob-append-offset")
	result.BlobAppendOffset = &blobAppendOffset
	blobCommittedBlockCount32, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-committed-block-count"), 10, 32)
	blobCommittedBlockCount := int32(blobCommittedBlockCount32)
	if err != nil {
		return nil, err
	}
	result.BlobCommittedBlockCount = &blobCommittedBlockCount
	encryptionKeySha256 := resp.Header.Get("x-ms-encryption-key-sha256")
	result.EncryptionKeySha256 = &encryptionKeySha256
	encryptionScope := resp.Header.Get("x-ms-encryption-scope")
	result.EncryptionScope = &encryptionScope
	requestServerEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-request-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.RequestServerEncrypted = &requestServerEncrypted
	return &result, nil
}

// Create - The Create Append Blob operation creates a new append blob.
func (client *appendBlobOperations) Create(ctx context.Context, contentLength int64, options *AppendBlobCreateOptions) (*AppendBlobCreateResponse, error) {
	req, err := client.createCreateRequest(contentLength, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createCreateRequest creates the Create request.
func (client *appendBlobOperations) createCreateRequest(contentLength int64, options *AppendBlobCreateOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-blob-type", "AppendBlob")
	req.Header.Set("Content-Length", strconv.FormatInt(contentLength, 10))
	if options != nil && options.BlobContentType != nil {
		req.Header.Set("x-ms-blob-content-type", *options.BlobContentType)
	}
	if options != nil && options.BlobContentEncoding != nil {
		req.Header.Set("x-ms-blob-content-encoding", *options.BlobContentEncoding)
	}
	if options != nil && options.BlobContentLanguage != nil {
		req.Header.Set("x-ms-blob-content-language", *options.BlobContentLanguage)
	}
	if options != nil && options.BlobContentMd5 != nil {
		req.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(*options.BlobContentMd5))
	}
	if options != nil && options.BlobCacheControl != nil {
		req.Header.Set("x-ms-blob-cache-control", *options.BlobCacheControl)
	}
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.BlobContentDisposition != nil {
		req.Header.Set("x-ms-blob-content-disposition", *options.BlobContentDisposition)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *appendBlobOperations) createHandleResponse(resp *azcore.Response) (*AppendBlobCreateResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := AppendBlobCreateResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	contentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("Content-MD5"))
	if err != nil {
		return nil, err
	}
	result.ContentMd5 = &contentMd5
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	requestServerEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-request-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.RequestServerEncrypted = &requestServerEncrypted
	encryptionKeySha256 := resp.Header.Get("x-ms-encryption-key-sha256")
	result.EncryptionKeySha256 = &encryptionKeySha256
	encryptionScope := resp.Header.Get("x-ms-encryption-scope")
	result.EncryptionScope = &encryptionScope
	return &result, nil
}
