// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// BlobOperations contains the methods for the Blob group.
type BlobOperations interface {
	// AbortCopyFromURL - The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata.
	AbortCopyFromURL(ctx context.Context, copyId string, options *BlobAbortCopyFromURLOptions) (*BlobAbortCopyFromURLResponse, error)
	// AcquireLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	AcquireLease(ctx context.Context, options *BlobAcquireLeaseOptions) (*BlobAcquireLeaseResponse, error)
	// BreakLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	BreakLease(ctx context.Context, options *BlobBreakLeaseOptions) (*BlobBreakLeaseResponse, error)
	// ChangeLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, options *BlobChangeLeaseOptions) (*BlobChangeLeaseResponse, error)
	// CopyFromURL - The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete.
	CopyFromURL(ctx context.Context, copySource url.URL, options *BlobCopyFromURLOptions) (*BlobCopyFromURLResponse, error)
	// CreateSnapshot - The Create Snapshot operation creates a read-only snapshot of a blob
	CreateSnapshot(ctx context.Context, options *BlobCreateSnapshotOptions) (*BlobCreateSnapshotResponse, error)
	// Delete - If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account's soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound).
	Delete(ctx context.Context, options *BlobDeleteOptions) (*BlobDeleteResponse, error)
	// Download - The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot.
	Download(ctx context.Context, options *BlobDownloadOptions) (*BlobDownloadResponse, error)
	// GetAccessControl - Get the owner, group, permissions, or access control list for a blob.
	GetAccessControl(ctx context.Context, options *BlobGetAccessControlOptions) (*BlobGetAccessControlResponse, error)
	// GetAccountInfo - Returns the sku name and account kind
	GetAccountInfo(ctx context.Context) (*BlobGetAccountInfoResponse, error)
	// GetProperties - The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob.
	GetProperties(ctx context.Context, options *BlobGetPropertiesOptions) (*BlobGetPropertiesResponse, error)
	// ReleaseLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	ReleaseLease(ctx context.Context, leaseId string, options *BlobReleaseLeaseOptions) (*BlobReleaseLeaseResponse, error)
	// Rename - Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
	Rename(ctx context.Context, renameSource string, options *BlobRenameOptions) (*BlobRenameResponse, error)
	// RenewLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	RenewLease(ctx context.Context, leaseId string, options *BlobRenewLeaseOptions) (*BlobRenewLeaseResponse, error)
	// SetAccessControl - Set the owner, group, permissions, or access control list for a blob.
	SetAccessControl(ctx context.Context, options *BlobSetAccessControlOptions) (*BlobSetAccessControlResponse, error)
	// SetHTTPHeaders - The Set HTTP Headers operation sets system properties on the blob
	SetHTTPHeaders(ctx context.Context, options *BlobSetHTTPHeadersOptions) (*BlobSetHTTPHeadersResponse, error)
	// SetMetadata - The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs
	SetMetadata(ctx context.Context, options *BlobSetMetadataOptions) (*BlobSetMetadataResponse, error)
	// SetTier - The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's ETag.
	SetTier(ctx context.Context, tier AccessTier, options *BlobSetTierOptions) (*BlobSetTierResponse, error)
	// StartCopyFromURL - The Start Copy From URL operation copies a blob or an internet resource to a new blob.
	StartCopyFromURL(ctx context.Context, copySource url.URL, options *BlobStartCopyFromURLOptions) (*BlobStartCopyFromURLResponse, error)
	// Undelete - Undelete a blob that was previously soft deleted
	Undelete(ctx context.Context, options *BlobUndeleteOptions) (*BlobUndeleteResponse, error)
}

// blobOperations implements the BlobOperations interface.
type blobOperations struct {
	*Client
	pathRenameMode *PathRenameMode
}

// AbortCopyFromURL - The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata.
func (client *blobOperations) AbortCopyFromURL(ctx context.Context, copyId string, options *BlobAbortCopyFromURLOptions) (*BlobAbortCopyFromURLResponse, error) {
	req, err := client.abortCopyFromUrlCreateRequest(copyId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.abortCopyFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// abortCopyFromUrlCreateRequest creates the AbortCopyFromURL request.
func (client *blobOperations) abortCopyFromUrlCreateRequest(copyId string, options *BlobAbortCopyFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "copy")
	query.Set("copyid", copyId)
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-copy-action", "abort")
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// abortCopyFromUrlHandleResponse handles the AbortCopyFromURL response.
func (client *blobOperations) abortCopyFromUrlHandleResponse(resp *azcore.Response) (*BlobAbortCopyFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, newStorageError(resp)
	}
	result := BlobAbortCopyFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// AcquireLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) AcquireLease(ctx context.Context, options *BlobAcquireLeaseOptions) (*BlobAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.acquireLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *blobOperations) acquireLeaseCreateRequest(options *BlobAcquireLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "acquire")
	if options != nil && options.Duration != nil {
		req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.ProposedLeaseId != nil {
		req.Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *blobOperations) acquireLeaseHandleResponse(resp *azcore.Response) (*BlobAcquireLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := BlobAcquireLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseId = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// BreakLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) BreakLease(ctx context.Context, options *BlobBreakLeaseOptions) (*BlobBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.breakLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *blobOperations) breakLeaseCreateRequest(options *BlobBreakLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "break")
	if options != nil && options.BreakPeriod != nil {
		req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*options.BreakPeriod), 10))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *blobOperations) breakLeaseHandleResponse(resp *azcore.Response) (*BlobBreakLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobBreakLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-time"); val != "" {
		leaseTime32, err := strconv.ParseInt(val, 10, 32)
		leaseTime := int32(leaseTime32)
		if err != nil {
			return nil, err
		}
		result.LeaseTime = &leaseTime
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// ChangeLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, options *BlobChangeLeaseOptions) (*BlobChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(leaseId, proposedLeaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.changeLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *blobOperations) changeLeaseCreateRequest(leaseId string, proposedLeaseId string, options *BlobChangeLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "change")
	req.Header.Set("x-ms-lease-id", leaseId)
	req.Header.Set("x-ms-proposed-lease-id", proposedLeaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *blobOperations) changeLeaseHandleResponse(resp *azcore.Response) (*BlobChangeLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobChangeLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// CopyFromURL - The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete.
func (client *blobOperations) CopyFromURL(ctx context.Context, copySource url.URL, options *BlobCopyFromURLOptions) (*BlobCopyFromURLResponse, error) {
	req, err := client.copyFromUrlCreateRequest(copySource, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.copyFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// copyFromUrlCreateRequest creates the CopyFromURL request.
func (client *blobOperations) copyFromUrlCreateRequest(copySource url.URL, options *BlobCopyFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-requires-sync", "true")
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*options.Tier))
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-copy-source", copySource.String())
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	if options != nil && options.SourceContentMd5 != nil {
		req.Header.Set("x-ms-source-content-md5", base64.StdEncoding.EncodeToString(*options.SourceContentMd5))
	}
	return req, nil
}

// copyFromUrlHandleResponse handles the CopyFromURL response.
func (client *blobOperations) copyFromUrlHandleResponse(resp *azcore.Response) (*BlobCopyFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobCopyFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyId = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.ContentMd5 = &contentMd5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.ContentCrc64 = &contentCrc64
	}
	return &result, nil
}

// CreateSnapshot - The Create Snapshot operation creates a read-only snapshot of a blob
func (client *blobOperations) CreateSnapshot(ctx context.Context, options *BlobCreateSnapshotOptions) (*BlobCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createSnapshotHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client *blobOperations) createSnapshotCreateRequest(options *BlobCreateSnapshotOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "snapshot")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client *blobOperations) createSnapshotHandleResponse(resp *azcore.Response) (*BlobCreateSnapshotResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := BlobCreateSnapshotResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-snapshot"); val != "" {
		result.Snapshot = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		requestServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.RequestServerEncrypted = &requestServerEncrypted
	}
	return &result, nil
}

// Delete - If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account's soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound).
func (client *blobOperations) Delete(ctx context.Context, options *BlobDeleteOptions) (*BlobDeleteResponse, error) {
	req, err := client.deleteCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client *blobOperations) deleteCreateRequest(options *BlobDeleteOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Snapshot != nil {
		query.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.DeleteSnapshots != nil {
		req.Header.Set("x-ms-delete-snapshots", string(*options.DeleteSnapshots))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *blobOperations) deleteHandleResponse(resp *azcore.Response) (*BlobDeleteResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobDeleteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// Download - The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot.
func (client *blobOperations) Download(ctx context.Context, options *BlobDownloadOptions) (*BlobDownloadResponse, error) {
	req, err := client.downloadCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.downloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// downloadCreateRequest creates the Download request.
func (client *blobOperations) downloadCreateRequest(options *BlobDownloadOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Snapshot != nil {
		query.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.SkipBodyDownload()
	if options != nil && options.RangeParameter != nil {
		req.Header.Set("x-ms-range", *options.RangeParameter)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.RangeGetContentMd5 != nil {
		req.Header.Set("x-ms-range-get-content-md5", strconv.FormatBool(*options.RangeGetContentMd5))
	}
	if options != nil && options.RangeGetContentCrc64 != nil {
		req.Header.Set("x-ms-range-get-content-crc64", strconv.FormatBool(*options.RangeGetContentCrc64))
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client *blobOperations) downloadHandleResponse(resp *azcore.Response) (*BlobDownloadResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobDownloadResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-meta"); val != "" {
		result.Meta = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("Content-Range"); val != "" {
		result.ContentRange = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.ContentMd5 = &contentMd5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyId = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return nil, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		serverEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.ServerEncrypted = &serverEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySha256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-blob-content-md5"); val != "" {
		blobContentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.BlobContentMd5 = &blobContentMd5
	}
	if val := resp.Header.Get("x-ms-content-crc64"); val != "" {
		contentCrc64, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.ContentCrc64 = &contentCrc64
	}
	return &result, nil
}

// GetAccessControl - Get the owner, group, permissions, or access control list for a blob.
func (client *blobOperations) GetAccessControl(ctx context.Context, options *BlobGetAccessControlOptions) (*BlobGetAccessControlResponse, error) {
	req, err := client.getAccessControlCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAccessControlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAccessControlCreateRequest creates the GetAccessControl request.
func (client *blobOperations) getAccessControlCreateRequest(options *BlobGetAccessControlOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("action", "getAccessControl")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Upn != nil {
		query.Set("upn", strconv.FormatBool(*options.Upn))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// getAccessControlHandleResponse handles the GetAccessControl response.
func (client *blobOperations) getAccessControlHandleResponse(resp *azcore.Response) (*BlobGetAccessControlResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newDataLakeStorageError(resp)
	}
	result := BlobGetAccessControlResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-owner"); val != "" {
		result.Owner = &val
	}
	if val := resp.Header.Get("x-ms-group"); val != "" {
		result.Group = &val
	}
	if val := resp.Header.Get("x-ms-permissions"); val != "" {
		result.Permissions = &val
	}
	if val := resp.Header.Get("x-ms-acl"); val != "" {
		result.Acl = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return &result, nil
}

// GetAccountInfo - Returns the sku name and account kind
func (client *blobOperations) GetAccountInfo(ctx context.Context) (*BlobGetAccountInfoResponse, error) {
	req, err := client.getAccountInfoCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAccountInfoHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAccountInfoCreateRequest creates the GetAccountInfo request.
func (client *blobOperations) getAccountInfoCreateRequest() (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "account")
	query.Set("comp", "properties")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// getAccountInfoHandleResponse handles the GetAccountInfo response.
func (client *blobOperations) getAccountInfoHandleResponse(resp *azcore.Response) (*BlobGetAccountInfoResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobGetAccountInfoResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-sku-name"); val != "" {
		result.SkuName = (*SkuName)(&val)
	}
	if val := resp.Header.Get("x-ms-account-kind"); val != "" {
		result.AccountKind = (*AccountKind)(&val)
	}
	return &result, nil
}

// GetProperties - The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob.
func (client *blobOperations) GetProperties(ctx context.Context, options *BlobGetPropertiesOptions) (*BlobGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *blobOperations) getPropertiesCreateRequest(options *BlobGetPropertiesOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Snapshot != nil {
		query.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *blobOperations) getPropertiesHandleResponse(resp *azcore.Response) (*BlobGetPropertiesResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobGetPropertiesResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-creation-time"); val != "" {
		creationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.CreationTime = &creationTime
	}
	if val := resp.Header.Get("x-ms-meta"); val != "" {
		result.Meta = &val
	}
	if val := resp.Header.Get("x-ms-blob-type"); val != "" {
		result.BlobType = (*BlobType)(&val)
	}
	if val := resp.Header.Get("x-ms-copy-completion-time"); val != "" {
		copyCompletionTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.CopyCompletionTime = &copyCompletionTime
	}
	if val := resp.Header.Get("x-ms-copy-status-description"); val != "" {
		result.CopyStatusDescription = &val
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyId = &val
	}
	if val := resp.Header.Get("x-ms-copy-progress"); val != "" {
		result.CopyProgress = &val
	}
	if val := resp.Header.Get("x-ms-copy-source"); val != "" {
		result.CopySource = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	if val := resp.Header.Get("x-ms-incremental-copy"); val != "" {
		incrementalCopy, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.IncrementalCopy = &incrementalCopy
	}
	if val := resp.Header.Get("x-ms-copy-destination-snapshot"); val != "" {
		result.CopyDestinationSnapshot = &val
	}
	if val := resp.Header.Get("x-ms-lease-duration"); val != "" {
		result.LeaseDuration = (*LeaseDurationType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-state"); val != "" {
		result.LeaseState = (*LeaseStateType)(&val)
	}
	if val := resp.Header.Get("x-ms-lease-status"); val != "" {
		result.LeaseStatus = (*LeaseStatusType)(&val)
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Content-MD5"); val != "" {
		contentMd5, err := base64.StdEncoding.DecodeString(val)
		if err != nil {
			return nil, err
		}
		result.ContentMd5 = &contentMd5
	}
	if val := resp.Header.Get("Content-Encoding"); val != "" {
		result.ContentEncoding = &val
	}
	if val := resp.Header.Get("Content-Disposition"); val != "" {
		result.ContentDisposition = &val
	}
	if val := resp.Header.Get("Content-Language"); val != "" {
		result.ContentLanguage = &val
	}
	if val := resp.Header.Get("Cache-Control"); val != "" {
		result.CacheControl = &val
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("Accept-Ranges"); val != "" {
		result.AcceptRanges = &val
	}
	if val := resp.Header.Get("x-ms-blob-committed-block-count"); val != "" {
		blobCommittedBlockCount32, err := strconv.ParseInt(val, 10, 32)
		blobCommittedBlockCount := int32(blobCommittedBlockCount32)
		if err != nil {
			return nil, err
		}
		result.BlobCommittedBlockCount = &blobCommittedBlockCount
	}
	if val := resp.Header.Get("x-ms-server-encrypted"); val != "" {
		serverEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.ServerEncrypted = &serverEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySha256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	if val := resp.Header.Get("x-ms-access-tier"); val != "" {
		result.AccessTier = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-inferred"); val != "" {
		accessTierInferred, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.AccessTierInferred = &accessTierInferred
	}
	if val := resp.Header.Get("x-ms-archive-status"); val != "" {
		result.ArchiveStatus = &val
	}
	if val := resp.Header.Get("x-ms-access-tier-change-time"); val != "" {
		accessTierChangeTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.AccessTierChangeTime = &accessTierChangeTime
	}
	return &result, nil
}

// ReleaseLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) ReleaseLease(ctx context.Context, leaseId string, options *BlobReleaseLeaseOptions) (*BlobReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(leaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.releaseLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *blobOperations) releaseLeaseCreateRequest(leaseId string, options *BlobReleaseLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "release")
	req.Header.Set("x-ms-lease-id", leaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *blobOperations) releaseLeaseHandleResponse(resp *azcore.Response) (*BlobReleaseLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobReleaseLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// Rename - Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
func (client *blobOperations) Rename(ctx context.Context, renameSource string, options *BlobRenameOptions) (*BlobRenameResponse, error) {
	req, err := client.renameCreateRequest(renameSource, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.renameHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// renameCreateRequest creates the Rename request.
func (client *blobOperations) renameCreateRequest(renameSource string, options *BlobRenameOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if client.pathRenameMode != nil {
		query.Set("mode", string(*client.pathRenameMode))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-rename-source", renameSource)
	if options != nil && options.DirectoryProperties != nil {
		req.Header.Set("x-ms-properties", *options.DirectoryProperties)
	}
	if options != nil && options.PosixPermissions != nil {
		req.Header.Set("x-ms-permissions", *options.PosixPermissions)
	}
	if options != nil && options.PosixUmask != nil {
		req.Header.Set("x-ms-umask", *options.PosixUmask)
	}
	if options != nil && options.CacheControl != nil {
		req.Header.Set("x-ms-cache-control", *options.CacheControl)
	}
	if options != nil && options.ContentType != nil {
		req.Header.Set("x-ms-content-type", *options.ContentType)
	}
	if options != nil && options.ContentEncoding != nil {
		req.Header.Set("x-ms-content-encoding", *options.ContentEncoding)
	}
	if options != nil && options.ContentLanguage != nil {
		req.Header.Set("x-ms-content-language", *options.ContentLanguage)
	}
	if options != nil && options.ContentDisposition != nil {
		req.Header.Set("x-ms-content-disposition", *options.ContentDisposition)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.SourceLeaseId != nil {
		req.Header.Set("x-ms-source-lease-id", *options.SourceLeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// renameHandleResponse handles the Rename response.
func (client *blobOperations) renameHandleResponse(resp *azcore.Response) (*BlobRenameResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newDataLakeStorageError(resp)
	}
	result := BlobRenameResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// RenewLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) RenewLease(ctx context.Context, leaseId string, options *BlobRenewLeaseOptions) (*BlobRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(leaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.renewLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client *blobOperations) renewLeaseCreateRequest(leaseId string, options *BlobRenewLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "renew")
	req.Header.Set("x-ms-lease-id", leaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client *blobOperations) renewLeaseHandleResponse(resp *azcore.Response) (*BlobRenewLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobRenewLeaseResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-lease-id"); val != "" {
		result.LeaseId = &val
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// SetAccessControl - Set the owner, group, permissions, or access control list for a blob.
func (client *blobOperations) SetAccessControl(ctx context.Context, options *BlobSetAccessControlOptions) (*BlobSetAccessControlResponse, error) {
	req, err := client.setAccessControlCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setAccessControlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setAccessControlCreateRequest creates the SetAccessControl request.
func (client *blobOperations) setAccessControlCreateRequest(options *BlobSetAccessControlOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("action", "setAccessControl")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.Owner != nil {
		req.Header.Set("x-ms-owner", *options.Owner)
	}
	if options != nil && options.Group != nil {
		req.Header.Set("x-ms-group", *options.Group)
	}
	if options != nil && options.PosixPermissions != nil {
		req.Header.Set("x-ms-permissions", *options.PosixPermissions)
	}
	if options != nil && options.PosixAcl != nil {
		req.Header.Set("x-ms-acl", *options.PosixAcl)
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// setAccessControlHandleResponse handles the SetAccessControl response.
func (client *blobOperations) setAccessControlHandleResponse(resp *azcore.Response) (*BlobSetAccessControlResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newDataLakeStorageError(resp)
	}
	result := BlobSetAccessControlResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return &result, nil
}

// SetHTTPHeaders - The Set HTTP Headers operation sets system properties on the blob
func (client *blobOperations) SetHTTPHeaders(ctx context.Context, options *BlobSetHTTPHeadersOptions) (*BlobSetHTTPHeadersResponse, error) {
	req, err := client.setHttpHeadersCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setHttpHeadersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setHttpHeadersCreateRequest creates the SetHTTPHeaders request.
func (client *blobOperations) setHttpHeadersCreateRequest(options *BlobSetHTTPHeadersOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.BlobCacheControl != nil {
		req.Header.Set("x-ms-blob-cache-control", *options.BlobCacheControl)
	}
	if options != nil && options.BlobContentType != nil {
		req.Header.Set("x-ms-blob-content-type", *options.BlobContentType)
	}
	if options != nil && options.BlobContentMd5 != nil {
		req.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(*options.BlobContentMd5))
	}
	if options != nil && options.BlobContentEncoding != nil {
		req.Header.Set("x-ms-blob-content-encoding", *options.BlobContentEncoding)
	}
	if options != nil && options.BlobContentLanguage != nil {
		req.Header.Set("x-ms-blob-content-language", *options.BlobContentLanguage)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.BlobContentDisposition != nil {
		req.Header.Set("x-ms-blob-content-disposition", *options.BlobContentDisposition)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// setHttpHeadersHandleResponse handles the SetHTTPHeaders response.
func (client *blobOperations) setHttpHeadersHandleResponse(resp *azcore.Response) (*BlobSetHTTPHeadersResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobSetHTTPHeadersResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-blob-sequence-number"); val != "" {
		blobSequenceNumber, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return nil, err
		}
		result.BlobSequenceNumber = &blobSequenceNumber
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}

// SetMetadata - The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs
func (client *blobOperations) SetMetadata(ctx context.Context, options *BlobSetMetadataOptions) (*BlobSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setMetadataHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *blobOperations) setMetadataCreateRequest(options *BlobSetMetadataOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *blobOperations) setMetadataHandleResponse(resp *azcore.Response) (*BlobSetMetadataResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobSetMetadataResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-request-server-encrypted"); val != "" {
		requestServerEncrypted, err := strconv.ParseBool(val)
		if err != nil {
			return nil, err
		}
		result.RequestServerEncrypted = &requestServerEncrypted
	}
	if val := resp.Header.Get("x-ms-encryption-key-sha256"); val != "" {
		result.EncryptionKeySha256 = &val
	}
	if val := resp.Header.Get("x-ms-encryption-scope"); val != "" {
		result.EncryptionScope = &val
	}
	return &result, nil
}

// SetTier - The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's ETag.
func (client *blobOperations) SetTier(ctx context.Context, tier AccessTier, options *BlobSetTierOptions) (*BlobSetTierResponse, error) {
	req, err := client.setTierCreateRequest(tier, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setTierHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setTierCreateRequest creates the SetTier request.
func (client *blobOperations) setTierCreateRequest(tier AccessTier, options *BlobSetTierOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "tier")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-access-tier", string(tier))
	if options != nil && options.RehydratePriority != nil {
		req.Header.Set("x-ms-rehydrate-priority", string(*options.RehydratePriority))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	return req, nil
}

// setTierHandleResponse handles the SetTier response.
func (client *blobOperations) setTierHandleResponse(resp *azcore.Response) (*BlobSetTierResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobSetTierResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	return &result, nil
}

// StartCopyFromURL - The Start Copy From URL operation copies a blob or an internet resource to a new blob.
func (client *blobOperations) StartCopyFromURL(ctx context.Context, copySource url.URL, options *BlobStartCopyFromURLOptions) (*BlobStartCopyFromURLResponse, error) {
	req, err := client.startCopyFromUrlCreateRequest(copySource, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.startCopyFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// startCopyFromUrlCreateRequest creates the StartCopyFromURL request.
func (client *blobOperations) startCopyFromUrlCreateRequest(copySource url.URL, options *BlobStartCopyFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*options.Tier))
	}
	if options != nil && options.RehydratePriority != nil {
		req.Header.Set("x-ms-rehydrate-priority", string(*options.RehydratePriority))
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-copy-source", copySource.String())
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// startCopyFromUrlHandleResponse handles the StartCopyFromURL response.
func (client *blobOperations) startCopyFromUrlHandleResponse(resp *azcore.Response) (*BlobStartCopyFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobStartCopyFromURLResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-copy-id"); val != "" {
		result.CopyId = &val
	}
	if val := resp.Header.Get("x-ms-copy-status"); val != "" {
		result.CopyStatus = (*CopyStatusType)(&val)
	}
	return &result, nil
}

// Undelete - Undelete a blob that was previously soft deleted
func (client *blobOperations) Undelete(ctx context.Context, options *BlobUndeleteOptions) (*BlobUndeleteResponse, error) {
	req, err := client.undeleteCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.undeleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// undeleteCreateRequest creates the Undelete request.
func (client *blobOperations) undeleteCreateRequest(options *BlobUndeleteOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "undelete")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// undeleteHandleResponse handles the Undelete response.
func (client *blobOperations) undeleteHandleResponse(resp *azcore.Response) (*BlobUndeleteResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobUndeleteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestId = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestId = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return nil, err
		}
		result.Date = &date
	}
	return &result, nil
}
