// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/base64"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"time"
)

// BlobOperations contains the methods for the Blob group.
type BlobOperations interface {
	// AbortCopyFromURL - The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata.
	AbortCopyFromURL(ctx context.Context, copyId string, options *BlobAbortCopyFromURLOptions) (*BlobAbortCopyFromURLResponse, error)
	// AcquireLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	AcquireLease(ctx context.Context, options *BlobAcquireLeaseOptions) (*BlobAcquireLeaseResponse, error)
	// BreakLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	BreakLease(ctx context.Context, options *BlobBreakLeaseOptions) (*BlobBreakLeaseResponse, error)
	// ChangeLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, options *BlobChangeLeaseOptions) (*BlobChangeLeaseResponse, error)
	// CopyFromURL - The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete.
	CopyFromURL(ctx context.Context, copySource url.URL, options *BlobCopyFromURLOptions) (*BlobCopyFromURLResponse, error)
	// CreateSnapshot - The Create Snapshot operation creates a read-only snapshot of a blob
	CreateSnapshot(ctx context.Context, options *BlobCreateSnapshotOptions) (*BlobCreateSnapshotResponse, error)
	// Delete - If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account's soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound).
	Delete(ctx context.Context, options *BlobDeleteOptions) (*BlobDeleteResponse, error)
	// Download - The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot.
	Download(ctx context.Context, options *BlobDownloadOptions) (*BlobDownloadResponse, error)
	// GetAccessControl - Get the owner, group, permissions, or access control list for a blob.
	GetAccessControl(ctx context.Context, options *BlobGetAccessControlOptions) (*BlobGetAccessControlResponse, error)
	// GetAccountInfo - Returns the sku name and account kind
	GetAccountInfo(ctx context.Context) (*BlobGetAccountInfoResponse, error)
	// GetProperties - The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob.
	GetProperties(ctx context.Context, options *BlobGetPropertiesOptions) (*BlobGetPropertiesResponse, error)
	// ReleaseLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	ReleaseLease(ctx context.Context, leaseId string, options *BlobReleaseLeaseOptions) (*BlobReleaseLeaseResponse, error)
	// Rename - Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
	Rename(ctx context.Context, renameSource string, options *BlobRenameOptions) (*BlobRenameResponse, error)
	// RenewLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
	RenewLease(ctx context.Context, leaseId string, options *BlobRenewLeaseOptions) (*BlobRenewLeaseResponse, error)
	// SetAccessControl - Set the owner, group, permissions, or access control list for a blob.
	SetAccessControl(ctx context.Context, options *BlobSetAccessControlOptions) (*BlobSetAccessControlResponse, error)
	// SetHTTPHeaders - The Set HTTP Headers operation sets system properties on the blob
	SetHTTPHeaders(ctx context.Context, options *BlobSetHTTPHeadersOptions) (*BlobSetHTTPHeadersResponse, error)
	// SetMetadata - The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs
	SetMetadata(ctx context.Context, options *BlobSetMetadataOptions) (*BlobSetMetadataResponse, error)
	// SetTier - The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's ETag.
	SetTier(ctx context.Context, tier AccessTier, options *BlobSetTierOptions) (*BlobSetTierResponse, error)
	// StartCopyFromURL - The Start Copy From URL operation copies a blob or an internet resource to a new blob.
	StartCopyFromURL(ctx context.Context, copySource url.URL, options *BlobStartCopyFromURLOptions) (*BlobStartCopyFromURLResponse, error)
	// Undelete - Undelete a blob that was previously soft deleted
	Undelete(ctx context.Context, options *BlobUndeleteOptions) (*BlobUndeleteResponse, error)
}

// blobOperations implements the BlobOperations interface.
type blobOperations struct {
	*Client
	pathRenameMode *PathRenameMode
}

// AbortCopyFromURL - The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length and full metadata.
func (client *blobOperations) AbortCopyFromURL(ctx context.Context, copyId string, options *BlobAbortCopyFromURLOptions) (*BlobAbortCopyFromURLResponse, error) {
	req, err := client.abortCopyFromUrlCreateRequest(copyId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.abortCopyFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// abortCopyFromUrlCreateRequest creates the AbortCopyFromURL request.
func (client *blobOperations) abortCopyFromUrlCreateRequest(copyId string, options *BlobAbortCopyFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "copy")
	query.Set("copyid", copyId)
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-copy-action", "abort")
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// abortCopyFromUrlHandleResponse handles the AbortCopyFromURL response.
func (client *blobOperations) abortCopyFromUrlHandleResponse(resp *azcore.Response) (*BlobAbortCopyFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, newStorageError(resp)
	}
	result := BlobAbortCopyFromURLResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// AcquireLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) AcquireLease(ctx context.Context, options *BlobAcquireLeaseOptions) (*BlobAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.acquireLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *blobOperations) acquireLeaseCreateRequest(options *BlobAcquireLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "acquire")
	if options != nil && options.Duration != nil {
		req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.ProposedLeaseId != nil {
		req.Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *blobOperations) acquireLeaseHandleResponse(resp *azcore.Response) (*BlobAcquireLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := BlobAcquireLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseId := resp.Header.Get("x-ms-lease-id")
	result.LeaseId = &leaseId
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// BreakLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) BreakLease(ctx context.Context, options *BlobBreakLeaseOptions) (*BlobBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.breakLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *blobOperations) breakLeaseCreateRequest(options *BlobBreakLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "break")
	if options != nil && options.BreakPeriod != nil {
		req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*options.BreakPeriod), 10))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *blobOperations) breakLeaseHandleResponse(resp *azcore.Response) (*BlobBreakLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobBreakLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseTime32, err := strconv.ParseInt(resp.Header.Get("x-ms-lease-time"), 10, 32)
	leaseTime := int32(leaseTime32)
	if err != nil {
		return nil, err
	}
	result.LeaseTime = &leaseTime
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// ChangeLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, options *BlobChangeLeaseOptions) (*BlobChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(leaseId, proposedLeaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.changeLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *blobOperations) changeLeaseCreateRequest(leaseId string, proposedLeaseId string, options *BlobChangeLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "change")
	req.Header.Set("x-ms-lease-id", leaseId)
	req.Header.Set("x-ms-proposed-lease-id", proposedLeaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *blobOperations) changeLeaseHandleResponse(resp *azcore.Response) (*BlobChangeLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobChangeLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseId := resp.Header.Get("x-ms-lease-id")
	result.LeaseId = &leaseId
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// CopyFromURL - The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the copy is complete.
func (client *blobOperations) CopyFromURL(ctx context.Context, copySource url.URL, options *BlobCopyFromURLOptions) (*BlobCopyFromURLResponse, error) {
	req, err := client.copyFromUrlCreateRequest(copySource, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.copyFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// copyFromUrlCreateRequest creates the CopyFromURL request.
func (client *blobOperations) copyFromUrlCreateRequest(copySource url.URL, options *BlobCopyFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-requires-sync", "true")
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*options.Tier))
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-copy-source", copySource.String())
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	if options != nil && options.SourceContentMd5 != nil {
		req.Header.Set("x-ms-source-content-md5", base64.StdEncoding.EncodeToString(*options.SourceContentMd5))
	}
	return req, nil
}

// copyFromUrlHandleResponse handles the CopyFromURL response.
func (client *blobOperations) copyFromUrlHandleResponse(resp *azcore.Response) (*BlobCopyFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobCopyFromURLResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	copyId := resp.Header.Get("x-ms-copy-id")
	result.CopyId = &copyId
	copyStatus := resp.Header.Get("x-ms-copy-status")
	result.CopyStatus = &copyStatus
	contentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("Content-MD5"))
	if err != nil {
		return nil, err
	}
	result.ContentMd5 = &contentMd5
	contentCrc64, err := base64.StdEncoding.DecodeString(resp.Header.Get("x-ms-content-crc64"))
	if err != nil {
		return nil, err
	}
	result.ContentCrc64 = &contentCrc64
	return &result, nil
}

// CreateSnapshot - The Create Snapshot operation creates a read-only snapshot of a blob
func (client *blobOperations) CreateSnapshot(ctx context.Context, options *BlobCreateSnapshotOptions) (*BlobCreateSnapshotResponse, error) {
	req, err := client.createSnapshotCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createSnapshotHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createSnapshotCreateRequest creates the CreateSnapshot request.
func (client *blobOperations) createSnapshotCreateRequest(options *BlobCreateSnapshotOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "snapshot")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// createSnapshotHandleResponse handles the CreateSnapshot response.
func (client *blobOperations) createSnapshotHandleResponse(resp *azcore.Response) (*BlobCreateSnapshotResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := BlobCreateSnapshotResponse{RawResponse: resp.Response}
	snapshot := resp.Header.Get("x-ms-snapshot")
	result.Snapshot = &snapshot
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	requestServerEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-request-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.RequestServerEncrypted = &requestServerEncrypted
	return &result, nil
}

// Delete - If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from the storage account. If the storage account's soft delete feature is enabled, then, when a blob is deleted, it is marked for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md). After the specified number of days has passed, the blob's data is permanently removed from the storage account. Note that you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API and specify the "include=deleted" query parameter to discover which blobs and snapshots have been soft deleted. You can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot causes the service to return an HTTP status code of 404 (ResourceNotFound).
func (client *blobOperations) Delete(ctx context.Context, options *BlobDeleteOptions) (*BlobDeleteResponse, error) {
	req, err := client.deleteCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client *blobOperations) deleteCreateRequest(options *BlobDeleteOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Snapshot != nil {
		query.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.DeleteSnapshots != nil {
		req.Header.Set("x-ms-delete-snapshots", string(*options.DeleteSnapshots))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *blobOperations) deleteHandleResponse(resp *azcore.Response) (*BlobDeleteResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobDeleteResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// Download - The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also call Download to read a snapshot.
func (client *blobOperations) Download(ctx context.Context, options *BlobDownloadOptions) (*BlobDownloadResponse, error) {
	req, err := client.downloadCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.downloadHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// downloadCreateRequest creates the Download request.
func (client *blobOperations) downloadCreateRequest(options *BlobDownloadOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Snapshot != nil {
		query.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	if options != nil && options.RangeParameter != nil {
		req.Header.Set("x-ms-range", *options.RangeParameter)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.RangeGetContentMd5 != nil {
		req.Header.Set("x-ms-range-get-content-md5", strconv.FormatBool(*options.RangeGetContentMd5))
	}
	if options != nil && options.RangeGetContentCrc64 != nil {
		req.Header.Set("x-ms-range-get-content-crc64", strconv.FormatBool(*options.RangeGetContentCrc64))
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// downloadHandleResponse handles the Download response.
func (client *blobOperations) downloadHandleResponse(resp *azcore.Response) (*BlobDownloadResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobDownloadResponse{RawResponse: resp.Response}
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	meta := resp.Header.Get("x-ms-meta")
	result.Meta = &meta
	contentLength, err := strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)
	if err != nil {
		return nil, err
	}
	result.ContentLength = &contentLength
	contentType := resp.Header.Get("Content-Type")
	result.ContentType = &contentType
	contentRange := resp.Header.Get("Content-Range")
	result.ContentRange = &contentRange
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	contentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("Content-MD5"))
	if err != nil {
		return nil, err
	}
	result.ContentMd5 = &contentMd5
	contentEncoding := resp.Header.Get("Content-Encoding")
	result.ContentEncoding = &contentEncoding
	cacheControl := resp.Header.Get("Cache-Control")
	result.CacheControl = &cacheControl
	contentDisposition := resp.Header.Get("Content-Disposition")
	result.ContentDisposition = &contentDisposition
	contentLanguage := resp.Header.Get("Content-Language")
	result.ContentLanguage = &contentLanguage
	blobSequenceNumber, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-sequence-number"), 10, 64)
	if err != nil {
		return nil, err
	}
	result.BlobSequenceNumber = &blobSequenceNumber
	blobType := BlobType(resp.Header.Get("x-ms-blob-type"))
	result.BlobType = &blobType
	copyCompletionTime, err := time.Parse(time.RFC1123, resp.Header.Get("x-ms-copy-completion-time"))
	if err != nil {
		return nil, err
	}
	result.CopyCompletionTime = &copyCompletionTime
	copyStatusDescription := resp.Header.Get("x-ms-copy-status-description")
	result.CopyStatusDescription = &copyStatusDescription
	copyId := resp.Header.Get("x-ms-copy-id")
	result.CopyId = &copyId
	copyProgress := resp.Header.Get("x-ms-copy-progress")
	result.CopyProgress = &copyProgress
	copySource := resp.Header.Get("x-ms-copy-source")
	result.CopySource = &copySource
	copyStatus := CopyStatusType(resp.Header.Get("x-ms-copy-status"))
	result.CopyStatus = &copyStatus
	leaseDuration := LeaseDurationType(resp.Header.Get("x-ms-lease-duration"))
	result.LeaseDuration = &leaseDuration
	leaseState := LeaseStateType(resp.Header.Get("x-ms-lease-state"))
	result.LeaseState = &leaseState
	leaseStatus := LeaseStatusType(resp.Header.Get("x-ms-lease-status"))
	result.LeaseStatus = &leaseStatus
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	acceptRanges := resp.Header.Get("Accept-Ranges")
	result.AcceptRanges = &acceptRanges
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	blobCommittedBlockCount32, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-committed-block-count"), 10, 32)
	blobCommittedBlockCount := int32(blobCommittedBlockCount32)
	if err != nil {
		return nil, err
	}
	result.BlobCommittedBlockCount = &blobCommittedBlockCount
	serverEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.ServerEncrypted = &serverEncrypted
	encryptionKeySha256 := resp.Header.Get("x-ms-encryption-key-sha256")
	result.EncryptionKeySha256 = &encryptionKeySha256
	encryptionScope := resp.Header.Get("x-ms-encryption-scope")
	result.EncryptionScope = &encryptionScope
	blobContentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("x-ms-blob-content-md5"))
	if err != nil {
		return nil, err
	}
	result.BlobContentMd5 = &blobContentMd5
	contentCrc64, err := base64.StdEncoding.DecodeString(resp.Header.Get("x-ms-content-crc64"))
	if err != nil {
		return nil, err
	}
	result.ContentCrc64 = &contentCrc64
	return &result, nil
}

// GetAccessControl - Get the owner, group, permissions, or access control list for a blob.
func (client *blobOperations) GetAccessControl(ctx context.Context, options *BlobGetAccessControlOptions) (*BlobGetAccessControlResponse, error) {
	req, err := client.getAccessControlCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAccessControlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAccessControlCreateRequest creates the GetAccessControl request.
func (client *blobOperations) getAccessControlCreateRequest(options *BlobGetAccessControlOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("action", "getAccessControl")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if options != nil && options.Upn != nil {
		query.Set("upn", strconv.FormatBool(*options.Upn))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// getAccessControlHandleResponse handles the GetAccessControl response.
func (client *blobOperations) getAccessControlHandleResponse(resp *azcore.Response) (*BlobGetAccessControlResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newDataLakeStorageError(resp)
	}
	result := BlobGetAccessControlResponse{RawResponse: resp.Response}
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	owner := resp.Header.Get("x-ms-owner")
	result.Owner = &owner
	group := resp.Header.Get("x-ms-group")
	result.Group = &group
	permissions := resp.Header.Get("x-ms-permissions")
	result.Permissions = &permissions
	acl := resp.Header.Get("x-ms-acl")
	result.Acl = &acl
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	return &result, nil
}

// GetAccountInfo - Returns the sku name and account kind
func (client *blobOperations) GetAccountInfo(ctx context.Context) (*BlobGetAccountInfoResponse, error) {
	req, err := client.getAccountInfoCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAccountInfoHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAccountInfoCreateRequest creates the GetAccountInfo request.
func (client *blobOperations) getAccountInfoCreateRequest() (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "account")
	query.Set("comp", "properties")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// getAccountInfoHandleResponse handles the GetAccountInfo response.
func (client *blobOperations) getAccountInfoHandleResponse(resp *azcore.Response) (*BlobGetAccountInfoResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobGetAccountInfoResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	skuName := SkuName(resp.Header.Get("x-ms-sku-name"))
	result.SkuName = &skuName
	accountKind := AccountKind(resp.Header.Get("x-ms-account-kind"))
	result.AccountKind = &accountKind
	return &result, nil
}

// GetProperties - The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the blob. It does not return the content of the blob.
func (client *blobOperations) GetProperties(ctx context.Context, options *BlobGetPropertiesOptions) (*BlobGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *blobOperations) getPropertiesCreateRequest(options *BlobGetPropertiesOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Snapshot != nil {
		query.Set("snapshot", *options.Snapshot)
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodHead, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *blobOperations) getPropertiesHandleResponse(resp *azcore.Response) (*BlobGetPropertiesResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobGetPropertiesResponse{RawResponse: resp.Response}
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	creationTime, err := time.Parse(time.RFC1123, resp.Header.Get("x-ms-creation-time"))
	if err != nil {
		return nil, err
	}
	result.CreationTime = &creationTime
	meta := resp.Header.Get("x-ms-meta")
	result.Meta = &meta
	blobType := BlobType(resp.Header.Get("x-ms-blob-type"))
	result.BlobType = &blobType
	copyCompletionTime, err := time.Parse(time.RFC1123, resp.Header.Get("x-ms-copy-completion-time"))
	if err != nil {
		return nil, err
	}
	result.CopyCompletionTime = &copyCompletionTime
	copyStatusDescription := resp.Header.Get("x-ms-copy-status-description")
	result.CopyStatusDescription = &copyStatusDescription
	copyId := resp.Header.Get("x-ms-copy-id")
	result.CopyId = &copyId
	copyProgress := resp.Header.Get("x-ms-copy-progress")
	result.CopyProgress = &copyProgress
	copySource := resp.Header.Get("x-ms-copy-source")
	result.CopySource = &copySource
	copyStatus := CopyStatusType(resp.Header.Get("x-ms-copy-status"))
	result.CopyStatus = &copyStatus
	incrementalCopy, err := strconv.ParseBool(resp.Header.Get("x-ms-incremental-copy"))
	if err != nil {
		return nil, err
	}
	result.IncrementalCopy = &incrementalCopy
	copyDestinationSnapshot := resp.Header.Get("x-ms-copy-destination-snapshot")
	result.CopyDestinationSnapshot = &copyDestinationSnapshot
	leaseDuration := LeaseDurationType(resp.Header.Get("x-ms-lease-duration"))
	result.LeaseDuration = &leaseDuration
	leaseState := LeaseStateType(resp.Header.Get("x-ms-lease-state"))
	result.LeaseState = &leaseState
	leaseStatus := LeaseStatusType(resp.Header.Get("x-ms-lease-status"))
	result.LeaseStatus = &leaseStatus
	contentLength, err := strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)
	if err != nil {
		return nil, err
	}
	result.ContentLength = &contentLength
	contentType := resp.Header.Get("Content-Type")
	result.ContentType = &contentType
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	contentMd5, err := base64.StdEncoding.DecodeString(resp.Header.Get("Content-MD5"))
	if err != nil {
		return nil, err
	}
	result.ContentMd5 = &contentMd5
	contentEncoding := resp.Header.Get("Content-Encoding")
	result.ContentEncoding = &contentEncoding
	contentDisposition := resp.Header.Get("Content-Disposition")
	result.ContentDisposition = &contentDisposition
	contentLanguage := resp.Header.Get("Content-Language")
	result.ContentLanguage = &contentLanguage
	cacheControl := resp.Header.Get("Cache-Control")
	result.CacheControl = &cacheControl
	blobSequenceNumber, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-sequence-number"), 10, 64)
	if err != nil {
		return nil, err
	}
	result.BlobSequenceNumber = &blobSequenceNumber
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	acceptRanges := resp.Header.Get("Accept-Ranges")
	result.AcceptRanges = &acceptRanges
	blobCommittedBlockCount32, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-committed-block-count"), 10, 32)
	blobCommittedBlockCount := int32(blobCommittedBlockCount32)
	if err != nil {
		return nil, err
	}
	result.BlobCommittedBlockCount = &blobCommittedBlockCount
	serverEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.ServerEncrypted = &serverEncrypted
	encryptionKeySha256 := resp.Header.Get("x-ms-encryption-key-sha256")
	result.EncryptionKeySha256 = &encryptionKeySha256
	encryptionScope := resp.Header.Get("x-ms-encryption-scope")
	result.EncryptionScope = &encryptionScope
	accessTier := resp.Header.Get("x-ms-access-tier")
	result.AccessTier = &accessTier
	accessTierInferred, err := strconv.ParseBool(resp.Header.Get("x-ms-access-tier-inferred"))
	if err != nil {
		return nil, err
	}
	result.AccessTierInferred = &accessTierInferred
	archiveStatus := resp.Header.Get("x-ms-archive-status")
	result.ArchiveStatus = &archiveStatus
	accessTierChangeTime, err := time.Parse(time.RFC1123, resp.Header.Get("x-ms-access-tier-change-time"))
	if err != nil {
		return nil, err
	}
	result.AccessTierChangeTime = &accessTierChangeTime
	return &result, nil
}

// ReleaseLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) ReleaseLease(ctx context.Context, leaseId string, options *BlobReleaseLeaseOptions) (*BlobReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(leaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.releaseLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *blobOperations) releaseLeaseCreateRequest(leaseId string, options *BlobReleaseLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "release")
	req.Header.Set("x-ms-lease-id", leaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *blobOperations) releaseLeaseHandleResponse(resp *azcore.Response) (*BlobReleaseLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobReleaseLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// Rename - Rename a blob/file.  By default, the destination is overwritten and if the destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).  To fail if the destination already exists, use a conditional request with If-None-Match: "*".
func (client *blobOperations) Rename(ctx context.Context, renameSource string, options *BlobRenameOptions) (*BlobRenameResponse, error) {
	req, err := client.renameCreateRequest(renameSource, client.pathRenameMode, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.renameHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// renameCreateRequest creates the Rename request.
func (client *blobOperations) renameCreateRequest(renameSource string, pathRenameMode *PathRenameMode, options *BlobRenameOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	if pathRenameMode != nil {
		query.Set("mode", string(*pathRenameMode))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-rename-source", renameSource)
	if options != nil && options.DirectoryProperties != nil {
		req.Header.Set("x-ms-properties", *options.DirectoryProperties)
	}
	if options != nil && options.PosixPermissions != nil {
		req.Header.Set("x-ms-permissions", *options.PosixPermissions)
	}
	if options != nil && options.PosixUmask != nil {
		req.Header.Set("x-ms-umask", *options.PosixUmask)
	}
	if options != nil && options.CacheControl != nil {
		req.Header.Set("x-ms-cache-control", *options.CacheControl)
	}
	if options != nil && options.ContentType != nil {
		req.Header.Set("x-ms-content-type", *options.ContentType)
	}
	if options != nil && options.ContentEncoding != nil {
		req.Header.Set("x-ms-content-encoding", *options.ContentEncoding)
	}
	if options != nil && options.ContentLanguage != nil {
		req.Header.Set("x-ms-content-language", *options.ContentLanguage)
	}
	if options != nil && options.ContentDisposition != nil {
		req.Header.Set("x-ms-content-disposition", *options.ContentDisposition)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.SourceLeaseId != nil {
		req.Header.Set("x-ms-source-lease-id", *options.SourceLeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// renameHandleResponse handles the Rename response.
func (client *blobOperations) renameHandleResponse(resp *azcore.Response) (*BlobRenameResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newDataLakeStorageError(resp)
	}
	result := BlobRenameResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	contentLength, err := strconv.ParseInt(resp.Header.Get("Content-Length"), 10, 64)
	if err != nil {
		return nil, err
	}
	result.ContentLength = &contentLength
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// RenewLease - [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations
func (client *blobOperations) RenewLease(ctx context.Context, leaseId string, options *BlobRenewLeaseOptions) (*BlobRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(leaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.renewLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client *blobOperations) renewLeaseCreateRequest(leaseId string, options *BlobRenewLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "renew")
	req.Header.Set("x-ms-lease-id", leaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client *blobOperations) renewLeaseHandleResponse(resp *azcore.Response) (*BlobRenewLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobRenewLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseId := resp.Header.Get("x-ms-lease-id")
	result.LeaseId = &leaseId
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// SetAccessControl - Set the owner, group, permissions, or access control list for a blob.
func (client *blobOperations) SetAccessControl(ctx context.Context, options *BlobSetAccessControlOptions) (*BlobSetAccessControlResponse, error) {
	req, err := client.setAccessControlCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setAccessControlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setAccessControlCreateRequest creates the SetAccessControl request.
func (client *blobOperations) setAccessControlCreateRequest(options *BlobSetAccessControlOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("action", "setAccessControl")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.Owner != nil {
		req.Header.Set("x-ms-owner", *options.Owner)
	}
	if options != nil && options.Group != nil {
		req.Header.Set("x-ms-group", *options.Group)
	}
	if options != nil && options.PosixPermissions != nil {
		req.Header.Set("x-ms-permissions", *options.PosixPermissions)
	}
	if options != nil && options.PosixAcl != nil {
		req.Header.Set("x-ms-acl", *options.PosixAcl)
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// setAccessControlHandleResponse handles the SetAccessControl response.
func (client *blobOperations) setAccessControlHandleResponse(resp *azcore.Response) (*BlobSetAccessControlResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newDataLakeStorageError(resp)
	}
	result := BlobSetAccessControlResponse{RawResponse: resp.Response}
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	return &result, nil
}

// SetHTTPHeaders - The Set HTTP Headers operation sets system properties on the blob
func (client *blobOperations) SetHTTPHeaders(ctx context.Context, options *BlobSetHTTPHeadersOptions) (*BlobSetHTTPHeadersResponse, error) {
	req, err := client.setHttpHeadersCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setHttpHeadersHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setHttpHeadersCreateRequest creates the SetHTTPHeaders request.
func (client *blobOperations) setHttpHeadersCreateRequest(options *BlobSetHTTPHeadersOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "properties")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.BlobCacheControl != nil {
		req.Header.Set("x-ms-blob-cache-control", *options.BlobCacheControl)
	}
	if options != nil && options.BlobContentType != nil {
		req.Header.Set("x-ms-blob-content-type", *options.BlobContentType)
	}
	if options != nil && options.BlobContentMd5 != nil {
		req.Header.Set("x-ms-blob-content-md5", base64.StdEncoding.EncodeToString(*options.BlobContentMd5))
	}
	if options != nil && options.BlobContentEncoding != nil {
		req.Header.Set("x-ms-blob-content-encoding", *options.BlobContentEncoding)
	}
	if options != nil && options.BlobContentLanguage != nil {
		req.Header.Set("x-ms-blob-content-language", *options.BlobContentLanguage)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	if options != nil && options.BlobContentDisposition != nil {
		req.Header.Set("x-ms-blob-content-disposition", *options.BlobContentDisposition)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// setHttpHeadersHandleResponse handles the SetHTTPHeaders response.
func (client *blobOperations) setHttpHeadersHandleResponse(resp *azcore.Response) (*BlobSetHTTPHeadersResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobSetHTTPHeadersResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	blobSequenceNumber, err := strconv.ParseInt(resp.Header.Get("x-ms-blob-sequence-number"), 10, 64)
	if err != nil {
		return nil, err
	}
	result.BlobSequenceNumber = &blobSequenceNumber
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// SetMetadata - The Set Blob Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs
func (client *blobOperations) SetMetadata(ctx context.Context, options *BlobSetMetadataOptions) (*BlobSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setMetadataHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *blobOperations) setMetadataCreateRequest(options *BlobSetMetadataOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.EncryptionKey != nil {
		req.Header.Set("x-ms-encryption-key", *options.EncryptionKey)
	}
	if options != nil && options.EncryptionKeySha256 != nil {
		req.Header.Set("x-ms-encryption-key-sha256", *options.EncryptionKeySha256)
	}
	if options != nil && options.EncryptionScope != nil {
		req.Header.Set("x-ms-encryption-scope", *options.EncryptionScope)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *blobOperations) setMetadataHandleResponse(resp *azcore.Response) (*BlobSetMetadataResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobSetMetadataResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	requestServerEncrypted, err := strconv.ParseBool(resp.Header.Get("x-ms-request-server-encrypted"))
	if err != nil {
		return nil, err
	}
	result.RequestServerEncrypted = &requestServerEncrypted
	encryptionKeySha256 := resp.Header.Get("x-ms-encryption-key-sha256")
	result.EncryptionKeySha256 = &encryptionKeySha256
	encryptionScope := resp.Header.Get("x-ms-encryption-scope")
	result.EncryptionScope = &encryptionScope
	return &result, nil
}

// SetTier - The Set Tier operation sets the tier on a blob. The operation is allowed on a page blob in a premium storage account and on a block blob in a blob storage account (locally redundant storage only). A premium page blob's tier determines the allowed size, IOPS, and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's ETag.
func (client *blobOperations) SetTier(ctx context.Context, tier AccessTier, options *BlobSetTierOptions) (*BlobSetTierResponse, error) {
	req, err := client.setTierCreateRequest(tier, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setTierHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setTierCreateRequest creates the SetTier request.
func (client *blobOperations) setTierCreateRequest(tier AccessTier, options *BlobSetTierOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "tier")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-access-tier", string(tier))
	if options != nil && options.RehydratePriority != nil {
		req.Header.Set("x-ms-rehydrate-priority", string(*options.RehydratePriority))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	return req, nil
}

// setTierHandleResponse handles the SetTier response.
func (client *blobOperations) setTierHandleResponse(resp *azcore.Response) (*BlobSetTierResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobSetTierResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	return &result, nil
}

// StartCopyFromURL - The Start Copy From URL operation copies a blob or an internet resource to a new blob.
func (client *blobOperations) StartCopyFromURL(ctx context.Context, copySource url.URL, options *BlobStartCopyFromURLOptions) (*BlobStartCopyFromURLResponse, error) {
	req, err := client.startCopyFromUrlCreateRequest(copySource, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.startCopyFromUrlHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// startCopyFromUrlCreateRequest creates the StartCopyFromURL request.
func (client *blobOperations) startCopyFromUrlCreateRequest(copySource url.URL, options *BlobStartCopyFromURLOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.Tier != nil {
		req.Header.Set("x-ms-access-tier", string(*options.Tier))
	}
	if options != nil && options.RehydratePriority != nil {
		req.Header.Set("x-ms-rehydrate-priority", string(*options.RehydratePriority))
	}
	if options != nil && options.SourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", options.SourceIfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", options.SourceIfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.SourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *options.SourceIfMatch)
	}
	if options != nil && options.SourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *options.SourceIfNoneMatch)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfMatch != nil {
		req.Header.Set("If-Match", *options.IfMatch)
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Header.Set("If-None-Match", *options.IfNoneMatch)
	}
	req.Header.Set("x-ms-copy-source", copySource.String())
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// startCopyFromUrlHandleResponse handles the StartCopyFromURL response.
func (client *blobOperations) startCopyFromUrlHandleResponse(resp *azcore.Response) (*BlobStartCopyFromURLResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := BlobStartCopyFromURLResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	copyId := resp.Header.Get("x-ms-copy-id")
	result.CopyId = &copyId
	copyStatus := CopyStatusType(resp.Header.Get("x-ms-copy-status"))
	result.CopyStatus = &copyStatus
	return &result, nil
}

// Undelete - Undelete a blob that was previously soft deleted
func (client *blobOperations) Undelete(ctx context.Context, options *BlobUndeleteOptions) (*BlobUndeleteResponse, error) {
	req, err := client.undeleteCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.undeleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// undeleteCreateRequest creates the Undelete request.
func (client *blobOperations) undeleteCreateRequest(options *BlobUndeleteOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "undelete")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// undeleteHandleResponse handles the Undelete response.
func (client *blobOperations) undeleteHandleResponse(resp *azcore.Response) (*BlobUndeleteResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := BlobUndeleteResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}
