// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azblob

import (
	"context"
	"encoding/xml"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// ContainerOperations contains the methods for the Container group.
type ContainerOperations interface {
	// AcquireLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	AcquireLease(ctx context.Context, options *ContainerAcquireLeaseOptions) (*ContainerAcquireLeaseResponse, error)
	// BreakLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	BreakLease(ctx context.Context, options *ContainerBreakLeaseOptions) (*ContainerBreakLeaseResponse, error)
	// ChangeLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, options *ContainerChangeLeaseOptions) (*ContainerChangeLeaseResponse, error)
	// Create - creates a new container under the specified account. If the container with the same name already exists, the operation fails
	Create(ctx context.Context, options *ContainerCreateOptions) (*ContainerCreateResponse, error)
	// Delete - operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection
	Delete(ctx context.Context, options *ContainerDeleteOptions) (*ContainerDeleteResponse, error)
	// GetAccessPolicy - gets the permissions for the specified container. The permissions indicate whether container data may be accessed publicly.
	GetAccessPolicy(ctx context.Context, options *ContainerGetAccessPolicyOptions) (*SignedIDentifierArrayResponse, error)
	// GetAccountInfo - Returns the sku name and account kind
	GetAccountInfo(ctx context.Context) (*ContainerGetAccountInfoResponse, error)
	// GetProperties - returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs
	GetProperties(ctx context.Context, options *ContainerGetPropertiesOptions) (*ContainerGetPropertiesResponse, error)
	// ListBlobFlatSegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
	ListBlobFlatSegment(options *ContainerListBlobFlatSegmentOptions) (ListBlobsFlatSegmentResponsePager, error)
	// ListBlobHierarchySegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
	ListBlobHierarchySegment(delimiter string, options *ContainerListBlobHierarchySegmentOptions) (ListBlobsHierarchySegmentResponsePager, error)
	// ReleaseLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	ReleaseLease(ctx context.Context, leaseId string, options *ContainerReleaseLeaseOptions) (*ContainerReleaseLeaseResponse, error)
	// RenewLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
	RenewLease(ctx context.Context, leaseId string, options *ContainerRenewLeaseOptions) (*ContainerRenewLeaseResponse, error)
	// SetAccessPolicy - sets the permissions for the specified container. The permissions indicate whether blobs in a container may be accessed publicly.
	SetAccessPolicy(ctx context.Context, options *ContainerSetAccessPolicyOptions) (*ContainerSetAccessPolicyResponse, error)
	// SetMetadata - operation sets one or more user-defined name-value pairs for the specified container.
	SetMetadata(ctx context.Context, options *ContainerSetMetadataOptions) (*ContainerSetMetadataResponse, error)
}

// containerOperations implements the ContainerOperations interface.
type containerOperations struct {
	*Client
}

// AcquireLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *containerOperations) AcquireLease(ctx context.Context, options *ContainerAcquireLeaseOptions) (*ContainerAcquireLeaseResponse, error) {
	req, err := client.acquireLeaseCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.acquireLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// acquireLeaseCreateRequest creates the AcquireLease request.
func (client *containerOperations) acquireLeaseCreateRequest(options *ContainerAcquireLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "acquire")
	if options != nil && options.Duration != nil {
		req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.ProposedLeaseId != nil {
		req.Header.Set("x-ms-proposed-lease-id", *options.ProposedLeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// acquireLeaseHandleResponse handles the AcquireLease response.
func (client *containerOperations) acquireLeaseHandleResponse(resp *azcore.Response) (*ContainerAcquireLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := ContainerAcquireLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseId := resp.Header.Get("x-ms-lease-id")
	result.LeaseId = &leaseId
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// BreakLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *containerOperations) BreakLease(ctx context.Context, options *ContainerBreakLeaseOptions) (*ContainerBreakLeaseResponse, error) {
	req, err := client.breakLeaseCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.breakLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// breakLeaseCreateRequest creates the BreakLease request.
func (client *containerOperations) breakLeaseCreateRequest(options *ContainerBreakLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "break")
	if options != nil && options.BreakPeriod != nil {
		req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*options.BreakPeriod), 10))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// breakLeaseHandleResponse handles the BreakLease response.
func (client *containerOperations) breakLeaseHandleResponse(resp *azcore.Response) (*ContainerBreakLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := ContainerBreakLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseTime32, err := strconv.ParseInt(resp.Header.Get("x-ms-lease-time"), 10, 32)
	leaseTime := int32(leaseTime32)
	if err != nil {
		return nil, err
	}
	result.LeaseTime = &leaseTime
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// ChangeLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *containerOperations) ChangeLease(ctx context.Context, leaseId string, proposedLeaseId string, options *ContainerChangeLeaseOptions) (*ContainerChangeLeaseResponse, error) {
	req, err := client.changeLeaseCreateRequest(leaseId, proposedLeaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.changeLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// changeLeaseCreateRequest creates the ChangeLease request.
func (client *containerOperations) changeLeaseCreateRequest(leaseId string, proposedLeaseId string, options *ContainerChangeLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "change")
	req.Header.Set("x-ms-lease-id", leaseId)
	req.Header.Set("x-ms-proposed-lease-id", proposedLeaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// changeLeaseHandleResponse handles the ChangeLease response.
func (client *containerOperations) changeLeaseHandleResponse(resp *azcore.Response) (*ContainerChangeLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerChangeLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseId := resp.Header.Get("x-ms-lease-id")
	result.LeaseId = &leaseId
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// Create - creates a new container under the specified account. If the container with the same name already exists, the operation fails
func (client *containerOperations) Create(ctx context.Context, options *ContainerCreateOptions) (*ContainerCreateResponse, error) {
	req, err := client.createCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createCreateRequest creates the Create request.
func (client *containerOperations) createCreateRequest(options *ContainerCreateOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.Access != nil {
		req.Header.Set("x-ms-blob-public-access", string(*options.Access))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	if options != nil && options.DefaultEncryptionScope != nil {
		req.Header.Set("x-ms-default-encryption-scope", *options.DefaultEncryptionScope)
	}
	if options != nil && options.PreventEncryptionScopeOverride != nil {
		req.Header.Set("x-ms-deny-encryption-scope-override", strconv.FormatBool(*options.PreventEncryptionScopeOverride))
	}
	return req, nil
}

// createHandleResponse handles the Create response.
func (client *containerOperations) createHandleResponse(resp *azcore.Response) (*ContainerCreateResponse, error) {
	if !resp.HasStatusCode(http.StatusCreated) {
		return nil, newStorageError(resp)
	}
	result := ContainerCreateResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// Delete - operation marks the specified container for deletion. The container and any blobs contained within it are later deleted during garbage collection
func (client *containerOperations) Delete(ctx context.Context, options *ContainerDeleteOptions) (*ContainerDeleteResponse, error) {
	req, err := client.deleteCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client *containerOperations) deleteCreateRequest(options *ContainerDeleteOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *containerOperations) deleteHandleResponse(resp *azcore.Response) (*ContainerDeleteResponse, error) {
	if !resp.HasStatusCode(http.StatusAccepted) {
		return nil, newStorageError(resp)
	}
	result := ContainerDeleteResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// GetAccessPolicy - gets the permissions for the specified container. The permissions indicate whether container data may be accessed publicly.
func (client *containerOperations) GetAccessPolicy(ctx context.Context, options *ContainerGetAccessPolicyOptions) (*SignedIDentifierArrayResponse, error) {
	req, err := client.getAccessPolicyCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAccessPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAccessPolicyCreateRequest creates the GetAccessPolicy request.
func (client *containerOperations) getAccessPolicyCreateRequest(options *ContainerGetAccessPolicyOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "acl")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// getAccessPolicyHandleResponse handles the GetAccessPolicy response.
func (client *containerOperations) getAccessPolicyHandleResponse(resp *azcore.Response) (*SignedIDentifierArrayResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := SignedIDentifierArrayResponse{RawResponse: resp.Response}
	blobPublicAccess := PublicAccessType(resp.Header.Get("x-ms-blob-public-access"))
	result.BlobPublicAccess = &blobPublicAccess
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, resp.UnmarshalAsXML(&result)
}

// GetAccountInfo - Returns the sku name and account kind
func (client *containerOperations) GetAccountInfo(ctx context.Context) (*ContainerGetAccountInfoResponse, error) {
	req, err := client.getAccountInfoCreateRequest()
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getAccountInfoHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getAccountInfoCreateRequest creates the GetAccountInfo request.
func (client *containerOperations) getAccountInfoCreateRequest() (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "account")
	query.Set("comp", "properties")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	return req, nil
}

// getAccountInfoHandleResponse handles the GetAccountInfo response.
func (client *containerOperations) getAccountInfoHandleResponse(resp *azcore.Response) (*ContainerGetAccountInfoResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerGetAccountInfoResponse{RawResponse: resp.Response}
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	skuName := SkuName(resp.Header.Get("x-ms-sku-name"))
	result.SkuName = &skuName
	accountKind := AccountKind(resp.Header.Get("x-ms-account-kind"))
	result.AccountKind = &accountKind
	return &result, nil
}

// GetProperties - returns all user-defined metadata and system properties for the specified container. The data returned does not include the container's list of blobs
func (client *containerOperations) GetProperties(ctx context.Context, options *ContainerGetPropertiesOptions) (*ContainerGetPropertiesResponse, error) {
	req, err := client.getPropertiesCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getPropertiesHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getPropertiesCreateRequest creates the GetProperties request.
func (client *containerOperations) getPropertiesCreateRequest(options *ContainerGetPropertiesOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// getPropertiesHandleResponse handles the GetProperties response.
func (client *containerOperations) getPropertiesHandleResponse(resp *azcore.Response) (*ContainerGetPropertiesResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerGetPropertiesResponse{RawResponse: resp.Response}
	meta := resp.Header.Get("x-ms-meta")
	result.Meta = &meta
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseDuration := LeaseDurationType(resp.Header.Get("x-ms-lease-duration"))
	result.LeaseDuration = &leaseDuration
	leaseState := LeaseStateType(resp.Header.Get("x-ms-lease-state"))
	result.LeaseState = &leaseState
	leaseStatus := LeaseStatusType(resp.Header.Get("x-ms-lease-status"))
	result.LeaseStatus = &leaseStatus
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	blobPublicAccess := PublicAccessType(resp.Header.Get("x-ms-blob-public-access"))
	result.BlobPublicAccess = &blobPublicAccess
	hasImmutabilityPolicy, err := strconv.ParseBool(resp.Header.Get("x-ms-has-immutability-policy"))
	if err != nil {
		return nil, err
	}
	result.HasImmutabilityPolicy = &hasImmutabilityPolicy
	hasLegalHold, err := strconv.ParseBool(resp.Header.Get("x-ms-has-legal-hold"))
	if err != nil {
		return nil, err
	}
	result.HasLegalHold = &hasLegalHold
	defaultEncryptionScope := resp.Header.Get("x-ms-default-encryption-scope")
	result.DefaultEncryptionScope = &defaultEncryptionScope
	denyEncryptionScopeOverride, err := strconv.ParseBool(resp.Header.Get("x-ms-deny-encryption-scope-override"))
	if err != nil {
		return nil, err
	}
	result.DenyEncryptionScopeOverride = &denyEncryptionScopeOverride
	return &result, nil
}

// ListBlobFlatSegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
func (client *containerOperations) ListBlobFlatSegment(options *ContainerListBlobFlatSegmentOptions) (ListBlobsFlatSegmentResponsePager, error) {
	req, err := client.listBlobFlatSegmentCreateRequest(options)
	if err != nil {
		return nil, err
	}
	return &listBlobsFlatSegmentResponsePager{
		client:    client,
		request:   req,
		responder: client.listBlobFlatSegmentHandleResponse,
		advancer: func(resp *ListBlobsFlatSegmentResponseResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.EnumerationResults.NextMarker)
			if err != nil {
				return nil, fmt.Errorf("invalid NextMarker: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextMarker %s", *resp.EnumerationResults.NextMarker)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listBlobFlatSegmentCreateRequest creates the ListBlobFlatSegment request.
func (client *containerOperations) listBlobFlatSegmentCreateRequest(options *ContainerListBlobFlatSegmentOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "list")
	if options != nil && options.Prefix != nil {
		query.Set("prefix", *options.Prefix)
	}
	if options != nil && options.Marker != nil {
		query.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		query.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Include != nil {
		query.Set("include", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(*options.Include), "[]")), ","))
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// listBlobFlatSegmentHandleResponse handles the ListBlobFlatSegment response.
func (client *containerOperations) listBlobFlatSegmentHandleResponse(resp *azcore.Response) (*ListBlobsFlatSegmentResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ListBlobsFlatSegmentResponseResponse{RawResponse: resp.Response}
	contentType := resp.Header.Get("Content-Type")
	result.ContentType = &contentType
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// ListBlobHierarchySegment - [Update] The List Blobs operation returns a list of the blobs under the specified container
func (client *containerOperations) ListBlobHierarchySegment(delimiter string, options *ContainerListBlobHierarchySegmentOptions) (ListBlobsHierarchySegmentResponsePager, error) {
	req, err := client.listBlobHierarchySegmentCreateRequest(delimiter, options)
	if err != nil {
		return nil, err
	}
	return &listBlobsHierarchySegmentResponsePager{
		client:    client,
		request:   req,
		responder: client.listBlobHierarchySegmentHandleResponse,
		advancer: func(resp *ListBlobsHierarchySegmentResponseResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.EnumerationResults.NextMarker)
			if err != nil {
				return nil, fmt.Errorf("invalid NextMarker: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextMarker %s", *resp.EnumerationResults.NextMarker)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listBlobHierarchySegmentCreateRequest creates the ListBlobHierarchySegment request.
func (client *containerOperations) listBlobHierarchySegmentCreateRequest(delimiter string, options *ContainerListBlobHierarchySegmentOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "list")
	if options != nil && options.Prefix != nil {
		query.Set("prefix", *options.Prefix)
	}
	query.Set("delimiter", delimiter)
	if options != nil && options.Marker != nil {
		query.Set("marker", *options.Marker)
	}
	if options != nil && options.Maxresults != nil {
		query.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Include != nil {
		query.Set("include", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(*options.Include), "[]")), ","))
	}
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// listBlobHierarchySegmentHandleResponse handles the ListBlobHierarchySegment response.
func (client *containerOperations) listBlobHierarchySegmentHandleResponse(resp *azcore.Response) (*ListBlobsHierarchySegmentResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ListBlobsHierarchySegmentResponseResponse{RawResponse: resp.Response}
	contentType := resp.Header.Get("Content-Type")
	result.ContentType = &contentType
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, resp.UnmarshalAsXML(&result.EnumerationResults)
}

// ReleaseLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *containerOperations) ReleaseLease(ctx context.Context, leaseId string, options *ContainerReleaseLeaseOptions) (*ContainerReleaseLeaseResponse, error) {
	req, err := client.releaseLeaseCreateRequest(leaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.releaseLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// releaseLeaseCreateRequest creates the ReleaseLease request.
func (client *containerOperations) releaseLeaseCreateRequest(leaseId string, options *ContainerReleaseLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "release")
	req.Header.Set("x-ms-lease-id", leaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// releaseLeaseHandleResponse handles the ReleaseLease response.
func (client *containerOperations) releaseLeaseHandleResponse(resp *azcore.Response) (*ContainerReleaseLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerReleaseLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// RenewLease - [Update] establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite
func (client *containerOperations) RenewLease(ctx context.Context, leaseId string, options *ContainerRenewLeaseOptions) (*ContainerRenewLeaseResponse, error) {
	req, err := client.renewLeaseCreateRequest(leaseId, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.renewLeaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// renewLeaseCreateRequest creates the RenewLease request.
func (client *containerOperations) renewLeaseCreateRequest(leaseId string, options *ContainerRenewLeaseOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("comp", "lease")
	query.Set("restype", "container")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	req.Header.Set("x-ms-lease-action", "renew")
	req.Header.Set("x-ms-lease-id", leaseId)
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// renewLeaseHandleResponse handles the RenewLease response.
func (client *containerOperations) renewLeaseHandleResponse(resp *azcore.Response) (*ContainerRenewLeaseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerRenewLeaseResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	leaseId := resp.Header.Get("x-ms-lease-id")
	result.LeaseId = &leaseId
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// SetAccessPolicy - sets the permissions for the specified container. The permissions indicate whether blobs in a container may be accessed publicly.
func (client *containerOperations) SetAccessPolicy(ctx context.Context, options *ContainerSetAccessPolicyOptions) (*ContainerSetAccessPolicyResponse, error) {
	req, err := client.setAccessPolicyCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setAccessPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setAccessPolicyCreateRequest creates the SetAccessPolicy request.
func (client *containerOperations) setAccessPolicyCreateRequest(options *ContainerSetAccessPolicyOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "acl")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.Access != nil {
		req.Header.Set("x-ms-blob-public-access", string(*options.Access))
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", options.IfUnmodifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	type wrapper struct {
		XMLName      xml.Name            `xml:"SignedIdentifiers"`
		ContainerAcl *[]SignedIDentifier `xml:"SignedIdentifier"`
	}
	if err := req.MarshalAsXML(wrapper{ContainerAcl: options.ContainerAcl}); err != nil {
		if err != nil {
			return nil, err
		}
	}
	return req, nil
}

// setAccessPolicyHandleResponse handles the SetAccessPolicy response.
func (client *containerOperations) setAccessPolicyHandleResponse(resp *azcore.Response) (*ContainerSetAccessPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerSetAccessPolicyResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}

// SetMetadata - operation sets one or more user-defined name-value pairs for the specified container.
func (client *containerOperations) SetMetadata(ctx context.Context, options *ContainerSetMetadataOptions) (*ContainerSetMetadataResponse, error) {
	req, err := client.setMetadataCreateRequest(options)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setMetadataHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setMetadataCreateRequest creates the SetMetadata request.
func (client *containerOperations) setMetadataCreateRequest(options *ContainerSetMetadataOptions) (*azcore.Request, error) {
	u := client.u
	query := u.Query()
	query.Set("restype", "container")
	query.Set("comp", "metadata")
	if options != nil && options.Timeout != nil {
		query.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if options != nil && options.LeaseId != nil {
		req.Header.Set("x-ms-lease-id", *options.LeaseId)
	}
	if options != nil && options.Metadata != nil {
		req.Header.Set("x-ms-meta", *options.Metadata)
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Header.Set("If-Modified-Since", options.IfModifiedSince.Format(time.RFC1123))
	}
	req.Header.Set("x-ms-version", "2019-07-07")
	if options != nil && options.RequestId != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestId)
	}
	return req, nil
}

// setMetadataHandleResponse handles the SetMetadata response.
func (client *containerOperations) setMetadataHandleResponse(resp *azcore.Response) (*ContainerSetMetadataResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, newStorageError(resp)
	}
	result := ContainerSetMetadataResponse{RawResponse: resp.Response}
	eTag := resp.Header.Get("ETag")
	result.ETag = &eTag
	lastModified, err := time.Parse(time.RFC1123, resp.Header.Get("Last-Modified"))
	if err != nil {
		return nil, err
	}
	result.LastModified = &lastModified
	clientRequestId := resp.Header.Get("x-ms-client-request-id")
	result.ClientRequestId = &clientRequestId
	requestId := resp.Header.Get("x-ms-request-id")
	result.RequestId = &requestId
	version := resp.Header.Get("x-ms-version")
	result.Version = &version
	date, err := time.Parse(time.RFC1123, resp.Header.Get("Date"))
	if err != nil {
		return nil, err
	}
	result.Date = &date
	return &result, nil
}
