// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package azstorage

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
)

// BlobContainersOperations contains the methods for the BlobContainers group.
type BlobContainersOperations interface {
	// ClearLegalHold - Clears legal hold tags. Clearing the same or non-existent tag results in an idempotent operation. ClearLegalHold clears out only the specified tags in the request.
	ClearLegalHold(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*LegalHoldResponse, error)
	// Create - Creates a new container under the specified account as described by request body. The container resource includes metadata and properties for that container. It does not include a list of the blobs contained by the container.
	Create(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*BlobContainerResponse, error)
	// CreateOrUpdateImmutabilityPolicy - Creates or updates an unlocked immutability policy. ETag in If-Match is honored if given but not required for this operation.
	CreateOrUpdateImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainersCreateOrUpdateImmutabilityPolicyOptions *BlobContainersCreateOrUpdateImmutabilityPolicyOptions) (*ImmutabilityPolicyResponse, error)
	// Delete - Deletes specified container under its account.
	Delete(ctx context.Context, resourceGroupName string, accountName string, containerName string) (*http.Response, error)
	// DeleteImmutabilityPolicy - Aborts an unlocked immutability policy. The response of delete has immutabilityPeriodSinceCreationInDays set to 0. ETag in If-Match is required for this operation. Deleting a locked immutability policy is not allowed, only way is to delete the container after deleting all blobs inside the container.
	DeleteImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*ImmutabilityPolicyResponse, error)
	// ExtendImmutabilityPolicy - Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only action allowed on a Locked policy will be this action. ETag in If-Match is required for this operation.
	ExtendImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string, blobContainersExtendImmutabilityPolicyOptions *BlobContainersExtendImmutabilityPolicyOptions) (*ImmutabilityPolicyResponse, error)
	// Get - Gets properties of a specified container.
	Get(ctx context.Context, resourceGroupName string, accountName string, containerName string) (*BlobContainerResponse, error)
	// GetImmutabilityPolicy - Gets the existing immutability policy along with the corresponding ETag in response headers and body.
	GetImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainersGetImmutabilityPolicyOptions *BlobContainersGetImmutabilityPolicyOptions) (*ImmutabilityPolicyResponse, error)
	// Lease - The Lease Container operation establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
	Lease(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainersLeaseOptions *BlobContainersLeaseOptions) (*LeaseContainerResponseResponse, error)
	// List - Lists all containers and does not support a prefix like data plane. Also SRP today does not return continuation token.
	List(resourceGroupName string, accountName string, blobContainersListOptions *BlobContainersListOptions) (ListContainerItemsPager, error)
	// LockImmutabilityPolicy - Sets the ImmutabilityPolicy to Locked state. The only action allowed on a Locked policy is ExtendImmutabilityPolicy action. ETag in If-Match is required for this operation.
	LockImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*ImmutabilityPolicyResponse, error)
	// SetLegalHold - Sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold follows an append pattern and does not clear out the existing tags that are not specified in the request.
	SetLegalHold(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*LegalHoldResponse, error)
	// Update - Updates container properties as specified in request body. Properties not mentioned in the request will be unchanged. Update fails if the specified container doesn't already exist.
	Update(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*BlobContainerResponse, error)
}

// blobContainersOperations implements the BlobContainersOperations interface.
type blobContainersOperations struct {
	*Client
	subscriptionID string
}

// ClearLegalHold - Clears legal hold tags. Clearing the same or non-existent tag results in an idempotent operation. ClearLegalHold clears out only the specified tags in the request.
func (client *blobContainersOperations) ClearLegalHold(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*LegalHoldResponse, error) {
	req, err := client.clearLegalHoldCreateRequest(resourceGroupName, accountName, containerName, legalHold)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.clearLegalHoldHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// clearLegalHoldCreateRequest creates the ClearLegalHold request.
func (client *blobContainersOperations) clearLegalHoldCreateRequest(resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/clearLegalHold"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(legalHold)
}

// clearLegalHoldHandleResponse handles the ClearLegalHold response.
func (client *blobContainersOperations) clearLegalHoldHandleResponse(resp *azcore.Response) (*LegalHoldResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.clearLegalHoldHandleError(resp)
	}
	result := LegalHoldResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.LegalHold)
}

// clearLegalHoldHandleError handles the ClearLegalHold error response.
func (client *blobContainersOperations) clearLegalHoldHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Create - Creates a new container under the specified account as described by request body. The container resource includes metadata and properties for that container. It does not include a list of the blobs contained by the container.
func (client *blobContainersOperations) Create(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*BlobContainerResponse, error) {
	req, err := client.createCreateRequest(resourceGroupName, accountName, containerName, blobContainer)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createCreateRequest creates the Create request.
func (client *blobContainersOperations) createCreateRequest(resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	return req, req.MarshalAsJSON(blobContainer)
}

// createHandleResponse handles the Create response.
func (client *blobContainersOperations) createHandleResponse(resp *azcore.Response) (*BlobContainerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusCreated) {
		return nil, client.createHandleError(resp)
	}
	result := BlobContainerResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BlobContainer)
}

// createHandleError handles the Create error response.
func (client *blobContainersOperations) createHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// CreateOrUpdateImmutabilityPolicy - Creates or updates an unlocked immutability policy. ETag in If-Match is honored if given but not required for this operation.
func (client *blobContainersOperations) CreateOrUpdateImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainersCreateOrUpdateImmutabilityPolicyOptions *BlobContainersCreateOrUpdateImmutabilityPolicyOptions) (*ImmutabilityPolicyResponse, error) {
	req, err := client.createOrUpdateImmutabilityPolicyCreateRequest(resourceGroupName, accountName, containerName, blobContainersCreateOrUpdateImmutabilityPolicyOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.createOrUpdateImmutabilityPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// createOrUpdateImmutabilityPolicyCreateRequest creates the CreateOrUpdateImmutabilityPolicy request.
func (client *blobContainersOperations) createOrUpdateImmutabilityPolicyCreateRequest(resourceGroupName string, accountName string, containerName string, blobContainersCreateOrUpdateImmutabilityPolicyOptions *BlobContainersCreateOrUpdateImmutabilityPolicyOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{immutabilityPolicyName}", url.PathEscape("default"))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPut, *u)
	if blobContainersCreateOrUpdateImmutabilityPolicyOptions != nil && blobContainersCreateOrUpdateImmutabilityPolicyOptions.IfMatch != nil {
		req.Header.Set("If-Match", *blobContainersCreateOrUpdateImmutabilityPolicyOptions.IfMatch)
	}
	if blobContainersCreateOrUpdateImmutabilityPolicyOptions != nil {
		return req, req.MarshalAsJSON(blobContainersCreateOrUpdateImmutabilityPolicyOptions.Parameters)
	}
	return req, nil
}

// createOrUpdateImmutabilityPolicyHandleResponse handles the CreateOrUpdateImmutabilityPolicy response.
func (client *blobContainersOperations) createOrUpdateImmutabilityPolicyHandleResponse(resp *azcore.Response) (*ImmutabilityPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.createOrUpdateImmutabilityPolicyHandleError(resp)
	}
	result := ImmutabilityPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return &result, resp.UnmarshalAsJSON(&result.ImmutabilityPolicy)
}

// createOrUpdateImmutabilityPolicyHandleError handles the CreateOrUpdateImmutabilityPolicy error response.
func (client *blobContainersOperations) createOrUpdateImmutabilityPolicyHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Delete - Deletes specified container under its account.
func (client *blobContainersOperations) Delete(ctx context.Context, resourceGroupName string, accountName string, containerName string) (*http.Response, error) {
	req, err := client.deleteCreateRequest(resourceGroupName, accountName, containerName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteCreateRequest creates the Delete request.
func (client *blobContainersOperations) deleteCreateRequest(resourceGroupName string, accountName string, containerName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *blobContainersOperations) deleteHandleResponse(resp *azcore.Response) (*http.Response, error) {
	if !resp.HasStatusCode(http.StatusOK, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp.Response, nil
}

// deleteHandleError handles the Delete error response.
func (client *blobContainersOperations) deleteHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// DeleteImmutabilityPolicy - Aborts an unlocked immutability policy. The response of delete has immutabilityPeriodSinceCreationInDays set to 0. ETag in If-Match is required for this operation. Deleting a locked immutability policy is not allowed, only way is to delete the container after deleting all blobs inside the container.
func (client *blobContainersOperations) DeleteImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*ImmutabilityPolicyResponse, error) {
	req, err := client.deleteImmutabilityPolicyCreateRequest(resourceGroupName, accountName, containerName, ifMatch)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.deleteImmutabilityPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// deleteImmutabilityPolicyCreateRequest creates the DeleteImmutabilityPolicy request.
func (client *blobContainersOperations) deleteImmutabilityPolicyCreateRequest(resourceGroupName string, accountName string, containerName string, ifMatch string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{immutabilityPolicyName}", url.PathEscape("default"))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodDelete, *u)
	req.Header.Set("If-Match", ifMatch)
	return req, nil
}

// deleteImmutabilityPolicyHandleResponse handles the DeleteImmutabilityPolicy response.
func (client *blobContainersOperations) deleteImmutabilityPolicyHandleResponse(resp *azcore.Response) (*ImmutabilityPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.deleteImmutabilityPolicyHandleError(resp)
	}
	result := ImmutabilityPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return &result, resp.UnmarshalAsJSON(&result.ImmutabilityPolicy)
}

// deleteImmutabilityPolicyHandleError handles the DeleteImmutabilityPolicy error response.
func (client *blobContainersOperations) deleteImmutabilityPolicyHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// ExtendImmutabilityPolicy - Extends the immutabilityPeriodSinceCreationInDays of a locked immutabilityPolicy. The only action allowed on a Locked policy will be this action. ETag in If-Match is required for this operation.
func (client *blobContainersOperations) ExtendImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string, blobContainersExtendImmutabilityPolicyOptions *BlobContainersExtendImmutabilityPolicyOptions) (*ImmutabilityPolicyResponse, error) {
	req, err := client.extendImmutabilityPolicyCreateRequest(resourceGroupName, accountName, containerName, ifMatch, blobContainersExtendImmutabilityPolicyOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.extendImmutabilityPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// extendImmutabilityPolicyCreateRequest creates the ExtendImmutabilityPolicy request.
func (client *blobContainersOperations) extendImmutabilityPolicyCreateRequest(resourceGroupName string, accountName string, containerName string, ifMatch string, blobContainersExtendImmutabilityPolicyOptions *BlobContainersExtendImmutabilityPolicyOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/extend"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	req.Header.Set("If-Match", ifMatch)
	if blobContainersExtendImmutabilityPolicyOptions != nil {
		return req, req.MarshalAsJSON(blobContainersExtendImmutabilityPolicyOptions.Parameters)
	}
	return req, nil
}

// extendImmutabilityPolicyHandleResponse handles the ExtendImmutabilityPolicy response.
func (client *blobContainersOperations) extendImmutabilityPolicyHandleResponse(resp *azcore.Response) (*ImmutabilityPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.extendImmutabilityPolicyHandleError(resp)
	}
	result := ImmutabilityPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return &result, resp.UnmarshalAsJSON(&result.ImmutabilityPolicy)
}

// extendImmutabilityPolicyHandleError handles the ExtendImmutabilityPolicy error response.
func (client *blobContainersOperations) extendImmutabilityPolicyHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Get - Gets properties of a specified container.
func (client *blobContainersOperations) Get(ctx context.Context, resourceGroupName string, accountName string, containerName string) (*BlobContainerResponse, error) {
	req, err := client.getCreateRequest(resourceGroupName, accountName, containerName)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getCreateRequest creates the Get request.
func (client *blobContainersOperations) getCreateRequest(resourceGroupName string, accountName string, containerName string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *blobContainersOperations) getHandleResponse(resp *azcore.Response) (*BlobContainerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getHandleError(resp)
	}
	result := BlobContainerResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BlobContainer)
}

// getHandleError handles the Get error response.
func (client *blobContainersOperations) getHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// GetImmutabilityPolicy - Gets the existing immutability policy along with the corresponding ETag in response headers and body.
func (client *blobContainersOperations) GetImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainersGetImmutabilityPolicyOptions *BlobContainersGetImmutabilityPolicyOptions) (*ImmutabilityPolicyResponse, error) {
	req, err := client.getImmutabilityPolicyCreateRequest(resourceGroupName, accountName, containerName, blobContainersGetImmutabilityPolicyOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.getImmutabilityPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// getImmutabilityPolicyCreateRequest creates the GetImmutabilityPolicy request.
func (client *blobContainersOperations) getImmutabilityPolicyCreateRequest(resourceGroupName string, accountName string, containerName string, blobContainersGetImmutabilityPolicyOptions *BlobContainersGetImmutabilityPolicyOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/{immutabilityPolicyName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{immutabilityPolicyName}", url.PathEscape("default"))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	if blobContainersGetImmutabilityPolicyOptions != nil && blobContainersGetImmutabilityPolicyOptions.IfMatch != nil {
		req.Header.Set("If-Match", *blobContainersGetImmutabilityPolicyOptions.IfMatch)
	}
	return req, nil
}

// getImmutabilityPolicyHandleResponse handles the GetImmutabilityPolicy response.
func (client *blobContainersOperations) getImmutabilityPolicyHandleResponse(resp *azcore.Response) (*ImmutabilityPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.getImmutabilityPolicyHandleError(resp)
	}
	result := ImmutabilityPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return &result, resp.UnmarshalAsJSON(&result.ImmutabilityPolicy)
}

// getImmutabilityPolicyHandleError handles the GetImmutabilityPolicy error response.
func (client *blobContainersOperations) getImmutabilityPolicyHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Lease - The Lease Container operation establishes and manages a lock on a container for delete operations. The lock duration can be 15 to 60 seconds, or can be infinite.
func (client *blobContainersOperations) Lease(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainersLeaseOptions *BlobContainersLeaseOptions) (*LeaseContainerResponseResponse, error) {
	req, err := client.leaseCreateRequest(resourceGroupName, accountName, containerName, blobContainersLeaseOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.leaseHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// leaseCreateRequest creates the Lease request.
func (client *blobContainersOperations) leaseCreateRequest(resourceGroupName string, accountName string, containerName string, blobContainersLeaseOptions *BlobContainersLeaseOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/lease"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	if blobContainersLeaseOptions != nil {
		return req, req.MarshalAsJSON(blobContainersLeaseOptions.Parameters)
	}
	return req, nil
}

// leaseHandleResponse handles the Lease response.
func (client *blobContainersOperations) leaseHandleResponse(resp *azcore.Response) (*LeaseContainerResponseResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.leaseHandleError(resp)
	}
	result := LeaseContainerResponseResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.LeaseContainerResponse)
}

// leaseHandleError handles the Lease error response.
func (client *blobContainersOperations) leaseHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// List - Lists all containers and does not support a prefix like data plane. Also SRP today does not return continuation token.
func (client *blobContainersOperations) List(resourceGroupName string, accountName string, blobContainersListOptions *BlobContainersListOptions) (ListContainerItemsPager, error) {
	req, err := client.listCreateRequest(resourceGroupName, accountName, blobContainersListOptions)
	if err != nil {
		return nil, err
	}
	return &listContainerItemsPager{
		pipeline:  client.p,
		request:   req,
		responder: client.listHandleResponse,
		advancer: func(resp *ListContainerItemsResponse) (*azcore.Request, error) {
			u, err := url.Parse(*resp.ListContainerItems.NextLink)
			if err != nil {
				return nil, fmt.Errorf("invalid NextLink: %w", err)
			}
			if u.Scheme == "" {
				return nil, fmt.Errorf("no scheme detected in NextLink %s", *resp.ListContainerItems.NextLink)
			}
			return azcore.NewRequest(http.MethodGet, *u), nil
		},
	}, nil
}

// listCreateRequest creates the List request.
func (client *blobContainersOperations) listCreateRequest(resourceGroupName string, accountName string, blobContainersListOptions *BlobContainersListOptions) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	if blobContainersListOptions != nil && blobContainersListOptions.Maxpagesize != nil {
		query.Set("$maxpagesize", *blobContainersListOptions.Maxpagesize)
	}
	if blobContainersListOptions != nil && blobContainersListOptions.Filter != nil {
		query.Set("$filter", *blobContainersListOptions.Filter)
	}
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodGet, *u)
	return req, nil
}

// listHandleResponse handles the List response.
func (client *blobContainersOperations) listHandleResponse(resp *azcore.Response) (*ListContainerItemsResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.listHandleError(resp)
	}
	result := ListContainerItemsResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.ListContainerItems)
}

// listHandleError handles the List error response.
func (client *blobContainersOperations) listHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// LockImmutabilityPolicy - Sets the ImmutabilityPolicy to Locked state. The only action allowed on a Locked policy is ExtendImmutabilityPolicy action. ETag in If-Match is required for this operation.
func (client *blobContainersOperations) LockImmutabilityPolicy(ctx context.Context, resourceGroupName string, accountName string, containerName string, ifMatch string) (*ImmutabilityPolicyResponse, error) {
	req, err := client.lockImmutabilityPolicyCreateRequest(resourceGroupName, accountName, containerName, ifMatch)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.lockImmutabilityPolicyHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// lockImmutabilityPolicyCreateRequest creates the LockImmutabilityPolicy request.
func (client *blobContainersOperations) lockImmutabilityPolicyCreateRequest(resourceGroupName string, accountName string, containerName string, ifMatch string) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/immutabilityPolicies/default/lock"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	req.Header.Set("If-Match", ifMatch)
	return req, nil
}

// lockImmutabilityPolicyHandleResponse handles the LockImmutabilityPolicy response.
func (client *blobContainersOperations) lockImmutabilityPolicyHandleResponse(resp *azcore.Response) (*ImmutabilityPolicyResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.lockImmutabilityPolicyHandleError(resp)
	}
	result := ImmutabilityPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return &result, resp.UnmarshalAsJSON(&result.ImmutabilityPolicy)
}

// lockImmutabilityPolicyHandleError handles the LockImmutabilityPolicy error response.
func (client *blobContainersOperations) lockImmutabilityPolicyHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// SetLegalHold - Sets legal hold tags. Setting the same tag results in an idempotent operation. SetLegalHold follows an append pattern and does not clear out the existing tags that are not specified in the request.
func (client *blobContainersOperations) SetLegalHold(ctx context.Context, resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*LegalHoldResponse, error) {
	req, err := client.setLegalHoldCreateRequest(resourceGroupName, accountName, containerName, legalHold)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.setLegalHoldHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// setLegalHoldCreateRequest creates the SetLegalHold request.
func (client *blobContainersOperations) setLegalHoldCreateRequest(resourceGroupName string, accountName string, containerName string, legalHold LegalHold) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}/setLegalHold"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPost, *u)
	return req, req.MarshalAsJSON(legalHold)
}

// setLegalHoldHandleResponse handles the SetLegalHold response.
func (client *blobContainersOperations) setLegalHoldHandleResponse(resp *azcore.Response) (*LegalHoldResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.setLegalHoldHandleError(resp)
	}
	result := LegalHoldResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.LegalHold)
}

// setLegalHoldHandleError handles the SetLegalHold error response.
func (client *blobContainersOperations) setLegalHoldHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}

// Update - Updates container properties as specified in request body. Properties not mentioned in the request will be unchanged. Update fails if the specified container doesn't already exist.
func (client *blobContainersOperations) Update(ctx context.Context, resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*BlobContainerResponse, error) {
	req, err := client.updateCreateRequest(resourceGroupName, accountName, containerName, blobContainer)
	if err != nil {
		return nil, err
	}
	resp, err := client.p.Do(ctx, req)
	if err != nil {
		return nil, err
	}
	result, err := client.updateHandleResponse(resp)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// updateCreateRequest creates the Update request.
func (client *blobContainersOperations) updateCreateRequest(resourceGroupName string, accountName string, containerName string, blobContainer BlobContainer) (*azcore.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}/blobServices/default/containers/{containerName}"
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	urlPath = strings.ReplaceAll(urlPath, "{accountName}", url.PathEscape(accountName))
	urlPath = strings.ReplaceAll(urlPath, "{containerName}", url.PathEscape(containerName))
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(client.subscriptionID))
	u, err := client.u.Parse(urlPath)
	if err != nil {
		return nil, err
	}
	query := u.Query()
	query.Set("api-version", "2019-06-01")
	u.RawQuery = query.Encode()
	req := azcore.NewRequest(http.MethodPatch, *u)
	return req, req.MarshalAsJSON(blobContainer)
}

// updateHandleResponse handles the Update response.
func (client *blobContainersOperations) updateHandleResponse(resp *azcore.Response) (*BlobContainerResponse, error) {
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.updateHandleError(resp)
	}
	result := BlobContainerResponse{RawResponse: resp.Response}
	return &result, resp.UnmarshalAsJSON(&result.BlobContainer)
}

// updateHandleError handles the Update error response.
func (client *blobContainersOperations) updateHandleError(resp *azcore.Response) error {
	return errors.New(resp.Status)
}
