// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package aztable

import (
	"context"
	"encoding/xml"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

type tableClient struct {
	con *connection
}

// Create - Creates a new table under the given account.
// If the operation fails it returns the *TableServiceError error type.
// Possible return types are *TableResponseResponse, *TableCreateResponse
func (client *tableClient) Create(ctx context.Context, tableProperties TableProperties, tableCreateOptions *TableCreateOptions, queryOptions *QueryOptions) (interface{}, error) {
	req, err := client.createCreateRequest(ctx, tableProperties, tableCreateOptions, queryOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated, http.StatusNoContent) {
		return nil, client.createHandleError(resp)
	}
	return client.createHandleResponse(resp)
}

// createCreateRequest creates the Create request.
func (client *tableClient) createCreateRequest(ctx context.Context, tableProperties TableProperties, tableCreateOptions *TableCreateOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/Tables"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableCreateOptions != nil && tableCreateOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableCreateOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	if tableCreateOptions != nil && tableCreateOptions.ResponsePreference != nil {
		req.Header.Set("Prefer", string(*tableCreateOptions.ResponsePreference))
	}
	req.Header.Set("Accept", "application/json;odata=minimalmetadata")
	return req, req.MarshalAsJSON(tableProperties)
}

// createHandleResponse handles the Create response.
func (client *tableClient) createHandleResponse(resp *azcore.Response) (interface{}, error) {
	switch resp.StatusCode {
	case http.StatusCreated:
		var val *TableResponse
		if err := resp.UnmarshalAsJSON(&val); err != nil {
			return nil, err
		}
		result := TableResponseResponse{RawResponse: resp.Response, TableResponse: val}
		if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
			result.ClientRequestID = &val
		}
		if val := resp.Header.Get("x-ms-request-id"); val != "" {
			result.RequestID = &val
		}
		if val := resp.Header.Get("x-ms-version"); val != "" {
			result.Version = &val
		}
		if val := resp.Header.Get("Date"); val != "" {
			date, err := time.Parse(time.RFC1123, val)
			if err != nil {
				return TableResponseResponse{}, err
			}
			result.Date = &date
		}
		if val := resp.Header.Get("Preference-Applied"); val != "" {
			result.PreferenceApplied = &val
		}
		return result, nil
	case http.StatusNoContent:
		result := TableCreateResponse{RawResponse: resp.Response}
		if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
			result.ClientRequestID = &val
		}
		if val := resp.Header.Get("x-ms-request-id"); val != "" {
			result.RequestID = &val
		}
		if val := resp.Header.Get("x-ms-version"); val != "" {
			result.Version = &val
		}
		if val := resp.Header.Get("Date"); val != "" {
			date, err := time.Parse(time.RFC1123, val)
			if err != nil {
				return TableCreateResponse{}, err
			}
			result.Date = &date
		}
		if val := resp.Header.Get("Preference-Applied"); val != "" {
			result.PreferenceApplied = &val
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
}

// createHandleError handles the Create error response.
func (client *tableClient) createHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Delete - Operation permanently deletes the specified table.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) Delete(ctx context.Context, table string, options *TableDeleteOptions) (TableDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, table, options)
	if err != nil {
		return TableDeleteResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableDeleteResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return TableDeleteResponse{}, client.deleteHandleError(resp)
	}
	return client.deleteHandleResponse(resp)
}

// deleteCreateRequest creates the Delete request.
func (client *tableClient) deleteCreateRequest(ctx context.Context, table string, options *TableDeleteOptions) (*azcore.Request, error) {
	urlPath := "/Tables('{table}')"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	req.Header.Set("x-ms-version", "2019-02-02")
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteHandleResponse handles the Delete response.
func (client *tableClient) deleteHandleResponse(resp *azcore.Response) (TableDeleteResponse, error) {
	result := TableDeleteResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableDeleteResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteHandleError handles the Delete error response.
func (client *tableClient) deleteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteEntity - Deletes the specified entity in a table.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) DeleteEntity(ctx context.Context, table string, partitionKey string, rowKey string, ifMatch string, tableDeleteEntityOptions *TableDeleteEntityOptions, queryOptions *QueryOptions) (TableDeleteEntityResponse, error) {
	req, err := client.deleteEntityCreateRequest(ctx, table, partitionKey, rowKey, ifMatch, tableDeleteEntityOptions, queryOptions)
	if err != nil {
		return TableDeleteEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableDeleteEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return TableDeleteEntityResponse{}, client.deleteEntityHandleError(resp)
	}
	return client.deleteEntityHandleResponse(resp)
}

// deleteEntityCreateRequest creates the DeleteEntity request.
func (client *tableClient) deleteEntityCreateRequest(ctx context.Context, table string, partitionKey string, rowKey string, ifMatch string, tableDeleteEntityOptions *TableDeleteEntityOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	if partitionKey == "" {
		return nil, errors.New("parameter partitionKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{partitionKey}", url.PathEscape(partitionKey))
	if rowKey == "" {
		return nil, errors.New("parameter rowKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{rowKey}", url.PathEscape(rowKey))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if tableDeleteEntityOptions != nil && tableDeleteEntityOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*tableDeleteEntityOptions.Timeout), 10))
	}
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableDeleteEntityOptions != nil && tableDeleteEntityOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableDeleteEntityOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	req.Header.Set("If-Match", ifMatch)
	req.Header.Set("Accept", "application/json;odata=minimalmetadata")
	return req, nil
}

// deleteEntityHandleResponse handles the DeleteEntity response.
func (client *tableClient) deleteEntityHandleResponse(resp *azcore.Response) (TableDeleteEntityResponse, error) {
	result := TableDeleteEntityResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableDeleteEntityResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// deleteEntityHandleError handles the DeleteEntity error response.
func (client *tableClient) deleteEntityHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetAccessPolicy - Retrieves details about any stored access policies specified on the table that may be used with Shared Access Signatures.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) GetAccessPolicy(ctx context.Context, table string, options *TableGetAccessPolicyOptions) (SignedIdentifierArrayResponse, error) {
	req, err := client.getAccessPolicyCreateRequest(ctx, table, options)
	if err != nil {
		return SignedIdentifierArrayResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SignedIdentifierArrayResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SignedIdentifierArrayResponse{}, client.getAccessPolicyHandleError(resp)
	}
	return client.getAccessPolicyHandleResponse(resp)
}

// getAccessPolicyCreateRequest creates the GetAccessPolicy request.
func (client *tableClient) getAccessPolicyCreateRequest(ctx context.Context, table string, options *TableGetAccessPolicyOptions) (*azcore.Request, error) {
	urlPath := "/{table}"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	reqQP.Set("comp", "acl")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Header.Set("Accept", "application/xml")
	return req, nil
}

// getAccessPolicyHandleResponse handles the GetAccessPolicy response.
func (client *tableClient) getAccessPolicyHandleResponse(resp *azcore.Response) (SignedIdentifierArrayResponse, error) {
	result := SignedIdentifierArrayResponse{RawResponse: resp.Response}
	if err := resp.UnmarshalAsXML(&result); err != nil {
		return SignedIdentifierArrayResponse{}, err
	}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return SignedIdentifierArrayResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// getAccessPolicyHandleError handles the GetAccessPolicy error response.
func (client *tableClient) getAccessPolicyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// InsertEntity - Insert entity in a table.
// If the operation fails it returns the *TableServiceError error type.
// Possible return types are *MapOfInterfaceResponse, *TableInsertEntityResponse
func (client *tableClient) InsertEntity(ctx context.Context, table string, tableInsertEntityOptions *TableInsertEntityOptions, queryOptions *QueryOptions) (interface{}, error) {
	req, err := client.insertEntityCreateRequest(ctx, table, tableInsertEntityOptions, queryOptions)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusCreated, http.StatusNoContent) {
		return nil, client.insertEntityHandleError(resp)
	}
	return client.insertEntityHandleResponse(resp)
}

// insertEntityCreateRequest creates the InsertEntity request.
func (client *tableClient) insertEntityCreateRequest(ctx context.Context, table string, tableInsertEntityOptions *TableInsertEntityOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/{table}"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if tableInsertEntityOptions != nil && tableInsertEntityOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*tableInsertEntityOptions.Timeout), 10))
	}
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableInsertEntityOptions != nil && tableInsertEntityOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableInsertEntityOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	if tableInsertEntityOptions != nil && tableInsertEntityOptions.ResponsePreference != nil {
		req.Header.Set("Prefer", string(*tableInsertEntityOptions.ResponsePreference))
	}
	req.Header.Set("Accept", "application/json;odata=minimalmetadata")
	if tableInsertEntityOptions != nil && tableInsertEntityOptions.TableEntityProperties != nil {
		return req, req.MarshalAsJSON(tableInsertEntityOptions.TableEntityProperties)
	}
	return req, nil
}

// insertEntityHandleResponse handles the InsertEntity response.
func (client *tableClient) insertEntityHandleResponse(resp *azcore.Response) (interface{}, error) {
	switch resp.StatusCode {
	case http.StatusCreated:
		var val map[string]interface{}
		if err := resp.UnmarshalAsJSON(&val); err != nil {
			return nil, err
		}
		result := MapOfInterfaceResponse{RawResponse: resp.Response, Value: val}
		if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
			result.ClientRequestID = &val
		}
		if val := resp.Header.Get("x-ms-request-id"); val != "" {
			result.RequestID = &val
		}
		if val := resp.Header.Get("x-ms-version"); val != "" {
			result.Version = &val
		}
		if val := resp.Header.Get("Date"); val != "" {
			date, err := time.Parse(time.RFC1123, val)
			if err != nil {
				return MapOfInterfaceResponse{}, err
			}
			result.Date = &date
		}
		if val := resp.Header.Get("ETag"); val != "" {
			result.ETag = &val
		}
		if val := resp.Header.Get("x-ms-continuation-NextPartitionKey"); val != "" {
			result.XMSContinuationNextPartitionKey = &val
		}
		if val := resp.Header.Get("x-ms-continuation-NextRowKey"); val != "" {
			result.XMSContinuationNextRowKey = &val
		}
		if val := resp.Header.Get("Preference-Applied"); val != "" {
			result.PreferenceApplied = &val
		}
		if val := resp.Header.Get("Content-Type"); val != "" {
			result.ContentType = &val
		}
		return result, nil
	case http.StatusNoContent:
		result := TableInsertEntityResponse{RawResponse: resp.Response}
		if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
			result.ClientRequestID = &val
		}
		if val := resp.Header.Get("x-ms-request-id"); val != "" {
			result.RequestID = &val
		}
		if val := resp.Header.Get("x-ms-version"); val != "" {
			result.Version = &val
		}
		if val := resp.Header.Get("Date"); val != "" {
			date, err := time.Parse(time.RFC1123, val)
			if err != nil {
				return TableInsertEntityResponse{}, err
			}
			result.Date = &date
		}
		if val := resp.Header.Get("ETag"); val != "" {
			result.ETag = &val
		}
		if val := resp.Header.Get("Preference-Applied"); val != "" {
			result.PreferenceApplied = &val
		}
		if val := resp.Header.Get("Content-Type"); val != "" {
			result.ContentType = &val
		}
		return result, nil
	default:
		return nil, fmt.Errorf("unhandled HTTP status code %d", resp.StatusCode)
	}
}

// insertEntityHandleError handles the InsertEntity error response.
func (client *tableClient) insertEntityHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// MergeEntity - Merge entity in a table.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) MergeEntity(ctx context.Context, table string, partitionKey string, rowKey string, tableMergeEntityOptions *TableMergeEntityOptions, queryOptions *QueryOptions) (TableMergeEntityResponse, error) {
	req, err := client.mergeEntityCreateRequest(ctx, table, partitionKey, rowKey, tableMergeEntityOptions, queryOptions)
	if err != nil {
		return TableMergeEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableMergeEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return TableMergeEntityResponse{}, client.mergeEntityHandleError(resp)
	}
	return client.mergeEntityHandleResponse(resp)
}

// mergeEntityCreateRequest creates the MergeEntity request.
func (client *tableClient) mergeEntityCreateRequest(ctx context.Context, table string, partitionKey string, rowKey string, tableMergeEntityOptions *TableMergeEntityOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	if partitionKey == "" {
		return nil, errors.New("parameter partitionKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{partitionKey}", url.PathEscape(partitionKey))
	if rowKey == "" {
		return nil, errors.New("parameter rowKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{rowKey}", url.PathEscape(rowKey))
	req, err := azcore.NewRequest(ctx, http.MethodPatch, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if tableMergeEntityOptions != nil && tableMergeEntityOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*tableMergeEntityOptions.Timeout), 10))
	}
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableMergeEntityOptions != nil && tableMergeEntityOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableMergeEntityOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	if tableMergeEntityOptions != nil && tableMergeEntityOptions.IfMatch != nil {
		req.Header.Set("If-Match", *tableMergeEntityOptions.IfMatch)
	}
	req.Header.Set("Accept", "application/json")
	if tableMergeEntityOptions != nil && tableMergeEntityOptions.TableEntityProperties != nil {
		return req, req.MarshalAsJSON(tableMergeEntityOptions.TableEntityProperties)
	}
	return req, nil
}

// mergeEntityHandleResponse handles the MergeEntity response.
func (client *tableClient) mergeEntityHandleResponse(resp *azcore.Response) (TableMergeEntityResponse, error) {
	result := TableMergeEntityResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableMergeEntityResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return result, nil
}

// mergeEntityHandleError handles the MergeEntity error response.
func (client *tableClient) mergeEntityHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// Query - Queries tables under the given account.
// If the operation fails it returns a generic error.
func (client *tableClient) Query(ctx context.Context, tableQueryOptions *TableQueryOptions, queryOptions *QueryOptions) (TableQueryResponseResponse, error) {
	req, err := client.queryCreateRequest(ctx, tableQueryOptions, queryOptions)
	if err != nil {
		return TableQueryResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableQueryResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TableQueryResponseResponse{}, client.queryHandleError(resp)
	}
	return client.queryHandleResponse(resp)
}

// queryCreateRequest creates the Query request.
func (client *tableClient) queryCreateRequest(ctx context.Context, tableQueryOptions *TableQueryOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/Tables"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	if queryOptions != nil && queryOptions.Select != nil {
		reqQP.Set("$select", *queryOptions.Select)
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	if tableQueryOptions != nil && tableQueryOptions.NextTableName != nil {
		reqQP.Set("NextTableName", *tableQueryOptions.NextTableName)
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableQueryOptions != nil && tableQueryOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableQueryOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	req.Header.Set("Accept", "application/json;odata=minimalmetadata")
	return req, nil
}

// queryHandleResponse handles the Query response.
func (client *tableClient) queryHandleResponse(resp *azcore.Response) (TableQueryResponseResponse, error) {
	var val *TableQueryResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TableQueryResponseResponse{}, err
	}
	result := TableQueryResponseResponse{RawResponse: resp.Response, TableQueryResponse: val}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableQueryResponseResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-continuation-NextTableName"); val != "" {
		result.XMSContinuationNextTableName = &val
	}
	return result, nil
}

// queryHandleError handles the Query error response.
func (client *tableClient) queryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	if len(body) == 0 {
		return azcore.NewResponseError(errors.New(resp.Status), resp.Response)
	}
	return azcore.NewResponseError(errors.New(string(body)), resp.Response)
}

// QueryEntities - Queries entities in a table.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) QueryEntities(ctx context.Context, table string, tableQueryEntitiesOptions *TableQueryEntitiesOptions, queryOptions *QueryOptions) (TableEntityQueryResponseResponse, error) {
	req, err := client.queryEntitiesCreateRequest(ctx, table, tableQueryEntitiesOptions, queryOptions)
	if err != nil {
		return TableEntityQueryResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableEntityQueryResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return TableEntityQueryResponseResponse{}, client.queryEntitiesHandleError(resp)
	}
	return client.queryEntitiesHandleResponse(resp)
}

// queryEntitiesCreateRequest creates the QueryEntities request.
func (client *tableClient) queryEntitiesCreateRequest(ctx context.Context, table string, tableQueryEntitiesOptions *TableQueryEntitiesOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/{table}()"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if tableQueryEntitiesOptions != nil && tableQueryEntitiesOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*tableQueryEntitiesOptions.Timeout), 10))
	}
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	if queryOptions != nil && queryOptions.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*queryOptions.Top), 10))
	}
	if queryOptions != nil && queryOptions.Select != nil {
		reqQP.Set("$select", *queryOptions.Select)
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	if tableQueryEntitiesOptions != nil && tableQueryEntitiesOptions.NextPartitionKey != nil {
		reqQP.Set("NextPartitionKey", *tableQueryEntitiesOptions.NextPartitionKey)
	}
	if tableQueryEntitiesOptions != nil && tableQueryEntitiesOptions.NextRowKey != nil {
		reqQP.Set("NextRowKey", *tableQueryEntitiesOptions.NextRowKey)
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableQueryEntitiesOptions != nil && tableQueryEntitiesOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableQueryEntitiesOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	req.Header.Set("Accept", "application/json;odata=minimalmetadata")
	return req, nil
}

// queryEntitiesHandleResponse handles the QueryEntities response.
func (client *tableClient) queryEntitiesHandleResponse(resp *azcore.Response) (TableEntityQueryResponseResponse, error) {
	var val *TableEntityQueryResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return TableEntityQueryResponseResponse{}, err
	}
	result := TableEntityQueryResponseResponse{RawResponse: resp.Response, TableEntityQueryResponse: val}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableEntityQueryResponseResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("x-ms-continuation-NextPartitionKey"); val != "" {
		result.XMSContinuationNextPartitionKey = &val
	}
	if val := resp.Header.Get("x-ms-continuation-NextRowKey"); val != "" {
		result.XMSContinuationNextRowKey = &val
	}
	return result, nil
}

// queryEntitiesHandleError handles the QueryEntities error response.
func (client *tableClient) queryEntitiesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// QueryEntityWithPartitionAndRowKey - Queries a single entity in a table.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) QueryEntityWithPartitionAndRowKey(ctx context.Context, table string, partitionKey string, rowKey string, tableQueryEntityWithPartitionAndRowKeyOptions *TableQueryEntityWithPartitionAndRowKeyOptions, queryOptions *QueryOptions) (MapOfInterfaceResponse, error) {
	req, err := client.queryEntityWithPartitionAndRowKeyCreateRequest(ctx, table, partitionKey, rowKey, tableQueryEntityWithPartitionAndRowKeyOptions, queryOptions)
	if err != nil {
		return MapOfInterfaceResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MapOfInterfaceResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MapOfInterfaceResponse{}, client.queryEntityWithPartitionAndRowKeyHandleError(resp)
	}
	return client.queryEntityWithPartitionAndRowKeyHandleResponse(resp)
}

// queryEntityWithPartitionAndRowKeyCreateRequest creates the QueryEntityWithPartitionAndRowKey request.
func (client *tableClient) queryEntityWithPartitionAndRowKeyCreateRequest(ctx context.Context, table string, partitionKey string, rowKey string, tableQueryEntityWithPartitionAndRowKeyOptions *TableQueryEntityWithPartitionAndRowKeyOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	if partitionKey == "" {
		return nil, errors.New("parameter partitionKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{partitionKey}", url.PathEscape(partitionKey))
	if rowKey == "" {
		return nil, errors.New("parameter rowKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{rowKey}", url.PathEscape(rowKey))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if tableQueryEntityWithPartitionAndRowKeyOptions != nil && tableQueryEntityWithPartitionAndRowKeyOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*tableQueryEntityWithPartitionAndRowKeyOptions.Timeout), 10))
	}
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	if queryOptions != nil && queryOptions.Select != nil {
		reqQP.Set("$select", *queryOptions.Select)
	}
	if queryOptions != nil && queryOptions.Filter != nil {
		reqQP.Set("$filter", *queryOptions.Filter)
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableQueryEntityWithPartitionAndRowKeyOptions != nil && tableQueryEntityWithPartitionAndRowKeyOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableQueryEntityWithPartitionAndRowKeyOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	req.Header.Set("Accept", "application/json;odata=minimalmetadata")
	return req, nil
}

// queryEntityWithPartitionAndRowKeyHandleResponse handles the QueryEntityWithPartitionAndRowKey response.
func (client *tableClient) queryEntityWithPartitionAndRowKeyHandleResponse(resp *azcore.Response) (MapOfInterfaceResponse, error) {
	var val map[string]interface{}
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MapOfInterfaceResponse{}, err
	}
	result := MapOfInterfaceResponse{RawResponse: resp.Response, Value: val}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return MapOfInterfaceResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("x-ms-continuation-NextPartitionKey"); val != "" {
		result.XMSContinuationNextPartitionKey = &val
	}
	if val := resp.Header.Get("x-ms-continuation-NextRowKey"); val != "" {
		result.XMSContinuationNextRowKey = &val
	}
	if val := resp.Header.Get("Preference-Applied"); val != "" {
		result.PreferenceApplied = &val
	}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// queryEntityWithPartitionAndRowKeyHandleError handles the QueryEntityWithPartitionAndRowKey error response.
func (client *tableClient) queryEntityWithPartitionAndRowKeyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// SetAccessPolicy - Sets stored access policies for the table that may be used with Shared Access Signatures.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) SetAccessPolicy(ctx context.Context, table string, options *TableSetAccessPolicyOptions) (TableSetAccessPolicyResponse, error) {
	req, err := client.setAccessPolicyCreateRequest(ctx, table, options)
	if err != nil {
		return TableSetAccessPolicyResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableSetAccessPolicyResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return TableSetAccessPolicyResponse{}, client.setAccessPolicyHandleError(resp)
	}
	return client.setAccessPolicyHandleResponse(resp)
}

// setAccessPolicyCreateRequest creates the SetAccessPolicy request.
func (client *tableClient) setAccessPolicyCreateRequest(ctx context.Context, table string, options *TableSetAccessPolicyOptions) (*azcore.Request, error) {
	urlPath := "/{table}"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if options != nil && options.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*options.Timeout), 10))
	}
	reqQP.Set("comp", "acl")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if options != nil && options.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *options.RequestID)
	}
	req.Header.Set("Accept", "application/xml")
	type wrapper struct {
		XMLName  xml.Name             `xml:"SignedIdentifiers"`
		TableACL *[]*SignedIdentifier `xml:"SignedIdentifier"`
	}
	if options != nil && options.TableACL != nil {
		return req, req.MarshalAsXML(wrapper{TableACL: &options.TableACL})
	}
	return req, nil
}

// setAccessPolicyHandleResponse handles the SetAccessPolicy response.
func (client *tableClient) setAccessPolicyHandleResponse(resp *azcore.Response) (TableSetAccessPolicyResponse, error) {
	result := TableSetAccessPolicyResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableSetAccessPolicyResponse{}, err
		}
		result.Date = &date
	}
	return result, nil
}

// setAccessPolicyHandleError handles the SetAccessPolicy error response.
func (client *tableClient) setAccessPolicyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateEntity - Update entity in a table.
// If the operation fails it returns the *TableServiceError error type.
func (client *tableClient) UpdateEntity(ctx context.Context, table string, partitionKey string, rowKey string, tableUpdateEntityOptions *TableUpdateEntityOptions, queryOptions *QueryOptions) (TableUpdateEntityResponse, error) {
	req, err := client.updateEntityCreateRequest(ctx, table, partitionKey, rowKey, tableUpdateEntityOptions, queryOptions)
	if err != nil {
		return TableUpdateEntityResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return TableUpdateEntityResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return TableUpdateEntityResponse{}, client.updateEntityHandleError(resp)
	}
	return client.updateEntityHandleResponse(resp)
}

// updateEntityCreateRequest creates the UpdateEntity request.
func (client *tableClient) updateEntityCreateRequest(ctx context.Context, table string, partitionKey string, rowKey string, tableUpdateEntityOptions *TableUpdateEntityOptions, queryOptions *QueryOptions) (*azcore.Request, error) {
	urlPath := "/{table}(PartitionKey='{partitionKey}',RowKey='{rowKey}')"
	if table == "" {
		return nil, errors.New("parameter table cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{table}", url.PathEscape(table))
	if partitionKey == "" {
		return nil, errors.New("parameter partitionKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{partitionKey}", url.PathEscape(partitionKey))
	if rowKey == "" {
		return nil, errors.New("parameter rowKey cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{rowKey}", url.PathEscape(rowKey))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	if tableUpdateEntityOptions != nil && tableUpdateEntityOptions.Timeout != nil {
		reqQP.Set("timeout", strconv.FormatInt(int64(*tableUpdateEntityOptions.Timeout), 10))
	}
	if queryOptions != nil && queryOptions.Format != nil {
		reqQP.Set("$format", string(*queryOptions.Format))
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("x-ms-version", "2019-02-02")
	if tableUpdateEntityOptions != nil && tableUpdateEntityOptions.RequestID != nil {
		req.Header.Set("x-ms-client-request-id", *tableUpdateEntityOptions.RequestID)
	}
	req.Header.Set("DataServiceVersion", "3.0")
	if tableUpdateEntityOptions != nil && tableUpdateEntityOptions.IfMatch != nil {
		req.Header.Set("If-Match", *tableUpdateEntityOptions.IfMatch)
	}
	req.Header.Set("Accept", "application/json")
	if tableUpdateEntityOptions != nil && tableUpdateEntityOptions.TableEntityProperties != nil {
		return req, req.MarshalAsJSON(tableUpdateEntityOptions.TableEntityProperties)
	}
	return req, nil
}

// updateEntityHandleResponse handles the UpdateEntity response.
func (client *tableClient) updateEntityHandleResponse(resp *azcore.Response) (TableUpdateEntityResponse, error) {
	result := TableUpdateEntityResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("x-ms-client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("x-ms-request-id"); val != "" {
		result.RequestID = &val
	}
	if val := resp.Header.Get("x-ms-version"); val != "" {
		result.Version = &val
	}
	if val := resp.Header.Get("Date"); val != "" {
		date, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return TableUpdateEntityResponse{}, err
		}
		result.Date = &date
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	return result, nil
}

// updateEntityHandleError handles the UpdateEntity error response.
func (client *tableClient) updateEntityHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := TableServiceError{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
