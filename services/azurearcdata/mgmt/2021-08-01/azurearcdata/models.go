package azurearcdata

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/azurearcdata/mgmt/2021-08-01/azurearcdata"

// BasicLoginInformation username and password for basic login authentication.
type BasicLoginInformation struct {
	// Username - Login username.
	Username *string `json:"username,omitempty"`
	// Password - Login password.
	Password *string `json:"password,omitempty"`
}

// CommonSku the resource model definition representing SKU for ARM resources
type CommonSku struct {
	// Name - The name of the SKU.  It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Dev - Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose.
	Dev *bool `json:"dev,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// DataControllerProperties the data controller properties.
type DataControllerProperties struct {
	// Infrastructure - The infrastructure the data controller is running on. Possible values include: 'Azure', 'Gcp', 'Aws', 'Alibaba', 'Onpremises', 'Other'
	Infrastructure    Infrastructure     `json:"infrastructure,omitempty"`
	OnPremiseProperty *OnPremiseProperty `json:"onPremiseProperty,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw          interface{}      `json:"k8sRaw,omitempty"`
	UploadWatermark *UploadWatermark `json:"uploadWatermark,omitempty"`
	// LastUploadedDate - Last uploaded date from Kubernetes cluster. Defaults to current date time
	LastUploadedDate            *date.Time                   `json:"lastUploadedDate,omitempty"`
	BasicLoginInformation       *BasicLoginInformation       `json:"basicLoginInformation,omitempty"`
	LogAnalyticsWorkspaceConfig *LogAnalyticsWorkspaceConfig `json:"logAnalyticsWorkspaceConfig,omitempty"`
	UploadServicePrincipal      *UploadServicePrincipal      `json:"uploadServicePrincipal,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// ClusterID - If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
	ClusterID *string `json:"clusterId,omitempty"`
	// ExtensionID - If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
	ExtensionID *string `json:"extensionId,omitempty"`
}

// MarshalJSON is the custom marshaler for DataControllerProperties.
func (dcp DataControllerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcp.Infrastructure != "" {
		objectMap["infrastructure"] = dcp.Infrastructure
	}
	if dcp.OnPremiseProperty != nil {
		objectMap["onPremiseProperty"] = dcp.OnPremiseProperty
	}
	if dcp.K8sRaw != nil {
		objectMap["k8sRaw"] = dcp.K8sRaw
	}
	if dcp.UploadWatermark != nil {
		objectMap["uploadWatermark"] = dcp.UploadWatermark
	}
	if dcp.LastUploadedDate != nil {
		objectMap["lastUploadedDate"] = dcp.LastUploadedDate
	}
	if dcp.BasicLoginInformation != nil {
		objectMap["basicLoginInformation"] = dcp.BasicLoginInformation
	}
	if dcp.LogAnalyticsWorkspaceConfig != nil {
		objectMap["logAnalyticsWorkspaceConfig"] = dcp.LogAnalyticsWorkspaceConfig
	}
	if dcp.UploadServicePrincipal != nil {
		objectMap["uploadServicePrincipal"] = dcp.UploadServicePrincipal
	}
	if dcp.ClusterID != nil {
		objectMap["clusterId"] = dcp.ClusterID
	}
	if dcp.ExtensionID != nil {
		objectMap["extensionId"] = dcp.ExtensionID
	}
	return json.Marshal(objectMap)
}

// DataControllerResource data controller resource
type DataControllerResource struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Properties - The data controller's properties
	Properties *DataControllerProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataControllerResource.
func (dcr DataControllerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcr.ExtendedLocation != nil {
		objectMap["extendedLocation"] = dcr.ExtendedLocation
	}
	if dcr.Properties != nil {
		objectMap["properties"] = dcr.Properties
	}
	if dcr.Tags != nil {
		objectMap["tags"] = dcr.Tags
	}
	if dcr.Location != nil {
		objectMap["location"] = dcr.Location
	}
	return json.Marshal(objectMap)
}

// DataControllersPutDataControllerFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DataControllersPutDataControllerFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DataControllersClient) (DataControllerResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DataControllersPutDataControllerFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DataControllersPutDataControllerFuture.Result.
func (future *DataControllersPutDataControllerFuture) result(client DataControllersClient) (dcr DataControllerResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.DataControllersPutDataControllerFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		dcr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.DataControllersPutDataControllerFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if dcr.Response.Response, err = future.GetResult(sender); err == nil && dcr.Response.Response.StatusCode != http.StatusNoContent {
		dcr, err = client.PutDataControllerResponder(dcr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.DataControllersPutDataControllerFuture", "Result", dcr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DataControllerUpdate used for updating a data controller resource.
type DataControllerUpdate struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for DataControllerUpdate.
func (dcu DataControllerUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcu.Tags != nil {
		objectMap["tags"] = dcu.Tags
	}
	return json.Marshal(objectMap)
}

// ErrorResponse an error response from the Azure Data on Azure Arc service.
type ErrorResponse struct {
	// Error - null
	Error *ErrorResponseBody `json:"error,omitempty"`
}

// ErrorResponseBody an error response from the Batch service.
type ErrorResponseBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]ErrorResponseBody `json:"details,omitempty"`
}

// ExtendedLocation the complex type of the extended location.
type ExtendedLocation struct {
	// Name - The name of the extended location.
	Name *string `json:"name,omitempty"`
	// Type - The type of the extended location. Possible values include: 'CustomLocation'
	Type ExtendedLocationTypes `json:"type,omitempty"`
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// K8sResourceRequirements the kubernetes resource limits and requests used to restrict or reserve resource
// usage.
type K8sResourceRequirements struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Requests - Requests for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
	Requests map[string]*string `json:"requests"`
	// Limits - Limits for a kubernetes resource type (e.g 'cpu', 'memory'). The 'cpu' request must be less than or equal to 'cpu' limit. Default 'cpu' is 2, minimum is 1. Default 'memory' is '4Gi', minimum is '2Gi. If sku.tier is GeneralPurpose, maximum 'cpu' is 24 and maximum 'memory' is '128Gi'.
	Limits map[string]*string `json:"limits"`
}

// MarshalJSON is the custom marshaler for K8sResourceRequirements.
func (krr K8sResourceRequirements) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if krr.Requests != nil {
		objectMap["requests"] = krr.Requests
	}
	if krr.Limits != nil {
		objectMap["limits"] = krr.Limits
	}
	for k, v := range krr.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for K8sResourceRequirements struct.
func (krr *K8sResourceRequirements) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if krr.AdditionalProperties == nil {
					krr.AdditionalProperties = make(map[string]interface{})
				}
				krr.AdditionalProperties[k] = additionalProperties
			}
		case "requests":
			if v != nil {
				var requests map[string]*string
				err = json.Unmarshal(*v, &requests)
				if err != nil {
					return err
				}
				krr.Requests = requests
			}
		case "limits":
			if v != nil {
				var limits map[string]*string
				err = json.Unmarshal(*v, &limits)
				if err != nil {
					return err
				}
				krr.Limits = limits
			}
		}
	}

	return nil
}

// K8sScheduling the kubernetes scheduling information.
type K8sScheduling struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	Default              *K8sSchedulingOptions  `json:"default,omitempty"`
}

// MarshalJSON is the custom marshaler for K8sScheduling.
func (ks K8sScheduling) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ks.Default != nil {
		objectMap["default"] = ks.Default
	}
	for k, v := range ks.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for K8sScheduling struct.
func (ks *K8sScheduling) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ks.AdditionalProperties == nil {
					ks.AdditionalProperties = make(map[string]interface{})
				}
				ks.AdditionalProperties[k] = additionalProperties
			}
		case "default":
			if v != nil {
				var defaultVar K8sSchedulingOptions
				err = json.Unmarshal(*v, &defaultVar)
				if err != nil {
					return err
				}
				ks.Default = &defaultVar
			}
		}
	}

	return nil
}

// K8sSchedulingOptions the kubernetes scheduling options. It describes restrictions used to help
// Kubernetes select appropriate nodes to host the database service
type K8sSchedulingOptions struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{}   `json:""`
	Resources            *K8sResourceRequirements `json:"resources,omitempty"`
}

// MarshalJSON is the custom marshaler for K8sSchedulingOptions.
func (kso K8sSchedulingOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kso.Resources != nil {
		objectMap["resources"] = kso.Resources
	}
	for k, v := range kso.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for K8sSchedulingOptions struct.
func (kso *K8sSchedulingOptions) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if kso.AdditionalProperties == nil {
					kso.AdditionalProperties = make(map[string]interface{})
				}
				kso.AdditionalProperties[k] = additionalProperties
			}
		case "resources":
			if v != nil {
				var resources K8sResourceRequirements
				err = json.Unmarshal(*v, &resources)
				if err != nil {
					return err
				}
				kso.Resources = &resources
			}
		}
	}

	return nil
}

// LogAnalyticsWorkspaceConfig log analytics workspace id and primary key
type LogAnalyticsWorkspaceConfig struct {
	// WorkspaceID - Azure Log Analytics workspace ID
	WorkspaceID *uuid.UUID `json:"workspaceId,omitempty"`
	// PrimaryKey - Primary key of the workspace
	PrimaryKey *string `json:"primaryKey,omitempty"`
}

// ODataError information about an error.
type ODataError struct {
	// Code - A language-independent error name.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Target - The target of the error (for example, the name of the property in error).
	Target *string `json:"target,omitempty"`
	// Details - The error details.
	Details *[]ODataError `json:"details,omitempty"`
}

// OnPremiseProperty properties from the Kubernetes data controller
type OnPremiseProperty struct {
	// ID - A globally unique ID identifying the associated Kubernetes cluster
	ID *uuid.UUID `json:"id,omitempty"`
	// PublicSigningKey - Certificate that contains the Kubernetes cluster public key used to verify signing
	PublicSigningKey *string `json:"publicSigningKey,omitempty"`
	// SigningCertificateThumbprint - Unique thumbprint returned to customer to verify the certificate being uploaded
	SigningCertificateThumbprint *string `json:"signingCertificateThumbprint,omitempty"`
}

// Operation azure Data Services on Azure Arc operation definition.
type Operation struct {
	// Name - The name of the operation being performed on this particular object.
	Name *string `json:"name,omitempty"`
	// Display - The localized display information for this particular operation / action.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation. Possible values include: 'OperationOriginUser', 'OperationOriginSystem'
	Origin OperationOrigin `json:"origin,omitempty"`
	// IsDataAction - Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Properties - READ-ONLY; Additional descriptions for the operation.
	Properties map[string]interface{} `json:"properties"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Name != nil {
		objectMap["name"] = o.Name
	}
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	if o.IsDataAction != nil {
		objectMap["isDataAction"] = o.IsDataAction
	}
	return json.Marshal(objectMap)
}

// OperationDisplay display metadata associated with the operation.
type OperationDisplay struct {
	// Provider - The localized friendly form of the resource provider name.
	Provider *string `json:"provider,omitempty"`
	// Resource - The localized friendly form of the resource type related to this action/operation.
	Resource *string `json:"resource,omitempty"`
	// Operation - The localized friendly name for the operation.
	Operation *string `json:"operation,omitempty"`
	// Description - The localized friendly description for the operation.
	Description *string `json:"description,omitempty"`
}

// OperationListResult result of the request to list Azure Data Services on Azure Arc operations.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// PageOfDataControllerResource ...
type PageOfDataControllerResource struct {
	autorest.Response `json:"-"`
	Value             *[]DataControllerResource `json:"value,omitempty"`
	// NextLink - Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PageOfDataControllerResourceIterator provides access to a complete listing of DataControllerResource
// values.
type PageOfDataControllerResourceIterator struct {
	i    int
	page PageOfDataControllerResourcePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PageOfDataControllerResourceIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PageOfDataControllerResourceIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PageOfDataControllerResourceIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PageOfDataControllerResourceIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PageOfDataControllerResourceIterator) Response() PageOfDataControllerResource {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PageOfDataControllerResourceIterator) Value() DataControllerResource {
	if !iter.page.NotDone() {
		return DataControllerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PageOfDataControllerResourceIterator type.
func NewPageOfDataControllerResourceIterator(page PageOfDataControllerResourcePage) PageOfDataControllerResourceIterator {
	return PageOfDataControllerResourceIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (podcr PageOfDataControllerResource) IsEmpty() bool {
	return podcr.Value == nil || len(*podcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (podcr PageOfDataControllerResource) hasNextLink() bool {
	return podcr.NextLink != nil && len(*podcr.NextLink) != 0
}

// pageOfDataControllerResourcePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (podcr PageOfDataControllerResource) pageOfDataControllerResourcePreparer(ctx context.Context) (*http.Request, error) {
	if !podcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(podcr.NextLink)))
}

// PageOfDataControllerResourcePage contains a page of DataControllerResource values.
type PageOfDataControllerResourcePage struct {
	fn    func(context.Context, PageOfDataControllerResource) (PageOfDataControllerResource, error)
	podcr PageOfDataControllerResource
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PageOfDataControllerResourcePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PageOfDataControllerResourcePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.podcr)
		if err != nil {
			return err
		}
		page.podcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PageOfDataControllerResourcePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PageOfDataControllerResourcePage) NotDone() bool {
	return !page.podcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PageOfDataControllerResourcePage) Response() PageOfDataControllerResource {
	return page.podcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PageOfDataControllerResourcePage) Values() []DataControllerResource {
	if page.podcr.IsEmpty() {
		return nil
	}
	return *page.podcr.Value
}

// Creates a new instance of the PageOfDataControllerResourcePage type.
func NewPageOfDataControllerResourcePage(cur PageOfDataControllerResource, getNextPage func(context.Context, PageOfDataControllerResource) (PageOfDataControllerResource, error)) PageOfDataControllerResourcePage {
	return PageOfDataControllerResourcePage{
		fn:    getNextPage,
		podcr: cur,
	}
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
// required location and tags
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource ...
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceSku ...
type ResourceSku struct {
	Capacity *int32  `json:"capacity,omitempty"`
	Family   *string `json:"family,omitempty"`
	Name     *string `json:"name,omitempty"`
	Size     *string `json:"size,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

// SQLManagedInstance a SqlManagedInstance.
type SQLManagedInstance struct {
	autorest.Response `json:"-"`
	// Properties - null
	Properties *SQLManagedInstanceProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Sku - Resource sku.
	Sku *SQLManagedInstanceSku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstance.
func (smi SQLManagedInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smi.Properties != nil {
		objectMap["properties"] = smi.Properties
	}
	if smi.ExtendedLocation != nil {
		objectMap["extendedLocation"] = smi.ExtendedLocation
	}
	if smi.Sku != nil {
		objectMap["sku"] = smi.Sku
	}
	if smi.Tags != nil {
		objectMap["tags"] = smi.Tags
	}
	if smi.Location != nil {
		objectMap["location"] = smi.Location
	}
	return json.Marshal(objectMap)
}

// SQLManagedInstanceK8sRaw the raw kubernetes information.
type SQLManagedInstanceK8sRaw struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{}     `json:""`
	Spec                 *SQLManagedInstanceK8sSpec `json:"spec,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceK8sRaw.
func (smikr SQLManagedInstanceK8sRaw) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smikr.Spec != nil {
		objectMap["spec"] = smikr.Spec
	}
	for k, v := range smikr.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SQLManagedInstanceK8sRaw struct.
func (smikr *SQLManagedInstanceK8sRaw) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if smikr.AdditionalProperties == nil {
					smikr.AdditionalProperties = make(map[string]interface{})
				}
				smikr.AdditionalProperties[k] = additionalProperties
			}
		case "spec":
			if v != nil {
				var spec SQLManagedInstanceK8sSpec
				err = json.Unmarshal(*v, &spec)
				if err != nil {
					return err
				}
				smikr.Spec = &spec
			}
		}
	}

	return nil
}

// SQLManagedInstanceK8sSpec the kubernetes spec information.
type SQLManagedInstanceK8sSpec struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	Scheduling           *K8sScheduling         `json:"scheduling,omitempty"`
	// Replicas - This option specifies the number of SQL Managed Instance replicas that will be deployed in your Kubernetes cluster for high availability purposes. If sku.tier is BusinessCritical, allowed values are '2' or '3' with default of '3'. If sku.tier is GeneralPurpose, replicas must be '1'.
	Replicas *int32 `json:"replicas,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceK8sSpec.
func (smiks SQLManagedInstanceK8sSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smiks.Scheduling != nil {
		objectMap["scheduling"] = smiks.Scheduling
	}
	if smiks.Replicas != nil {
		objectMap["replicas"] = smiks.Replicas
	}
	for k, v := range smiks.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SQLManagedInstanceK8sSpec struct.
func (smiks *SQLManagedInstanceK8sSpec) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if smiks.AdditionalProperties == nil {
					smiks.AdditionalProperties = make(map[string]interface{})
				}
				smiks.AdditionalProperties[k] = additionalProperties
			}
		case "scheduling":
			if v != nil {
				var scheduling K8sScheduling
				err = json.Unmarshal(*v, &scheduling)
				if err != nil {
					return err
				}
				smiks.Scheduling = &scheduling
			}
		case "replicas":
			if v != nil {
				var replicas int32
				err = json.Unmarshal(*v, &replicas)
				if err != nil {
					return err
				}
				smiks.Replicas = &replicas
			}
		}
	}

	return nil
}

// SQLManagedInstanceListResult a list of SqlManagedInstance.
type SQLManagedInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]SQLManagedInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceListResult.
func (smilr SQLManagedInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SQLManagedInstanceListResultIterator provides access to a complete listing of SQLManagedInstance values.
type SQLManagedInstanceListResultIterator struct {
	i    int
	page SQLManagedInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SQLManagedInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLManagedInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SQLManagedInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SQLManagedInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SQLManagedInstanceListResultIterator) Response() SQLManagedInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SQLManagedInstanceListResultIterator) Value() SQLManagedInstance {
	if !iter.page.NotDone() {
		return SQLManagedInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SQLManagedInstanceListResultIterator type.
func NewSQLManagedInstanceListResultIterator(page SQLManagedInstanceListResultPage) SQLManagedInstanceListResultIterator {
	return SQLManagedInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (smilr SQLManagedInstanceListResult) IsEmpty() bool {
	return smilr.Value == nil || len(*smilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (smilr SQLManagedInstanceListResult) hasNextLink() bool {
	return smilr.NextLink != nil && len(*smilr.NextLink) != 0
}

// sQLManagedInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (smilr SQLManagedInstanceListResult) sQLManagedInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !smilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(smilr.NextLink)))
}

// SQLManagedInstanceListResultPage contains a page of SQLManagedInstance values.
type SQLManagedInstanceListResultPage struct {
	fn    func(context.Context, SQLManagedInstanceListResult) (SQLManagedInstanceListResult, error)
	smilr SQLManagedInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SQLManagedInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLManagedInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.smilr)
		if err != nil {
			return err
		}
		page.smilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SQLManagedInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SQLManagedInstanceListResultPage) NotDone() bool {
	return !page.smilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SQLManagedInstanceListResultPage) Response() SQLManagedInstanceListResult {
	return page.smilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SQLManagedInstanceListResultPage) Values() []SQLManagedInstance {
	if page.smilr.IsEmpty() {
		return nil
	}
	return *page.smilr.Value
}

// Creates a new instance of the SQLManagedInstanceListResultPage type.
func NewSQLManagedInstanceListResultPage(cur SQLManagedInstanceListResult, getNextPage func(context.Context, SQLManagedInstanceListResult) (SQLManagedInstanceListResult, error)) SQLManagedInstanceListResultPage {
	return SQLManagedInstanceListResultPage{
		fn:    getNextPage,
		smilr: cur,
	}
}

// SQLManagedInstanceProperties properties of sqlManagedInstance.
type SQLManagedInstanceProperties struct {
	// DataControllerID - null
	DataControllerID *string `json:"dataControllerId,omitempty"`
	// Admin - The instance admin user
	Admin *string `json:"admin,omitempty"`
	// StartTime - The instance start time
	StartTime *string `json:"startTime,omitempty"`
	// EndTime - The instance end time
	EndTime *string `json:"endTime,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw *SQLManagedInstanceK8sRaw `json:"k8sRaw,omitempty"`
	// BasicLoginInformation - Username and password for basic authentication.
	BasicLoginInformation *BasicLoginInformation `json:"basicLoginInformation,omitempty"`
	// LastUploadedDate - Last uploaded date from Kubernetes cluster. Defaults to current date time
	LastUploadedDate *date.Time `json:"lastUploadedDate,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// LicenseType - The license type to apply for this managed instance. Possible values include: 'BasePrice', 'LicenseIncluded'
	LicenseType ArcSQLManagedInstanceLicenseType `json:"licenseType,omitempty"`
	// ClusterID - If a CustomLocation is provided, this contains the ARM id of the connected cluster the custom location belongs to.
	ClusterID *string `json:"clusterId,omitempty"`
	// ExtensionID - If a CustomLocation is provided, this contains the ARM id of the extension the custom location belongs to.
	ExtensionID *string `json:"extensionId,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceProperties.
func (smip SQLManagedInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smip.DataControllerID != nil {
		objectMap["dataControllerId"] = smip.DataControllerID
	}
	if smip.Admin != nil {
		objectMap["admin"] = smip.Admin
	}
	if smip.StartTime != nil {
		objectMap["startTime"] = smip.StartTime
	}
	if smip.EndTime != nil {
		objectMap["endTime"] = smip.EndTime
	}
	if smip.K8sRaw != nil {
		objectMap["k8sRaw"] = smip.K8sRaw
	}
	if smip.BasicLoginInformation != nil {
		objectMap["basicLoginInformation"] = smip.BasicLoginInformation
	}
	if smip.LastUploadedDate != nil {
		objectMap["lastUploadedDate"] = smip.LastUploadedDate
	}
	if smip.LicenseType != "" {
		objectMap["licenseType"] = smip.LicenseType
	}
	if smip.ClusterID != nil {
		objectMap["clusterId"] = smip.ClusterID
	}
	if smip.ExtensionID != nil {
		objectMap["extensionId"] = smip.ExtensionID
	}
	return json.Marshal(objectMap)
}

// SQLManagedInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SQLManagedInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SQLManagedInstancesClient) (SQLManagedInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SQLManagedInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SQLManagedInstancesCreateFuture.Result.
func (future *SQLManagedInstancesCreateFuture) result(client SQLManagedInstancesClient) (smi SQLManagedInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.SQLManagedInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		smi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.SQLManagedInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if smi.Response.Response, err = future.GetResult(sender); err == nil && smi.Response.Response.StatusCode != http.StatusNoContent {
		smi, err = client.CreateResponder(smi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.SQLManagedInstancesCreateFuture", "Result", smi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SQLManagedInstanceSku the resource model definition representing SKU for Azure Managed Instance - Azure
// Arc
type SQLManagedInstanceSku struct {
	// Name - The name of the SKU.
	Name *string `json:"name,omitempty"`
	// Tier - The pricing tier for the instance. Possible values include: 'GeneralPurpose', 'BusinessCritical'
	Tier SQLManagedInstanceSkuTier `json:"tier,omitempty"`
	// Dev - Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose.
	Dev *bool `json:"dev,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size     *string `json:"size,omitempty"`
	Family   *string `json:"family,omitempty"`
	Capacity *int32  `json:"capacity,omitempty"`
}

// SQLManagedInstanceUpdate an update to a SQL Managed Instance.
type SQLManagedInstanceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceUpdate.
func (smiu SQLManagedInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smiu.Tags != nil {
		objectMap["tags"] = smiu.Tags
	}
	return json.Marshal(objectMap)
}

// SQLServerInstance a SqlServerInstance.
type SQLServerInstance struct {
	autorest.Response `json:"-"`
	// Properties - null
	Properties *SQLServerInstanceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstance.
func (ssi SQLServerInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssi.Properties != nil {
		objectMap["properties"] = ssi.Properties
	}
	if ssi.Tags != nil {
		objectMap["tags"] = ssi.Tags
	}
	if ssi.Location != nil {
		objectMap["location"] = ssi.Location
	}
	return json.Marshal(objectMap)
}

// SQLServerInstanceListResult a list of SqlServerInstance.
type SQLServerInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]SQLServerInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceListResult.
func (ssilr SQLServerInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SQLServerInstanceListResultIterator provides access to a complete listing of SQLServerInstance values.
type SQLServerInstanceListResultIterator struct {
	i    int
	page SQLServerInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SQLServerInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLServerInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SQLServerInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SQLServerInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SQLServerInstanceListResultIterator) Response() SQLServerInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SQLServerInstanceListResultIterator) Value() SQLServerInstance {
	if !iter.page.NotDone() {
		return SQLServerInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SQLServerInstanceListResultIterator type.
func NewSQLServerInstanceListResultIterator(page SQLServerInstanceListResultPage) SQLServerInstanceListResultIterator {
	return SQLServerInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssilr SQLServerInstanceListResult) IsEmpty() bool {
	return ssilr.Value == nil || len(*ssilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssilr SQLServerInstanceListResult) hasNextLink() bool {
	return ssilr.NextLink != nil && len(*ssilr.NextLink) != 0
}

// sQLServerInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssilr SQLServerInstanceListResult) sQLServerInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ssilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssilr.NextLink)))
}

// SQLServerInstanceListResultPage contains a page of SQLServerInstance values.
type SQLServerInstanceListResultPage struct {
	fn    func(context.Context, SQLServerInstanceListResult) (SQLServerInstanceListResult, error)
	ssilr SQLServerInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SQLServerInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLServerInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssilr)
		if err != nil {
			return err
		}
		page.ssilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SQLServerInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SQLServerInstanceListResultPage) NotDone() bool {
	return !page.ssilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SQLServerInstanceListResultPage) Response() SQLServerInstanceListResult {
	return page.ssilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SQLServerInstanceListResultPage) Values() []SQLServerInstance {
	if page.ssilr.IsEmpty() {
		return nil
	}
	return *page.ssilr.Value
}

// Creates a new instance of the SQLServerInstanceListResultPage type.
func NewSQLServerInstanceListResultPage(cur SQLServerInstanceListResult, getNextPage func(context.Context, SQLServerInstanceListResult) (SQLServerInstanceListResult, error)) SQLServerInstanceListResultPage {
	return SQLServerInstanceListResultPage{
		fn:    getNextPage,
		ssilr: cur,
	}
}

// SQLServerInstanceProperties properties of SqlServerInstance.
type SQLServerInstanceProperties struct {
	// Version - SQL Server version. Possible values include: 'SQLServer2019', 'SQLServer2017', 'SQLServer2016'
	Version SQLVersion `json:"version,omitempty"`
	// Edition - SQL Server edition. Possible values include: 'Evaluation', 'Enterprise', 'Standard', 'Web', 'Developer', 'Express'
	Edition EditionType `json:"edition,omitempty"`
	// ContainerResourceID - ARM Resource id of the container resource (Azure Arc for Servers).
	ContainerResourceID *string `json:"containerResourceId,omitempty"`
	// CreateTime - READ-ONLY; The time when the resource was created.
	CreateTime *string `json:"createTime,omitempty"`
	// VCore - The number of logical processors used by the SQL Server instance.
	VCore *string `json:"vCore,omitempty"`
	// Status - The cloud connectivity status. Possible values include: 'Connected', 'Disconnected', 'Unknown'
	Status ConnectionStatus `json:"status,omitempty"`
	// PatchLevel - SQL Server update level.
	PatchLevel *string `json:"patchLevel,omitempty"`
	// Collation - SQL Server collation.
	Collation *string `json:"collation,omitempty"`
	// CurrentVersion - SQL Server current version.
	CurrentVersion *string `json:"currentVersion,omitempty"`
	// InstanceName - SQL Server instance name.
	InstanceName *string `json:"instanceName,omitempty"`
	// TCPDynamicPorts - Dynamic TCP ports used by SQL Server.
	TCPDynamicPorts *string `json:"tcpDynamicPorts,omitempty"`
	// TCPStaticPorts - Static TCP ports used by SQL Server.
	TCPStaticPorts *string `json:"tcpStaticPorts,omitempty"`
	// ProductID - SQL Server product ID.
	ProductID *string `json:"productId,omitempty"`
	// LicenseType - SQL Server license type. Possible values include: 'Paid', 'Free', 'HADR', 'Undefined'
	LicenseType ArcSQLServerLicenseType `json:"licenseType,omitempty"`
	// AzureDefenderStatusLastUpdated - Timestamp of last Azure Defender status update.
	AzureDefenderStatusLastUpdated *date.Time `json:"azureDefenderStatusLastUpdated,omitempty"`
	// AzureDefenderStatus - Status of Azure Defender. Possible values include: 'DefenderStatusProtected', 'DefenderStatusUnprotected', 'DefenderStatusUnknown'
	AzureDefenderStatus DefenderStatus `json:"azureDefenderStatus,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceProperties.
func (ssip SQLServerInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssip.Version != "" {
		objectMap["version"] = ssip.Version
	}
	if ssip.Edition != "" {
		objectMap["edition"] = ssip.Edition
	}
	if ssip.ContainerResourceID != nil {
		objectMap["containerResourceId"] = ssip.ContainerResourceID
	}
	if ssip.VCore != nil {
		objectMap["vCore"] = ssip.VCore
	}
	if ssip.Status != "" {
		objectMap["status"] = ssip.Status
	}
	if ssip.PatchLevel != nil {
		objectMap["patchLevel"] = ssip.PatchLevel
	}
	if ssip.Collation != nil {
		objectMap["collation"] = ssip.Collation
	}
	if ssip.CurrentVersion != nil {
		objectMap["currentVersion"] = ssip.CurrentVersion
	}
	if ssip.InstanceName != nil {
		objectMap["instanceName"] = ssip.InstanceName
	}
	if ssip.TCPDynamicPorts != nil {
		objectMap["tcpDynamicPorts"] = ssip.TCPDynamicPorts
	}
	if ssip.TCPStaticPorts != nil {
		objectMap["tcpStaticPorts"] = ssip.TCPStaticPorts
	}
	if ssip.ProductID != nil {
		objectMap["productId"] = ssip.ProductID
	}
	if ssip.LicenseType != "" {
		objectMap["licenseType"] = ssip.LicenseType
	}
	if ssip.AzureDefenderStatusLastUpdated != nil {
		objectMap["azureDefenderStatusLastUpdated"] = ssip.AzureDefenderStatusLastUpdated
	}
	if ssip.AzureDefenderStatus != "" {
		objectMap["azureDefenderStatus"] = ssip.AzureDefenderStatus
	}
	return json.Marshal(objectMap)
}

// SQLServerInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SQLServerInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SQLServerInstancesClient) (SQLServerInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SQLServerInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SQLServerInstancesCreateFuture.Result.
func (future *SQLServerInstancesCreateFuture) result(client SQLServerInstancesClient) (ssi SQLServerInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.SQLServerInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.SQLServerInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssi.Response.Response, err = future.GetResult(sender); err == nil && ssi.Response.Response.StatusCode != http.StatusNoContent {
		ssi, err = client.CreateResponder(ssi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.SQLServerInstancesCreateFuture", "Result", ssi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SQLServerInstanceUpdate an update to a SQL Server Instance.
type SQLServerInstanceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceUpdate.
func (ssiu SQLServerInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssiu.Tags != nil {
		objectMap["tags"] = ssiu.Tags
	}
	return json.Marshal(objectMap)
}

// SystemData read only system data
type SystemData struct {
	// CreatedBy - An identifier for the identity that created the resource
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType IdentityType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC)
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - An identifier for the identity that last modified the resource
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType IdentityType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for a ARM tracked top level resource
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// UploadServicePrincipal service principal for uploading billing, metrics and logs.
type UploadServicePrincipal struct {
	// ClientID - Client ID of the service principal for uploading data.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// TenantID - Tenant ID of the service principal.
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// Authority - Authority for the service principal. Example: https://login.microsoftonline.com/
	Authority *string `json:"authority,omitempty"`
	// ClientSecret - Secret of the service principal
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// UploadWatermark properties on upload watermark.  Mostly timestamp for each upload data type
type UploadWatermark struct {
	// Metrics - Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
	Metrics *date.Time `json:"metrics,omitempty"`
	// Logs - Last uploaded date for logs from kubernetes cluster. Defaults to current date time
	Logs *date.Time `json:"logs,omitempty"`
	// Usages - Last uploaded date for usages from kubernetes cluster. Defaults to current date time
	Usages *date.Time `json:"usages,omitempty"`
}
