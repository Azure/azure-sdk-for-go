package speechservices

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/satori/go.uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/cognitiveservices/v2.0/speechservices"

// DataImportKind enumerates the values for data import kind.
type DataImportKind string

const (
	// Acoustic ...
	Acoustic DataImportKind = "Acoustic"
	// CustomVoice ...
	CustomVoice DataImportKind = "CustomVoice"
	// Language ...
	Language DataImportKind = "Language"
	// LanguageGeneration ...
	LanguageGeneration DataImportKind = "LanguageGeneration"
	// None ...
	None DataImportKind = "None"
	// Pronunciation ...
	Pronunciation DataImportKind = "Pronunciation"
)

// PossibleDataImportKindValues returns an array of possible values for the DataImportKind const type.
func PossibleDataImportKindValues() []DataImportKind {
	return []DataImportKind{Acoustic, CustomVoice, Language, LanguageGeneration, None, Pronunciation}
}

// DataImportKind1 enumerates the values for data import kind 1.
type DataImportKind1 string

const (
	// DataImportKind1Acoustic ...
	DataImportKind1Acoustic DataImportKind1 = "Acoustic"
	// DataImportKind1CustomVoice ...
	DataImportKind1CustomVoice DataImportKind1 = "CustomVoice"
	// DataImportKind1Language ...
	DataImportKind1Language DataImportKind1 = "Language"
	// DataImportKind1LanguageGeneration ...
	DataImportKind1LanguageGeneration DataImportKind1 = "LanguageGeneration"
	// DataImportKind1None ...
	DataImportKind1None DataImportKind1 = "None"
	// DataImportKind1Pronunciation ...
	DataImportKind1Pronunciation DataImportKind1 = "Pronunciation"
)

// PossibleDataImportKind1Values returns an array of possible values for the DataImportKind1 const type.
func PossibleDataImportKind1Values() []DataImportKind1 {
	return []DataImportKind1{DataImportKind1Acoustic, DataImportKind1CustomVoice, DataImportKind1Language, DataImportKind1LanguageGeneration, DataImportKind1None, DataImportKind1Pronunciation}
}

// EndpointKind enumerates the values for endpoint kind.
type EndpointKind string

const (
	// EndpointKindCustomVoice ...
	EndpointKindCustomVoice EndpointKind = "CustomVoice"
	// EndpointKindLanguageGeneration ...
	EndpointKindLanguageGeneration EndpointKind = "LanguageGeneration"
	// EndpointKindLanguageIdentification ...
	EndpointKindLanguageIdentification EndpointKind = "LanguageIdentification"
	// EndpointKindNone ...
	EndpointKindNone EndpointKind = "None"
	// EndpointKindSpeechRecognition ...
	EndpointKindSpeechRecognition EndpointKind = "SpeechRecognition"
)

// PossibleEndpointKindValues returns an array of possible values for the EndpointKind const type.
func PossibleEndpointKindValues() []EndpointKind {
	return []EndpointKind{EndpointKindCustomVoice, EndpointKindLanguageGeneration, EndpointKindLanguageIdentification, EndpointKindNone, EndpointKindSpeechRecognition}
}

// ModelKind enumerates the values for model kind.
type ModelKind string

const (
	// ModelKindAcoustic ...
	ModelKindAcoustic ModelKind = "Acoustic"
	// ModelKindAcousticAndLanguage ...
	ModelKindAcousticAndLanguage ModelKind = "AcousticAndLanguage"
	// ModelKindCustomVoice ...
	ModelKindCustomVoice ModelKind = "CustomVoice"
	// ModelKindLanguage ...
	ModelKindLanguage ModelKind = "Language"
	// ModelKindLanguageGeneration ...
	ModelKindLanguageGeneration ModelKind = "LanguageGeneration"
	// ModelKindLanguageIdentification ...
	ModelKindLanguageIdentification ModelKind = "LanguageIdentification"
	// ModelKindNone ...
	ModelKindNone ModelKind = "None"
	// ModelKindSentiment ...
	ModelKindSentiment ModelKind = "Sentiment"
)

// PossibleModelKindValues returns an array of possible values for the ModelKind const type.
func PossibleModelKindValues() []ModelKind {
	return []ModelKind{ModelKindAcoustic, ModelKindAcousticAndLanguage, ModelKindCustomVoice, ModelKindLanguage, ModelKindLanguageGeneration, ModelKindLanguageIdentification, ModelKindNone, ModelKindSentiment}
}

// ModelKind1 enumerates the values for model kind 1.
type ModelKind1 string

const (
	// ModelKind1Acoustic ...
	ModelKind1Acoustic ModelKind1 = "Acoustic"
	// ModelKind1AcousticAndLanguage ...
	ModelKind1AcousticAndLanguage ModelKind1 = "AcousticAndLanguage"
	// ModelKind1CustomVoice ...
	ModelKind1CustomVoice ModelKind1 = "CustomVoice"
	// ModelKind1Language ...
	ModelKind1Language ModelKind1 = "Language"
	// ModelKind1LanguageGeneration ...
	ModelKind1LanguageGeneration ModelKind1 = "LanguageGeneration"
	// ModelKind1LanguageIdentification ...
	ModelKind1LanguageIdentification ModelKind1 = "LanguageIdentification"
	// ModelKind1None ...
	ModelKind1None ModelKind1 = "None"
	// ModelKind1Sentiment ...
	ModelKind1Sentiment ModelKind1 = "Sentiment"
)

// PossibleModelKind1Values returns an array of possible values for the ModelKind1 const type.
func PossibleModelKind1Values() []ModelKind1 {
	return []ModelKind1{ModelKind1Acoustic, ModelKind1AcousticAndLanguage, ModelKind1CustomVoice, ModelKind1Language, ModelKind1LanguageGeneration, ModelKind1LanguageIdentification, ModelKind1None, ModelKind1Sentiment}
}

// ModelKind2 enumerates the values for model kind 2.
type ModelKind2 string

const (
	// ModelKind2Acoustic ...
	ModelKind2Acoustic ModelKind2 = "Acoustic"
	// ModelKind2AcousticAndLanguage ...
	ModelKind2AcousticAndLanguage ModelKind2 = "AcousticAndLanguage"
	// ModelKind2CustomVoice ...
	ModelKind2CustomVoice ModelKind2 = "CustomVoice"
	// ModelKind2Language ...
	ModelKind2Language ModelKind2 = "Language"
	// ModelKind2LanguageGeneration ...
	ModelKind2LanguageGeneration ModelKind2 = "LanguageGeneration"
	// ModelKind2LanguageIdentification ...
	ModelKind2LanguageIdentification ModelKind2 = "LanguageIdentification"
	// ModelKind2None ...
	ModelKind2None ModelKind2 = "None"
	// ModelKind2Sentiment ...
	ModelKind2Sentiment ModelKind2 = "Sentiment"
)

// PossibleModelKind2Values returns an array of possible values for the ModelKind2 const type.
func PossibleModelKind2Values() []ModelKind2 {
	return []ModelKind2{ModelKind2Acoustic, ModelKind2AcousticAndLanguage, ModelKind2CustomVoice, ModelKind2Language, ModelKind2LanguageGeneration, ModelKind2LanguageIdentification, ModelKind2None, ModelKind2Sentiment}
}

// Status enumerates the values for status.
type Status string

const (
	// Failed ...
	Failed Status = "Failed"
	// NotStarted ...
	NotStarted Status = "NotStarted"
	// Running ...
	Running Status = "Running"
	// Succeeded ...
	Succeeded Status = "Succeeded"
)

// PossibleStatusValues returns an array of possible values for the Status const type.
func PossibleStatusValues() []Status {
	return []Status{Failed, NotStarted, Running, Succeeded}
}

// Status1 enumerates the values for status 1.
type Status1 string

const (
	// Status1Failed ...
	Status1Failed Status1 = "Failed"
	// Status1NotStarted ...
	Status1NotStarted Status1 = "NotStarted"
	// Status1Running ...
	Status1Running Status1 = "Running"
	// Status1Succeeded ...
	Status1Succeeded Status1 = "Succeeded"
)

// PossibleStatus1Values returns an array of possible values for the Status1 const type.
func PossibleStatus1Values() []Status1 {
	return []Status1{Status1Failed, Status1NotStarted, Status1Running, Status1Succeeded}
}

// Status2 enumerates the values for status 2.
type Status2 string

const (
	// Status2Failed ...
	Status2Failed Status2 = "Failed"
	// Status2NotStarted ...
	Status2NotStarted Status2 = "NotStarted"
	// Status2Running ...
	Status2Running Status2 = "Running"
	// Status2Succeeded ...
	Status2Succeeded Status2 = "Succeeded"
)

// PossibleStatus2Values returns an array of possible values for the Status2 const type.
func PossibleStatus2Values() []Status2 {
	return []Status2{Status2Failed, Status2NotStarted, Status2Running, Status2Succeeded}
}

// Status3 enumerates the values for status 3.
type Status3 string

const (
	// Status3Failed ...
	Status3Failed Status3 = "Failed"
	// Status3NotStarted ...
	Status3NotStarted Status3 = "NotStarted"
	// Status3Running ...
	Status3Running Status3 = "Running"
	// Status3Succeeded ...
	Status3Succeeded Status3 = "Succeeded"
)

// PossibleStatus3Values returns an array of possible values for the Status3 const type.
func PossibleStatus3Values() []Status3 {
	return []Status3{Status3Failed, Status3NotStarted, Status3Running, Status3Succeeded}
}

// Status4 enumerates the values for status 4.
type Status4 string

const (
	// Status4Failed ...
	Status4Failed Status4 = "Failed"
	// Status4NotStarted ...
	Status4NotStarted Status4 = "NotStarted"
	// Status4Running ...
	Status4Running Status4 = "Running"
	// Status4Succeeded ...
	Status4Succeeded Status4 = "Succeeded"
)

// PossibleStatus4Values returns an array of possible values for the Status4 const type.
func PossibleStatus4Values() []Status4 {
	return []Status4{Status4Failed, Status4NotStarted, Status4Running, Status4Succeeded}
}

// Status5 enumerates the values for status 5.
type Status5 string

const (
	// Status5Failed ...
	Status5Failed Status5 = "Failed"
	// Status5NotStarted ...
	Status5NotStarted Status5 = "NotStarted"
	// Status5Running ...
	Status5Running Status5 = "Running"
	// Status5Succeeded ...
	Status5Succeeded Status5 = "Succeeded"
)

// PossibleStatus5Values returns an array of possible values for the Status5 const type.
func PossibleStatus5Values() []Status5 {
	return []Status5{Status5Failed, Status5NotStarted, Status5Running, Status5Succeeded}
}

// Status6 enumerates the values for status 6.
type Status6 string

const (
	// Error ...
	Error Status6 = "Error"
	// Healthy ...
	Healthy Status6 = "Healthy"
	// Sick ...
	Sick Status6 = "Sick"
)

// PossibleStatus6Values returns an array of possible values for the Status6 const type.
func PossibleStatus6Values() []Status6 {
	return []Status6{Error, Healthy, Sick}
}

// Status7 enumerates the values for status 7.
type Status7 string

const (
	// Status7Error ...
	Status7Error Status7 = "Error"
	// Status7Healthy ...
	Status7Healthy Status7 = "Healthy"
	// Status7Sick ...
	Status7Sick Status7 = "Sick"
)

// PossibleStatus7Values returns an array of possible values for the Status7 const type.
func PossibleStatus7Values() []Status7 {
	return []Status7{Status7Error, Status7Healthy, Status7Sick}
}

// Status8 enumerates the values for status 8.
type Status8 string

const (
	// Status8Failed ...
	Status8Failed Status8 = "Failed"
	// Status8NotStarted ...
	Status8NotStarted Status8 = "NotStarted"
	// Status8Running ...
	Status8Running Status8 = "Running"
	// Status8Succeeded ...
	Status8Succeeded Status8 = "Succeeded"
)

// PossibleStatus8Values returns an array of possible values for the Status8 const type.
func PossibleStatus8Values() []Status8 {
	return []Status8{Status8Failed, Status8NotStarted, Status8Running, Status8Succeeded}
}

// VoiceTestKind enumerates the values for voice test kind.
type VoiceTestKind string

const (
	// VoiceTestKindNone ...
	VoiceTestKindNone VoiceTestKind = "None"
	// VoiceTestKindSSML ...
	VoiceTestKindSSML VoiceTestKind = "SSML"
	// VoiceTestKindText ...
	VoiceTestKindText VoiceTestKind = "Text"
)

// PossibleVoiceTestKindValues returns an array of possible values for the VoiceTestKind const type.
func PossibleVoiceTestKindValues() []VoiceTestKind {
	return []VoiceTestKind{VoiceTestKindNone, VoiceTestKindSSML, VoiceTestKindText}
}

// VoiceTestKind1 enumerates the values for voice test kind 1.
type VoiceTestKind1 string

const (
	// VoiceTestKind1None ...
	VoiceTestKind1None VoiceTestKind1 = "None"
	// VoiceTestKind1SSML ...
	VoiceTestKind1SSML VoiceTestKind1 = "SSML"
	// VoiceTestKind1Text ...
	VoiceTestKind1Text VoiceTestKind1 = "Text"
)

// PossibleVoiceTestKind1Values returns an array of possible values for the VoiceTestKind1 const type.
func PossibleVoiceTestKind1Values() []VoiceTestKind1 {
	return []VoiceTestKind1{VoiceTestKind1None, VoiceTestKind1SSML, VoiceTestKind1Text}
}

// AccuracyTestCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccuracyTestCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *AccuracyTestCreateFuture) Result(client AccuracyTestClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.AccuracyTestCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.AccuracyTestCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.AccuracyTestCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Component ...
type Component struct {
	Name *string `json:"name,omitempty"`
	Type *string `json:"type,omitempty"`
	// Status - Possible values include: 'Healthy', 'Sick', 'Error'
	Status  Status6 `json:"status,omitempty"`
	Message *string `json:"message,omitempty"`
}

// Dataset ...
type Dataset struct {
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
	// DataImportKind - The kind of the dataset (e.g. acoustic data, language data ...). Possible values include: 'Acoustic', 'Language', 'Pronunciation', 'None', 'CustomVoice', 'LanguageGeneration'
	DataImportKind DataImportKind `json:"dataImportKind,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Succeeded', 'Failed', 'NotStarted', 'Running'
	Status Status `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for Dataset.
func (d Dataset) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ID != nil {
		objectMap["id"] = d.ID
	}
	if d.DataImportKind != "" {
		objectMap["dataImportKind"] = d.DataImportKind
	}
	if d.Name != nil {
		objectMap["name"] = d.Name
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.Properties != nil {
		objectMap["properties"] = d.Properties
	}
	if d.Locale != nil {
		objectMap["locale"] = d.Locale
	}
	if d.CreatedDateTime != nil {
		objectMap["createdDateTime"] = d.CreatedDateTime
	}
	if d.LastActionDateTime != nil {
		objectMap["lastActionDateTime"] = d.LastActionDateTime
	}
	if d.Status != "" {
		objectMap["status"] = d.Status
	}
	return json.Marshal(objectMap)
}

// DatasetDefinition ...
type DatasetDefinition struct {
	// DataImportKind - The kind of the dataset (e.g. acoustic data, language data ...). Possible values include: 'DataImportKind1None', 'DataImportKind1Language', 'DataImportKind1Acoustic', 'DataImportKind1Pronunciation', 'DataImportKind1CustomVoice', 'DataImportKind1LanguageGeneration'
	DataImportKind DataImportKind1 `json:"dataImportKind,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
}

// MarshalJSON is the custom marshaler for DatasetDefinition.
func (dd DatasetDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dd.DataImportKind != "" {
		objectMap["dataImportKind"] = dd.DataImportKind
	}
	if dd.Name != nil {
		objectMap["name"] = dd.Name
	}
	if dd.Description != nil {
		objectMap["description"] = dd.Description
	}
	if dd.Properties != nil {
		objectMap["properties"] = dd.Properties
	}
	if dd.Locale != nil {
		objectMap["locale"] = dd.Locale
	}
	return json.Marshal(objectMap)
}

// DatasetIdentity ...
type DatasetIdentity struct {
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
}

// DatasetUpdate ...
type DatasetUpdate struct {
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
}

// DatasetUploadFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DatasetUploadFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *DatasetUploadFuture) Result(client DatasetClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.DatasetUploadFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.DatasetUploadFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.UploadResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.DatasetUploadFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Endpoint ...
type Endpoint struct {
	// ConcurrentRecognitions - The number of concurrent recognitions the endpoint supports
	ConcurrentRecognitions *int32 `json:"concurrentRecognitions,omitempty"`
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
	// EndpointKind - The kind of this endpoint (e.g. custom speech, custom voice ...). Possible values include: 'EndpointKindNone', 'EndpointKindSpeechRecognition', 'EndpointKindCustomVoice', 'EndpointKindLanguageGeneration', 'EndpointKindLanguageIdentification'
	EndpointKind EndpointKind `json:"endpointKind,omitempty"`
	// EndpointUrls - The list of endpoint urls
	EndpointUrls map[string]*string `json:"endpointUrls"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Status3NotStarted', 'Status3Running', 'Status3Succeeded', 'Status3Failed'
	Status Status3 `json:"status,omitempty"`
	// ModelsProperty - Information about the deployed models
	ModelsProperty *[]Model `json:"models,omitempty"`
	// ContentLoggingEnabled - A value indicating whether content logging (audio &amp; transcriptions) is being used for a deployment.
	// Suppressing content logging will result in a higher cost for the deployment.
	// Free subscriptions can only deploy true
	ContentLoggingEnabled *bool `json:"contentLoggingEnabled,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
}

// MarshalJSON is the custom marshaler for Endpoint.
func (e Endpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if e.ConcurrentRecognitions != nil {
		objectMap["concurrentRecognitions"] = e.ConcurrentRecognitions
	}
	if e.ID != nil {
		objectMap["id"] = e.ID
	}
	if e.EndpointKind != "" {
		objectMap["endpointKind"] = e.EndpointKind
	}
	if e.EndpointUrls != nil {
		objectMap["endpointUrls"] = e.EndpointUrls
	}
	if e.CreatedDateTime != nil {
		objectMap["createdDateTime"] = e.CreatedDateTime
	}
	if e.LastActionDateTime != nil {
		objectMap["lastActionDateTime"] = e.LastActionDateTime
	}
	if e.Status != "" {
		objectMap["status"] = e.Status
	}
	if e.ModelsProperty != nil {
		objectMap["models"] = e.ModelsProperty
	}
	if e.ContentLoggingEnabled != nil {
		objectMap["contentLoggingEnabled"] = e.ContentLoggingEnabled
	}
	if e.Name != nil {
		objectMap["name"] = e.Name
	}
	if e.Description != nil {
		objectMap["description"] = e.Description
	}
	if e.Properties != nil {
		objectMap["properties"] = e.Properties
	}
	if e.Locale != nil {
		objectMap["locale"] = e.Locale
	}
	return json.Marshal(objectMap)
}

// EndpointCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type EndpointCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *EndpointCreateFuture) Result(client EndpointClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.EndpointCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.EndpointCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.EndpointCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// EndpointData ...
type EndpointData struct {
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
	// DataURL - The resulting data Url for the model deployment
	DataURL *string `json:"dataUrl,omitempty"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Status4Succeeded', 'Status4NotStarted', 'Status4Running', 'Status4Failed'
	Status Status4 `json:"status,omitempty"`
	// StartDate - The start date of the demplyment data export
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The end date of the demplyment data export
	EndDate *date.Time `json:"endDate,omitempty"`
}

// EndpointDataDefinition ...
type EndpointDataDefinition struct {
	// StartDate - The start date of the demplyment data export
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The end date of the demplyment data export
	EndDate *date.Time `json:"endDate,omitempty"`
}

// EndpointDataExportCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type EndpointDataExportCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *EndpointDataExportCreateFuture) Result(client EndpointDataExportClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.EndpointDataExportCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.EndpointDataExportCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.EndpointDataExportCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// EndpointDefinition ...
type EndpointDefinition struct {
	// ConcurrentRecognitions - The number of concurrent recognitions the endpoint supports
	ConcurrentRecognitions *int32 `json:"concurrentRecognitions,omitempty"`
	// ModelsProperty - Information about the deployed models
	ModelsProperty *[]ModelIdentity `json:"models,omitempty"`
	// ContentLoggingEnabled - A value indicating whether content logging (audio &amp; transcriptions) is being used for a deployment.
	// Suppressing content logging will result in a higher cost for the deployment.
	// Free subscriptions can only deploy true
	ContentLoggingEnabled *bool `json:"contentLoggingEnabled,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
}

// MarshalJSON is the custom marshaler for EndpointDefinition.
func (ed EndpointDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ed.ConcurrentRecognitions != nil {
		objectMap["concurrentRecognitions"] = ed.ConcurrentRecognitions
	}
	if ed.ModelsProperty != nil {
		objectMap["models"] = ed.ModelsProperty
	}
	if ed.ContentLoggingEnabled != nil {
		objectMap["contentLoggingEnabled"] = ed.ContentLoggingEnabled
	}
	if ed.Name != nil {
		objectMap["name"] = ed.Name
	}
	if ed.Description != nil {
		objectMap["description"] = ed.Description
	}
	if ed.Properties != nil {
		objectMap["properties"] = ed.Properties
	}
	if ed.Locale != nil {
		objectMap["locale"] = ed.Locale
	}
	return json.Marshal(objectMap)
}

// EndpointUpdate ...
type EndpointUpdate struct {
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
}

// ErrorContent the interface represents the content of an error response defined in the OneAPI v2.1
// documentation.
type ErrorContent struct {
	autorest.Response `json:"-"`
	// Details - An array of details representing distinct related errors that occurred during the request
	Details *[]ErrorDetail `json:"details,omitempty"`
	// Innererror - The stack trace of the error. The payload is service-defined.
	// If the error is not at the root level, the object contains a Code
	// and an InnerError property
	Innererror *InnerError `json:"innererror,omitempty"`
	// Code - A service-defined error code that should be human-readable.
	// This code serves as a more specific indicator of the error than
	// the HTTP error code specified in the response
	Code *string `json:"code,omitempty"`
	// Message - A human-readable representation of the error. It is intended as
	// an aid to developers and is not suitable for exposure to end users
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error (e.g., the name of the property in error)
	Target *string `json:"target,omitempty"`
}

// ErrorDetail an array of implementations of this interface can be used as details for an error.
type ErrorDetail struct {
	// Code - A service-defined error code that should be human-readable.
	// This code serves as a more specific indicator of the error than
	// the HTTP error code specified in the response
	Code *string `json:"code,omitempty"`
	// Message - A human-readable representation of the error. It is intended as
	// an aid to developers and is not suitable for exposure to end users
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error (e.g., the name of the property in error)
	Target *string `json:"target,omitempty"`
}

// HealthStatusResponse ...
type HealthStatusResponse struct {
	autorest.Response `json:"-"`
	// Status - Possible values include: 'Status7Healthy', 'Status7Sick', 'Status7Error'
	Status     Status7      `json:"status,omitempty"`
	Message    *string      `json:"message,omitempty"`
	Components *[]Component `json:"components,omitempty"`
}

// InnerError an implementation of this interface represents a stage in a stack trace.
// If the error level is the root, the {Microsoft.SpeechServices.Common.Client.IInnerError.Code} and the
// {Microsoft.SpeechServices.Common.Client.IInnerError.InnerError}
// property may be omitted.
type InnerError struct {
	// Code - A service-defined error code that should be human-readable.
	// This code serves as a more specific indicator of the error than
	// the HTTP error code specified in the response
	Code *string `json:"code,omitempty"`
	// Innererror - A human-readable representation of the error. It is intended as
	// an aid to developers and is not suitable for exposure to end users
	Innererror *InnerError `json:"innererror,omitempty"`
}

// IReadOnlyDictionary ...
type IReadOnlyDictionary struct {
	None *[]string `json:"none,omitempty"`
	// Language - language data information
	Language *[]string `json:"language,omitempty"`
	// Acoustic - acoustic data information
	Acoustic *[]string `json:"acoustic,omitempty"`
	// Pronunciation - pronunciation data information
	Pronunciation *[]string `json:"pronunciation,omitempty"`
	// CustomVoice - voice data information
	CustomVoice *[]string `json:"customVoice,omitempty"`
	// LanguageGeneration - language information
	LanguageGeneration *[]string `json:"languageGeneration,omitempty"`
}

// LanguageGenerationEndpointCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LanguageGenerationEndpointCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LanguageGenerationEndpointCreateFuture) Result(client LanguageGenerationEndpointClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.LanguageGenerationEndpointCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.LanguageGenerationEndpointCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.LanguageGenerationEndpointCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// LanguageGenerationModelCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type LanguageGenerationModelCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *LanguageGenerationModelCreateFuture) Result(client LanguageGenerationModelClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.LanguageGenerationModelCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.LanguageGenerationModelCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.LanguageGenerationModelCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// Model ...
type Model struct {
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
	// BaseModel - The base model used for adaptation
	BaseModel *Model `json:"baseModel,omitempty"`
	// Datasets - Datasets used for adaptation
	Datasets *[]Dataset `json:"datasets,omitempty"`
	// ModelKind - The kind of this model (e.g. acoustic, language ...). Possible values include: 'ModelKindAcousticAndLanguage', 'ModelKindNone', 'ModelKindAcoustic', 'ModelKindLanguage', 'ModelKindCustomVoice', 'ModelKindLanguageGeneration', 'ModelKindSentiment', 'ModelKindLanguageIdentification'
	ModelKind ModelKind `json:"modelKind,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Status1Succeeded', 'Status1Failed', 'Status1NotStarted', 'Status1Running'
	Status Status1 `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for Model.
func (mVar Model) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mVar.ID != nil {
		objectMap["id"] = mVar.ID
	}
	if mVar.BaseModel != nil {
		objectMap["baseModel"] = mVar.BaseModel
	}
	if mVar.Datasets != nil {
		objectMap["datasets"] = mVar.Datasets
	}
	if mVar.ModelKind != "" {
		objectMap["modelKind"] = mVar.ModelKind
	}
	if mVar.Name != nil {
		objectMap["name"] = mVar.Name
	}
	if mVar.Description != nil {
		objectMap["description"] = mVar.Description
	}
	if mVar.Properties != nil {
		objectMap["properties"] = mVar.Properties
	}
	if mVar.Locale != nil {
		objectMap["locale"] = mVar.Locale
	}
	if mVar.CreatedDateTime != nil {
		objectMap["createdDateTime"] = mVar.CreatedDateTime
	}
	if mVar.LastActionDateTime != nil {
		objectMap["lastActionDateTime"] = mVar.LastActionDateTime
	}
	if mVar.Status != "" {
		objectMap["status"] = mVar.Status
	}
	return json.Marshal(objectMap)
}

// ModelCreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ModelCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ModelCreateFuture) Result(client ModelClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.ModelCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.ModelCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.ModelCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ModelDefinition ...
type ModelDefinition struct {
	// Text - The text used to adapt this language model
	Text *string `json:"text,omitempty"`
	// BaseModel - The base model used for adaptation
	BaseModel *ModelIdentity `json:"baseModel,omitempty"`
	// Datasets - Datasets used for adaptation
	Datasets *[]DatasetIdentity `json:"datasets,omitempty"`
	// ModelKind - The kind of this model (e.g. acoustic, language ...). Possible values include: 'ModelKind2Acoustic', 'ModelKind2AcousticAndLanguage', 'ModelKind2Language', 'ModelKind2None', 'ModelKind2CustomVoice', 'ModelKind2LanguageGeneration', 'ModelKind2Sentiment', 'ModelKind2LanguageIdentification'
	ModelKind ModelKind2 `json:"modelKind,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
}

// MarshalJSON is the custom marshaler for ModelDefinition.
func (md ModelDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if md.Text != nil {
		objectMap["text"] = md.Text
	}
	if md.BaseModel != nil {
		objectMap["baseModel"] = md.BaseModel
	}
	if md.Datasets != nil {
		objectMap["datasets"] = md.Datasets
	}
	if md.ModelKind != "" {
		objectMap["modelKind"] = md.ModelKind
	}
	if md.Name != nil {
		objectMap["name"] = md.Name
	}
	if md.Description != nil {
		objectMap["description"] = md.Description
	}
	if md.Properties != nil {
		objectMap["properties"] = md.Properties
	}
	if md.Locale != nil {
		objectMap["locale"] = md.Locale
	}
	return json.Marshal(objectMap)
}

// ModelIdentity ...
type ModelIdentity struct {
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
}

// ModelUpdate ...
type ModelUpdate struct {
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
}

// SetObject ...
type SetObject struct {
	autorest.Response `json:"-"`
	Value             interface{} `json:"value,omitempty"`
}

// SpeechEndpointDefinition ...
type SpeechEndpointDefinition struct {
	// ConcurrentRecognitions - The number of concurrent recognitions the endpoint supports
	ConcurrentRecognitions *int32 `json:"concurrentRecognitions,omitempty"`
	// ModelsProperty - Information about the deployed models
	ModelsProperty *[]ModelIdentity `json:"models,omitempty"`
	// ContentLoggingEnabled - A value indicating whether content logging (audio &amp; transcriptions) is being used for a deployment.
	// Suppressing content logging will result in a higher cost for the deployment.
	// Free subscriptions can only deploy true
	ContentLoggingEnabled *bool `json:"contentLoggingEnabled,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
}

// MarshalJSON is the custom marshaler for SpeechEndpointDefinition.
func (sed SpeechEndpointDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sed.ConcurrentRecognitions != nil {
		objectMap["concurrentRecognitions"] = sed.ConcurrentRecognitions
	}
	if sed.ModelsProperty != nil {
		objectMap["models"] = sed.ModelsProperty
	}
	if sed.ContentLoggingEnabled != nil {
		objectMap["contentLoggingEnabled"] = sed.ContentLoggingEnabled
	}
	if sed.Name != nil {
		objectMap["name"] = sed.Name
	}
	if sed.Description != nil {
		objectMap["description"] = sed.Description
	}
	if sed.Properties != nil {
		objectMap["properties"] = sed.Properties
	}
	if sed.Locale != nil {
		objectMap["locale"] = sed.Locale
	}
	return json.Marshal(objectMap)
}

// SpeechModelDefinition ...
type SpeechModelDefinition struct {
	// Text - The text used to adapt this language model
	Text *string `json:"text,omitempty"`
	// BaseModel - The base model used for adaptation
	BaseModel *ModelIdentity `json:"baseModel,omitempty"`
	// Datasets - Datasets used for adaptation
	Datasets *[]DatasetIdentity `json:"datasets,omitempty"`
	// ModelKind - The kind of this model (e.g. acoustic, language ...). Possible values include: 'ModelKind1None', 'ModelKind1Acoustic', 'ModelKind1Language', 'ModelKind1AcousticAndLanguage', 'ModelKind1CustomVoice', 'ModelKind1LanguageGeneration', 'ModelKind1Sentiment', 'ModelKind1LanguageIdentification'
	ModelKind ModelKind1 `json:"modelKind,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
}

// MarshalJSON is the custom marshaler for SpeechModelDefinition.
func (smd SpeechModelDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smd.Text != nil {
		objectMap["text"] = smd.Text
	}
	if smd.BaseModel != nil {
		objectMap["baseModel"] = smd.BaseModel
	}
	if smd.Datasets != nil {
		objectMap["datasets"] = smd.Datasets
	}
	if smd.ModelKind != "" {
		objectMap["modelKind"] = smd.ModelKind
	}
	if smd.Name != nil {
		objectMap["name"] = smd.Name
	}
	if smd.Description != nil {
		objectMap["description"] = smd.Description
	}
	if smd.Properties != nil {
		objectMap["properties"] = smd.Properties
	}
	if smd.Locale != nil {
		objectMap["locale"] = smd.Locale
	}
	return json.Marshal(objectMap)
}

// Test ...
type Test struct {
	// Dataset - Information about the dataset used in the test
	Dataset *Dataset `json:"dataset,omitempty"`
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
	// WordErrorRate - The word error rate of the tested model
	WordErrorRate *float64 `json:"wordErrorRate,omitempty"`
	// ResultsURL - The URL that can be used to download the test results.
	// Each line in the file represents a tab separated list of filename, reference transcription and decoder output.
	//
	// The URL will only be valid, if the test completed successfully
	ResultsURL *string `json:"resultsUrl,omitempty"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Status2Succeeded', 'Status2Failed', 'Status2NotStarted', 'Status2Running'
	Status Status2 `json:"status,omitempty"`
	// ModelsProperty - Information about the models used for this accuracy test
	ModelsProperty *[]Model `json:"models,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for Test.
func (t Test) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.Dataset != nil {
		objectMap["dataset"] = t.Dataset
	}
	if t.ID != nil {
		objectMap["id"] = t.ID
	}
	if t.WordErrorRate != nil {
		objectMap["wordErrorRate"] = t.WordErrorRate
	}
	if t.ResultsURL != nil {
		objectMap["resultsUrl"] = t.ResultsURL
	}
	if t.CreatedDateTime != nil {
		objectMap["createdDateTime"] = t.CreatedDateTime
	}
	if t.LastActionDateTime != nil {
		objectMap["lastActionDateTime"] = t.LastActionDateTime
	}
	if t.Status != "" {
		objectMap["status"] = t.Status
	}
	if t.ModelsProperty != nil {
		objectMap["models"] = t.ModelsProperty
	}
	if t.Name != nil {
		objectMap["name"] = t.Name
	}
	if t.Description != nil {
		objectMap["description"] = t.Description
	}
	if t.Properties != nil {
		objectMap["properties"] = t.Properties
	}
	return json.Marshal(objectMap)
}

// TestDefinition ...
type TestDefinition struct {
	// Dataset - Information about the dataset used in the test
	Dataset *DatasetIdentity `json:"dataset,omitempty"`
	// ModelsProperty - Information about the models used for this accuracy test
	ModelsProperty *[]ModelIdentity `json:"models,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for TestDefinition.
func (td TestDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if td.Dataset != nil {
		objectMap["dataset"] = td.Dataset
	}
	if td.ModelsProperty != nil {
		objectMap["models"] = td.ModelsProperty
	}
	if td.Name != nil {
		objectMap["name"] = td.Name
	}
	if td.Description != nil {
		objectMap["description"] = td.Description
	}
	if td.Properties != nil {
		objectMap["properties"] = td.Properties
	}
	return json.Marshal(objectMap)
}

// TestUpdate ...
type TestUpdate struct {
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
}

// Transcription ...
type Transcription struct {
	RecordingsURL *string `json:"recordingsUrl,omitempty"`
	// ID - The identifier of this entity
	ID             *uuid.UUID `json:"id,omitempty"`
	ModelsProperty *[]Model   `json:"models,omitempty"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
	// ResultsUrls - The results Urls for the transcription
	ResultsUrls map[string]*string `json:"resultsUrls"`
	// StatusMessage - The failure reason for the transcription
	StatusMessage *string `json:"statusMessage,omitempty"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Status5Succeeded', 'Status5NotStarted', 'Status5Running', 'Status5Failed'
	Status Status5 `json:"status,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for Transcription.
func (t Transcription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.RecordingsURL != nil {
		objectMap["recordingsUrl"] = t.RecordingsURL
	}
	if t.ID != nil {
		objectMap["id"] = t.ID
	}
	if t.ModelsProperty != nil {
		objectMap["models"] = t.ModelsProperty
	}
	if t.Locale != nil {
		objectMap["locale"] = t.Locale
	}
	if t.ResultsUrls != nil {
		objectMap["resultsUrls"] = t.ResultsUrls
	}
	if t.StatusMessage != nil {
		objectMap["statusMessage"] = t.StatusMessage
	}
	if t.CreatedDateTime != nil {
		objectMap["createdDateTime"] = t.CreatedDateTime
	}
	if t.LastActionDateTime != nil {
		objectMap["lastActionDateTime"] = t.LastActionDateTime
	}
	if t.Status != "" {
		objectMap["status"] = t.Status
	}
	if t.Name != nil {
		objectMap["name"] = t.Name
	}
	if t.Description != nil {
		objectMap["description"] = t.Description
	}
	if t.Properties != nil {
		objectMap["properties"] = t.Properties
	}
	return json.Marshal(objectMap)
}

// TranscriptionDefinition ...
type TranscriptionDefinition struct {
	RecordingsURL  *string          `json:"recordingsUrl,omitempty"`
	ModelsProperty *[]ModelIdentity `json:"models,omitempty"`
	// Locale - The locale of the contained data
	Locale *string `json:"locale,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
	// Properties - The custom properties of this entity
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for TranscriptionDefinition.
func (td TranscriptionDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if td.RecordingsURL != nil {
		objectMap["recordingsUrl"] = td.RecordingsURL
	}
	if td.ModelsProperty != nil {
		objectMap["models"] = td.ModelsProperty
	}
	if td.Locale != nil {
		objectMap["locale"] = td.Locale
	}
	if td.Name != nil {
		objectMap["name"] = td.Name
	}
	if td.Description != nil {
		objectMap["description"] = td.Description
	}
	if td.Properties != nil {
		objectMap["properties"] = td.Properties
	}
	return json.Marshal(objectMap)
}

// TranscriptionUpdate ...
type TranscriptionUpdate struct {
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
}

// VoiceDatasetUploadFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VoiceDatasetUploadFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VoiceDatasetUploadFuture) Result(client VoiceDatasetClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.VoiceDatasetUploadFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.VoiceDatasetUploadFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.UploadResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.VoiceDatasetUploadFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VoiceDeploymentCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VoiceDeploymentCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VoiceDeploymentCreateFuture) Result(client VoiceDeploymentClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.VoiceDeploymentCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.VoiceDeploymentCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.VoiceDeploymentCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VoiceModelCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VoiceModelCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VoiceModelCreateFuture) Result(client VoiceModelClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.VoiceModelCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.VoiceModelCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.VoiceModelCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VoiceTest ...
type VoiceTest struct {
	// ID - The identifier of this entity
	ID *uuid.UUID `json:"id,omitempty"`
	// AudioURI - The audio URI of the voice test
	AudioURI *string `json:"audioUri,omitempty"`
	// TextURI - The text URI of the voice test
	TextURI *string `json:"textUri,omitempty"`
	// CreatedDateTime - The time-stamp when the object was created
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// LastActionDateTime - The time-stamp when the current status was entered
	LastActionDateTime *date.Time `json:"lastActionDateTime,omitempty"`
	// Status - The status of the object. Possible values include: 'Status8Succeeded', 'Status8NotStarted', 'Status8Running', 'Status8Failed'
	Status Status8 `json:"status,omitempty"`
	// Model - Information about the models used in the voice test
	Model *Model `json:"model,omitempty"`
	// VoiceTestKind - The kind of this test (e.g. Text, SSML). Possible values include: 'VoiceTestKindNone', 'VoiceTestKindText', 'VoiceTestKindSSML'
	VoiceTestKind VoiceTestKind `json:"voiceTestKind,omitempty"`
}

// VoiceTestCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VoiceTestCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *VoiceTestCreateFuture) Result(client VoiceTestClient) (ec ErrorContent, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.VoiceTestCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("speechservices.VoiceTestCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ec.Response.Response, err = future.GetResult(sender); err == nil && ec.Response.Response.StatusCode != http.StatusNoContent {
		ec, err = client.CreateResponder(ec.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "speechservices.VoiceTestCreateFuture", "Result", ec.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VoiceTestDefinition ...
type VoiceTestDefinition struct {
	// Text - Information about the text used in the voice test
	Text *string `json:"text,omitempty"`
	// Model - Information about the models used in the voice test
	Model *ModelIdentity `json:"model,omitempty"`
	// VoiceTestKind - The kind of this test (e.g. Text, SSML). Possible values include: 'VoiceTestKind1None', 'VoiceTestKind1Text', 'VoiceTestKind1SSML'
	VoiceTestKind VoiceTestKind1 `json:"voiceTestKind,omitempty"`
}

// WebHookConfigurationSecret ...
type WebHookConfigurationSecret struct {
	// Secret - A secret that will be used to create a SHA1 hash of the payload with the secret as HMAC key.
	// This hash will be set as X-MicrosoftSpeechServices-Signature header when calling back into the registered URL
	Secret *string `json:"secret,omitempty"`
}

// WebHookUpdate ...
type WebHookUpdate struct {
	// Configuration - The configuration of the web hook registration.
	//
	// If the property secret is omitted or contains an empty string in a POST or PATCH request,
	// no signature hash will be calculated.
	//
	// When retrieving web hook registration information from the service, the secret is always omitted
	Configuration *WebHookConfigurationSecret `json:"configuration,omitempty"`
	// Active - A value indicating whether callbacks to the registered URL are made or not
	Active *bool `json:"active,omitempty"`
	// Name - The name of the object
	Name *string `json:"name,omitempty"`
	// Description - The description of the object
	Description *string `json:"description,omitempty"`
}
