package catalog

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io/ioutil"
	"net/http"
	"net/url"
)

// Client is the creates an Azure Data Lake Analytics catalog client.
type Client struct {
	ManagementClient
}

// NewClient creates an instance of the Client client.
func NewClient(url url.URL, p pipeline.Pipeline) Client {
	return Client{NewManagementClient(url, p)}
}

// CreateCredential creates the specified credential for use with external data sources in the specified database.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database in which to create the credential. Note: This is NOT an external database name, but the name of
// an existing U-SQL database that should contain the new credential object. credentialName is the name of the
// credential. parameters is the parameters required to create the credential (name and password)
func (client Client) CreateCredential(ctx context.Context, accountName string, databaseName string, credentialName string, parameters DataLakeAnalyticsCatalogCredentialCreateParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.Password", name: null, rule: true, chain: nil},
				{target: "parameters.URI", name: null, rule: true, chain: nil},
				{target: "parameters.UserID", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.createCredentialPreparer(accountName, databaseName, credentialName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createCredentialResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// createCredentialPreparer prepares the CreateCredential request.
func (client Client) createCredentialPreparer(accountName string, databaseName string, credentialName string, parameters DataLakeAnalyticsCatalogCredentialCreateParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// createCredentialResponder handles the response to the CreateCredential request.
func (client Client) createCredentialResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// CreateSecret creates the specified secret for use with external data sources in the specified database. This is
// deprecated and will be removed in the next release. Please use CreateCredential instead.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database in which to create the secret. secretName is the name of the secret. parameters is the
// parameters required to create the secret (name and password)
func (client Client) CreateSecret(ctx context.Context, accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.Password", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.createSecretPreparer(accountName, databaseName, secretName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createSecretResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// createSecretPreparer prepares the CreateSecret request.
func (client Client) createSecretPreparer(accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// createSecretResponder handles the response to the CreateSecret request.
func (client Client) createSecretResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// DeleteAllSecrets deletes all secrets in the specified database. This is deprecated and will be removed in the next
// release. In the future, please only drop individual credentials using DeleteCredential
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the secret.
func (client Client) DeleteAllSecrets(ctx context.Context, accountName string, databaseName string) (*http.Response, error) {
	req, err := client.deleteAllSecretsPreparer(accountName, databaseName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteAllSecretsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// deleteAllSecretsPreparer prepares the DeleteAllSecrets request.
func (client Client) deleteAllSecretsPreparer(accountName string, databaseName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteAllSecretsResponder handles the response to the DeleteAllSecrets request.
func (client Client) deleteAllSecretsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// DeleteCredential deletes the specified credential in the specified database
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the credential. credentialName is the name of the credential to delete parameters is
// the parameters to delete a credential if the current user is not the account owner. cascade is indicates if the
// delete should be a cascading delete (which deletes all resources dependent on the credential as well as the
// credential) or not. If false will fail if there are any resources relying on the credential.
func (client Client) DeleteCredential(ctx context.Context, accountName string, databaseName string, credentialName string, parameters *DataLakeAnalyticsCatalogCredentialDeleteParameters, cascade *bool) (*http.Response, error) {
	req, err := client.deleteCredentialPreparer(accountName, databaseName, credentialName, parameters, cascade)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteCredentialResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// deleteCredentialPreparer prepares the DeleteCredential request.
func (client Client) deleteCredentialPreparer(accountName string, databaseName string, credentialName string, parameters *DataLakeAnalyticsCatalogCredentialDeleteParameters, cascade *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if cascade != nil {
		params.Set("cascade", fmt.Sprintf("%v", *cascade))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// deleteCredentialResponder handles the response to the DeleteCredential request.
func (client Client) deleteCredentialResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// DeleteSecret deletes the specified secret in the specified database. This is deprecated and will be removed in the
// next release. Please use DeleteCredential instead.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the secret. secretName is the name of the secret to delete
func (client Client) DeleteSecret(ctx context.Context, accountName string, databaseName string, secretName string) (*http.Response, error) {
	req, err := client.deleteSecretPreparer(accountName, databaseName, secretName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteSecretResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// deleteSecretPreparer prepares the DeleteSecret request.
func (client Client) deleteSecretPreparer(accountName string, databaseName string, secretName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteSecretResponder handles the response to the DeleteSecret request.
func (client Client) deleteSecretResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// GetAssembly retrieves the specified assembly from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the assembly. assemblyName is the name of the assembly.
func (client Client) GetAssembly(ctx context.Context, accountName string, databaseName string, assemblyName string) (*USQLAssembly, error) {
	req, err := client.getAssemblyPreparer(accountName, databaseName, assemblyName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getAssemblyResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLAssembly), err
}

// getAssemblyPreparer prepares the GetAssembly request.
func (client Client) getAssemblyPreparer(accountName string, databaseName string, assemblyName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getAssemblyResponder handles the response to the GetAssembly request.
func (client Client) getAssemblyResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLAssembly{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetCredential retrieves the specified credential from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the schema. credentialName is the name of the credential.
func (client Client) GetCredential(ctx context.Context, accountName string, databaseName string, credentialName string) (*USQLCredential, error) {
	req, err := client.getCredentialPreparer(accountName, databaseName, credentialName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getCredentialResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLCredential), err
}

// getCredentialPreparer prepares the GetCredential request.
func (client Client) getCredentialPreparer(accountName string, databaseName string, credentialName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getCredentialResponder handles the response to the GetCredential request.
func (client Client) getCredentialResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLCredential{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDatabase retrieves the specified database from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database.
func (client Client) GetDatabase(ctx context.Context, accountName string, databaseName string) (*USQLDatabase, error) {
	req, err := client.getDatabasePreparer(accountName, databaseName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLDatabase), err
}

// getDatabasePreparer prepares the GetDatabase request.
func (client Client) getDatabasePreparer(accountName string, databaseName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDatabaseResponder handles the response to the GetDatabase request.
func (client Client) getDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLDatabase{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetExternalDataSource retrieves the specified external data source from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the external data source. externalDataSourceName is the name of the external data
// source.
func (client Client) GetExternalDataSource(ctx context.Context, accountName string, databaseName string, externalDataSourceName string) (*USQLExternalDataSource, error) {
	req, err := client.getExternalDataSourcePreparer(accountName, databaseName, externalDataSourceName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getExternalDataSourceResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLExternalDataSource), err
}

// getExternalDataSourcePreparer prepares the GetExternalDataSource request.
func (client Client) getExternalDataSourcePreparer(accountName string, databaseName string, externalDataSourceName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getExternalDataSourceResponder handles the response to the GetExternalDataSource request.
func (client Client) getExternalDataSourceResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLExternalDataSource{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetPackage retrieves the specified package from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the package. schemaName is the name of the schema containing the package.
// packageName is the name of the package.
func (client Client) GetPackage(ctx context.Context, accountName string, databaseName string, schemaName string, packageName string) (*USQLPackage, error) {
	req, err := client.getPackagePreparer(accountName, databaseName, schemaName, packageName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getPackageResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLPackage), err
}

// getPackagePreparer prepares the GetPackage request.
func (client Client) getPackagePreparer(accountName string, databaseName string, schemaName string, packageName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getPackageResponder handles the response to the GetPackage request.
func (client Client) getPackageResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLPackage{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetProcedure retrieves the specified procedure from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the procedure. schemaName is the name of the schema containing the procedure.
// procedureName is the name of the procedure.
func (client Client) GetProcedure(ctx context.Context, accountName string, databaseName string, schemaName string, procedureName string) (*USQLProcedure, error) {
	req, err := client.getProcedurePreparer(accountName, databaseName, schemaName, procedureName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getProcedureResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLProcedure), err
}

// getProcedurePreparer prepares the GetProcedure request.
func (client Client) getProcedurePreparer(accountName string, databaseName string, schemaName string, procedureName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getProcedureResponder handles the response to the GetProcedure request.
func (client Client) getProcedureResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLProcedure{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetSchema retrieves the specified schema from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the schema. schemaName is the name of the schema.
func (client Client) GetSchema(ctx context.Context, accountName string, databaseName string, schemaName string) (*USQLSchema, error) {
	req, err := client.getSchemaPreparer(accountName, databaseName, schemaName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getSchemaResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLSchema), err
}

// getSchemaPreparer prepares the GetSchema request.
func (client Client) getSchemaPreparer(accountName string, databaseName string, schemaName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getSchemaResponder handles the response to the GetSchema request.
func (client Client) getSchemaResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLSchema{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetSecret gets the specified secret in the specified database. This is deprecated and will be removed in the next
// release. Please use GetCredential instead.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the secret. secretName is the name of the secret to get
func (client Client) GetSecret(ctx context.Context, accountName string, databaseName string, secretName string) (*USQLSecret, error) {
	req, err := client.getSecretPreparer(accountName, databaseName, secretName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getSecretResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLSecret), err
}

// getSecretPreparer prepares the GetSecret request.
func (client Client) getSecretPreparer(accountName string, databaseName string, secretName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getSecretResponder handles the response to the GetSecret request.
func (client Client) getSecretResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLSecret{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetTable retrieves the specified table from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table. schemaName is the name of the schema containing the table. tableName is
// the name of the table.
func (client Client) GetTable(ctx context.Context, accountName string, databaseName string, schemaName string, tableName string) (*USQLTable, error) {
	req, err := client.getTablePreparer(accountName, databaseName, schemaName, tableName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getTableResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTable), err
}

// getTablePreparer prepares the GetTable request.
func (client Client) getTablePreparer(accountName string, databaseName string, schemaName string, tableName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getTableResponder handles the response to the GetTable request.
func (client Client) getTableResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTable{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetTablePartition retrieves the specified table partition from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the partition. schemaName is the name of the schema containing the partition.
// tableName is the name of the table containing the partition. partitionName is the name of the table partition.
func (client Client) GetTablePartition(ctx context.Context, accountName string, databaseName string, schemaName string, tableName string, partitionName string) (*USQLTablePartition, error) {
	req, err := client.getTablePartitionPreparer(accountName, databaseName, schemaName, tableName, partitionName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getTablePartitionResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTablePartition), err
}

// getTablePartitionPreparer prepares the GetTablePartition request.
func (client Client) getTablePartitionPreparer(accountName string, databaseName string, schemaName string, tableName string, partitionName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getTablePartitionResponder handles the response to the GetTablePartition request.
func (client Client) getTablePartitionResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTablePartition{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetTableStatistic retrieves the specified table statistics from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the statistics. schemaName is the name of the schema containing the statistics.
// tableName is the name of the table containing the statistics. statisticsName is the name of the table statistics.
func (client Client) GetTableStatistic(ctx context.Context, accountName string, databaseName string, schemaName string, tableName string, statisticsName string) (*USQLTableStatistics, error) {
	req, err := client.getTableStatisticPreparer(accountName, databaseName, schemaName, tableName, statisticsName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getTableStatisticResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableStatistics), err
}

// getTableStatisticPreparer prepares the GetTableStatistic request.
func (client Client) getTableStatisticPreparer(accountName string, databaseName string, schemaName string, tableName string, statisticsName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getTableStatisticResponder handles the response to the GetTableStatistic request.
func (client Client) getTableStatisticResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableStatistics{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetTableType retrieves the specified table type from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table type. schemaName is the name of the schema containing the table type.
// tableTypeName is the name of the table type to retrieve.
func (client Client) GetTableType(ctx context.Context, accountName string, databaseName string, schemaName string, tableTypeName string) (*USQLTableType, error) {
	req, err := client.getTableTypePreparer(accountName, databaseName, schemaName, tableTypeName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getTableTypeResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableType), err
}

// getTableTypePreparer prepares the GetTableType request.
func (client Client) getTableTypePreparer(accountName string, databaseName string, schemaName string, tableTypeName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getTableTypeResponder handles the response to the GetTableType request.
func (client Client) getTableTypeResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableType{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetTableValuedFunction retrieves the specified table valued function from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table valued function. schemaName is the name of the schema containing the table
// valued function. tableValuedFunctionName is the name of the tableValuedFunction.
func (client Client) GetTableValuedFunction(ctx context.Context, accountName string, databaseName string, schemaName string, tableValuedFunctionName string) (*USQLTableValuedFunction, error) {
	req, err := client.getTableValuedFunctionPreparer(accountName, databaseName, schemaName, tableValuedFunctionName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getTableValuedFunctionResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableValuedFunction), err
}

// getTableValuedFunctionPreparer prepares the GetTableValuedFunction request.
func (client Client) getTableValuedFunctionPreparer(accountName string, databaseName string, schemaName string, tableValuedFunctionName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getTableValuedFunctionResponder handles the response to the GetTableValuedFunction request.
func (client Client) getTableValuedFunctionResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableValuedFunction{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetView retrieves the specified view from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the view. schemaName is the name of the schema containing the view. viewName is the
// name of the view.
func (client Client) GetView(ctx context.Context, accountName string, databaseName string, schemaName string, viewName string) (*USQLView, error) {
	req, err := client.getViewPreparer(accountName, databaseName, schemaName, viewName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getViewResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLView), err
}

// getViewPreparer prepares the GetView request.
func (client Client) getViewPreparer(accountName string, databaseName string, schemaName string, viewName string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getViewResponder handles the response to the GetView request.
func (client Client) getViewResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLView{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GrantACL grants an access control list (ACL) entry to the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. parameters is
// parameters supplied to create or update an access control list (ACL) entry for a Data Lake Analytics catalog.
func (client Client) GrantACL(ctx context.Context, accountName string, parameters ACLCreateOrUpdateParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.PrincipalID", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.grantACLPreparer(accountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.grantACLResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// grantACLPreparer prepares the GrantACL request.
func (client Client) grantACLPreparer(accountName string, parameters ACLCreateOrUpdateParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("op", "GRANTACE")
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// grantACLResponder handles the response to the GrantACL request.
func (client Client) grantACLResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// GrantACLToDatabase grants an access control list (ACL) entry to the database from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database. parameters is parameters supplied to create or update an access control list (ACL) entry for a
// database.
func (client Client) GrantACLToDatabase(ctx context.Context, accountName string, databaseName string, parameters ACLCreateOrUpdateParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.PrincipalID", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.grantACLToDatabasePreparer(accountName, databaseName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.grantACLToDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// grantACLToDatabasePreparer prepares the GrantACLToDatabase request.
func (client Client) grantACLToDatabasePreparer(accountName string, databaseName string, parameters ACLCreateOrUpdateParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("op", "GRANTACE")
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// grantACLToDatabaseResponder handles the response to the GrantACLToDatabase request.
func (client Client) grantACLToDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// ListAcls retrieves the list of access control list (ACL) entries for the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. filter is oData
// filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over before
// returning elements. Optional. selectParameter is oData Select statement. Limits the properties on each entry to just
// those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more
// comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the
// values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to
// request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
// Optional.
func (client Client) ListAcls(ctx context.Context, accountName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*ACLList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listAclsPreparer(accountName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listAclsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ACLList), err
}

// listAclsPreparer prepares the ListAcls request.
func (client Client) listAclsPreparer(accountName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listAclsResponder handles the response to the ListAcls request.
func (client Client) listAclsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &ACLList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListAclsByDatabase retrieves the list of access control list (ACL) entries for the database from the Data Lake
// Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database. filter is oData filter. Optional. top is the number of items to return. Optional. skip is the
// number of items to skip over before returning elements. Optional. selectParameter is oData Select statement. Limits
// the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional.
// orderby is orderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc"
// depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is
// the Boolean value of true or false to request a count of the matching resources included with the resources in the
// response, e.g. Categories?$count=true. Optional.
func (client Client) ListAclsByDatabase(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*ACLList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listAclsByDatabasePreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listAclsByDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ACLList), err
}

// listAclsByDatabasePreparer prepares the ListAclsByDatabase request.
func (client Client) listAclsByDatabasePreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listAclsByDatabaseResponder handles the response to the ListAclsByDatabase request.
func (client Client) listAclsByDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &ACLList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListAssemblies retrieves the list of assemblies from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the assembly. filter is oData filter. Optional. top is the number of items to
// return. Optional. skip is the number of items to skip over before returning elements. Optional. selectParameter is
// oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListAssemblies(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLAssemblyList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listAssembliesPreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listAssembliesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLAssemblyList), err
}

// listAssembliesPreparer prepares the ListAssemblies request.
func (client Client) listAssembliesPreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listAssembliesResponder handles the response to the ListAssemblies request.
func (client Client) listAssembliesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLAssemblyList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListCredentials retrieves the list of credentials from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the schema. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. selectParameter is oData
// Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListCredentials(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLCredentialList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listCredentialsPreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listCredentialsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLCredentialList), err
}

// listCredentialsPreparer prepares the ListCredentials request.
func (client Client) listCredentialsPreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listCredentialsResponder handles the response to the ListCredentials request.
func (client Client) listCredentialsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLCredentialList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListDatabases retrieves the list of databases from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. filter is oData
// filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over before
// returning elements. Optional. selectParameter is oData Select statement. Limits the properties on each entry to just
// those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more
// comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the
// values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to
// request a count of the matching resources included with the resources in the response, e.g. Categories?$count=true.
// Optional.
func (client Client) ListDatabases(ctx context.Context, accountName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLDatabaseList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listDatabasesPreparer(accountName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listDatabasesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLDatabaseList), err
}

// listDatabasesPreparer prepares the ListDatabases request.
func (client Client) listDatabasesPreparer(accountName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listDatabasesResponder handles the response to the ListDatabases request.
func (client Client) listDatabasesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLDatabaseList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListExternalDataSources retrieves the list of external data sources from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the external data sources. filter is oData filter. Optional. top is the number of
// items to return. Optional. skip is the number of items to skip over before returning elements. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListExternalDataSources(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLExternalDataSourceList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listExternalDataSourcesPreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listExternalDataSourcesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLExternalDataSourceList), err
}

// listExternalDataSourcesPreparer prepares the ListExternalDataSources request.
func (client Client) listExternalDataSourcesPreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listExternalDataSourcesResponder handles the response to the ListExternalDataSources request.
func (client Client) listExternalDataSourcesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLExternalDataSourceList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListPackages retrieves the list of packages from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the packages. schemaName is the name of the schema containing the packages. filter
// is oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on each entry
// to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One
// or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like
// the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false
// to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client Client) ListPackages(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLPackageList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listPackagesPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listPackagesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLPackageList), err
}

// listPackagesPreparer prepares the ListPackages request.
func (client Client) listPackagesPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listPackagesResponder handles the response to the ListPackages request.
func (client Client) listPackagesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLPackageList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListProcedures retrieves the list of procedures from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the procedures. schemaName is the name of the schema containing the procedures.
// filter is oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to
// skip over before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on
// each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy
// clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the
// order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value
// of true or false to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client Client) ListProcedures(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLProcedureList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listProceduresPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listProceduresResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLProcedureList), err
}

// listProceduresPreparer prepares the ListProcedures request.
func (client Client) listProceduresPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listProceduresResponder handles the response to the ListProcedures request.
func (client Client) listProceduresResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLProcedureList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListSchemas retrieves the list of schemas from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the schema. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. selectParameter is oData
// Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListSchemas(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLSchemaList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listSchemasPreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listSchemasResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLSchemaList), err
}

// listSchemasPreparer prepares the ListSchemas request.
func (client Client) listSchemasPreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listSchemasResponder handles the response to the ListSchemas request.
func (client Client) listSchemasResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLSchemaList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTablePartitions retrieves the list of table partitions from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the partitions. schemaName is the name of the schema containing the partitions.
// tableName is the name of the table containing the partitions. filter is oData filter. Optional. top is the number of
// items to return. Optional. skip is the number of items to skip over before returning elements. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListTablePartitions(ctx context.Context, accountName string, databaseName string, schemaName string, tableName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTablePartitionList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTablePartitionsPreparer(accountName, databaseName, schemaName, tableName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTablePartitionsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTablePartitionList), err
}

// listTablePartitionsPreparer prepares the ListTablePartitions request.
func (client Client) listTablePartitionsPreparer(accountName string, databaseName string, schemaName string, tableName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTablePartitionsResponder handles the response to the ListTablePartitions request.
func (client Client) listTablePartitionsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTablePartitionList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTables retrieves the list of tables from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the tables. schemaName is the name of the schema containing the tables. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on each entry
// to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One
// or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like
// the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false
// to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional. basic is the basic switch indicates what level of information to return when
// listing tables. When basic is true, only database_name, schema_name, table_name and version are returned for each
// table, otherwise all table metadata is returned. By default, it is false. Optional.
func (client Client) ListTables(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool, basic *bool) (*USQLTableList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTablesPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count, basic)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTablesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableList), err
}

// listTablesPreparer prepares the ListTables request.
func (client Client) listTablesPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool, basic *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	if basic != nil {
		params.Set("basic", fmt.Sprintf("%v", *basic))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTablesResponder handles the response to the ListTables request.
func (client Client) listTablesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTablesByDatabase retrieves the list of all tables in a database from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the tables. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. selectParameter is oData
// Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. basic is
// the basic switch indicates what level of information to return when listing tables. When basic is true, only
// database_name, schema_name, table_name and version are returned for each table, otherwise all table metadata is
// returned. By default, it is false
func (client Client) ListTablesByDatabase(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool, basic *bool) (*USQLTableList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTablesByDatabasePreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count, basic)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTablesByDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableList), err
}

// listTablesByDatabasePreparer prepares the ListTablesByDatabase request.
func (client Client) listTablesByDatabasePreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool, basic *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	if basic != nil {
		params.Set("basic", fmt.Sprintf("%v", *basic))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTablesByDatabaseResponder handles the response to the ListTablesByDatabase request.
func (client Client) listTablesByDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTableStatistics retrieves the list of table statistics from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the statistics. schemaName is the name of the schema containing the statistics.
// tableName is the name of the table containing the statistics. filter is oData filter. Optional. top is the number of
// items to return. Optional. skip is the number of items to skip over before returning elements. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListTableStatistics(ctx context.Context, accountName string, databaseName string, schemaName string, tableName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTableStatisticsList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTableStatisticsPreparer(accountName, databaseName, schemaName, tableName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTableStatisticsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableStatisticsList), err
}

// listTableStatisticsPreparer prepares the ListTableStatistics request.
func (client Client) listTableStatisticsPreparer(accountName string, databaseName string, schemaName string, tableName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTableStatisticsResponder handles the response to the ListTableStatistics request.
func (client Client) listTableStatisticsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableStatisticsList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTableStatisticsByDatabase retrieves the list of all statistics in a database from the Data Lake Analytics
// catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table statistics. filter is oData filter. Optional. top is the number of items
// to return. Optional. skip is the number of items to skip over before returning elements. Optional. selectParameter
// is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListTableStatisticsByDatabase(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTableStatisticsList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTableStatisticsByDatabasePreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTableStatisticsByDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableStatisticsList), err
}

// listTableStatisticsByDatabasePreparer prepares the ListTableStatisticsByDatabase request.
func (client Client) listTableStatisticsByDatabasePreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTableStatisticsByDatabaseResponder handles the response to the ListTableStatisticsByDatabase request.
func (client Client) listTableStatisticsByDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableStatisticsList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTableStatisticsByDatabaseAndSchema retrieves the list of all table statistics within the specified schema from
// the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the statistics. schemaName is the name of the schema containing the statistics.
// filter is oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to
// skip over before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on
// each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy
// clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the
// order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value
// of true or false to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client Client) ListTableStatisticsByDatabaseAndSchema(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTableStatisticsList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTableStatisticsByDatabaseAndSchemaPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTableStatisticsByDatabaseAndSchemaResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableStatisticsList), err
}

// listTableStatisticsByDatabaseAndSchemaPreparer prepares the ListTableStatisticsByDatabaseAndSchema request.
func (client Client) listTableStatisticsByDatabaseAndSchemaPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTableStatisticsByDatabaseAndSchemaResponder handles the response to the ListTableStatisticsByDatabaseAndSchema request.
func (client Client) listTableStatisticsByDatabaseAndSchemaResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableStatisticsList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTableTypes retrieves the list of table types from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table types. schemaName is the name of the schema containing the table types.
// filter is oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to
// skip over before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on
// each entry to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy
// clause. One or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the
// order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value
// of true or false to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client Client) ListTableTypes(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTableTypeList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTableTypesPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTableTypesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableTypeList), err
}

// listTableTypesPreparer prepares the ListTableTypes request.
func (client Client) listTableTypesPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTableTypesResponder handles the response to the ListTableTypes request.
func (client Client) listTableTypesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableTypeList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTableValuedFunctions retrieves the list of table valued functions from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table valued functions. schemaName is the name of the schema containing the
// table valued functions. filter is oData filter. Optional. top is the number of items to return. Optional. skip is
// the number of items to skip over before returning elements. Optional. selectParameter is oData Select statement.
// Limits the properties on each entry to just those requested, e.g. Categories?$select=CategoryName,Description.
// Optional. orderby is orderBy clause. One or more comma-separated expressions with an optional "asc" (the default) or
// "desc" depending on the order you'd like the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional.
// count is the Boolean value of true or false to request a count of the matching resources included with the resources
// in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListTableValuedFunctions(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTableValuedFunctionList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTableValuedFunctionsPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTableValuedFunctionsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableValuedFunctionList), err
}

// listTableValuedFunctionsPreparer prepares the ListTableValuedFunctions request.
func (client Client) listTableValuedFunctionsPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTableValuedFunctionsResponder handles the response to the ListTableValuedFunctions request.
func (client Client) listTableValuedFunctionsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableValuedFunctionList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTableValuedFunctionsByDatabase retrieves the list of all table valued functions in a database from the Data Lake
// Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the table valued functions. filter is oData filter. Optional. top is the number of
// items to return. Optional. skip is the number of items to skip over before returning elements. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListTableValuedFunctionsByDatabase(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTableValuedFunctionList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTableValuedFunctionsByDatabasePreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTableValuedFunctionsByDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTableValuedFunctionList), err
}

// listTableValuedFunctionsByDatabasePreparer prepares the ListTableValuedFunctionsByDatabase request.
func (client Client) listTableValuedFunctionsByDatabasePreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTableValuedFunctionsByDatabaseResponder handles the response to the ListTableValuedFunctionsByDatabase request.
func (client Client) listTableValuedFunctionsByDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTableValuedFunctionList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListTypes retrieves the list of types within the specified database and schema from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the types. schemaName is the name of the schema containing the types. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on each entry
// to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One
// or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like
// the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false
// to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client Client) ListTypes(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLTypeList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listTypesPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listTypesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLTypeList), err
}

// listTypesPreparer prepares the ListTypes request.
func (client Client) listTypesPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listTypesResponder handles the response to the ListTypes request.
func (client Client) listTypesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLTypeList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListViews retrieves the list of views from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the views. schemaName is the name of the schema containing the views. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. selectParameter is oData Select statement. Limits the properties on each entry
// to just those requested, e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One
// or more comma-separated expressions with an optional "asc" (the default) or "desc" depending on the order you'd like
// the values sorted, e.g. Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false
// to request a count of the matching resources included with the resources in the response, e.g.
// Categories?$count=true. Optional.
func (client Client) ListViews(ctx context.Context, accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLViewList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listViewsPreparer(accountName, databaseName, schemaName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listViewsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLViewList), err
}

// listViewsPreparer prepares the ListViews request.
func (client Client) listViewsPreparer(accountName string, databaseName string, schemaName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listViewsResponder handles the response to the ListViews request.
func (client Client) listViewsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLViewList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListViewsByDatabase retrieves the list of all views in a database from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the views. filter is oData filter. Optional. top is the number of items to return.
// Optional. skip is the number of items to skip over before returning elements. Optional. selectParameter is oData
// Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional.
func (client Client) ListViewsByDatabase(ctx context.Context, accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (*USQLViewList, error) {
	if err := validate([]validation{
		{targetValue: top,
			constraints: []constraint{{target: "top", name: null, rule: false,
				chain: []constraint{{target: "top", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: skip,
			constraints: []constraint{{target: "skip", name: null, rule: false,
				chain: []constraint{{target: "skip", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listViewsByDatabasePreparer(accountName, databaseName, filter, top, skip, selectParameter, orderby, count)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listViewsByDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*USQLViewList), err
}

// listViewsByDatabasePreparer prepares the ListViewsByDatabase request.
func (client Client) listViewsByDatabasePreparer(accountName string, databaseName string, filter *string, top *int32, skip *int32, selectParameter *string, orderby *string, count *bool) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listViewsByDatabaseResponder handles the response to the ListViewsByDatabase request.
func (client Client) listViewsByDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &USQLViewList{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// RevokeACL revokes an access control list (ACL) entry from the Data Lake Analytics catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. parameters is
// parameters supplied to delete an access control list (ACL) entry from a Data Lake Analytics catalog.
func (client Client) RevokeACL(ctx context.Context, accountName string, parameters ACLDeleteParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.PrincipalID", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.revokeACLPreparer(accountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.revokeACLResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// revokeACLPreparer prepares the RevokeACL request.
func (client Client) revokeACLPreparer(accountName string, parameters ACLDeleteParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("op", "REVOKEACE")
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// revokeACLResponder handles the response to the RevokeACL request.
func (client Client) revokeACLResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// RevokeACLFromDatabase revokes an access control list (ACL) entry for the database from the Data Lake Analytics
// catalog.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database. parameters is parameters supplied to delete an access control list (ACL) entry for a database.
func (client Client) RevokeACLFromDatabase(ctx context.Context, accountName string, databaseName string, parameters ACLDeleteParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.PrincipalID", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.revokeACLFromDatabasePreparer(accountName, databaseName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.revokeACLFromDatabaseResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// revokeACLFromDatabasePreparer prepares the RevokeACLFromDatabase request.
func (client Client) revokeACLFromDatabasePreparer(accountName string, databaseName string, parameters ACLDeleteParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("op", "REVOKEACE")
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// revokeACLFromDatabaseResponder handles the response to the RevokeACLFromDatabase request.
func (client Client) revokeACLFromDatabaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// UpdateCredential modifies the specified credential for use with external data sources in the specified database
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the credential. credentialName is the name of the credential. parameters is the
// parameters required to modify the credential (name and password)
func (client Client) UpdateCredential(ctx context.Context, accountName string, databaseName string, credentialName string, parameters DataLakeAnalyticsCatalogCredentialUpdateParameters) (*http.Response, error) {
	req, err := client.updateCredentialPreparer(accountName, databaseName, credentialName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.updateCredentialResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// updateCredentialPreparer prepares the UpdateCredential request.
func (client Client) updateCredentialPreparer(accountName string, databaseName string, credentialName string, parameters DataLakeAnalyticsCatalogCredentialUpdateParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PATCH", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// updateCredentialResponder handles the response to the UpdateCredential request.
func (client Client) updateCredentialResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// UpdateSecret modifies the specified secret for use with external data sources in the specified database. This is
// deprecated and will be removed in the next release. Please use UpdateCredential instead.
//
// accountName is the Azure Data Lake Analytics account upon which to execute catalog operations. databaseName is the
// name of the database containing the secret. secretName is the name of the secret. parameters is the parameters
// required to modify the secret (name and password)
func (client Client) UpdateSecret(ctx context.Context, accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (*http.Response, error) {
	req, err := client.updateSecretPreparer(accountName, databaseName, secretName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.updateSecretResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// updateSecretPreparer prepares the UpdateSecret request.
func (client Client) updateSecretPreparer(accountName string, databaseName string, secretName string, parameters DataLakeAnalyticsCatalogSecretCreateOrUpdateParameters) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PATCH", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// updateSecretResponder handles the response to the UpdateSecret request.
func (client Client) updateSecretResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}
