package catalog

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/xml"
	"reflect"
	"time"
	"unsafe"
)

const (
	rfc3339Format = "2006-01-02T15:04:05.0000000Z07:00"
)

// used to convert times from UTC to GMT before sending across the wire
var gmt = time.FixedZone("GMT", 0)

// internal type used for marshalling time in RFC1123 format
type timeRFC1123 struct {
	time.Time
}

// MarshalText implements the encoding.TextMarshaler interface for timeRFC1123.
func (t timeRFC1123) MarshalText() ([]byte, error) {
	return []byte(t.Format(time.RFC1123)), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for timeRFC1123.
func (t *timeRFC1123) UnmarshalText(data []byte) (err error) {
	t.Time, err = time.Parse(time.RFC1123, string(data))
	return
}

// internal type used for marshalling time in RFC3339 format
type timeRFC3339 struct {
	time.Time
}

// MarshalText implements the encoding.TextMarshaler interface for timeRFC3339.
func (t timeRFC3339) MarshalText() ([]byte, error) {
	return []byte(t.Format(rfc3339Format)), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for timeRFC3339.
func (t *timeRFC3339) UnmarshalText(data []byte) (err error) {
	t.Time, err = time.Parse(rfc3339Format, string(data))
	return
}

// internal type used for marshalling
type uSQLSecret struct {
	ComputeAccountName *string      `json:"computeAccountName,omitempty"`
	Version            *uuid.UUID   `json:"version,omitempty"`
	DatabaseName       *string      `json:"databaseName,omitempty"`
	Name               *string      `json:"secretName,omitempty"`
	CreationTime       *timeRFC3339 `json:"creationTime,omitempty"`
	URI                *string      `json:"uri,omitempty"`
	Password           *string      `json:"password,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for USQLSecret.
func (us USQLSecret) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*USQLSecret)(nil)).Elem().Size() != reflect.TypeOf((*uSQLSecret)(nil)).Elem().Size() {
		panic("size mismatch between USQLSecret and uSQLSecret")
	}
	us2 := (*uSQLSecret)(unsafe.Pointer(&us))
	return e.EncodeElement(*us2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for USQLSecret.
func (us *USQLSecret) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*USQLSecret)(nil)).Elem().Size() != reflect.TypeOf((*uSQLSecret)(nil)).Elem().Size() {
		panic("size mismatch between USQLSecret and uSQLSecret")
	}
	us2 := (*uSQLSecret)(unsafe.Pointer(us))
	return d.DecodeElement(us2, &start)
}

// internal type used for marshalling
type uSQLTablePartition struct {
	ComputeAccountName *string      `json:"computeAccountName,omitempty"`
	Version            *uuid.UUID   `json:"version,omitempty"`
	DatabaseName       *string      `json:"databaseName,omitempty"`
	SchemaName         *string      `json:"schemaName,omitempty"`
	Name               *string      `json:"partitionName,omitempty"`
	ParentName         *DdlName     `json:"parentName,omitempty"`
	IndexID            *int32       `json:"indexId,omitempty"`
	Label              []string     `json:"label,omitempty"`
	CreateDate         *timeRFC3339 `json:"createDate,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for USQLTablePartition.
func (utp USQLTablePartition) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*USQLTablePartition)(nil)).Elem().Size() != reflect.TypeOf((*uSQLTablePartition)(nil)).Elem().Size() {
		panic("size mismatch between USQLTablePartition and uSQLTablePartition")
	}
	utp2 := (*uSQLTablePartition)(unsafe.Pointer(&utp))
	return e.EncodeElement(*utp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for USQLTablePartition.
func (utp *USQLTablePartition) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*USQLTablePartition)(nil)).Elem().Size() != reflect.TypeOf((*uSQLTablePartition)(nil)).Elem().Size() {
		panic("size mismatch between USQLTablePartition and uSQLTablePartition")
	}
	utp2 := (*uSQLTablePartition)(unsafe.Pointer(utp))
	return d.DecodeElement(utp2, &start)
}

// internal type used for marshalling
type uSQLTableStatistics struct {
	ComputeAccountName *string      `json:"computeAccountName,omitempty"`
	Version            *uuid.UUID   `json:"version,omitempty"`
	DatabaseName       *string      `json:"databaseName,omitempty"`
	SchemaName         *string      `json:"schemaName,omitempty"`
	TableName          *string      `json:"tableName,omitempty"`
	Name               *string      `json:"statisticsName,omitempty"`
	UserStatName       *string      `json:"userStatName,omitempty"`
	StatDataPath       *string      `json:"statDataPath,omitempty"`
	CreateTime         *timeRFC3339 `json:"createTime,omitempty"`
	UpdateTime         *timeRFC3339 `json:"updateTime,omitempty"`
	IsUserCreated      *bool        `json:"isUserCreated,omitempty"`
	IsAutoCreated      *bool        `json:"isAutoCreated,omitempty"`
	HasFilter          *bool        `json:"hasFilter,omitempty"`
	FilterDefinition   *string      `json:"filterDefinition,omitempty"`
	ColNames           []string     `json:"colNames,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for USQLTableStatistics.
func (uts USQLTableStatistics) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*USQLTableStatistics)(nil)).Elem().Size() != reflect.TypeOf((*uSQLTableStatistics)(nil)).Elem().Size() {
		panic("size mismatch between USQLTableStatistics and uSQLTableStatistics")
	}
	uts2 := (*uSQLTableStatistics)(unsafe.Pointer(&uts))
	return e.EncodeElement(*uts2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for USQLTableStatistics.
func (uts *USQLTableStatistics) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*USQLTableStatistics)(nil)).Elem().Size() != reflect.TypeOf((*uSQLTableStatistics)(nil)).Elem().Size() {
		panic("size mismatch between USQLTableStatistics and uSQLTableStatistics")
	}
	uts2 := (*uSQLTableStatistics)(unsafe.Pointer(uts))
	return d.DecodeElement(uts2, &start)
}
