package account

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io/ioutil"
	"net/http"
)

// Client is the creates an Azure Data Lake Analytics account management client.
type Client struct {
	ManagementClient
}

// NewClient creates an instance of the Client client.
func NewClient(p pipeline.Pipeline) Client {
	return Client{NewManagementClient(p)}
}

// AddDataLakeStoreAccount updates the specified Data Lake Analytics account to include the additional Data Lake Store
// account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to which to add the Data Lake Store account. dataLakeStoreAccountName
// is the name of the Data Lake Store account to add. parameters is the details of the Data Lake Store account.
func (client Client) AddDataLakeStoreAccount(ctx context.Context, resourceGroupName string, accountName string, dataLakeStoreAccountName string, parameters AddDataLakeStoreParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.Properties", name: null, rule: true, chain: nil}}}}); err != nil {
		return nil, err
	}
	req, err := client.addDataLakeStoreAccountPreparer(resourceGroupName, accountName, dataLakeStoreAccountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addDataLakeStoreAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addDataLakeStoreAccountPreparer prepares the AddDataLakeStoreAccount request.
func (client Client) addDataLakeStoreAccountPreparer(resourceGroupName string, accountName string, dataLakeStoreAccountName string, parameters AddDataLakeStoreParameters) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/{dataLakeStoreAccountName}"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// addDataLakeStoreAccountResponder handles the response to the AddDataLakeStoreAccount request.
func (client Client) addDataLakeStoreAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// AddStorageAccount updates the specified Data Lake Analytics account to add an Azure Storage account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to which to add the Azure Storage account. storageAccountName is the
// name of the Azure Storage account to add parameters is the parameters containing the access key and optional suffix
// for the Azure Storage Account.
func (client Client) AddStorageAccount(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (*http.Response, error) {
	if err := validate([]validation{
		{targetValue: parameters,
			constraints: []constraint{{target: "parameters.Properties", name: null, rule: true,
				chain: []constraint{{target: "parameters.Properties.AccessKey", name: null, rule: true, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.addStorageAccountPreparer(resourceGroupName, accountName, storageAccountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.addStorageAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// addStorageAccountPreparer prepares the AddStorageAccount request.
func (client Client) addStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// addStorageAccountResponder handles the response to the AddStorageAccount request.
func (client Client) addStorageAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// Create creates the specified Data Lake Analytics account. This supplies the user with computation services for Data
// Lake Analytics workloads This method may poll for completion. Polling can be canceled by passing the cancel channel
// argument. The channel will be used to cancel polling and any outstanding HTTP requests.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account.the account
// will be associated with. name is the name of the Data Lake Analytics account to create. parameters is parameters
// supplied to the create Data Lake Analytics account operation.
func (client Client) Create(ctx context.Context, resourceGroupName string, name string, parameters DataLakeAnalyticsAccount) (*DataLakeAnalyticsAccount, error) {
	req, err := client.createPreparer(resourceGroupName, name, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccount), err
}

// createPreparer prepares the Create request.
func (client Client) createPreparer(resourceGroupName string, name string, parameters DataLakeAnalyticsAccount) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{name}"
	req, err := pipeline.NewRequest("PUT", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// createResponder handles the response to the Create request.
func (client Client) createResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusCreated, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccount{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Delete begins the delete delete process for the Data Lake Analytics account object specified by the account name.
// This method may poll for completion. Polling can be canceled by passing the cancel channel argument. The channel
// will be used to cancel polling and any outstanding HTTP requests.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to delete
func (client Client) Delete(ctx context.Context, resourceGroupName string, accountName string) (*http.Response, error) {
	req, err := client.deletePreparer(resourceGroupName, accountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// deletePreparer prepares the Delete request.
func (client Client) deletePreparer(resourceGroupName string, accountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}"
	req, err := pipeline.NewRequest("DELETE", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteResponder handles the response to the Delete request.
func (client Client) deleteResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusAccepted, http.StatusNotFound, http.StatusNoContent)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// DeleteDataLakeStoreAccount updates the Data Lake Analytics account specified to remove the specified Data Lake Store
// account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to remove the Data Lake Store account.
// dataLakeStoreAccountName is the name of the Data Lake Store account to remove
func (client Client) DeleteDataLakeStoreAccount(ctx context.Context, resourceGroupName string, accountName string, dataLakeStoreAccountName string) (*http.Response, error) {
	req, err := client.deleteDataLakeStoreAccountPreparer(resourceGroupName, accountName, dataLakeStoreAccountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteDataLakeStoreAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// deleteDataLakeStoreAccountPreparer prepares the DeleteDataLakeStoreAccount request.
func (client Client) deleteDataLakeStoreAccountPreparer(resourceGroupName string, accountName string, dataLakeStoreAccountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/{dataLakeStoreAccountName}"
	req, err := pipeline.NewRequest("DELETE", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteDataLakeStoreAccountResponder handles the response to the DeleteDataLakeStoreAccount request.
func (client Client) deleteDataLakeStoreAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// DeleteStorageAccount updates the specified Data Lake Analytics account to remove an Azure Storage account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to remove the Azure Storage account. storageAccountName is
// the name of the Azure Storage account to remove
func (client Client) DeleteStorageAccount(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string) (*http.Response, error) {
	req, err := client.deleteStorageAccountPreparer(resourceGroupName, accountName, storageAccountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteStorageAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// deleteStorageAccountPreparer prepares the DeleteStorageAccount request.
func (client Client) deleteStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}"
	req, err := pipeline.NewRequest("DELETE", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// deleteStorageAccountResponder handles the response to the DeleteStorageAccount request.
func (client Client) deleteStorageAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}

// Get gets details of the specified Data Lake Analytics account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to retrieve.
func (client Client) Get(ctx context.Context, resourceGroupName string, accountName string) (*DataLakeAnalyticsAccount, error) {
	req, err := client.getPreparer(resourceGroupName, accountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccount), err
}

// getPreparer prepares the Get request.
func (client Client) getPreparer(resourceGroupName string, accountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getResponder handles the response to the Get request.
func (client Client) getResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccount{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetDataLakeStoreAccount gets the specified Data Lake Store account details in the specified Data Lake Analytics
// account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to retrieve the Data Lake Store account details.
// dataLakeStoreAccountName is the name of the Data Lake Store account to retrieve
func (client Client) GetDataLakeStoreAccount(ctx context.Context, resourceGroupName string, accountName string, dataLakeStoreAccountName string) (*DataLakeStoreAccountInfo, error) {
	req, err := client.getDataLakeStoreAccountPreparer(resourceGroupName, accountName, dataLakeStoreAccountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getDataLakeStoreAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeStoreAccountInfo), err
}

// getDataLakeStoreAccountPreparer prepares the GetDataLakeStoreAccount request.
func (client Client) getDataLakeStoreAccountPreparer(resourceGroupName string, accountName string, dataLakeStoreAccountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/{dataLakeStoreAccountName}"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getDataLakeStoreAccountResponder handles the response to the GetDataLakeStoreAccount request.
func (client Client) getDataLakeStoreAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeStoreAccountInfo{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetStorageAccount gets the specified Azure Storage account linked to the given Data Lake Analytics account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to retrieve Azure storage account details.
// storageAccountName is the name of the Azure Storage account for which to retrieve the details.
func (client Client) GetStorageAccount(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string) (*StorageAccountInfo, error) {
	req, err := client.getStorageAccountPreparer(resourceGroupName, accountName, storageAccountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getStorageAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*StorageAccountInfo), err
}

// getStorageAccountPreparer prepares the GetStorageAccount request.
func (client Client) getStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getStorageAccountResponder handles the response to the GetStorageAccount request.
func (client Client) getStorageAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &StorageAccountInfo{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// GetStorageContainer gets the specified Azure Storage container associated with the given Data Lake Analytics and
// Azure Storage accounts.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to retrieve blob container. storageAccountName is the name
// of the Azure storage account from which to retrieve the blob container. containerName is the name of the Azure
// storage container to retrieve
func (client Client) GetStorageContainer(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string, containerName string) (*BlobContainer, error) {
	req, err := client.getStorageContainerPreparer(resourceGroupName, accountName, storageAccountName, containerName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getStorageContainerResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*BlobContainer), err
}

// getStorageContainerPreparer prepares the GetStorageContainer request.
func (client Client) getStorageContainerPreparer(resourceGroupName string, accountName string, storageAccountName string, containerName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}/Containers/{containerName}"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// getStorageContainerResponder handles the response to the GetStorageContainer request.
func (client Client) getStorageContainerResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &BlobContainer{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// List gets the first page of Data Lake Analytics accounts, if any, within the current subscription. This includes a
// link to the next page, if any.
//
// filter is oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to
// skip over before returning elements. Optional. expand is oData expansion. Expand related resources in line with the
// retrieved resources, e.g. Categories/$expand=Products would expand Product data in line with each Category entry.
// Optional. selectParameter is oData Select statement. Limits the properties on each entry to just those requested,
// e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the desired return format. Return the
// response in particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client Client) List(ctx context.Context, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (*DataLakeAnalyticsAccountListResult, error) {
	req, err := client.listPreparer(filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccountListResult), err
}

// listPreparer prepares the List request.
func (client Client) listPreparer(filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/providers/Microsoft.DataLakeAnalytics/accounts"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if expand != nil {
		params.Set("$expand", *expand)
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	if search != nil {
		params.Set("$search", *search)
	}
	if formatParameter != nil {
		params.Set("$format", *formatParameter)
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listResponder handles the response to the List request.
func (client Client) listResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccountListResult{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListByResourceGroup gets the first page of Data Lake Analytics accounts, if any, within a specific resource group.
// This includes a link to the next page, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories/$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the return format. Return the response in
// particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client Client) ListByResourceGroup(ctx context.Context, resourceGroupName string, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (*DataLakeAnalyticsAccountListResult, error) {
	req, err := client.listByResourceGroupPreparer(resourceGroupName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listByResourceGroupResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccountListResult), err
}

// listByResourceGroupPreparer prepares the ListByResourceGroup request.
func (client Client) listByResourceGroupPreparer(resourceGroupName string, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if expand != nil {
		params.Set("$expand", *expand)
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	if search != nil {
		params.Set("$search", *search)
	}
	if formatParameter != nil {
		params.Set("$format", *formatParameter)
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listByResourceGroupResponder handles the response to the ListByResourceGroup request.
func (client Client) listByResourceGroupResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccountListResult{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListDataLakeStoreAccounts gets the first page of Data Lake Store accounts linked to the specified Data Lake
// Analytics account. The response includes a link to the next page, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to list Data Lake Store accounts. filter is oData filter.
// Optional. top is the number of items to return. Optional. skip is the number of items to skip over before returning
// elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved resources, e.g.
// Categories/$expand=Products would expand Product data in line with each Category entry. Optional. selectParameter is
// oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the desired return format. Return the
// response in particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client Client) ListDataLakeStoreAccounts(ctx context.Context, resourceGroupName string, accountName string, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (*DataLakeAnalyticsAccountListDataLakeStoreResult, error) {
	req, err := client.listDataLakeStoreAccountsPreparer(resourceGroupName, accountName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listDataLakeStoreAccountsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccountListDataLakeStoreResult), err
}

// listDataLakeStoreAccountsPreparer prepares the ListDataLakeStoreAccounts request.
func (client Client) listDataLakeStoreAccountsPreparer(resourceGroupName string, accountName string, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if expand != nil {
		params.Set("$expand", *expand)
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	if search != nil {
		params.Set("$search", *search)
	}
	if formatParameter != nil {
		params.Set("$format", *formatParameter)
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listDataLakeStoreAccountsResponder handles the response to the ListDataLakeStoreAccounts request.
func (client Client) listDataLakeStoreAccountsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccountListDataLakeStoreResult{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListSasTokens gets the SAS token associated with the specified Data Lake Analytics and Azure Storage account and
// container combination.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which an Azure Storage account's SAS token is being requested.
// storageAccountName is the name of the Azure storage account for which the SAS token is being requested.
// containerName is the name of the Azure storage container for which the SAS token is being requested.
func (client Client) ListSasTokens(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string, containerName string) (*ListSasTokensResult, error) {
	req, err := client.listSasTokensPreparer(resourceGroupName, accountName, storageAccountName, containerName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listSasTokensResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ListSasTokensResult), err
}

// listSasTokensPreparer prepares the ListSasTokens request.
func (client Client) listSasTokensPreparer(resourceGroupName string, accountName string, storageAccountName string, containerName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}/Containers/{containerName}/listSasTokens"
	req, err := pipeline.NewRequest("POST", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listSasTokensResponder handles the response to the ListSasTokens request.
func (client Client) listSasTokensResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &ListSasTokensResult{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListStorageAccounts gets the first page of Azure Storage accounts, if any, linked to the specified Data Lake
// Analytics account. The response includes a link to the next page, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to list Azure Storage accounts. filter is the OData filter.
// Optional. top is the number of items to return. Optional. skip is the number of items to skip over before returning
// elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved resources, e.g.
// Categories/$expand=Products would expand Product data in line with each Category entry. Optional. selectParameter is
// oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the desired return format. Return the
// response in particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client Client) ListStorageAccounts(ctx context.Context, resourceGroupName string, accountName string, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (*DataLakeAnalyticsAccountListStorageAccountsResult, error) {
	req, err := client.listStorageAccountsPreparer(resourceGroupName, accountName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listStorageAccountsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccountListStorageAccountsResult), err
}

// listStorageAccountsPreparer prepares the ListStorageAccounts request.
func (client Client) listStorageAccountsPreparer(resourceGroupName string, accountName string, filter *string, top *int32, skip *int32, expand *string, selectParameter *string, orderby *string, count *bool, search *string, formatParameter *string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if filter != nil {
		params.Set("$filter", *filter)
	}
	if top != nil {
		params.Set("$top", fmt.Sprintf("%v", *top))
	}
	if skip != nil {
		params.Set("$skip", fmt.Sprintf("%v", *skip))
	}
	if expand != nil {
		params.Set("$expand", *expand)
	}
	if selectParameter != nil {
		params.Set("$select", *selectParameter)
	}
	if orderby != nil {
		params.Set("$orderby", *orderby)
	}
	if count != nil {
		params.Set("$count", fmt.Sprintf("%v", *count))
	}
	if search != nil {
		params.Set("$search", *search)
	}
	if formatParameter != nil {
		params.Set("$format", *formatParameter)
	}
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listStorageAccountsResponder handles the response to the ListStorageAccounts request.
func (client Client) listStorageAccountsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccountListStorageAccountsResult{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListStorageContainers lists the Azure Storage containers, if any, associated with the specified Data Lake Analytics
// and Azure Storage account combination. The response includes a link to the next page of results, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to list Azure Storage blob containers. storageAccountName
// is the name of the Azure storage account from which to list blob containers.
func (client Client) ListStorageContainers(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string) (*ListBlobContainersResult, error) {
	req, err := client.listStorageContainersPreparer(resourceGroupName, accountName, storageAccountName)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listStorageContainersResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ListBlobContainersResult), err
}

// listStorageContainersPreparer prepares the ListStorageContainers request.
func (client Client) listStorageContainersPreparer(resourceGroupName string, accountName string, storageAccountName string) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}/Containers"
	req, err := pipeline.NewRequest("GET", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	return req, nil
}

// listStorageContainersResponder handles the response to the ListStorageContainers request.
func (client Client) listStorageContainersResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &ListBlobContainersResult{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// Update updates the Data Lake Analytics account object specified by the accountName with the contents of the account
// object. This method may poll for completion. Polling can be canceled by passing the cancel channel argument. The
// channel will be used to cancel polling and any outstanding HTTP requests.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. name is the
// name of the Data Lake Analytics account to update. parameters is parameters supplied to the update Data Lake
// Analytics account operation.
func (client Client) Update(ctx context.Context, resourceGroupName string, name string, parameters DataLakeAnalyticsAccount) (*DataLakeAnalyticsAccount, error) {
	req, err := client.updatePreparer(resourceGroupName, name, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.updateResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DataLakeAnalyticsAccount), err
}

// updatePreparer prepares the Update request.
func (client Client) updatePreparer(resourceGroupName string, name string, parameters DataLakeAnalyticsAccount) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{name}"
	req, err := pipeline.NewRequest("PATCH", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// updateResponder handles the response to the Update request.
func (client Client) updateResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusCreated)
	if resp == nil {
		return nil, err
	}
	result := &DataLakeAnalyticsAccount{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// UpdateStorageAccount updates the Data Lake Analytics account to replace Azure Storage blob account details, such as
// the access key and/or suffix.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to modify storage accounts in storageAccountName is the Azure Storage
// account to modify parameters is the parameters containing the access key and suffix to update the storage account
// with.
func (client Client) UpdateStorageAccount(ctx context.Context, resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (*http.Response, error) {
	req, err := client.updateStorageAccountPreparer(resourceGroupName, accountName, storageAccountName, parameters)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.updateStorageAccountResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.Response(), err
}

// updateStorageAccountPreparer prepares the UpdateStorageAccount request.
func (client Client) updateStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (pipeline.Request, error) {
	u := client.url
	u.Path = "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}"
	req, err := pipeline.NewRequest("PATCH", u, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("api-version", APIVersion)
	req.URL.RawQuery = params.Encode()
	b, err := json.Marshal(parameters)
	if err != nil {
		return req, pipeline.NewError(err, "failed to marshal request body")
	}
	req.Header.Set("Content-Type", "application/json")
	err = req.SetBody(bytes.NewReader(b))
	if err != nil {
		return req, pipeline.NewError(err, "failed to set request body")
	}
	return req, nil
}

// updateStorageAccountResponder handles the response to the UpdateStorageAccount request.
func (client Client) updateStorageAccountResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	return resp, err
}
