package account

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"net/http"
)

// GroupClient is the creates an Azure Data Lake Analytics account management client.
type GroupClient struct {
	ManagementClient
}

// NewGroupClient creates an instance of the GroupClient client.
func NewGroupClient(subscriptionID string) GroupClient {
	return NewGroupClientWithBaseURI(DefaultBaseURI, subscriptionID)
}

// NewGroupClientWithBaseURI creates an instance of the GroupClient client.
func NewGroupClientWithBaseURI(baseURI string, subscriptionID string) GroupClient {
	return GroupClient{NewWithBaseURI(baseURI, subscriptionID)}
}

// AddDataLakeStoreAccount updates the specified Data Lake Analytics account to include the additional Data Lake Store
// account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to which to add the Data Lake Store account. dataLakeStoreAccountName
// is the name of the Data Lake Store account to add. parameters is the details of the Data Lake Store account.
func (client GroupClient) AddDataLakeStoreAccount(resourceGroupName string, accountName string, dataLakeStoreAccountName string, parameters AddDataLakeStoreParameters) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: parameters,
			Constraints: []validation.Constraint{{Target: "parameters.Properties", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "account.GroupClient", "AddDataLakeStoreAccount")
	}

	req, err := client.AddDataLakeStoreAccountPreparer(resourceGroupName, accountName, dataLakeStoreAccountName, parameters)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "AddDataLakeStoreAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddDataLakeStoreAccountSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "account.GroupClient", "AddDataLakeStoreAccount", resp, "Failure sending request")
		return
	}

	result, err = client.AddDataLakeStoreAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "AddDataLakeStoreAccount", resp, "Failure responding to request")
	}

	return
}

// AddDataLakeStoreAccountPreparer prepares the AddDataLakeStoreAccount request.
func (client GroupClient) AddDataLakeStoreAccountPreparer(resourceGroupName string, accountName string, dataLakeStoreAccountName string, parameters AddDataLakeStoreParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":              autorest.Encode("path", accountName),
		"dataLakeStoreAccountName": autorest.Encode("path", dataLakeStoreAccountName),
		"resourceGroupName":        autorest.Encode("path", resourceGroupName),
		"subscriptionId":           autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/{dataLakeStoreAccountName}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// AddDataLakeStoreAccountSender sends the AddDataLakeStoreAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) AddDataLakeStoreAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// AddDataLakeStoreAccountResponder handles the response to the AddDataLakeStoreAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) AddDataLakeStoreAccountResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// AddStorageAccount updates the specified Data Lake Analytics account to add an Azure Storage account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to which to add the Azure Storage account. storageAccountName is the
// name of the Azure Storage account to add parameters is the parameters containing the access key and optional suffix
// for the Azure Storage Account.
func (client GroupClient) AddStorageAccount(resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: parameters,
			Constraints: []validation.Constraint{{Target: "parameters.Properties", Name: validation.Null, Rule: true,
				Chain: []validation.Constraint{{Target: "parameters.Properties.AccessKey", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "account.GroupClient", "AddStorageAccount")
	}

	req, err := client.AddStorageAccountPreparer(resourceGroupName, accountName, storageAccountName, parameters)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "AddStorageAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.AddStorageAccountSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "account.GroupClient", "AddStorageAccount", resp, "Failure sending request")
		return
	}

	result, err = client.AddStorageAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "AddStorageAccount", resp, "Failure responding to request")
	}

	return
}

// AddStorageAccountPreparer prepares the AddStorageAccount request.
func (client GroupClient) AddStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// AddStorageAccountSender sends the AddStorageAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) AddStorageAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// AddStorageAccountResponder handles the response to the AddStorageAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) AddStorageAccountResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Create creates the specified Data Lake Analytics account. This supplies the user with computation services for Data
// Lake Analytics workloads This method may poll for completion. Polling can be canceled by passing the cancel channel
// argument. The channel will be used to cancel polling and any outstanding HTTP requests.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account.the account
// will be associated with. name is the name of the Data Lake Analytics account to create. parameters is parameters
// supplied to the create Data Lake Analytics account operation.
func (client GroupClient) Create(resourceGroupName string, name string, parameters DataLakeAnalyticsAccount, cancel <-chan struct{}) (<-chan DataLakeAnalyticsAccount, <-chan error) {
	resultChan := make(chan DataLakeAnalyticsAccount, 1)
	errChan := make(chan error, 1)
	go func() {
		var err error
		var result DataLakeAnalyticsAccount
		defer func() {
			if err != nil {
				errChan <- err
			}
			resultChan <- result
			close(resultChan)
			close(errChan)
		}()
		req, err := client.CreatePreparer(resourceGroupName, name, parameters, cancel)
		if err != nil {
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Create", nil, "Failure preparing request")
			return
		}

		resp, err := client.CreateSender(req)
		if err != nil {
			result.Response = autorest.Response{Response: resp}
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Create", resp, "Failure sending request")
			return
		}

		result, err = client.CreateResponder(resp)
		if err != nil {
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Create", resp, "Failure responding to request")
		}
	}()
	return resultChan, errChan
}

// CreatePreparer prepares the Create request.
func (client GroupClient) CreatePreparer(resourceGroupName string, name string, parameters DataLakeAnalyticsAccount, cancel <-chan struct{}) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{name}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{Cancel: cancel})
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) CreateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		azure.DoPollForAsynchronous(client.PollingDelay))
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client GroupClient) CreateResponder(resp *http.Response) (result DataLakeAnalyticsAccount, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusCreated, http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Delete begins the delete delete process for the Data Lake Analytics account object specified by the account name.
// This method may poll for completion. Polling can be canceled by passing the cancel channel argument. The channel
// will be used to cancel polling and any outstanding HTTP requests.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to delete
func (client GroupClient) Delete(resourceGroupName string, accountName string, cancel <-chan struct{}) (<-chan autorest.Response, <-chan error) {
	resultChan := make(chan autorest.Response, 1)
	errChan := make(chan error, 1)
	go func() {
		var err error
		var result autorest.Response
		defer func() {
			if err != nil {
				errChan <- err
			}
			resultChan <- result
			close(resultChan)
			close(errChan)
		}()
		req, err := client.DeletePreparer(resourceGroupName, accountName, cancel)
		if err != nil {
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Delete", nil, "Failure preparing request")
			return
		}

		resp, err := client.DeleteSender(req)
		if err != nil {
			result.Response = resp
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Delete", resp, "Failure sending request")
			return
		}

		result, err = client.DeleteResponder(resp)
		if err != nil {
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Delete", resp, "Failure responding to request")
		}
	}()
	return resultChan, errChan
}

// DeletePreparer prepares the Delete request.
func (client GroupClient) DeletePreparer(resourceGroupName string, accountName string, cancel <-chan struct{}) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":       autorest.Encode("path", accountName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{Cancel: cancel})
}

// DeleteSender sends the Delete request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) DeleteSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		azure.DoPollForAsynchronous(client.PollingDelay))
}

// DeleteResponder handles the response to the Delete request. The method always
// closes the http.Response Body.
func (client GroupClient) DeleteResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNotFound, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteDataLakeStoreAccount updates the Data Lake Analytics account specified to remove the specified Data Lake Store
// account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to remove the Data Lake Store account.
// dataLakeStoreAccountName is the name of the Data Lake Store account to remove
func (client GroupClient) DeleteDataLakeStoreAccount(resourceGroupName string, accountName string, dataLakeStoreAccountName string) (result autorest.Response, err error) {
	req, err := client.DeleteDataLakeStoreAccountPreparer(resourceGroupName, accountName, dataLakeStoreAccountName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "DeleteDataLakeStoreAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDataLakeStoreAccountSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "account.GroupClient", "DeleteDataLakeStoreAccount", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDataLakeStoreAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "DeleteDataLakeStoreAccount", resp, "Failure responding to request")
	}

	return
}

// DeleteDataLakeStoreAccountPreparer prepares the DeleteDataLakeStoreAccount request.
func (client GroupClient) DeleteDataLakeStoreAccountPreparer(resourceGroupName string, accountName string, dataLakeStoreAccountName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":              autorest.Encode("path", accountName),
		"dataLakeStoreAccountName": autorest.Encode("path", dataLakeStoreAccountName),
		"resourceGroupName":        autorest.Encode("path", resourceGroupName),
		"subscriptionId":           autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/{dataLakeStoreAccountName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteDataLakeStoreAccountSender sends the DeleteDataLakeStoreAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) DeleteDataLakeStoreAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteDataLakeStoreAccountResponder handles the response to the DeleteDataLakeStoreAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) DeleteDataLakeStoreAccountResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteStorageAccount updates the specified Data Lake Analytics account to remove an Azure Storage account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to remove the Azure Storage account. storageAccountName is
// the name of the Azure Storage account to remove
func (client GroupClient) DeleteStorageAccount(resourceGroupName string, accountName string, storageAccountName string) (result autorest.Response, err error) {
	req, err := client.DeleteStorageAccountPreparer(resourceGroupName, accountName, storageAccountName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "DeleteStorageAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteStorageAccountSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "account.GroupClient", "DeleteStorageAccount", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteStorageAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "DeleteStorageAccount", resp, "Failure responding to request")
	}

	return
}

// DeleteStorageAccountPreparer prepares the DeleteStorageAccount request.
func (client GroupClient) DeleteStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteStorageAccountSender sends the DeleteStorageAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) DeleteStorageAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteStorageAccountResponder handles the response to the DeleteStorageAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) DeleteStorageAccountResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Get gets details of the specified Data Lake Analytics account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to retrieve.
func (client GroupClient) Get(resourceGroupName string, accountName string) (result DataLakeAnalyticsAccount, err error) {
	req, err := client.GetPreparer(resourceGroupName, accountName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "Get", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "Get", resp, "Failure sending request")
		return
	}

	result, err = client.GetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "Get", resp, "Failure responding to request")
	}

	return
}

// GetPreparer prepares the Get request.
func (client GroupClient) GetPreparer(resourceGroupName string, accountName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":       autorest.Encode("path", accountName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetSender sends the Get request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetResponder handles the response to the Get request. The method always
// closes the http.Response Body.
func (client GroupClient) GetResponder(resp *http.Response) (result DataLakeAnalyticsAccount, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDataLakeStoreAccount gets the specified Data Lake Store account details in the specified Data Lake Analytics
// account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to retrieve the Data Lake Store account details.
// dataLakeStoreAccountName is the name of the Data Lake Store account to retrieve
func (client GroupClient) GetDataLakeStoreAccount(resourceGroupName string, accountName string, dataLakeStoreAccountName string) (result DataLakeStoreAccountInfo, err error) {
	req, err := client.GetDataLakeStoreAccountPreparer(resourceGroupName, accountName, dataLakeStoreAccountName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetDataLakeStoreAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDataLakeStoreAccountSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetDataLakeStoreAccount", resp, "Failure sending request")
		return
	}

	result, err = client.GetDataLakeStoreAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetDataLakeStoreAccount", resp, "Failure responding to request")
	}

	return
}

// GetDataLakeStoreAccountPreparer prepares the GetDataLakeStoreAccount request.
func (client GroupClient) GetDataLakeStoreAccountPreparer(resourceGroupName string, accountName string, dataLakeStoreAccountName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":              autorest.Encode("path", accountName),
		"dataLakeStoreAccountName": autorest.Encode("path", dataLakeStoreAccountName),
		"resourceGroupName":        autorest.Encode("path", resourceGroupName),
		"subscriptionId":           autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/{dataLakeStoreAccountName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetDataLakeStoreAccountSender sends the GetDataLakeStoreAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetDataLakeStoreAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetDataLakeStoreAccountResponder handles the response to the GetDataLakeStoreAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) GetDataLakeStoreAccountResponder(resp *http.Response) (result DataLakeStoreAccountInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetStorageAccount gets the specified Azure Storage account linked to the given Data Lake Analytics account.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which to retrieve Azure storage account details.
// storageAccountName is the name of the Azure Storage account for which to retrieve the details.
func (client GroupClient) GetStorageAccount(resourceGroupName string, accountName string, storageAccountName string) (result StorageAccountInfo, err error) {
	req, err := client.GetStorageAccountPreparer(resourceGroupName, accountName, storageAccountName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetStorageAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetStorageAccountSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetStorageAccount", resp, "Failure sending request")
		return
	}

	result, err = client.GetStorageAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetStorageAccount", resp, "Failure responding to request")
	}

	return
}

// GetStorageAccountPreparer prepares the GetStorageAccount request.
func (client GroupClient) GetStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetStorageAccountSender sends the GetStorageAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetStorageAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetStorageAccountResponder handles the response to the GetStorageAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) GetStorageAccountResponder(resp *http.Response) (result StorageAccountInfo, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetStorageContainer gets the specified Azure Storage container associated with the given Data Lake Analytics and
// Azure Storage accounts.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to retrieve blob container. storageAccountName is the name
// of the Azure storage account from which to retrieve the blob container. containerName is the name of the Azure
// storage container to retrieve
func (client GroupClient) GetStorageContainer(resourceGroupName string, accountName string, storageAccountName string, containerName string) (result BlobContainer, err error) {
	req, err := client.GetStorageContainerPreparer(resourceGroupName, accountName, storageAccountName, containerName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetStorageContainer", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetStorageContainerSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetStorageContainer", resp, "Failure sending request")
		return
	}

	result, err = client.GetStorageContainerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "GetStorageContainer", resp, "Failure responding to request")
	}

	return
}

// GetStorageContainerPreparer prepares the GetStorageContainer request.
func (client GroupClient) GetStorageContainerPreparer(resourceGroupName string, accountName string, storageAccountName string, containerName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"containerName":      autorest.Encode("path", containerName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}/Containers/{containerName}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetStorageContainerSender sends the GetStorageContainer request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) GetStorageContainerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetStorageContainerResponder handles the response to the GetStorageContainer request. The method always
// closes the http.Response Body.
func (client GroupClient) GetStorageContainerResponder(resp *http.Response) (result BlobContainer, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// List gets the first page of Data Lake Analytics accounts, if any, within the current subscription. This includes a
// link to the next page, if any.
//
// filter is oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to
// skip over before returning elements. Optional. expand is oData expansion. Expand related resources in line with the
// retrieved resources, e.g. Categories/$expand=Products would expand Product data in line with each Category entry.
// Optional. selectParameter is oData Select statement. Limits the properties on each entry to just those requested,
// e.g. Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the desired return format. Return the
// response in particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client GroupClient) List(filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (result DataLakeAnalyticsAccountListResult, err error) {
	req, err := client.ListPreparer(filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "List", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "List", resp, "Failure sending request")
		return
	}

	result, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "List", resp, "Failure responding to request")
	}

	return
}

// ListPreparer prepares the List request.
func (client GroupClient) ListPreparer(filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}
	if len(search) > 0 {
		queryParameters["$search"] = autorest.Encode("query", search)
	}
	if len(formatParameter) > 0 {
		queryParameters["$format"] = autorest.Encode("query", formatParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.DataLakeAnalytics/accounts", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListSender sends the List request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListResponder handles the response to the List request. The method always
// closes the http.Response Body.
func (client GroupClient) ListResponder(resp *http.Response) (result DataLakeAnalyticsAccountListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListNextResults retrieves the next set of results, if any.
func (client GroupClient) ListNextResults(lastResults DataLakeAnalyticsAccountListResult) (result DataLakeAnalyticsAccountListResult, err error) {
	req, err := lastResults.DataLakeAnalyticsAccountListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "List", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "List", resp, "Failure sending next results request")
	}

	result, err = client.ListResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "List", resp, "Failure responding to next results request")
	}

	return
}

// ListComplete gets all elements from the list without paging.
func (client GroupClient) ListComplete(filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string, cancel <-chan struct{}) (<-chan DataLakeAnalyticsAccount, <-chan error) {
	resultChan := make(chan DataLakeAnalyticsAccount)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.List(filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListByResourceGroup gets the first page of Data Lake Analytics accounts, if any, within a specific resource group.
// This includes a link to the next page, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. filter is
// oData filter. Optional. top is the number of items to return. Optional. skip is the number of items to skip over
// before returning elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved
// resources, e.g. Categories/$expand=Products would expand Product data in line with each Category entry. Optional.
// selectParameter is oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the return format. Return the response in
// particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client GroupClient) ListByResourceGroup(resourceGroupName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (result DataLakeAnalyticsAccountListResult, err error) {
	req, err := client.ListByResourceGroupPreparer(resourceGroupName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListByResourceGroup", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListByResourceGroupSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListByResourceGroup", resp, "Failure sending request")
		return
	}

	result, err = client.ListByResourceGroupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListByResourceGroup", resp, "Failure responding to request")
	}

	return
}

// ListByResourceGroupPreparer prepares the ListByResourceGroup request.
func (client GroupClient) ListByResourceGroupPreparer(resourceGroupName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}
	if len(search) > 0 {
		queryParameters["$search"] = autorest.Encode("query", search)
	}
	if len(formatParameter) > 0 {
		queryParameters["$format"] = autorest.Encode("query", formatParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListByResourceGroupSender sends the ListByResourceGroup request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListByResourceGroupSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListByResourceGroupResponder handles the response to the ListByResourceGroup request. The method always
// closes the http.Response Body.
func (client GroupClient) ListByResourceGroupResponder(resp *http.Response) (result DataLakeAnalyticsAccountListResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListByResourceGroupNextResults retrieves the next set of results, if any.
func (client GroupClient) ListByResourceGroupNextResults(lastResults DataLakeAnalyticsAccountListResult) (result DataLakeAnalyticsAccountListResult, err error) {
	req, err := lastResults.DataLakeAnalyticsAccountListResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListByResourceGroup", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListByResourceGroupSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListByResourceGroup", resp, "Failure sending next results request")
	}

	result, err = client.ListByResourceGroupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListByResourceGroup", resp, "Failure responding to next results request")
	}

	return
}

// ListByResourceGroupComplete gets all elements from the list without paging.
func (client GroupClient) ListByResourceGroupComplete(resourceGroupName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string, cancel <-chan struct{}) (<-chan DataLakeAnalyticsAccount, <-chan error) {
	resultChan := make(chan DataLakeAnalyticsAccount)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListByResourceGroup(resourceGroupName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListByResourceGroupNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListDataLakeStoreAccounts gets the first page of Data Lake Store accounts linked to the specified Data Lake
// Analytics account. The response includes a link to the next page, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to list Data Lake Store accounts. filter is oData filter.
// Optional. top is the number of items to return. Optional. skip is the number of items to skip over before returning
// elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved resources, e.g.
// Categories/$expand=Products would expand Product data in line with each Category entry. Optional. selectParameter is
// oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the desired return format. Return the
// response in particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client GroupClient) ListDataLakeStoreAccounts(resourceGroupName string, accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (result DataLakeAnalyticsAccountListDataLakeStoreResult, err error) {
	req, err := client.ListDataLakeStoreAccountsPreparer(resourceGroupName, accountName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListDataLakeStoreAccounts", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDataLakeStoreAccountsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListDataLakeStoreAccounts", resp, "Failure sending request")
		return
	}

	result, err = client.ListDataLakeStoreAccountsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListDataLakeStoreAccounts", resp, "Failure responding to request")
	}

	return
}

// ListDataLakeStoreAccountsPreparer prepares the ListDataLakeStoreAccounts request.
func (client GroupClient) ListDataLakeStoreAccountsPreparer(resourceGroupName string, accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":       autorest.Encode("path", accountName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}
	if len(search) > 0 {
		queryParameters["$search"] = autorest.Encode("query", search)
	}
	if len(formatParameter) > 0 {
		queryParameters["$format"] = autorest.Encode("query", formatParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/DataLakeStoreAccounts/", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListDataLakeStoreAccountsSender sends the ListDataLakeStoreAccounts request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListDataLakeStoreAccountsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListDataLakeStoreAccountsResponder handles the response to the ListDataLakeStoreAccounts request. The method always
// closes the http.Response Body.
func (client GroupClient) ListDataLakeStoreAccountsResponder(resp *http.Response) (result DataLakeAnalyticsAccountListDataLakeStoreResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListDataLakeStoreAccountsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListDataLakeStoreAccountsNextResults(lastResults DataLakeAnalyticsAccountListDataLakeStoreResult) (result DataLakeAnalyticsAccountListDataLakeStoreResult, err error) {
	req, err := lastResults.DataLakeAnalyticsAccountListDataLakeStoreResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListDataLakeStoreAccounts", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListDataLakeStoreAccountsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListDataLakeStoreAccounts", resp, "Failure sending next results request")
	}

	result, err = client.ListDataLakeStoreAccountsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListDataLakeStoreAccounts", resp, "Failure responding to next results request")
	}

	return
}

// ListDataLakeStoreAccountsComplete gets all elements from the list without paging.
func (client GroupClient) ListDataLakeStoreAccountsComplete(resourceGroupName string, accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string, cancel <-chan struct{}) (<-chan DataLakeStoreAccountInfo, <-chan error) {
	resultChan := make(chan DataLakeStoreAccountInfo)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListDataLakeStoreAccounts(resourceGroupName, accountName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListDataLakeStoreAccountsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListSasTokens gets the SAS token associated with the specified Data Lake Analytics and Azure Storage account and
// container combination.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account from which an Azure Storage account's SAS token is being requested.
// storageAccountName is the name of the Azure storage account for which the SAS token is being requested.
// containerName is the name of the Azure storage container for which the SAS token is being requested.
func (client GroupClient) ListSasTokens(resourceGroupName string, accountName string, storageAccountName string, containerName string) (result ListSasTokensResult, err error) {
	req, err := client.ListSasTokensPreparer(resourceGroupName, accountName, storageAccountName, containerName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListSasTokens", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSasTokensSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListSasTokens", resp, "Failure sending request")
		return
	}

	result, err = client.ListSasTokensResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListSasTokens", resp, "Failure responding to request")
	}

	return
}

// ListSasTokensPreparer prepares the ListSasTokens request.
func (client GroupClient) ListSasTokensPreparer(resourceGroupName string, accountName string, storageAccountName string, containerName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"containerName":      autorest.Encode("path", containerName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}/Containers/{containerName}/listSasTokens", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListSasTokensSender sends the ListSasTokens request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListSasTokensSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListSasTokensResponder handles the response to the ListSasTokens request. The method always
// closes the http.Response Body.
func (client GroupClient) ListSasTokensResponder(resp *http.Response) (result ListSasTokensResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListSasTokensNextResults retrieves the next set of results, if any.
func (client GroupClient) ListSasTokensNextResults(lastResults ListSasTokensResult) (result ListSasTokensResult, err error) {
	req, err := lastResults.ListSasTokensResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListSasTokens", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListSasTokensSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListSasTokens", resp, "Failure sending next results request")
	}

	result, err = client.ListSasTokensResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListSasTokens", resp, "Failure responding to next results request")
	}

	return
}

// ListSasTokensComplete gets all elements from the list without paging.
func (client GroupClient) ListSasTokensComplete(resourceGroupName string, accountName string, storageAccountName string, containerName string, cancel <-chan struct{}) (<-chan SasTokenInfo, <-chan error) {
	resultChan := make(chan SasTokenInfo)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListSasTokens(resourceGroupName, accountName, storageAccountName, containerName)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListSasTokensNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListStorageAccounts gets the first page of Azure Storage accounts, if any, linked to the specified Data Lake
// Analytics account. The response includes a link to the next page, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to list Azure Storage accounts. filter is the OData filter.
// Optional. top is the number of items to return. Optional. skip is the number of items to skip over before returning
// elements. Optional. expand is oData expansion. Expand related resources in line with the retrieved resources, e.g.
// Categories/$expand=Products would expand Product data in line with each Category entry. Optional. selectParameter is
// oData Select statement. Limits the properties on each entry to just those requested, e.g.
// Categories?$select=CategoryName,Description. Optional. orderby is orderBy clause. One or more comma-separated
// expressions with an optional "asc" (the default) or "desc" depending on the order you'd like the values sorted, e.g.
// Categories?$orderby=CategoryName desc. Optional. count is the Boolean value of true or false to request a count of
// the matching resources included with the resources in the response, e.g. Categories?$count=true. Optional. search is
// a free form search. A free-text search expression to match for whether a particular entry should be included in the
// feed, e.g. Categories?$search=blue OR green. Optional. formatParameter is the desired return format. Return the
// response in particular formatxii without access to request headers for standard content-type negotiation (e.g
// Orders?$format=json). Optional.
func (client GroupClient) ListStorageAccounts(resourceGroupName string, accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (result DataLakeAnalyticsAccountListStorageAccountsResult, err error) {
	req, err := client.ListStorageAccountsPreparer(resourceGroupName, accountName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageAccounts", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListStorageAccountsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageAccounts", resp, "Failure sending request")
		return
	}

	result, err = client.ListStorageAccountsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageAccounts", resp, "Failure responding to request")
	}

	return
}

// ListStorageAccountsPreparer prepares the ListStorageAccounts request.
func (client GroupClient) ListStorageAccountsPreparer(resourceGroupName string, accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":       autorest.Encode("path", accountName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if top != nil {
		queryParameters["$top"] = autorest.Encode("query", *top)
	}
	if skip != nil {
		queryParameters["$skip"] = autorest.Encode("query", *skip)
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(selectParameter) > 0 {
		queryParameters["$select"] = autorest.Encode("query", selectParameter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if count != nil {
		queryParameters["$count"] = autorest.Encode("query", *count)
	}
	if len(search) > 0 {
		queryParameters["$search"] = autorest.Encode("query", search)
	}
	if len(formatParameter) > 0 {
		queryParameters["$format"] = autorest.Encode("query", formatParameter)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListStorageAccountsSender sends the ListStorageAccounts request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListStorageAccountsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListStorageAccountsResponder handles the response to the ListStorageAccounts request. The method always
// closes the http.Response Body.
func (client GroupClient) ListStorageAccountsResponder(resp *http.Response) (result DataLakeAnalyticsAccountListStorageAccountsResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListStorageAccountsNextResults retrieves the next set of results, if any.
func (client GroupClient) ListStorageAccountsNextResults(lastResults DataLakeAnalyticsAccountListStorageAccountsResult) (result DataLakeAnalyticsAccountListStorageAccountsResult, err error) {
	req, err := lastResults.DataLakeAnalyticsAccountListStorageAccountsResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageAccounts", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListStorageAccountsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageAccounts", resp, "Failure sending next results request")
	}

	result, err = client.ListStorageAccountsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageAccounts", resp, "Failure responding to next results request")
	}

	return
}

// ListStorageAccountsComplete gets all elements from the list without paging.
func (client GroupClient) ListStorageAccountsComplete(resourceGroupName string, accountName string, filter string, top *int32, skip *int32, expand string, selectParameter string, orderby string, count *bool, search string, formatParameter string, cancel <-chan struct{}) (<-chan StorageAccountInfo, <-chan error) {
	resultChan := make(chan StorageAccountInfo)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListStorageAccounts(resourceGroupName, accountName, filter, top, skip, expand, selectParameter, orderby, count, search, formatParameter)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListStorageAccountsNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// ListStorageContainers lists the Azure Storage containers, if any, associated with the specified Data Lake Analytics
// and Azure Storage account combination. The response includes a link to the next page of results, if any.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account for which to list Azure Storage blob containers. storageAccountName
// is the name of the Azure storage account from which to list blob containers.
func (client GroupClient) ListStorageContainers(resourceGroupName string, accountName string, storageAccountName string) (result ListBlobContainersResult, err error) {
	req, err := client.ListStorageContainersPreparer(resourceGroupName, accountName, storageAccountName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageContainers", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListStorageContainersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageContainers", resp, "Failure sending request")
		return
	}

	result, err = client.ListStorageContainersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageContainers", resp, "Failure responding to request")
	}

	return
}

// ListStorageContainersPreparer prepares the ListStorageContainers request.
func (client GroupClient) ListStorageContainersPreparer(resourceGroupName string, accountName string, storageAccountName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}/Containers", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListStorageContainersSender sends the ListStorageContainers request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) ListStorageContainersSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListStorageContainersResponder handles the response to the ListStorageContainers request. The method always
// closes the http.Response Body.
func (client GroupClient) ListStorageContainersResponder(resp *http.Response) (result ListBlobContainersResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListStorageContainersNextResults retrieves the next set of results, if any.
func (client GroupClient) ListStorageContainersNextResults(lastResults ListBlobContainersResult) (result ListBlobContainersResult, err error) {
	req, err := lastResults.ListBlobContainersResultPreparer()
	if err != nil {
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageContainers", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}

	resp, err := client.ListStorageContainersSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageContainers", resp, "Failure sending next results request")
	}

	result, err = client.ListStorageContainersResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "ListStorageContainers", resp, "Failure responding to next results request")
	}

	return
}

// ListStorageContainersComplete gets all elements from the list without paging.
func (client GroupClient) ListStorageContainersComplete(resourceGroupName string, accountName string, storageAccountName string, cancel <-chan struct{}) (<-chan BlobContainer, <-chan error) {
	resultChan := make(chan BlobContainer)
	errChan := make(chan error, 1)
	go func() {
		defer func() {
			close(resultChan)
			close(errChan)
		}()
		list, err := client.ListStorageContainers(resourceGroupName, accountName, storageAccountName)
		if err != nil {
			errChan <- err
			return
		}
		if list.Value != nil {
			for _, item := range *list.Value {
				select {
				case <-cancel:
					return
				case resultChan <- item:
					// Intentionally left blank
				}
			}
		}
		for list.NextLink != nil {
			list, err = client.ListStorageContainersNextResults(list)
			if err != nil {
				errChan <- err
				return
			}
			if list.Value != nil {
				for _, item := range *list.Value {
					select {
					case <-cancel:
						return
					case resultChan <- item:
						// Intentionally left blank
					}
				}
			}
		}
	}()
	return resultChan, errChan
}

// Update updates the Data Lake Analytics account object specified by the accountName with the contents of the account
// object. This method may poll for completion. Polling can be canceled by passing the cancel channel argument. The
// channel will be used to cancel polling and any outstanding HTTP requests.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. name is the
// name of the Data Lake Analytics account to update. parameters is parameters supplied to the update Data Lake
// Analytics account operation.
func (client GroupClient) Update(resourceGroupName string, name string, parameters DataLakeAnalyticsAccount, cancel <-chan struct{}) (<-chan DataLakeAnalyticsAccount, <-chan error) {
	resultChan := make(chan DataLakeAnalyticsAccount, 1)
	errChan := make(chan error, 1)
	go func() {
		var err error
		var result DataLakeAnalyticsAccount
		defer func() {
			if err != nil {
				errChan <- err
			}
			resultChan <- result
			close(resultChan)
			close(errChan)
		}()
		req, err := client.UpdatePreparer(resourceGroupName, name, parameters, cancel)
		if err != nil {
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Update", nil, "Failure preparing request")
			return
		}

		resp, err := client.UpdateSender(req)
		if err != nil {
			result.Response = autorest.Response{Response: resp}
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Update", resp, "Failure sending request")
			return
		}

		result, err = client.UpdateResponder(resp)
		if err != nil {
			err = autorest.NewErrorWithError(err, "account.GroupClient", "Update", resp, "Failure responding to request")
		}
	}()
	return resultChan, errChan
}

// UpdatePreparer prepares the Update request.
func (client GroupClient) UpdatePreparer(resourceGroupName string, name string, parameters DataLakeAnalyticsAccount, cancel <-chan struct{}) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"name":              autorest.Encode("path", name),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{name}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{Cancel: cancel})
}

// UpdateSender sends the Update request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) UpdateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client,
		req,
		azure.DoPollForAsynchronous(client.PollingDelay))
}

// UpdateResponder handles the response to the Update request. The method always
// closes the http.Response Body.
func (client GroupClient) UpdateResponder(resp *http.Response) (result DataLakeAnalyticsAccount, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateStorageAccount updates the Data Lake Analytics account to replace Azure Storage blob account details, such as
// the access key and/or suffix.
//
// resourceGroupName is the name of the Azure resource group that contains the Data Lake Analytics account. accountName
// is the name of the Data Lake Analytics account to modify storage accounts in storageAccountName is the Azure Storage
// account to modify parameters is the parameters containing the access key and suffix to update the storage account
// with.
func (client GroupClient) UpdateStorageAccount(resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (result autorest.Response, err error) {
	req, err := client.UpdateStorageAccountPreparer(resourceGroupName, accountName, storageAccountName, parameters)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "UpdateStorageAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateStorageAccountSender(req)
	if err != nil {
		result.Response = resp
		err = autorest.NewErrorWithError(err, "account.GroupClient", "UpdateStorageAccount", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateStorageAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "account.GroupClient", "UpdateStorageAccount", resp, "Failure responding to request")
	}

	return
}

// UpdateStorageAccountPreparer prepares the UpdateStorageAccount request.
func (client GroupClient) UpdateStorageAccountPreparer(resourceGroupName string, accountName string, storageAccountName string, parameters AddStorageAccountParameters) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"accountName":        autorest.Encode("path", accountName),
		"resourceGroupName":  autorest.Encode("path", resourceGroupName),
		"storageAccountName": autorest.Encode("path", storageAccountName),
		"subscriptionId":     autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2015-10-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsJSON(),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataLakeAnalytics/accounts/{accountName}/StorageAccounts/{storageAccountName}", pathParameters),
		autorest.WithJSON(parameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// UpdateStorageAccountSender sends the UpdateStorageAccount request. The method will close the
// http.Response Body if it receives an error.
func (client GroupClient) UpdateStorageAccountSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// UpdateStorageAccountResponder handles the response to the UpdateStorageAccount request. The method always
// closes the http.Response Body.
func (client GroupClient) UpdateStorageAccountResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
