package graphrbac

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/graphrbac/1.6/graphrbac"

// ObjectType enumerates the values for object type.
type ObjectType string

const (
	// ObjectTypeApplication ...
	ObjectTypeApplication ObjectType = "Application"
	// ObjectTypeDirectoryObject ...
	ObjectTypeDirectoryObject ObjectType = "DirectoryObject"
	// ObjectTypeGroup ...
	ObjectTypeGroup ObjectType = "Group"
	// ObjectTypeServicePrincipal ...
	ObjectTypeServicePrincipal ObjectType = "ServicePrincipal"
	// ObjectTypeUser ...
	ObjectTypeUser ObjectType = "User"
)

// PossibleObjectTypeValues returns an array of possible values for the ObjectType const type.
func PossibleObjectTypeValues() []ObjectType {
	return []ObjectType{ObjectTypeApplication, ObjectTypeDirectoryObject, ObjectTypeGroup, ObjectTypeServicePrincipal, ObjectTypeUser}
}

// UserType enumerates the values for user type.
type UserType string

const (
	// Guest ...
	Guest UserType = "Guest"
	// Member ...
	Member UserType = "Member"
)

// PossibleUserTypeValues returns an array of possible values for the UserType const type.
func PossibleUserTypeValues() []UserType {
	return []UserType{Guest, Member}
}

// AddOwnerParameters request parameters for adding a owner to an application.
type AddOwnerParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// URL - A owner object URL, such as "https://graph.windows.net/0b1f9851-1bf0-433f-aec3-cb9272f093dc/directoryObjects/f260bbc4-c254-447b-94cf-293b5ec434dd", where "0b1f9851-1bf0-433f-aec3-cb9272f093dc" is the tenantId and "f260bbc4-c254-447b-94cf-293b5ec434dd" is the objectId of the owner (user, application, servicePrincipal, group) to be added.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for AddOwnerParameters.
func (aop AddOwnerParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aop.URL != nil {
		objectMap["url"] = aop.URL
	}
	for k, v := range aop.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AddOwnerParameters struct.
func (aop *AddOwnerParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if aop.AdditionalProperties == nil {
					aop.AdditionalProperties = make(map[string]interface{})
				}
				aop.AdditionalProperties[k] = additionalProperties
			}
		case "url":
			if v != nil {
				var URL string
				err = json.Unmarshal(*v, &URL)
				if err != nil {
					return err
				}
				aop.URL = &URL
			}
		}
	}

	return nil
}

// ADGroup active Directory group information.
type ADGroup struct {
	autorest.Response `json:"-"`
	// DisplayName - The display name of the group.
	DisplayName *string `json:"displayName,omitempty"`
	// MailEnabled - Whether the group is mail-enabled. Must be false. This is because only pure security groups can be created using the Graph API.
	MailEnabled *bool `json:"mailEnabled,omitempty"`
	// MailNickname - The mail alias for the group.
	MailNickname *string `json:"mailNickname,omitempty"`
	// SecurityEnabled - Whether the group is security-enable.
	SecurityEnabled *bool `json:"securityEnabled,omitempty"`
	// Mail - The primary email address of the group.
	Mail *string `json:"mail,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ObjectID - The object ID.
	ObjectID *string `json:"objectId,omitempty"`
	// DeletionTimestamp - The time at which the directory object was deleted.
	DeletionTimestamp *date.Time `json:"deletionTimestamp,omitempty"`
	// ObjectType - Possible values include: 'ObjectTypeDirectoryObject', 'ObjectTypeApplication', 'ObjectTypeGroup', 'ObjectTypeServicePrincipal', 'ObjectTypeUser'
	ObjectType ObjectType `json:"objectType,omitempty"`
}

// MarshalJSON is the custom marshaler for ADGroup.
func (ag ADGroup) MarshalJSON() ([]byte, error) {
	ag.ObjectType = ObjectTypeGroup
	objectMap := make(map[string]interface{})
	if ag.DisplayName != nil {
		objectMap["displayName"] = ag.DisplayName
	}
	if ag.MailEnabled != nil {
		objectMap["mailEnabled"] = ag.MailEnabled
	}
	if ag.MailNickname != nil {
		objectMap["mailNickname"] = ag.MailNickname
	}
	if ag.SecurityEnabled != nil {
		objectMap["securityEnabled"] = ag.SecurityEnabled
	}
	if ag.Mail != nil {
		objectMap["mail"] = ag.Mail
	}
	if ag.ObjectID != nil {
		objectMap["objectId"] = ag.ObjectID
	}
	if ag.DeletionTimestamp != nil {
		objectMap["deletionTimestamp"] = ag.DeletionTimestamp
	}
	if ag.ObjectType != "" {
		objectMap["objectType"] = ag.ObjectType
	}
	for k, v := range ag.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// AsApplication is the BasicDirectoryObject implementation for ADGroup.
func (ag ADGroup) AsApplication() (*Application, bool) {
	return nil, false
}

// AsADGroup is the BasicDirectoryObject implementation for ADGroup.
func (ag ADGroup) AsADGroup() (*ADGroup, bool) {
	return &ag, true
}

// AsServicePrincipal is the BasicDirectoryObject implementation for ADGroup.
func (ag ADGroup) AsServicePrincipal() (*ServicePrincipal, bool) {
	return nil, false
}

// AsUser is the BasicDirectoryObject implementation for ADGroup.
func (ag ADGroup) AsUser() (*User, bool) {
	return nil, false
}

// AsDirectoryObject is the BasicDirectoryObject implementation for ADGroup.
func (ag ADGroup) AsDirectoryObject() (*DirectoryObject, bool) {
	return nil, false
}

// AsBasicDirectoryObject is the BasicDirectoryObject implementation for ADGroup.
func (ag ADGroup) AsBasicDirectoryObject() (BasicDirectoryObject, bool) {
	return &ag, true
}

// UnmarshalJSON is the custom unmarshaler for ADGroup struct.
func (ag *ADGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				ag.DisplayName = &displayName
			}
		case "mailEnabled":
			if v != nil {
				var mailEnabled bool
				err = json.Unmarshal(*v, &mailEnabled)
				if err != nil {
					return err
				}
				ag.MailEnabled = &mailEnabled
			}
		case "mailNickname":
			if v != nil {
				var mailNickname string
				err = json.Unmarshal(*v, &mailNickname)
				if err != nil {
					return err
				}
				ag.MailNickname = &mailNickname
			}
		case "securityEnabled":
			if v != nil {
				var securityEnabled bool
				err = json.Unmarshal(*v, &securityEnabled)
				if err != nil {
					return err
				}
				ag.SecurityEnabled = &securityEnabled
			}
		case "mail":
			if v != nil {
				var mailVar string
				err = json.Unmarshal(*v, &mailVar)
				if err != nil {
					return err
				}
				ag.Mail = &mailVar
			}
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ag.AdditionalProperties == nil {
					ag.AdditionalProperties = make(map[string]interface{})
				}
				ag.AdditionalProperties[k] = additionalProperties
			}
		case "objectId":
			if v != nil {
				var objectID string
				err = json.Unmarshal(*v, &objectID)
				if err != nil {
					return err
				}
				ag.ObjectID = &objectID
			}
		case "deletionTimestamp":
			if v != nil {
				var deletionTimestamp date.Time
				err = json.Unmarshal(*v, &deletionTimestamp)
				if err != nil {
					return err
				}
				ag.DeletionTimestamp = &deletionTimestamp
			}
		case "objectType":
			if v != nil {
				var objectType ObjectType
				err = json.Unmarshal(*v, &objectType)
				if err != nil {
					return err
				}
				ag.ObjectType = objectType
			}
		}
	}

	return nil
}

// Application active Directory application information.
type Application struct {
	autorest.Response `json:"-"`
	// AppID - The application ID.
	AppID *string `json:"appId,omitempty"`
	// AppRoles - The collection of application roles that an application may declare. These roles can be assigned to users, groups or service principals.
	AppRoles *[]AppRole `json:"appRoles,omitempty"`
	// AppPermissions - The application permissions.
	AppPermissions *[]string `json:"appPermissions,omitempty"`
	// AvailableToOtherTenants - Whether the application is be available to other tenants.
	AvailableToOtherTenants *bool `json:"availableToOtherTenants,omitempty"`
	// DisplayName - The display name of the application.
	DisplayName *string `json:"displayName,omitempty"`
	// IdentifierUris - A collection of URIs for the application.
	IdentifierUris *[]string `json:"identifierUris,omitempty"`
	// ReplyUrls - A collection of reply URLs for the application.
	ReplyUrls *[]string `json:"replyUrls,omitempty"`
	// Homepage - The home page of the application.
	Homepage *string `json:"homepage,omitempty"`
	// Oauth2AllowImplicitFlow - Whether to allow implicit grant flow for OAuth2
	Oauth2AllowImplicitFlow *bool `json:"oauth2AllowImplicitFlow,omitempty"`
	// RequiredResourceAccess - Specifies resources that this application requires access to and the set of OAuth permission scopes and application roles that it needs under each of those resources. This pre-configuration of required resource access drives the consent experience.
	RequiredResourceAccess *[]RequiredResourceAccess `json:"requiredResourceAccess,omitempty"`
	// KeyCredentials - A collection of KeyCredential objects.
	KeyCredentials *[]KeyCredential `json:"keyCredentials,omitempty"`
	// PasswordCredentials - A collection of PasswordCredential objects
	PasswordCredentials *[]PasswordCredential `json:"passwordCredentials,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ObjectID - The object ID.
	ObjectID *string `json:"objectId,omitempty"`
	// DeletionTimestamp - The time at which the directory object was deleted.
	DeletionTimestamp *date.Time `json:"deletionTimestamp,omitempty"`
	// ObjectType - Possible values include: 'ObjectTypeDirectoryObject', 'ObjectTypeApplication', 'ObjectTypeGroup', 'ObjectTypeServicePrincipal', 'ObjectTypeUser'
	ObjectType ObjectType `json:"objectType,omitempty"`
}

// MarshalJSON is the custom marshaler for Application.
func (a Application) MarshalJSON() ([]byte, error) {
	a.ObjectType = ObjectTypeApplication
	objectMap := make(map[string]interface{})
	if a.AppID != nil {
		objectMap["appId"] = a.AppID
	}
	if a.AppRoles != nil {
		objectMap["appRoles"] = a.AppRoles
	}
	if a.AppPermissions != nil {
		objectMap["appPermissions"] = a.AppPermissions
	}
	if a.AvailableToOtherTenants != nil {
		objectMap["availableToOtherTenants"] = a.AvailableToOtherTenants
	}
	if a.DisplayName != nil {
		objectMap["displayName"] = a.DisplayName
	}
	if a.IdentifierUris != nil {
		objectMap["identifierUris"] = a.IdentifierUris
	}
	if a.ReplyUrls != nil {
		objectMap["replyUrls"] = a.ReplyUrls
	}
	if a.Homepage != nil {
		objectMap["homepage"] = a.Homepage
	}
	if a.Oauth2AllowImplicitFlow != nil {
		objectMap["oauth2AllowImplicitFlow"] = a.Oauth2AllowImplicitFlow
	}
	if a.RequiredResourceAccess != nil {
		objectMap["requiredResourceAccess"] = a.RequiredResourceAccess
	}
	if a.KeyCredentials != nil {
		objectMap["keyCredentials"] = a.KeyCredentials
	}
	if a.PasswordCredentials != nil {
		objectMap["passwordCredentials"] = a.PasswordCredentials
	}
	if a.ObjectID != nil {
		objectMap["objectId"] = a.ObjectID
	}
	if a.DeletionTimestamp != nil {
		objectMap["deletionTimestamp"] = a.DeletionTimestamp
	}
	if a.ObjectType != "" {
		objectMap["objectType"] = a.ObjectType
	}
	for k, v := range a.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// AsApplication is the BasicDirectoryObject implementation for Application.
func (a Application) AsApplication() (*Application, bool) {
	return &a, true
}

// AsADGroup is the BasicDirectoryObject implementation for Application.
func (a Application) AsADGroup() (*ADGroup, bool) {
	return nil, false
}

// AsServicePrincipal is the BasicDirectoryObject implementation for Application.
func (a Application) AsServicePrincipal() (*ServicePrincipal, bool) {
	return nil, false
}

// AsUser is the BasicDirectoryObject implementation for Application.
func (a Application) AsUser() (*User, bool) {
	return nil, false
}

// AsDirectoryObject is the BasicDirectoryObject implementation for Application.
func (a Application) AsDirectoryObject() (*DirectoryObject, bool) {
	return nil, false
}

// AsBasicDirectoryObject is the BasicDirectoryObject implementation for Application.
func (a Application) AsBasicDirectoryObject() (BasicDirectoryObject, bool) {
	return &a, true
}

// UnmarshalJSON is the custom unmarshaler for Application struct.
func (a *Application) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "appId":
			if v != nil {
				var appID string
				err = json.Unmarshal(*v, &appID)
				if err != nil {
					return err
				}
				a.AppID = &appID
			}
		case "appRoles":
			if v != nil {
				var appRoles []AppRole
				err = json.Unmarshal(*v, &appRoles)
				if err != nil {
					return err
				}
				a.AppRoles = &appRoles
			}
		case "appPermissions":
			if v != nil {
				var appPermissions []string
				err = json.Unmarshal(*v, &appPermissions)
				if err != nil {
					return err
				}
				a.AppPermissions = &appPermissions
			}
		case "availableToOtherTenants":
			if v != nil {
				var availableToOtherTenants bool
				err = json.Unmarshal(*v, &availableToOtherTenants)
				if err != nil {
					return err
				}
				a.AvailableToOtherTenants = &availableToOtherTenants
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				a.DisplayName = &displayName
			}
		case "identifierUris":
			if v != nil {
				var identifierUris []string
				err = json.Unmarshal(*v, &identifierUris)
				if err != nil {
					return err
				}
				a.IdentifierUris = &identifierUris
			}
		case "replyUrls":
			if v != nil {
				var replyUrls []string
				err = json.Unmarshal(*v, &replyUrls)
				if err != nil {
					return err
				}
				a.ReplyUrls = &replyUrls
			}
		case "homepage":
			if v != nil {
				var homepage string
				err = json.Unmarshal(*v, &homepage)
				if err != nil {
					return err
				}
				a.Homepage = &homepage
			}
		case "oauth2AllowImplicitFlow":
			if v != nil {
				var oauth2AllowImplicitFlow bool
				err = json.Unmarshal(*v, &oauth2AllowImplicitFlow)
				if err != nil {
					return err
				}
				a.Oauth2AllowImplicitFlow = &oauth2AllowImplicitFlow
			}
		case "requiredResourceAccess":
			if v != nil {
				var requiredResourceAccess []RequiredResourceAccess
				err = json.Unmarshal(*v, &requiredResourceAccess)
				if err != nil {
					return err
				}
				a.RequiredResourceAccess = &requiredResourceAccess
			}
		case "keyCredentials":
			if v != nil {
				var keyCredentials []KeyCredential
				err = json.Unmarshal(*v, &keyCredentials)
				if err != nil {
					return err
				}
				a.KeyCredentials = &keyCredentials
			}
		case "passwordCredentials":
			if v != nil {
				var passwordCredentials []PasswordCredential
				err = json.Unmarshal(*v, &passwordCredentials)
				if err != nil {
					return err
				}
				a.PasswordCredentials = &passwordCredentials
			}
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if a.AdditionalProperties == nil {
					a.AdditionalProperties = make(map[string]interface{})
				}
				a.AdditionalProperties[k] = additionalProperties
			}
		case "objectId":
			if v != nil {
				var objectID string
				err = json.Unmarshal(*v, &objectID)
				if err != nil {
					return err
				}
				a.ObjectID = &objectID
			}
		case "deletionTimestamp":
			if v != nil {
				var deletionTimestamp date.Time
				err = json.Unmarshal(*v, &deletionTimestamp)
				if err != nil {
					return err
				}
				a.DeletionTimestamp = &deletionTimestamp
			}
		case "objectType":
			if v != nil {
				var objectType ObjectType
				err = json.Unmarshal(*v, &objectType)
				if err != nil {
					return err
				}
				a.ObjectType = objectType
			}
		}
	}

	return nil
}

// ApplicationCreateParameters request parameters for creating a new application.
type ApplicationCreateParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// AppRoles - The collection of application roles that an application may declare. These roles can be assigned to users, groups or service principals.
	AppRoles *[]AppRole `json:"appRoles,omitempty"`
	// AvailableToOtherTenants - Whether the application is available to other tenants.
	AvailableToOtherTenants *bool `json:"availableToOtherTenants,omitempty"`
	// DisplayName - The display name of the application.
	DisplayName *string `json:"displayName,omitempty"`
	// Homepage - The home page of the application.
	Homepage *string `json:"homepage,omitempty"`
	// IdentifierUris - A collection of URIs for the application.
	IdentifierUris *[]string `json:"identifierUris,omitempty"`
	// ReplyUrls - A collection of reply URLs for the application.
	ReplyUrls *[]string `json:"replyUrls,omitempty"`
	// KeyCredentials - The list of KeyCredential objects.
	KeyCredentials *[]KeyCredential `json:"keyCredentials,omitempty"`
	// PasswordCredentials - The list of PasswordCredential objects.
	PasswordCredentials *[]PasswordCredential `json:"passwordCredentials,omitempty"`
	// Oauth2AllowImplicitFlow - Whether to allow implicit grant flow for OAuth2
	Oauth2AllowImplicitFlow *bool `json:"oauth2AllowImplicitFlow,omitempty"`
	// RequiredResourceAccess - Specifies resources that this application requires access to and the set of OAuth permission scopes and application roles that it needs under each of those resources. This pre-configuration of required resource access drives the consent experience.
	RequiredResourceAccess *[]RequiredResourceAccess `json:"requiredResourceAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationCreateParameters.
func (acp ApplicationCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if acp.AppRoles != nil {
		objectMap["appRoles"] = acp.AppRoles
	}
	if acp.AvailableToOtherTenants != nil {
		objectMap["availableToOtherTenants"] = acp.AvailableToOtherTenants
	}
	if acp.DisplayName != nil {
		objectMap["displayName"] = acp.DisplayName
	}
	if acp.Homepage != nil {
		objectMap["homepage"] = acp.Homepage
	}
	if acp.IdentifierUris != nil {
		objectMap["identifierUris"] = acp.IdentifierUris
	}
	if acp.ReplyUrls != nil {
		objectMap["replyUrls"] = acp.ReplyUrls
	}
	if acp.KeyCredentials != nil {
		objectMap["keyCredentials"] = acp.KeyCredentials
	}
	if acp.PasswordCredentials != nil {
		objectMap["passwordCredentials"] = acp.PasswordCredentials
	}
	if acp.Oauth2AllowImplicitFlow != nil {
		objectMap["oauth2AllowImplicitFlow"] = acp.Oauth2AllowImplicitFlow
	}
	if acp.RequiredResourceAccess != nil {
		objectMap["requiredResourceAccess"] = acp.RequiredResourceAccess
	}
	for k, v := range acp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationCreateParameters struct.
func (acp *ApplicationCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if acp.AdditionalProperties == nil {
					acp.AdditionalProperties = make(map[string]interface{})
				}
				acp.AdditionalProperties[k] = additionalProperties
			}
		case "appRoles":
			if v != nil {
				var appRoles []AppRole
				err = json.Unmarshal(*v, &appRoles)
				if err != nil {
					return err
				}
				acp.AppRoles = &appRoles
			}
		case "availableToOtherTenants":
			if v != nil {
				var availableToOtherTenants bool
				err = json.Unmarshal(*v, &availableToOtherTenants)
				if err != nil {
					return err
				}
				acp.AvailableToOtherTenants = &availableToOtherTenants
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				acp.DisplayName = &displayName
			}
		case "homepage":
			if v != nil {
				var homepage string
				err = json.Unmarshal(*v, &homepage)
				if err != nil {
					return err
				}
				acp.Homepage = &homepage
			}
		case "identifierUris":
			if v != nil {
				var identifierUris []string
				err = json.Unmarshal(*v, &identifierUris)
				if err != nil {
					return err
				}
				acp.IdentifierUris = &identifierUris
			}
		case "replyUrls":
			if v != nil {
				var replyUrls []string
				err = json.Unmarshal(*v, &replyUrls)
				if err != nil {
					return err
				}
				acp.ReplyUrls = &replyUrls
			}
		case "keyCredentials":
			if v != nil {
				var keyCredentials []KeyCredential
				err = json.Unmarshal(*v, &keyCredentials)
				if err != nil {
					return err
				}
				acp.KeyCredentials = &keyCredentials
			}
		case "passwordCredentials":
			if v != nil {
				var passwordCredentials []PasswordCredential
				err = json.Unmarshal(*v, &passwordCredentials)
				if err != nil {
					return err
				}
				acp.PasswordCredentials = &passwordCredentials
			}
		case "oauth2AllowImplicitFlow":
			if v != nil {
				var oauth2AllowImplicitFlow bool
				err = json.Unmarshal(*v, &oauth2AllowImplicitFlow)
				if err != nil {
					return err
				}
				acp.Oauth2AllowImplicitFlow = &oauth2AllowImplicitFlow
			}
		case "requiredResourceAccess":
			if v != nil {
				var requiredResourceAccess []RequiredResourceAccess
				err = json.Unmarshal(*v, &requiredResourceAccess)
				if err != nil {
					return err
				}
				acp.RequiredResourceAccess = &requiredResourceAccess
			}
		}
	}

	return nil
}

// ApplicationListResult application list operation result.
type ApplicationListResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of applications.
	Value *[]Application `json:"value,omitempty"`
	// OdataNextLink - The URL to get the next set of results.
	OdataNextLink *string `json:"odata.nextLink,omitempty"`
}

// ApplicationListResultIterator provides access to a complete listing of Application values.
type ApplicationListResultIterator struct {
	i    int
	page ApplicationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ApplicationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ApplicationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ApplicationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ApplicationListResultIterator) Response() ApplicationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ApplicationListResultIterator) Value() Application {
	if !iter.page.NotDone() {
		return Application{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ApplicationListResultIterator type.
func NewApplicationListResultIterator(page ApplicationListResultPage) ApplicationListResultIterator {
	return ApplicationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (alr ApplicationListResult) IsEmpty() bool {
	return alr.Value == nil || len(*alr.Value) == 0
}

// ApplicationListResultPage contains a page of Application values.
type ApplicationListResultPage struct {
	fn  func(context.Context, ApplicationListResult) (ApplicationListResult, error)
	alr ApplicationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ApplicationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ApplicationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.alr)
	if err != nil {
		return err
	}
	page.alr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ApplicationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ApplicationListResultPage) NotDone() bool {
	return !page.alr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ApplicationListResultPage) Response() ApplicationListResult {
	return page.alr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ApplicationListResultPage) Values() []Application {
	if page.alr.IsEmpty() {
		return nil
	}
	return *page.alr.Value
}

// Creates a new instance of the ApplicationListResultPage type.
func NewApplicationListResultPage(getNextPage func(context.Context, ApplicationListResult) (ApplicationListResult, error)) ApplicationListResultPage {
	return ApplicationListResultPage{fn: getNextPage}
}

// ApplicationUpdateParameters request parameters for updating an existing application.
type ApplicationUpdateParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// AppRoles - The collection of application roles that an application may declare. These roles can be assigned to users, groups or service principals.
	AppRoles *[]AppRole `json:"appRoles,omitempty"`
	// AvailableToOtherTenants - Whether the application is available to other tenants
	AvailableToOtherTenants *bool `json:"availableToOtherTenants,omitempty"`
	// DisplayName - The display name of the application.
	DisplayName *string `json:"displayName,omitempty"`
	// Homepage - The home page of the application.
	Homepage *string `json:"homepage,omitempty"`
	// IdentifierUris - A collection of URIs for the application.
	IdentifierUris *[]string `json:"identifierUris,omitempty"`
	// ReplyUrls - A collection of reply URLs for the application.
	ReplyUrls *[]string `json:"replyUrls,omitempty"`
	// KeyCredentials - The list of KeyCredential objects.
	KeyCredentials *[]KeyCredential `json:"keyCredentials,omitempty"`
	// PasswordCredentials - The list of PasswordCredential objects.
	PasswordCredentials *[]PasswordCredential `json:"passwordCredentials,omitempty"`
	// Oauth2AllowImplicitFlow - Whether to allow implicit grant flow for OAuth2
	Oauth2AllowImplicitFlow *bool `json:"oauth2AllowImplicitFlow,omitempty"`
	// RequiredResourceAccess - Specifies resources that this application requires access to and the set of OAuth permission scopes and application roles that it needs under each of those resources. This pre-configuration of required resource access drives the consent experience.
	RequiredResourceAccess *[]RequiredResourceAccess `json:"requiredResourceAccess,omitempty"`
}

// MarshalJSON is the custom marshaler for ApplicationUpdateParameters.
func (aup ApplicationUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aup.AppRoles != nil {
		objectMap["appRoles"] = aup.AppRoles
	}
	if aup.AvailableToOtherTenants != nil {
		objectMap["availableToOtherTenants"] = aup.AvailableToOtherTenants
	}
	if aup.DisplayName != nil {
		objectMap["displayName"] = aup.DisplayName
	}
	if aup.Homepage != nil {
		objectMap["homepage"] = aup.Homepage
	}
	if aup.IdentifierUris != nil {
		objectMap["identifierUris"] = aup.IdentifierUris
	}
	if aup.ReplyUrls != nil {
		objectMap["replyUrls"] = aup.ReplyUrls
	}
	if aup.KeyCredentials != nil {
		objectMap["keyCredentials"] = aup.KeyCredentials
	}
	if aup.PasswordCredentials != nil {
		objectMap["passwordCredentials"] = aup.PasswordCredentials
	}
	if aup.Oauth2AllowImplicitFlow != nil {
		objectMap["oauth2AllowImplicitFlow"] = aup.Oauth2AllowImplicitFlow
	}
	if aup.RequiredResourceAccess != nil {
		objectMap["requiredResourceAccess"] = aup.RequiredResourceAccess
	}
	for k, v := range aup.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ApplicationUpdateParameters struct.
func (aup *ApplicationUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if aup.AdditionalProperties == nil {
					aup.AdditionalProperties = make(map[string]interface{})
				}
				aup.AdditionalProperties[k] = additionalProperties
			}
		case "appRoles":
			if v != nil {
				var appRoles []AppRole
				err = json.Unmarshal(*v, &appRoles)
				if err != nil {
					return err
				}
				aup.AppRoles = &appRoles
			}
		case "availableToOtherTenants":
			if v != nil {
				var availableToOtherTenants bool
				err = json.Unmarshal(*v, &availableToOtherTenants)
				if err != nil {
					return err
				}
				aup.AvailableToOtherTenants = &availableToOtherTenants
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				aup.DisplayName = &displayName
			}
		case "homepage":
			if v != nil {
				var homepage string
				err = json.Unmarshal(*v, &homepage)
				if err != nil {
					return err
				}
				aup.Homepage = &homepage
			}
		case "identifierUris":
			if v != nil {
				var identifierUris []string
				err = json.Unmarshal(*v, &identifierUris)
				if err != nil {
					return err
				}
				aup.IdentifierUris = &identifierUris
			}
		case "replyUrls":
			if v != nil {
				var replyUrls []string
				err = json.Unmarshal(*v, &replyUrls)
				if err != nil {
					return err
				}
				aup.ReplyUrls = &replyUrls
			}
		case "keyCredentials":
			if v != nil {
				var keyCredentials []KeyCredential
				err = json.Unmarshal(*v, &keyCredentials)
				if err != nil {
					return err
				}
				aup.KeyCredentials = &keyCredentials
			}
		case "passwordCredentials":
			if v != nil {
				var passwordCredentials []PasswordCredential
				err = json.Unmarshal(*v, &passwordCredentials)
				if err != nil {
					return err
				}
				aup.PasswordCredentials = &passwordCredentials
			}
		case "oauth2AllowImplicitFlow":
			if v != nil {
				var oauth2AllowImplicitFlow bool
				err = json.Unmarshal(*v, &oauth2AllowImplicitFlow)
				if err != nil {
					return err
				}
				aup.Oauth2AllowImplicitFlow = &oauth2AllowImplicitFlow
			}
		case "requiredResourceAccess":
			if v != nil {
				var requiredResourceAccess []RequiredResourceAccess
				err = json.Unmarshal(*v, &requiredResourceAccess)
				if err != nil {
					return err
				}
				aup.RequiredResourceAccess = &requiredResourceAccess
			}
		}
	}

	return nil
}

// AppRole ...
type AppRole struct {
	// ID - Unique role identifier inside the appRoles collection.
	ID *string `json:"id,omitempty"`
	// AllowedMemberTypes - Specifies whether this app role definition can be assigned to users and groups by setting to 'User', or to other applications (that are accessing this application in daemon service scenarios) by setting to 'Application', or to both.
	AllowedMemberTypes *[]string `json:"allowedMemberTypes,omitempty"`
	// Description - Permission help text that appears in the admin app assignment and consent experiences.
	Description *string `json:"description,omitempty"`
	// DisplayName - Display name for the permission that appears in the admin consent and app assignment experiences.
	DisplayName *string `json:"displayName,omitempty"`
	// IsEnabled - When creating or updating a role definition, this must be set to true (which is the default). To delete a role, this must first be set to false. At that point, in a subsequent call, this role may be removed.
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// Value - Specifies the value of the roles claim that the application should expect in the authentication and access tokens.
	Value *string `json:"value,omitempty"`
}

// CheckGroupMembershipParameters request parameters for IsMemberOf API call.
type CheckGroupMembershipParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// GroupID - The object ID of the group to check.
	GroupID *string `json:"groupId,omitempty"`
	// MemberID - The object ID of the contact, group, user, or service principal to check for membership in the specified group.
	MemberID *string `json:"memberId,omitempty"`
}

// MarshalJSON is the custom marshaler for CheckGroupMembershipParameters.
func (cgmp CheckGroupMembershipParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cgmp.GroupID != nil {
		objectMap["groupId"] = cgmp.GroupID
	}
	if cgmp.MemberID != nil {
		objectMap["memberId"] = cgmp.MemberID
	}
	for k, v := range cgmp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CheckGroupMembershipParameters struct.
func (cgmp *CheckGroupMembershipParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if cgmp.AdditionalProperties == nil {
					cgmp.AdditionalProperties = make(map[string]interface{})
				}
				cgmp.AdditionalProperties[k] = additionalProperties
			}
		case "groupId":
			if v != nil {
				var groupID string
				err = json.Unmarshal(*v, &groupID)
				if err != nil {
					return err
				}
				cgmp.GroupID = &groupID
			}
		case "memberId":
			if v != nil {
				var memberID string
				err = json.Unmarshal(*v, &memberID)
				if err != nil {
					return err
				}
				cgmp.MemberID = &memberID
			}
		}
	}

	return nil
}

// CheckGroupMembershipResult server response for IsMemberOf API call
type CheckGroupMembershipResult struct {
	autorest.Response `json:"-"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Value - True if the specified user, group, contact, or service principal has either direct or transitive membership in the specified group; otherwise, false.
	Value *bool `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for CheckGroupMembershipResult.
func (cgmr CheckGroupMembershipResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cgmr.Value != nil {
		objectMap["value"] = cgmr.Value
	}
	for k, v := range cgmr.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CheckGroupMembershipResult struct.
func (cgmr *CheckGroupMembershipResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if cgmr.AdditionalProperties == nil {
					cgmr.AdditionalProperties = make(map[string]interface{})
				}
				cgmr.AdditionalProperties[k] = additionalProperties
			}
		case "value":
			if v != nil {
				var value bool
				err = json.Unmarshal(*v, &value)
				if err != nil {
					return err
				}
				cgmr.Value = &value
			}
		}
	}

	return nil
}

// BasicDirectoryObject represents an Azure Active Directory object.
type BasicDirectoryObject interface {
	AsApplication() (*Application, bool)
	AsADGroup() (*ADGroup, bool)
	AsServicePrincipal() (*ServicePrincipal, bool)
	AsUser() (*User, bool)
	AsDirectoryObject() (*DirectoryObject, bool)
}

// DirectoryObject represents an Azure Active Directory object.
type DirectoryObject struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ObjectID - The object ID.
	ObjectID *string `json:"objectId,omitempty"`
	// DeletionTimestamp - The time at which the directory object was deleted.
	DeletionTimestamp *date.Time `json:"deletionTimestamp,omitempty"`
	// ObjectType - Possible values include: 'ObjectTypeDirectoryObject', 'ObjectTypeApplication', 'ObjectTypeGroup', 'ObjectTypeServicePrincipal', 'ObjectTypeUser'
	ObjectType ObjectType `json:"objectType,omitempty"`
}

func unmarshalBasicDirectoryObject(body []byte) (BasicDirectoryObject, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["objectType"] {
	case string(ObjectTypeApplication):
		var a Application
		err := json.Unmarshal(body, &a)
		return a, err
	case string(ObjectTypeGroup):
		var ag ADGroup
		err := json.Unmarshal(body, &ag)
		return ag, err
	case string(ObjectTypeServicePrincipal):
		var sp ServicePrincipal
		err := json.Unmarshal(body, &sp)
		return sp, err
	case string(ObjectTypeUser):
		var u User
		err := json.Unmarshal(body, &u)
		return u, err
	default:
		var do DirectoryObject
		err := json.Unmarshal(body, &do)
		return do, err
	}
}
func unmarshalBasicDirectoryObjectArray(body []byte) ([]BasicDirectoryObject, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	doArray := make([]BasicDirectoryObject, len(rawMessages))

	for index, rawMessage := range rawMessages {
		do, err := unmarshalBasicDirectoryObject(*rawMessage)
		if err != nil {
			return nil, err
		}
		doArray[index] = do
	}
	return doArray, nil
}

// MarshalJSON is the custom marshaler for DirectoryObject.
func (do DirectoryObject) MarshalJSON() ([]byte, error) {
	do.ObjectType = ObjectTypeDirectoryObject
	objectMap := make(map[string]interface{})
	if do.ObjectID != nil {
		objectMap["objectId"] = do.ObjectID
	}
	if do.DeletionTimestamp != nil {
		objectMap["deletionTimestamp"] = do.DeletionTimestamp
	}
	if do.ObjectType != "" {
		objectMap["objectType"] = do.ObjectType
	}
	for k, v := range do.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// AsApplication is the BasicDirectoryObject implementation for DirectoryObject.
func (do DirectoryObject) AsApplication() (*Application, bool) {
	return nil, false
}

// AsADGroup is the BasicDirectoryObject implementation for DirectoryObject.
func (do DirectoryObject) AsADGroup() (*ADGroup, bool) {
	return nil, false
}

// AsServicePrincipal is the BasicDirectoryObject implementation for DirectoryObject.
func (do DirectoryObject) AsServicePrincipal() (*ServicePrincipal, bool) {
	return nil, false
}

// AsUser is the BasicDirectoryObject implementation for DirectoryObject.
func (do DirectoryObject) AsUser() (*User, bool) {
	return nil, false
}

// AsDirectoryObject is the BasicDirectoryObject implementation for DirectoryObject.
func (do DirectoryObject) AsDirectoryObject() (*DirectoryObject, bool) {
	return &do, true
}

// AsBasicDirectoryObject is the BasicDirectoryObject implementation for DirectoryObject.
func (do DirectoryObject) AsBasicDirectoryObject() (BasicDirectoryObject, bool) {
	return &do, true
}

// UnmarshalJSON is the custom unmarshaler for DirectoryObject struct.
func (do *DirectoryObject) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if do.AdditionalProperties == nil {
					do.AdditionalProperties = make(map[string]interface{})
				}
				do.AdditionalProperties[k] = additionalProperties
			}
		case "objectId":
			if v != nil {
				var objectID string
				err = json.Unmarshal(*v, &objectID)
				if err != nil {
					return err
				}
				do.ObjectID = &objectID
			}
		case "deletionTimestamp":
			if v != nil {
				var deletionTimestamp date.Time
				err = json.Unmarshal(*v, &deletionTimestamp)
				if err != nil {
					return err
				}
				do.DeletionTimestamp = &deletionTimestamp
			}
		case "objectType":
			if v != nil {
				var objectType ObjectType
				err = json.Unmarshal(*v, &objectType)
				if err != nil {
					return err
				}
				do.ObjectType = objectType
			}
		}
	}

	return nil
}

// DirectoryObjectListResult directoryObject list operation result.
type DirectoryObjectListResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of DirectoryObject.
	Value *[]BasicDirectoryObject `json:"value,omitempty"`
	// OdataNextLink - The URL to get the next set of results.
	OdataNextLink *string `json:"odata.nextLink,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DirectoryObjectListResult struct.
func (dolr *DirectoryObjectListResult) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "value":
			if v != nil {
				value, err := unmarshalBasicDirectoryObjectArray(*v)
				if err != nil {
					return err
				}
				dolr.Value = &value
			}
		case "odata.nextLink":
			if v != nil {
				var odataNextLink string
				err = json.Unmarshal(*v, &odataNextLink)
				if err != nil {
					return err
				}
				dolr.OdataNextLink = &odataNextLink
			}
		}
	}

	return nil
}

// DirectoryObjectListResultIterator provides access to a complete listing of DirectoryObject values.
type DirectoryObjectListResultIterator struct {
	i    int
	page DirectoryObjectListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DirectoryObjectListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DirectoryObjectListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DirectoryObjectListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DirectoryObjectListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DirectoryObjectListResultIterator) Response() DirectoryObjectListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DirectoryObjectListResultIterator) Value() BasicDirectoryObject {
	if !iter.page.NotDone() {
		return DirectoryObject{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DirectoryObjectListResultIterator type.
func NewDirectoryObjectListResultIterator(page DirectoryObjectListResultPage) DirectoryObjectListResultIterator {
	return DirectoryObjectListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dolr DirectoryObjectListResult) IsEmpty() bool {
	return dolr.Value == nil || len(*dolr.Value) == 0
}

// directoryObjectListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dolr DirectoryObjectListResult) directoryObjectListResultPreparer(ctx context.Context) (*http.Request, error) {
	if dolr.OdataNextLink == nil || len(to.String(dolr.OdataNextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dolr.OdataNextLink)))
}

// DirectoryObjectListResultPage contains a page of BasicDirectoryObject values.
type DirectoryObjectListResultPage struct {
	fn   func(context.Context, DirectoryObjectListResult) (DirectoryObjectListResult, error)
	dolr DirectoryObjectListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DirectoryObjectListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DirectoryObjectListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.dolr)
	if err != nil {
		return err
	}
	page.dolr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DirectoryObjectListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DirectoryObjectListResultPage) NotDone() bool {
	return !page.dolr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DirectoryObjectListResultPage) Response() DirectoryObjectListResult {
	return page.dolr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DirectoryObjectListResultPage) Values() []BasicDirectoryObject {
	if page.dolr.IsEmpty() {
		return nil
	}
	return *page.dolr.Value
}

// Creates a new instance of the DirectoryObjectListResultPage type.
func NewDirectoryObjectListResultPage(getNextPage func(context.Context, DirectoryObjectListResult) (DirectoryObjectListResult, error)) DirectoryObjectListResultPage {
	return DirectoryObjectListResultPage{fn: getNextPage}
}

// Domain active Directory Domain information.
type Domain struct {
	autorest.Response `json:"-"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// AuthenticationType - the type of the authentication into the domain.
	AuthenticationType *string `json:"authenticationType,omitempty"`
	// IsDefault - if this is the default domain in the tenant.
	IsDefault *bool `json:"isDefault,omitempty"`
	// IsVerified - if this domain's ownership is verified.
	IsVerified *bool `json:"isVerified,omitempty"`
	// Name - the domain name.
	Name *string `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for Domain.
func (d Domain) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.AuthenticationType != nil {
		objectMap["authenticationType"] = d.AuthenticationType
	}
	if d.IsDefault != nil {
		objectMap["isDefault"] = d.IsDefault
	}
	if d.IsVerified != nil {
		objectMap["isVerified"] = d.IsVerified
	}
	if d.Name != nil {
		objectMap["name"] = d.Name
	}
	for k, v := range d.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Domain struct.
func (d *Domain) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if d.AdditionalProperties == nil {
					d.AdditionalProperties = make(map[string]interface{})
				}
				d.AdditionalProperties[k] = additionalProperties
			}
		case "authenticationType":
			if v != nil {
				var authenticationType string
				err = json.Unmarshal(*v, &authenticationType)
				if err != nil {
					return err
				}
				d.AuthenticationType = &authenticationType
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				d.IsDefault = &isDefault
			}
		case "isVerified":
			if v != nil {
				var isVerified bool
				err = json.Unmarshal(*v, &isVerified)
				if err != nil {
					return err
				}
				d.IsVerified = &isVerified
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				d.Name = &name
			}
		}
	}

	return nil
}

// DomainListResult server response for Get tenant domains API call.
type DomainListResult struct {
	autorest.Response `json:"-"`
	// Value - the list of domains.
	Value *[]Domain `json:"value,omitempty"`
}

// ErrorMessage active Directory error message.
type ErrorMessage struct {
	// Message - Error message value.
	Message *string `json:"value,omitempty"`
}

// GetObjectsParameters request parameters for the GetObjectsByObjectIds API.
type GetObjectsParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ObjectIds - The requested object IDs.
	ObjectIds *[]string `json:"objectIds,omitempty"`
	// Types - The requested object types.
	Types *[]string `json:"types,omitempty"`
	// IncludeDirectoryObjectReferences - If true, also searches for object IDs in the partner tenant.
	IncludeDirectoryObjectReferences *bool `json:"includeDirectoryObjectReferences,omitempty"`
}

// MarshalJSON is the custom marshaler for GetObjectsParameters.
func (gop GetObjectsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gop.ObjectIds != nil {
		objectMap["objectIds"] = gop.ObjectIds
	}
	if gop.Types != nil {
		objectMap["types"] = gop.Types
	}
	if gop.IncludeDirectoryObjectReferences != nil {
		objectMap["includeDirectoryObjectReferences"] = gop.IncludeDirectoryObjectReferences
	}
	for k, v := range gop.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GetObjectsParameters struct.
func (gop *GetObjectsParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if gop.AdditionalProperties == nil {
					gop.AdditionalProperties = make(map[string]interface{})
				}
				gop.AdditionalProperties[k] = additionalProperties
			}
		case "objectIds":
			if v != nil {
				var objectIds []string
				err = json.Unmarshal(*v, &objectIds)
				if err != nil {
					return err
				}
				gop.ObjectIds = &objectIds
			}
		case "types":
			if v != nil {
				var typesVar []string
				err = json.Unmarshal(*v, &typesVar)
				if err != nil {
					return err
				}
				gop.Types = &typesVar
			}
		case "includeDirectoryObjectReferences":
			if v != nil {
				var includeDirectoryObjectReferences bool
				err = json.Unmarshal(*v, &includeDirectoryObjectReferences)
				if err != nil {
					return err
				}
				gop.IncludeDirectoryObjectReferences = &includeDirectoryObjectReferences
			}
		}
	}

	return nil
}

// GraphError active Directory error information.
type GraphError struct {
	// OdataError - A Graph API error.
	*OdataError `json:"odata.error,omitempty"`
}

// MarshalJSON is the custom marshaler for GraphError.
func (ge GraphError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ge.OdataError != nil {
		objectMap["odata.error"] = ge.OdataError
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GraphError struct.
func (ge *GraphError) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "odata.error":
			if v != nil {
				var odataError OdataError
				err = json.Unmarshal(*v, &odataError)
				if err != nil {
					return err
				}
				ge.OdataError = &odataError
			}
		}
	}

	return nil
}

// GroupAddMemberParameters request parameters for adding a member to a group.
type GroupAddMemberParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// URL - A member object URL, such as "https://graph.windows.net/0b1f9851-1bf0-433f-aec3-cb9272f093dc/directoryObjects/f260bbc4-c254-447b-94cf-293b5ec434dd", where "0b1f9851-1bf0-433f-aec3-cb9272f093dc" is the tenantId and "f260bbc4-c254-447b-94cf-293b5ec434dd" is the objectId of the member (user, application, servicePrincipal, group) to be added.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for GroupAddMemberParameters.
func (gamp GroupAddMemberParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gamp.URL != nil {
		objectMap["url"] = gamp.URL
	}
	for k, v := range gamp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GroupAddMemberParameters struct.
func (gamp *GroupAddMemberParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if gamp.AdditionalProperties == nil {
					gamp.AdditionalProperties = make(map[string]interface{})
				}
				gamp.AdditionalProperties[k] = additionalProperties
			}
		case "url":
			if v != nil {
				var URL string
				err = json.Unmarshal(*v, &URL)
				if err != nil {
					return err
				}
				gamp.URL = &URL
			}
		}
	}

	return nil
}

// GroupCreateParameters request parameters for creating a new group.
type GroupCreateParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// DisplayName - Group display name
	DisplayName *string `json:"displayName,omitempty"`
	// MailEnabled - Whether the group is mail-enabled. Must be false. This is because only pure security groups can be created using the Graph API.
	MailEnabled *bool `json:"mailEnabled,omitempty"`
	// MailNickname - Mail nickname
	MailNickname *string `json:"mailNickname,omitempty"`
	// SecurityEnabled - Whether the group is a security group. Must be true. This is because only pure security groups can be created using the Graph API.
	SecurityEnabled *bool `json:"securityEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for GroupCreateParameters.
func (gcp GroupCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gcp.DisplayName != nil {
		objectMap["displayName"] = gcp.DisplayName
	}
	if gcp.MailEnabled != nil {
		objectMap["mailEnabled"] = gcp.MailEnabled
	}
	if gcp.MailNickname != nil {
		objectMap["mailNickname"] = gcp.MailNickname
	}
	if gcp.SecurityEnabled != nil {
		objectMap["securityEnabled"] = gcp.SecurityEnabled
	}
	for k, v := range gcp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GroupCreateParameters struct.
func (gcp *GroupCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if gcp.AdditionalProperties == nil {
					gcp.AdditionalProperties = make(map[string]interface{})
				}
				gcp.AdditionalProperties[k] = additionalProperties
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				gcp.DisplayName = &displayName
			}
		case "mailEnabled":
			if v != nil {
				var mailEnabled bool
				err = json.Unmarshal(*v, &mailEnabled)
				if err != nil {
					return err
				}
				gcp.MailEnabled = &mailEnabled
			}
		case "mailNickname":
			if v != nil {
				var mailNickname string
				err = json.Unmarshal(*v, &mailNickname)
				if err != nil {
					return err
				}
				gcp.MailNickname = &mailNickname
			}
		case "securityEnabled":
			if v != nil {
				var securityEnabled bool
				err = json.Unmarshal(*v, &securityEnabled)
				if err != nil {
					return err
				}
				gcp.SecurityEnabled = &securityEnabled
			}
		}
	}

	return nil
}

// GroupGetMemberGroupsParameters request parameters for GetMemberGroups API call.
type GroupGetMemberGroupsParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// SecurityEnabledOnly - If true, only membership in security-enabled groups should be checked. Otherwise, membership in all groups should be checked.
	SecurityEnabledOnly *bool `json:"securityEnabledOnly,omitempty"`
}

// MarshalJSON is the custom marshaler for GroupGetMemberGroupsParameters.
func (ggmgp GroupGetMemberGroupsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ggmgp.SecurityEnabledOnly != nil {
		objectMap["securityEnabledOnly"] = ggmgp.SecurityEnabledOnly
	}
	for k, v := range ggmgp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GroupGetMemberGroupsParameters struct.
func (ggmgp *GroupGetMemberGroupsParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ggmgp.AdditionalProperties == nil {
					ggmgp.AdditionalProperties = make(map[string]interface{})
				}
				ggmgp.AdditionalProperties[k] = additionalProperties
			}
		case "securityEnabledOnly":
			if v != nil {
				var securityEnabledOnly bool
				err = json.Unmarshal(*v, &securityEnabledOnly)
				if err != nil {
					return err
				}
				ggmgp.SecurityEnabledOnly = &securityEnabledOnly
			}
		}
	}

	return nil
}

// GroupGetMemberGroupsResult server response for GetMemberGroups API call.
type GroupGetMemberGroupsResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of group IDs of which the group is a member.
	Value *[]string `json:"value,omitempty"`
}

// GroupListResult server response for Get tenant groups API call
type GroupListResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of Active Directory groups.
	Value *[]ADGroup `json:"value,omitempty"`
	// OdataNextLink - The URL to get the next set of results.
	OdataNextLink *string `json:"odata.nextLink,omitempty"`
}

// GroupListResultIterator provides access to a complete listing of ADGroup values.
type GroupListResultIterator struct {
	i    int
	page GroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *GroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *GroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter GroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter GroupListResultIterator) Response() GroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter GroupListResultIterator) Value() ADGroup {
	if !iter.page.NotDone() {
		return ADGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the GroupListResultIterator type.
func NewGroupListResultIterator(page GroupListResultPage) GroupListResultIterator {
	return GroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (glr GroupListResult) IsEmpty() bool {
	return glr.Value == nil || len(*glr.Value) == 0
}

// GroupListResultPage contains a page of ADGroup values.
type GroupListResultPage struct {
	fn  func(context.Context, GroupListResult) (GroupListResult, error)
	glr GroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *GroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.glr)
	if err != nil {
		return err
	}
	page.glr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *GroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page GroupListResultPage) NotDone() bool {
	return !page.glr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page GroupListResultPage) Response() GroupListResult {
	return page.glr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page GroupListResultPage) Values() []ADGroup {
	if page.glr.IsEmpty() {
		return nil
	}
	return *page.glr.Value
}

// Creates a new instance of the GroupListResultPage type.
func NewGroupListResultPage(getNextPage func(context.Context, GroupListResult) (GroupListResult, error)) GroupListResultPage {
	return GroupListResultPage{fn: getNextPage}
}

// KeyCredential active Directory Key Credential information.
type KeyCredential struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// StartDate - Start date.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - End date.
	EndDate *date.Time `json:"endDate,omitempty"`
	// Value - Key value.
	Value *string `json:"value,omitempty"`
	// KeyID - Key ID.
	KeyID *string `json:"keyId,omitempty"`
	// Usage - Usage. Acceptable values are 'Verify' and 'Sign'.
	Usage *string `json:"usage,omitempty"`
	// Type - Type. Acceptable values are 'AsymmetricX509Cert' and 'Symmetric'.
	Type *string `json:"type,omitempty"`
	// CustomKeyIdentifier - Custom Key Identifier
	CustomKeyIdentifier *string `json:"customKeyIdentifier,omitempty"`
}

// MarshalJSON is the custom marshaler for KeyCredential.
func (kc KeyCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kc.StartDate != nil {
		objectMap["startDate"] = kc.StartDate
	}
	if kc.EndDate != nil {
		objectMap["endDate"] = kc.EndDate
	}
	if kc.Value != nil {
		objectMap["value"] = kc.Value
	}
	if kc.KeyID != nil {
		objectMap["keyId"] = kc.KeyID
	}
	if kc.Usage != nil {
		objectMap["usage"] = kc.Usage
	}
	if kc.Type != nil {
		objectMap["type"] = kc.Type
	}
	if kc.CustomKeyIdentifier != nil {
		objectMap["customKeyIdentifier"] = kc.CustomKeyIdentifier
	}
	for k, v := range kc.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for KeyCredential struct.
func (kc *KeyCredential) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if kc.AdditionalProperties == nil {
					kc.AdditionalProperties = make(map[string]interface{})
				}
				kc.AdditionalProperties[k] = additionalProperties
			}
		case "startDate":
			if v != nil {
				var startDate date.Time
				err = json.Unmarshal(*v, &startDate)
				if err != nil {
					return err
				}
				kc.StartDate = &startDate
			}
		case "endDate":
			if v != nil {
				var endDate date.Time
				err = json.Unmarshal(*v, &endDate)
				if err != nil {
					return err
				}
				kc.EndDate = &endDate
			}
		case "value":
			if v != nil {
				var value string
				err = json.Unmarshal(*v, &value)
				if err != nil {
					return err
				}
				kc.Value = &value
			}
		case "keyId":
			if v != nil {
				var keyID string
				err = json.Unmarshal(*v, &keyID)
				if err != nil {
					return err
				}
				kc.KeyID = &keyID
			}
		case "usage":
			if v != nil {
				var usage string
				err = json.Unmarshal(*v, &usage)
				if err != nil {
					return err
				}
				kc.Usage = &usage
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				kc.Type = &typeVar
			}
		case "customKeyIdentifier":
			if v != nil {
				var customKeyIdentifier string
				err = json.Unmarshal(*v, &customKeyIdentifier)
				if err != nil {
					return err
				}
				kc.CustomKeyIdentifier = &customKeyIdentifier
			}
		}
	}

	return nil
}

// KeyCredentialListResult keyCredential list operation result.
type KeyCredentialListResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of KeyCredentials.
	Value *[]KeyCredential `json:"value,omitempty"`
}

// KeyCredentialsUpdateParameters request parameters for a KeyCredentials update operation
type KeyCredentialsUpdateParameters struct {
	// Value - A collection of KeyCredentials.
	Value *[]KeyCredential `json:"value,omitempty"`
}

// OdataError active Directory OData error information.
type OdataError struct {
	// Code - Error code.
	Code *string `json:"code,omitempty"`
	// ErrorMessage - Error Message.
	*ErrorMessage `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for OdataError.
func (oe OdataError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oe.Code != nil {
		objectMap["code"] = oe.Code
	}
	if oe.ErrorMessage != nil {
		objectMap["message"] = oe.ErrorMessage
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OdataError struct.
func (oe *OdataError) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "code":
			if v != nil {
				var code string
				err = json.Unmarshal(*v, &code)
				if err != nil {
					return err
				}
				oe.Code = &code
			}
		case "message":
			if v != nil {
				var errorMessage ErrorMessage
				err = json.Unmarshal(*v, &errorMessage)
				if err != nil {
					return err
				}
				oe.ErrorMessage = &errorMessage
			}
		}
	}

	return nil
}

// PasswordCredential active Directory Password Credential information.
type PasswordCredential struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// StartDate - Start date.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - End date.
	EndDate *date.Time `json:"endDate,omitempty"`
	// KeyID - Key ID.
	KeyID *string `json:"keyId,omitempty"`
	// Value - Key value.
	Value *string `json:"value,omitempty"`
	// CustomKeyIdentifier - Custom Key Identifier
	CustomKeyIdentifier *[]byte `json:"customKeyIdentifier,omitempty"`
}

// MarshalJSON is the custom marshaler for PasswordCredential.
func (pc PasswordCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pc.StartDate != nil {
		objectMap["startDate"] = pc.StartDate
	}
	if pc.EndDate != nil {
		objectMap["endDate"] = pc.EndDate
	}
	if pc.KeyID != nil {
		objectMap["keyId"] = pc.KeyID
	}
	if pc.Value != nil {
		objectMap["value"] = pc.Value
	}
	if pc.CustomKeyIdentifier != nil {
		objectMap["customKeyIdentifier"] = pc.CustomKeyIdentifier
	}
	for k, v := range pc.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PasswordCredential struct.
func (pc *PasswordCredential) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if pc.AdditionalProperties == nil {
					pc.AdditionalProperties = make(map[string]interface{})
				}
				pc.AdditionalProperties[k] = additionalProperties
			}
		case "startDate":
			if v != nil {
				var startDate date.Time
				err = json.Unmarshal(*v, &startDate)
				if err != nil {
					return err
				}
				pc.StartDate = &startDate
			}
		case "endDate":
			if v != nil {
				var endDate date.Time
				err = json.Unmarshal(*v, &endDate)
				if err != nil {
					return err
				}
				pc.EndDate = &endDate
			}
		case "keyId":
			if v != nil {
				var keyID string
				err = json.Unmarshal(*v, &keyID)
				if err != nil {
					return err
				}
				pc.KeyID = &keyID
			}
		case "value":
			if v != nil {
				var value string
				err = json.Unmarshal(*v, &value)
				if err != nil {
					return err
				}
				pc.Value = &value
			}
		case "customKeyIdentifier":
			if v != nil {
				var customKeyIdentifier []byte
				err = json.Unmarshal(*v, &customKeyIdentifier)
				if err != nil {
					return err
				}
				pc.CustomKeyIdentifier = &customKeyIdentifier
			}
		}
	}

	return nil
}

// PasswordCredentialListResult passwordCredential list operation result.
type PasswordCredentialListResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of PasswordCredentials.
	Value *[]PasswordCredential `json:"value,omitempty"`
}

// PasswordCredentialsUpdateParameters request parameters for a PasswordCredentials update operation.
type PasswordCredentialsUpdateParameters struct {
	// Value - A collection of PasswordCredentials.
	Value *[]PasswordCredential `json:"value,omitempty"`
}

// PasswordProfile the password profile associated with a user.
type PasswordProfile struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Password - Password
	Password *string `json:"password,omitempty"`
	// ForceChangePasswordNextLogin - Whether to force a password change on next login.
	ForceChangePasswordNextLogin *bool `json:"forceChangePasswordNextLogin,omitempty"`
}

// MarshalJSON is the custom marshaler for PasswordProfile.
func (pp PasswordProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.Password != nil {
		objectMap["password"] = pp.Password
	}
	if pp.ForceChangePasswordNextLogin != nil {
		objectMap["forceChangePasswordNextLogin"] = pp.ForceChangePasswordNextLogin
	}
	for k, v := range pp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PasswordProfile struct.
func (pp *PasswordProfile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if pp.AdditionalProperties == nil {
					pp.AdditionalProperties = make(map[string]interface{})
				}
				pp.AdditionalProperties[k] = additionalProperties
			}
		case "password":
			if v != nil {
				var password string
				err = json.Unmarshal(*v, &password)
				if err != nil {
					return err
				}
				pp.Password = &password
			}
		case "forceChangePasswordNextLogin":
			if v != nil {
				var forceChangePasswordNextLogin bool
				err = json.Unmarshal(*v, &forceChangePasswordNextLogin)
				if err != nil {
					return err
				}
				pp.ForceChangePasswordNextLogin = &forceChangePasswordNextLogin
			}
		}
	}

	return nil
}

// Permissions ...
type Permissions struct {
	autorest.Response `json:"-"`
	// OdataType - Microsoft.DirectoryServices.OAuth2PermissionGrant
	OdataType *string `json:"odata.type,omitempty"`
	// ClientID - The objectId of the Service Principal associated with the app
	ClientID *string `json:"clientId,omitempty"`
	// ConsentType - Typically set to AllPrincipals
	ConsentType *string `json:"consentType,omitempty"`
	// PrincipalID - Set to null if AllPrincipals is set
	PrincipalID interface{} `json:"principalId,omitempty"`
	// ResourceID - Service Principal Id of the resource you want to grant
	ResourceID *string `json:"resourceId,omitempty"`
	// Scope - Typically set to user_impersonation
	Scope *string `json:"scope,omitempty"`
	// StartTime - Start time for TTL
	StartTime *string `json:"startTime,omitempty"`
	// ExpiryTime - Expiry time for TTL
	ExpiryTime *string `json:"expiryTime,omitempty"`
}

// RequiredResourceAccess specifies the set of OAuth 2.0 permission scopes and app roles under the
// specified resource that an application requires access to. The specified OAuth 2.0 permission scopes may
// be requested by client applications (through the requiredResourceAccess collection) when calling a
// resource application. The requiredResourceAccess property of the Application entity is a collection of
// RequiredResourceAccess.
type RequiredResourceAccess struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ResourceAccess - The list of OAuth2.0 permission scopes and app roles that the application requires from the specified resource.
	ResourceAccess *[]ResourceAccess `json:"resourceAccess,omitempty"`
	// ResourceAppID - The unique identifier for the resource that the application requires access to. This should be equal to the appId declared on the target resource application.
	ResourceAppID *string `json:"resourceAppId,omitempty"`
}

// MarshalJSON is the custom marshaler for RequiredResourceAccess.
func (rra RequiredResourceAccess) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rra.ResourceAccess != nil {
		objectMap["resourceAccess"] = rra.ResourceAccess
	}
	if rra.ResourceAppID != nil {
		objectMap["resourceAppId"] = rra.ResourceAppID
	}
	for k, v := range rra.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RequiredResourceAccess struct.
func (rra *RequiredResourceAccess) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if rra.AdditionalProperties == nil {
					rra.AdditionalProperties = make(map[string]interface{})
				}
				rra.AdditionalProperties[k] = additionalProperties
			}
		case "resourceAccess":
			if v != nil {
				var resourceAccess []ResourceAccess
				err = json.Unmarshal(*v, &resourceAccess)
				if err != nil {
					return err
				}
				rra.ResourceAccess = &resourceAccess
			}
		case "resourceAppId":
			if v != nil {
				var resourceAppID string
				err = json.Unmarshal(*v, &resourceAppID)
				if err != nil {
					return err
				}
				rra.ResourceAppID = &resourceAppID
			}
		}
	}

	return nil
}

// ResourceAccess specifies an OAuth 2.0 permission scope or an app role that an application requires. The
// resourceAccess property of the RequiredResourceAccess type is a collection of ResourceAccess.
type ResourceAccess struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ID - The unique identifier for one of the OAuth2Permission or AppRole instances that the resource application exposes.
	ID *string `json:"id,omitempty"`
	// Type - Specifies whether the id property references an OAuth2Permission or an AppRole. Possible values are "scope" or "role".
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceAccess.
func (ra ResourceAccess) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ra.ID != nil {
		objectMap["id"] = ra.ID
	}
	if ra.Type != nil {
		objectMap["type"] = ra.Type
	}
	for k, v := range ra.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourceAccess struct.
func (ra *ResourceAccess) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ra.AdditionalProperties == nil {
					ra.AdditionalProperties = make(map[string]interface{})
				}
				ra.AdditionalProperties[k] = additionalProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ra.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ra.Type = &typeVar
			}
		}
	}

	return nil
}

// ServicePrincipal active Directory service principal information.
type ServicePrincipal struct {
	autorest.Response `json:"-"`
	// DisplayName - The display name of the service principal.
	DisplayName *string `json:"displayName,omitempty"`
	// AppID - The application ID.
	AppID *string `json:"appId,omitempty"`
	// AppRoles - The collection of application roles that an application may declare. These roles can be assigned to users, groups or service principals.
	AppRoles *[]AppRole `json:"appRoles,omitempty"`
	// ServicePrincipalNames - A collection of service principal names.
	ServicePrincipalNames *[]string `json:"servicePrincipalNames,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ObjectID - The object ID.
	ObjectID *string `json:"objectId,omitempty"`
	// DeletionTimestamp - The time at which the directory object was deleted.
	DeletionTimestamp *date.Time `json:"deletionTimestamp,omitempty"`
	// ObjectType - Possible values include: 'ObjectTypeDirectoryObject', 'ObjectTypeApplication', 'ObjectTypeGroup', 'ObjectTypeServicePrincipal', 'ObjectTypeUser'
	ObjectType ObjectType `json:"objectType,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipal.
func (sp ServicePrincipal) MarshalJSON() ([]byte, error) {
	sp.ObjectType = ObjectTypeServicePrincipal
	objectMap := make(map[string]interface{})
	if sp.DisplayName != nil {
		objectMap["displayName"] = sp.DisplayName
	}
	if sp.AppID != nil {
		objectMap["appId"] = sp.AppID
	}
	if sp.AppRoles != nil {
		objectMap["appRoles"] = sp.AppRoles
	}
	if sp.ServicePrincipalNames != nil {
		objectMap["servicePrincipalNames"] = sp.ServicePrincipalNames
	}
	if sp.ObjectID != nil {
		objectMap["objectId"] = sp.ObjectID
	}
	if sp.DeletionTimestamp != nil {
		objectMap["deletionTimestamp"] = sp.DeletionTimestamp
	}
	if sp.ObjectType != "" {
		objectMap["objectType"] = sp.ObjectType
	}
	for k, v := range sp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// AsApplication is the BasicDirectoryObject implementation for ServicePrincipal.
func (sp ServicePrincipal) AsApplication() (*Application, bool) {
	return nil, false
}

// AsADGroup is the BasicDirectoryObject implementation for ServicePrincipal.
func (sp ServicePrincipal) AsADGroup() (*ADGroup, bool) {
	return nil, false
}

// AsServicePrincipal is the BasicDirectoryObject implementation for ServicePrincipal.
func (sp ServicePrincipal) AsServicePrincipal() (*ServicePrincipal, bool) {
	return &sp, true
}

// AsUser is the BasicDirectoryObject implementation for ServicePrincipal.
func (sp ServicePrincipal) AsUser() (*User, bool) {
	return nil, false
}

// AsDirectoryObject is the BasicDirectoryObject implementation for ServicePrincipal.
func (sp ServicePrincipal) AsDirectoryObject() (*DirectoryObject, bool) {
	return nil, false
}

// AsBasicDirectoryObject is the BasicDirectoryObject implementation for ServicePrincipal.
func (sp ServicePrincipal) AsBasicDirectoryObject() (BasicDirectoryObject, bool) {
	return &sp, true
}

// UnmarshalJSON is the custom unmarshaler for ServicePrincipal struct.
func (sp *ServicePrincipal) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sp.DisplayName = &displayName
			}
		case "appId":
			if v != nil {
				var appID string
				err = json.Unmarshal(*v, &appID)
				if err != nil {
					return err
				}
				sp.AppID = &appID
			}
		case "appRoles":
			if v != nil {
				var appRoles []AppRole
				err = json.Unmarshal(*v, &appRoles)
				if err != nil {
					return err
				}
				sp.AppRoles = &appRoles
			}
		case "servicePrincipalNames":
			if v != nil {
				var servicePrincipalNames []string
				err = json.Unmarshal(*v, &servicePrincipalNames)
				if err != nil {
					return err
				}
				sp.ServicePrincipalNames = &servicePrincipalNames
			}
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if sp.AdditionalProperties == nil {
					sp.AdditionalProperties = make(map[string]interface{})
				}
				sp.AdditionalProperties[k] = additionalProperties
			}
		case "objectId":
			if v != nil {
				var objectID string
				err = json.Unmarshal(*v, &objectID)
				if err != nil {
					return err
				}
				sp.ObjectID = &objectID
			}
		case "deletionTimestamp":
			if v != nil {
				var deletionTimestamp date.Time
				err = json.Unmarshal(*v, &deletionTimestamp)
				if err != nil {
					return err
				}
				sp.DeletionTimestamp = &deletionTimestamp
			}
		case "objectType":
			if v != nil {
				var objectType ObjectType
				err = json.Unmarshal(*v, &objectType)
				if err != nil {
					return err
				}
				sp.ObjectType = objectType
			}
		}
	}

	return nil
}

// ServicePrincipalCreateParameters request parameters for creating a new service principal.
type ServicePrincipalCreateParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// AccountEnabled - Whether the account is enabled
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// AppID - application Id
	AppID *string `json:"appId,omitempty"`
	// AppRoleAssignmentRequired - Specifies whether an AppRoleAssignment to a user or group is required before Azure AD will issue a user or access token to the application.
	AppRoleAssignmentRequired *bool `json:"appRoleAssignmentRequired,omitempty"`
	// DisplayName - The display name for the service principal.
	DisplayName *string `json:"displayName,omitempty"`
	ErrorURL    *string `json:"errorUrl,omitempty"`
	// Homepage - The URL to the homepage of the associated application.
	Homepage *string `json:"homepage,omitempty"`
	// KeyCredentials - A collection of KeyCredential objects.
	KeyCredentials *[]KeyCredential `json:"keyCredentials,omitempty"`
	// PasswordCredentials - A collection of PasswordCredential objects
	PasswordCredentials *[]PasswordCredential `json:"passwordCredentials,omitempty"`
	// PublisherName - The display name of the tenant in which the associated application is specified.
	PublisherName *string `json:"publisherName,omitempty"`
	// ReplyUrls - A collection of reply URLs for the service principal.
	ReplyUrls       *[]string `json:"replyUrls,omitempty"`
	SamlMetadataURL *string   `json:"samlMetadataUrl,omitempty"`
	// ServicePrincipalNames - A collection of service principal names.
	ServicePrincipalNames *[]string `json:"servicePrincipalNames,omitempty"`
	Tags                  *[]string `json:"tags,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipalCreateParameters.
func (spcp ServicePrincipalCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spcp.AccountEnabled != nil {
		objectMap["accountEnabled"] = spcp.AccountEnabled
	}
	if spcp.AppID != nil {
		objectMap["appId"] = spcp.AppID
	}
	if spcp.AppRoleAssignmentRequired != nil {
		objectMap["appRoleAssignmentRequired"] = spcp.AppRoleAssignmentRequired
	}
	if spcp.DisplayName != nil {
		objectMap["displayName"] = spcp.DisplayName
	}
	if spcp.ErrorURL != nil {
		objectMap["errorUrl"] = spcp.ErrorURL
	}
	if spcp.Homepage != nil {
		objectMap["homepage"] = spcp.Homepage
	}
	if spcp.KeyCredentials != nil {
		objectMap["keyCredentials"] = spcp.KeyCredentials
	}
	if spcp.PasswordCredentials != nil {
		objectMap["passwordCredentials"] = spcp.PasswordCredentials
	}
	if spcp.PublisherName != nil {
		objectMap["publisherName"] = spcp.PublisherName
	}
	if spcp.ReplyUrls != nil {
		objectMap["replyUrls"] = spcp.ReplyUrls
	}
	if spcp.SamlMetadataURL != nil {
		objectMap["samlMetadataUrl"] = spcp.SamlMetadataURL
	}
	if spcp.ServicePrincipalNames != nil {
		objectMap["servicePrincipalNames"] = spcp.ServicePrincipalNames
	}
	if spcp.Tags != nil {
		objectMap["tags"] = spcp.Tags
	}
	for k, v := range spcp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServicePrincipalCreateParameters struct.
func (spcp *ServicePrincipalCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if spcp.AdditionalProperties == nil {
					spcp.AdditionalProperties = make(map[string]interface{})
				}
				spcp.AdditionalProperties[k] = additionalProperties
			}
		case "accountEnabled":
			if v != nil {
				var accountEnabled bool
				err = json.Unmarshal(*v, &accountEnabled)
				if err != nil {
					return err
				}
				spcp.AccountEnabled = &accountEnabled
			}
		case "appId":
			if v != nil {
				var appID string
				err = json.Unmarshal(*v, &appID)
				if err != nil {
					return err
				}
				spcp.AppID = &appID
			}
		case "appRoleAssignmentRequired":
			if v != nil {
				var appRoleAssignmentRequired bool
				err = json.Unmarshal(*v, &appRoleAssignmentRequired)
				if err != nil {
					return err
				}
				spcp.AppRoleAssignmentRequired = &appRoleAssignmentRequired
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				spcp.DisplayName = &displayName
			}
		case "errorUrl":
			if v != nil {
				var errorURL string
				err = json.Unmarshal(*v, &errorURL)
				if err != nil {
					return err
				}
				spcp.ErrorURL = &errorURL
			}
		case "homepage":
			if v != nil {
				var homepage string
				err = json.Unmarshal(*v, &homepage)
				if err != nil {
					return err
				}
				spcp.Homepage = &homepage
			}
		case "keyCredentials":
			if v != nil {
				var keyCredentials []KeyCredential
				err = json.Unmarshal(*v, &keyCredentials)
				if err != nil {
					return err
				}
				spcp.KeyCredentials = &keyCredentials
			}
		case "passwordCredentials":
			if v != nil {
				var passwordCredentials []PasswordCredential
				err = json.Unmarshal(*v, &passwordCredentials)
				if err != nil {
					return err
				}
				spcp.PasswordCredentials = &passwordCredentials
			}
		case "publisherName":
			if v != nil {
				var publisherName string
				err = json.Unmarshal(*v, &publisherName)
				if err != nil {
					return err
				}
				spcp.PublisherName = &publisherName
			}
		case "replyUrls":
			if v != nil {
				var replyUrls []string
				err = json.Unmarshal(*v, &replyUrls)
				if err != nil {
					return err
				}
				spcp.ReplyUrls = &replyUrls
			}
		case "samlMetadataUrl":
			if v != nil {
				var samlMetadataURL string
				err = json.Unmarshal(*v, &samlMetadataURL)
				if err != nil {
					return err
				}
				spcp.SamlMetadataURL = &samlMetadataURL
			}
		case "servicePrincipalNames":
			if v != nil {
				var servicePrincipalNames []string
				err = json.Unmarshal(*v, &servicePrincipalNames)
				if err != nil {
					return err
				}
				spcp.ServicePrincipalNames = &servicePrincipalNames
			}
		case "tags":
			if v != nil {
				var tags []string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				spcp.Tags = &tags
			}
		}
	}

	return nil
}

// ServicePrincipalListResult server response for get tenant service principals API call.
type ServicePrincipalListResult struct {
	autorest.Response `json:"-"`
	// Value - the list of service principals.
	Value *[]ServicePrincipal `json:"value,omitempty"`
	// OdataNextLink - the URL to get the next set of results.
	OdataNextLink *string `json:"odata.nextLink,omitempty"`
}

// ServicePrincipalListResultIterator provides access to a complete listing of ServicePrincipal values.
type ServicePrincipalListResultIterator struct {
	i    int
	page ServicePrincipalListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServicePrincipalListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicePrincipalListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServicePrincipalListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServicePrincipalListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServicePrincipalListResultIterator) Response() ServicePrincipalListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServicePrincipalListResultIterator) Value() ServicePrincipal {
	if !iter.page.NotDone() {
		return ServicePrincipal{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServicePrincipalListResultIterator type.
func NewServicePrincipalListResultIterator(page ServicePrincipalListResultPage) ServicePrincipalListResultIterator {
	return ServicePrincipalListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (splr ServicePrincipalListResult) IsEmpty() bool {
	return splr.Value == nil || len(*splr.Value) == 0
}

// ServicePrincipalListResultPage contains a page of ServicePrincipal values.
type ServicePrincipalListResultPage struct {
	fn   func(context.Context, ServicePrincipalListResult) (ServicePrincipalListResult, error)
	splr ServicePrincipalListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServicePrincipalListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServicePrincipalListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.splr)
	if err != nil {
		return err
	}
	page.splr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServicePrincipalListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServicePrincipalListResultPage) NotDone() bool {
	return !page.splr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServicePrincipalListResultPage) Response() ServicePrincipalListResult {
	return page.splr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServicePrincipalListResultPage) Values() []ServicePrincipal {
	if page.splr.IsEmpty() {
		return nil
	}
	return *page.splr.Value
}

// Creates a new instance of the ServicePrincipalListResultPage type.
func NewServicePrincipalListResultPage(getNextPage func(context.Context, ServicePrincipalListResult) (ServicePrincipalListResult, error)) ServicePrincipalListResultPage {
	return ServicePrincipalListResultPage{fn: getNextPage}
}

// ServicePrincipalUpdateParameters request parameters for creating a new service principal.
type ServicePrincipalUpdateParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// AccountEnabled - Whether the account is enabled
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// AppID - application Id
	AppID *string `json:"appId,omitempty"`
	// AppRoleAssignmentRequired - Specifies whether an AppRoleAssignment to a user or group is required before Azure AD will issue a user or access token to the application.
	AppRoleAssignmentRequired *bool `json:"appRoleAssignmentRequired,omitempty"`
	// DisplayName - The display name for the service principal.
	DisplayName *string `json:"displayName,omitempty"`
	ErrorURL    *string `json:"errorUrl,omitempty"`
	// Homepage - The URL to the homepage of the associated application.
	Homepage *string `json:"homepage,omitempty"`
	// KeyCredentials - A collection of KeyCredential objects.
	KeyCredentials *[]KeyCredential `json:"keyCredentials,omitempty"`
	// PasswordCredentials - A collection of PasswordCredential objects
	PasswordCredentials *[]PasswordCredential `json:"passwordCredentials,omitempty"`
	// PublisherName - The display name of the tenant in which the associated application is specified.
	PublisherName *string `json:"publisherName,omitempty"`
	// ReplyUrls - A collection of reply URLs for the service principal.
	ReplyUrls       *[]string `json:"replyUrls,omitempty"`
	SamlMetadataURL *string   `json:"samlMetadataUrl,omitempty"`
	// ServicePrincipalNames - A collection of service principal names.
	ServicePrincipalNames *[]string `json:"servicePrincipalNames,omitempty"`
	Tags                  *[]string `json:"tags,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipalUpdateParameters.
func (spup ServicePrincipalUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if spup.AccountEnabled != nil {
		objectMap["accountEnabled"] = spup.AccountEnabled
	}
	if spup.AppID != nil {
		objectMap["appId"] = spup.AppID
	}
	if spup.AppRoleAssignmentRequired != nil {
		objectMap["appRoleAssignmentRequired"] = spup.AppRoleAssignmentRequired
	}
	if spup.DisplayName != nil {
		objectMap["displayName"] = spup.DisplayName
	}
	if spup.ErrorURL != nil {
		objectMap["errorUrl"] = spup.ErrorURL
	}
	if spup.Homepage != nil {
		objectMap["homepage"] = spup.Homepage
	}
	if spup.KeyCredentials != nil {
		objectMap["keyCredentials"] = spup.KeyCredentials
	}
	if spup.PasswordCredentials != nil {
		objectMap["passwordCredentials"] = spup.PasswordCredentials
	}
	if spup.PublisherName != nil {
		objectMap["publisherName"] = spup.PublisherName
	}
	if spup.ReplyUrls != nil {
		objectMap["replyUrls"] = spup.ReplyUrls
	}
	if spup.SamlMetadataURL != nil {
		objectMap["samlMetadataUrl"] = spup.SamlMetadataURL
	}
	if spup.ServicePrincipalNames != nil {
		objectMap["servicePrincipalNames"] = spup.ServicePrincipalNames
	}
	if spup.Tags != nil {
		objectMap["tags"] = spup.Tags
	}
	for k, v := range spup.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServicePrincipalUpdateParameters struct.
func (spup *ServicePrincipalUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if spup.AdditionalProperties == nil {
					spup.AdditionalProperties = make(map[string]interface{})
				}
				spup.AdditionalProperties[k] = additionalProperties
			}
		case "accountEnabled":
			if v != nil {
				var accountEnabled bool
				err = json.Unmarshal(*v, &accountEnabled)
				if err != nil {
					return err
				}
				spup.AccountEnabled = &accountEnabled
			}
		case "appId":
			if v != nil {
				var appID string
				err = json.Unmarshal(*v, &appID)
				if err != nil {
					return err
				}
				spup.AppID = &appID
			}
		case "appRoleAssignmentRequired":
			if v != nil {
				var appRoleAssignmentRequired bool
				err = json.Unmarshal(*v, &appRoleAssignmentRequired)
				if err != nil {
					return err
				}
				spup.AppRoleAssignmentRequired = &appRoleAssignmentRequired
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				spup.DisplayName = &displayName
			}
		case "errorUrl":
			if v != nil {
				var errorURL string
				err = json.Unmarshal(*v, &errorURL)
				if err != nil {
					return err
				}
				spup.ErrorURL = &errorURL
			}
		case "homepage":
			if v != nil {
				var homepage string
				err = json.Unmarshal(*v, &homepage)
				if err != nil {
					return err
				}
				spup.Homepage = &homepage
			}
		case "keyCredentials":
			if v != nil {
				var keyCredentials []KeyCredential
				err = json.Unmarshal(*v, &keyCredentials)
				if err != nil {
					return err
				}
				spup.KeyCredentials = &keyCredentials
			}
		case "passwordCredentials":
			if v != nil {
				var passwordCredentials []PasswordCredential
				err = json.Unmarshal(*v, &passwordCredentials)
				if err != nil {
					return err
				}
				spup.PasswordCredentials = &passwordCredentials
			}
		case "publisherName":
			if v != nil {
				var publisherName string
				err = json.Unmarshal(*v, &publisherName)
				if err != nil {
					return err
				}
				spup.PublisherName = &publisherName
			}
		case "replyUrls":
			if v != nil {
				var replyUrls []string
				err = json.Unmarshal(*v, &replyUrls)
				if err != nil {
					return err
				}
				spup.ReplyUrls = &replyUrls
			}
		case "samlMetadataUrl":
			if v != nil {
				var samlMetadataURL string
				err = json.Unmarshal(*v, &samlMetadataURL)
				if err != nil {
					return err
				}
				spup.SamlMetadataURL = &samlMetadataURL
			}
		case "servicePrincipalNames":
			if v != nil {
				var servicePrincipalNames []string
				err = json.Unmarshal(*v, &servicePrincipalNames)
				if err != nil {
					return err
				}
				spup.ServicePrincipalNames = &servicePrincipalNames
			}
		case "tags":
			if v != nil {
				var tags []string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				spup.Tags = &tags
			}
		}
	}

	return nil
}

// SignInName contains information about a sign-in name of a local account user in an Azure Active
// Directory B2C tenant.
type SignInName struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Type - A string value that can be used to classify user sign-in types in your directory, such as 'emailAddress' or 'userName'.
	Type *string `json:"type,omitempty"`
	// Value - The sign-in used by the local account. Must be unique across the company/tenant. For example, 'johnc@example.com'.
	Value *string `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for SignInName.
func (sin SignInName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sin.Type != nil {
		objectMap["type"] = sin.Type
	}
	if sin.Value != nil {
		objectMap["value"] = sin.Value
	}
	for k, v := range sin.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SignInName struct.
func (sin *SignInName) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if sin.AdditionalProperties == nil {
					sin.AdditionalProperties = make(map[string]interface{})
				}
				sin.AdditionalProperties[k] = additionalProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sin.Type = &typeVar
			}
		case "value":
			if v != nil {
				var value string
				err = json.Unmarshal(*v, &value)
				if err != nil {
					return err
				}
				sin.Value = &value
			}
		}
	}

	return nil
}

// User active Directory user information.
type User struct {
	autorest.Response `json:"-"`
	// ImmutableID - This must be specified if you are using a federated domain for the user's userPrincipalName (UPN) property when creating a new user account. It is used to associate an on-premises Active Directory user account with their Azure AD user object.
	ImmutableID *string `json:"immutableId,omitempty"`
	// UsageLocation - A two letter country code (ISO standard 3166). Required for users that will be assigned licenses due to legal requirement to check for availability of services in countries. Examples include: "US", "JP", and "GB".
	UsageLocation *string `json:"usageLocation,omitempty"`
	// GivenName - The given name for the user.
	GivenName *string `json:"givenName,omitempty"`
	// Surname - The user's surname (family name or last name).
	Surname *string `json:"surname,omitempty"`
	// UserType - A string value that can be used to classify user types in your directory, such as 'Member' and 'Guest'. Possible values include: 'Member', 'Guest'
	UserType UserType `json:"userType,omitempty"`
	// AccountEnabled - Whether the account is enabled.
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// DisplayName - The display name of the user.
	DisplayName *string `json:"displayName,omitempty"`
	// UserPrincipalName - The principal name of the user.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// MailNickname - The mail alias for the user.
	MailNickname *string `json:"mailNickname,omitempty"`
	// Mail - The primary email address of the user.
	Mail *string `json:"mail,omitempty"`
	// SignInNames - The sign-in names of the user.
	SignInNames *[]SignInName `json:"signInNames,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ObjectID - The object ID.
	ObjectID *string `json:"objectId,omitempty"`
	// DeletionTimestamp - The time at which the directory object was deleted.
	DeletionTimestamp *date.Time `json:"deletionTimestamp,omitempty"`
	// ObjectType - Possible values include: 'ObjectTypeDirectoryObject', 'ObjectTypeApplication', 'ObjectTypeGroup', 'ObjectTypeServicePrincipal', 'ObjectTypeUser'
	ObjectType ObjectType `json:"objectType,omitempty"`
}

// MarshalJSON is the custom marshaler for User.
func (u User) MarshalJSON() ([]byte, error) {
	u.ObjectType = ObjectTypeUser
	objectMap := make(map[string]interface{})
	if u.ImmutableID != nil {
		objectMap["immutableId"] = u.ImmutableID
	}
	if u.UsageLocation != nil {
		objectMap["usageLocation"] = u.UsageLocation
	}
	if u.GivenName != nil {
		objectMap["givenName"] = u.GivenName
	}
	if u.Surname != nil {
		objectMap["surname"] = u.Surname
	}
	if u.UserType != "" {
		objectMap["userType"] = u.UserType
	}
	if u.AccountEnabled != nil {
		objectMap["accountEnabled"] = u.AccountEnabled
	}
	if u.DisplayName != nil {
		objectMap["displayName"] = u.DisplayName
	}
	if u.UserPrincipalName != nil {
		objectMap["userPrincipalName"] = u.UserPrincipalName
	}
	if u.MailNickname != nil {
		objectMap["mailNickname"] = u.MailNickname
	}
	if u.Mail != nil {
		objectMap["mail"] = u.Mail
	}
	if u.SignInNames != nil {
		objectMap["signInNames"] = u.SignInNames
	}
	if u.ObjectID != nil {
		objectMap["objectId"] = u.ObjectID
	}
	if u.DeletionTimestamp != nil {
		objectMap["deletionTimestamp"] = u.DeletionTimestamp
	}
	if u.ObjectType != "" {
		objectMap["objectType"] = u.ObjectType
	}
	for k, v := range u.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// AsApplication is the BasicDirectoryObject implementation for User.
func (u User) AsApplication() (*Application, bool) {
	return nil, false
}

// AsADGroup is the BasicDirectoryObject implementation for User.
func (u User) AsADGroup() (*ADGroup, bool) {
	return nil, false
}

// AsServicePrincipal is the BasicDirectoryObject implementation for User.
func (u User) AsServicePrincipal() (*ServicePrincipal, bool) {
	return nil, false
}

// AsUser is the BasicDirectoryObject implementation for User.
func (u User) AsUser() (*User, bool) {
	return &u, true
}

// AsDirectoryObject is the BasicDirectoryObject implementation for User.
func (u User) AsDirectoryObject() (*DirectoryObject, bool) {
	return nil, false
}

// AsBasicDirectoryObject is the BasicDirectoryObject implementation for User.
func (u User) AsBasicDirectoryObject() (BasicDirectoryObject, bool) {
	return &u, true
}

// UnmarshalJSON is the custom unmarshaler for User struct.
func (u *User) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "immutableId":
			if v != nil {
				var immutableID string
				err = json.Unmarshal(*v, &immutableID)
				if err != nil {
					return err
				}
				u.ImmutableID = &immutableID
			}
		case "usageLocation":
			if v != nil {
				var usageLocation string
				err = json.Unmarshal(*v, &usageLocation)
				if err != nil {
					return err
				}
				u.UsageLocation = &usageLocation
			}
		case "givenName":
			if v != nil {
				var givenName string
				err = json.Unmarshal(*v, &givenName)
				if err != nil {
					return err
				}
				u.GivenName = &givenName
			}
		case "surname":
			if v != nil {
				var surname string
				err = json.Unmarshal(*v, &surname)
				if err != nil {
					return err
				}
				u.Surname = &surname
			}
		case "userType":
			if v != nil {
				var userType UserType
				err = json.Unmarshal(*v, &userType)
				if err != nil {
					return err
				}
				u.UserType = userType
			}
		case "accountEnabled":
			if v != nil {
				var accountEnabled bool
				err = json.Unmarshal(*v, &accountEnabled)
				if err != nil {
					return err
				}
				u.AccountEnabled = &accountEnabled
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				u.DisplayName = &displayName
			}
		case "userPrincipalName":
			if v != nil {
				var userPrincipalName string
				err = json.Unmarshal(*v, &userPrincipalName)
				if err != nil {
					return err
				}
				u.UserPrincipalName = &userPrincipalName
			}
		case "mailNickname":
			if v != nil {
				var mailNickname string
				err = json.Unmarshal(*v, &mailNickname)
				if err != nil {
					return err
				}
				u.MailNickname = &mailNickname
			}
		case "mail":
			if v != nil {
				var mailVar string
				err = json.Unmarshal(*v, &mailVar)
				if err != nil {
					return err
				}
				u.Mail = &mailVar
			}
		case "signInNames":
			if v != nil {
				var signInNames []SignInName
				err = json.Unmarshal(*v, &signInNames)
				if err != nil {
					return err
				}
				u.SignInNames = &signInNames
			}
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if u.AdditionalProperties == nil {
					u.AdditionalProperties = make(map[string]interface{})
				}
				u.AdditionalProperties[k] = additionalProperties
			}
		case "objectId":
			if v != nil {
				var objectID string
				err = json.Unmarshal(*v, &objectID)
				if err != nil {
					return err
				}
				u.ObjectID = &objectID
			}
		case "deletionTimestamp":
			if v != nil {
				var deletionTimestamp date.Time
				err = json.Unmarshal(*v, &deletionTimestamp)
				if err != nil {
					return err
				}
				u.DeletionTimestamp = &deletionTimestamp
			}
		case "objectType":
			if v != nil {
				var objectType ObjectType
				err = json.Unmarshal(*v, &objectType)
				if err != nil {
					return err
				}
				u.ObjectType = objectType
			}
		}
	}

	return nil
}

// UserBase ...
type UserBase struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ImmutableID - This must be specified if you are using a federated domain for the user's userPrincipalName (UPN) property when creating a new user account. It is used to associate an on-premises Active Directory user account with their Azure AD user object.
	ImmutableID *string `json:"immutableId,omitempty"`
	// UsageLocation - A two letter country code (ISO standard 3166). Required for users that will be assigned licenses due to legal requirement to check for availability of services in countries. Examples include: "US", "JP", and "GB".
	UsageLocation *string `json:"usageLocation,omitempty"`
	// GivenName - The given name for the user.
	GivenName *string `json:"givenName,omitempty"`
	// Surname - The user's surname (family name or last name).
	Surname *string `json:"surname,omitempty"`
	// UserType - A string value that can be used to classify user types in your directory, such as 'Member' and 'Guest'. Possible values include: 'Member', 'Guest'
	UserType UserType `json:"userType,omitempty"`
}

// MarshalJSON is the custom marshaler for UserBase.
func (ub UserBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ub.ImmutableID != nil {
		objectMap["immutableId"] = ub.ImmutableID
	}
	if ub.UsageLocation != nil {
		objectMap["usageLocation"] = ub.UsageLocation
	}
	if ub.GivenName != nil {
		objectMap["givenName"] = ub.GivenName
	}
	if ub.Surname != nil {
		objectMap["surname"] = ub.Surname
	}
	if ub.UserType != "" {
		objectMap["userType"] = ub.UserType
	}
	for k, v := range ub.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for UserBase struct.
func (ub *UserBase) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ub.AdditionalProperties == nil {
					ub.AdditionalProperties = make(map[string]interface{})
				}
				ub.AdditionalProperties[k] = additionalProperties
			}
		case "immutableId":
			if v != nil {
				var immutableID string
				err = json.Unmarshal(*v, &immutableID)
				if err != nil {
					return err
				}
				ub.ImmutableID = &immutableID
			}
		case "usageLocation":
			if v != nil {
				var usageLocation string
				err = json.Unmarshal(*v, &usageLocation)
				if err != nil {
					return err
				}
				ub.UsageLocation = &usageLocation
			}
		case "givenName":
			if v != nil {
				var givenName string
				err = json.Unmarshal(*v, &givenName)
				if err != nil {
					return err
				}
				ub.GivenName = &givenName
			}
		case "surname":
			if v != nil {
				var surname string
				err = json.Unmarshal(*v, &surname)
				if err != nil {
					return err
				}
				ub.Surname = &surname
			}
		case "userType":
			if v != nil {
				var userType UserType
				err = json.Unmarshal(*v, &userType)
				if err != nil {
					return err
				}
				ub.UserType = userType
			}
		}
	}

	return nil
}

// UserCreateParameters request parameters for creating a new work or school account user.
type UserCreateParameters struct {
	// AccountEnabled - Whether the account is enabled.
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// DisplayName - The display name of the user.
	DisplayName *string `json:"displayName,omitempty"`
	// PasswordProfile - Password Profile
	PasswordProfile *PasswordProfile `json:"passwordProfile,omitempty"`
	// UserPrincipalName - The user principal name (someuser@contoso.com). It must contain one of the verified domains for the tenant.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// MailNickname - The mail alias for the user.
	MailNickname *string `json:"mailNickname,omitempty"`
	// Mail - The primary email address of the user.
	Mail *string `json:"mail,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ImmutableID - This must be specified if you are using a federated domain for the user's userPrincipalName (UPN) property when creating a new user account. It is used to associate an on-premises Active Directory user account with their Azure AD user object.
	ImmutableID *string `json:"immutableId,omitempty"`
	// UsageLocation - A two letter country code (ISO standard 3166). Required for users that will be assigned licenses due to legal requirement to check for availability of services in countries. Examples include: "US", "JP", and "GB".
	UsageLocation *string `json:"usageLocation,omitempty"`
	// GivenName - The given name for the user.
	GivenName *string `json:"givenName,omitempty"`
	// Surname - The user's surname (family name or last name).
	Surname *string `json:"surname,omitempty"`
	// UserType - A string value that can be used to classify user types in your directory, such as 'Member' and 'Guest'. Possible values include: 'Member', 'Guest'
	UserType UserType `json:"userType,omitempty"`
}

// MarshalJSON is the custom marshaler for UserCreateParameters.
func (ucp UserCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ucp.AccountEnabled != nil {
		objectMap["accountEnabled"] = ucp.AccountEnabled
	}
	if ucp.DisplayName != nil {
		objectMap["displayName"] = ucp.DisplayName
	}
	if ucp.PasswordProfile != nil {
		objectMap["passwordProfile"] = ucp.PasswordProfile
	}
	if ucp.UserPrincipalName != nil {
		objectMap["userPrincipalName"] = ucp.UserPrincipalName
	}
	if ucp.MailNickname != nil {
		objectMap["mailNickname"] = ucp.MailNickname
	}
	if ucp.Mail != nil {
		objectMap["mail"] = ucp.Mail
	}
	if ucp.ImmutableID != nil {
		objectMap["immutableId"] = ucp.ImmutableID
	}
	if ucp.UsageLocation != nil {
		objectMap["usageLocation"] = ucp.UsageLocation
	}
	if ucp.GivenName != nil {
		objectMap["givenName"] = ucp.GivenName
	}
	if ucp.Surname != nil {
		objectMap["surname"] = ucp.Surname
	}
	if ucp.UserType != "" {
		objectMap["userType"] = ucp.UserType
	}
	for k, v := range ucp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for UserCreateParameters struct.
func (ucp *UserCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "accountEnabled":
			if v != nil {
				var accountEnabled bool
				err = json.Unmarshal(*v, &accountEnabled)
				if err != nil {
					return err
				}
				ucp.AccountEnabled = &accountEnabled
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				ucp.DisplayName = &displayName
			}
		case "passwordProfile":
			if v != nil {
				var passwordProfile PasswordProfile
				err = json.Unmarshal(*v, &passwordProfile)
				if err != nil {
					return err
				}
				ucp.PasswordProfile = &passwordProfile
			}
		case "userPrincipalName":
			if v != nil {
				var userPrincipalName string
				err = json.Unmarshal(*v, &userPrincipalName)
				if err != nil {
					return err
				}
				ucp.UserPrincipalName = &userPrincipalName
			}
		case "mailNickname":
			if v != nil {
				var mailNickname string
				err = json.Unmarshal(*v, &mailNickname)
				if err != nil {
					return err
				}
				ucp.MailNickname = &mailNickname
			}
		case "mail":
			if v != nil {
				var mailVar string
				err = json.Unmarshal(*v, &mailVar)
				if err != nil {
					return err
				}
				ucp.Mail = &mailVar
			}
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ucp.AdditionalProperties == nil {
					ucp.AdditionalProperties = make(map[string]interface{})
				}
				ucp.AdditionalProperties[k] = additionalProperties
			}
		case "immutableId":
			if v != nil {
				var immutableID string
				err = json.Unmarshal(*v, &immutableID)
				if err != nil {
					return err
				}
				ucp.ImmutableID = &immutableID
			}
		case "usageLocation":
			if v != nil {
				var usageLocation string
				err = json.Unmarshal(*v, &usageLocation)
				if err != nil {
					return err
				}
				ucp.UsageLocation = &usageLocation
			}
		case "givenName":
			if v != nil {
				var givenName string
				err = json.Unmarshal(*v, &givenName)
				if err != nil {
					return err
				}
				ucp.GivenName = &givenName
			}
		case "surname":
			if v != nil {
				var surname string
				err = json.Unmarshal(*v, &surname)
				if err != nil {
					return err
				}
				ucp.Surname = &surname
			}
		case "userType":
			if v != nil {
				var userType UserType
				err = json.Unmarshal(*v, &userType)
				if err != nil {
					return err
				}
				ucp.UserType = userType
			}
		}
	}

	return nil
}

// UserGetMemberGroupsParameters request parameters for GetMemberGroups API call.
type UserGetMemberGroupsParameters struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// SecurityEnabledOnly - If true, only membership in security-enabled groups should be checked. Otherwise, membership in all groups should be checked.
	SecurityEnabledOnly *bool `json:"securityEnabledOnly,omitempty"`
}

// MarshalJSON is the custom marshaler for UserGetMemberGroupsParameters.
func (ugmgp UserGetMemberGroupsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ugmgp.SecurityEnabledOnly != nil {
		objectMap["securityEnabledOnly"] = ugmgp.SecurityEnabledOnly
	}
	for k, v := range ugmgp.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for UserGetMemberGroupsParameters struct.
func (ugmgp *UserGetMemberGroupsParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ugmgp.AdditionalProperties == nil {
					ugmgp.AdditionalProperties = make(map[string]interface{})
				}
				ugmgp.AdditionalProperties[k] = additionalProperties
			}
		case "securityEnabledOnly":
			if v != nil {
				var securityEnabledOnly bool
				err = json.Unmarshal(*v, &securityEnabledOnly)
				if err != nil {
					return err
				}
				ugmgp.SecurityEnabledOnly = &securityEnabledOnly
			}
		}
	}

	return nil
}

// UserGetMemberGroupsResult server response for GetMemberGroups API call.
type UserGetMemberGroupsResult struct {
	autorest.Response `json:"-"`
	// Value - A collection of group IDs of which the user is a member.
	Value *[]string `json:"value,omitempty"`
}

// UserListResult server response for Get tenant users API call.
type UserListResult struct {
	autorest.Response `json:"-"`
	// Value - the list of users.
	Value *[]User `json:"value,omitempty"`
	// OdataNextLink - The URL to get the next set of results.
	OdataNextLink *string `json:"odata.nextLink,omitempty"`
}

// UserListResultIterator provides access to a complete listing of User values.
type UserListResultIterator struct {
	i    int
	page UserListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *UserListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UserListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *UserListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter UserListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter UserListResultIterator) Response() UserListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter UserListResultIterator) Value() User {
	if !iter.page.NotDone() {
		return User{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the UserListResultIterator type.
func NewUserListResultIterator(page UserListResultPage) UserListResultIterator {
	return UserListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ulr UserListResult) IsEmpty() bool {
	return ulr.Value == nil || len(*ulr.Value) == 0
}

// UserListResultPage contains a page of User values.
type UserListResultPage struct {
	fn  func(context.Context, UserListResult) (UserListResult, error)
	ulr UserListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *UserListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/UserListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.ulr)
	if err != nil {
		return err
	}
	page.ulr = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *UserListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page UserListResultPage) NotDone() bool {
	return !page.ulr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page UserListResultPage) Response() UserListResult {
	return page.ulr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page UserListResultPage) Values() []User {
	if page.ulr.IsEmpty() {
		return nil
	}
	return *page.ulr.Value
}

// Creates a new instance of the UserListResultPage type.
func NewUserListResultPage(getNextPage func(context.Context, UserListResult) (UserListResult, error)) UserListResultPage {
	return UserListResultPage{fn: getNextPage}
}

// UserUpdateParameters request parameters for updating an existing work or school account user.
type UserUpdateParameters struct {
	// AccountEnabled - Whether the account is enabled.
	AccountEnabled *bool `json:"accountEnabled,omitempty"`
	// DisplayName - The display name of the user.
	DisplayName *string `json:"displayName,omitempty"`
	// PasswordProfile - The password profile of the user.
	PasswordProfile *PasswordProfile `json:"passwordProfile,omitempty"`
	// UserPrincipalName - The user principal name (someuser@contoso.com). It must contain one of the verified domains for the tenant.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// MailNickname - The mail alias for the user.
	MailNickname *string `json:"mailNickname,omitempty"`
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// ImmutableID - This must be specified if you are using a federated domain for the user's userPrincipalName (UPN) property when creating a new user account. It is used to associate an on-premises Active Directory user account with their Azure AD user object.
	ImmutableID *string `json:"immutableId,omitempty"`
	// UsageLocation - A two letter country code (ISO standard 3166). Required for users that will be assigned licenses due to legal requirement to check for availability of services in countries. Examples include: "US", "JP", and "GB".
	UsageLocation *string `json:"usageLocation,omitempty"`
	// GivenName - The given name for the user.
	GivenName *string `json:"givenName,omitempty"`
	// Surname - The user's surname (family name or last name).
	Surname *string `json:"surname,omitempty"`
	// UserType - A string value that can be used to classify user types in your directory, such as 'Member' and 'Guest'. Possible values include: 'Member', 'Guest'
	UserType UserType `json:"userType,omitempty"`
}

// MarshalJSON is the custom marshaler for UserUpdateParameters.
func (uup UserUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if uup.AccountEnabled != nil {
		objectMap["accountEnabled"] = uup.AccountEnabled
	}
	if uup.DisplayName != nil {
		objectMap["displayName"] = uup.DisplayName
	}
	if uup.PasswordProfile != nil {
		objectMap["passwordProfile"] = uup.PasswordProfile
	}
	if uup.UserPrincipalName != nil {
		objectMap["userPrincipalName"] = uup.UserPrincipalName
	}
	if uup.MailNickname != nil {
		objectMap["mailNickname"] = uup.MailNickname
	}
	if uup.ImmutableID != nil {
		objectMap["immutableId"] = uup.ImmutableID
	}
	if uup.UsageLocation != nil {
		objectMap["usageLocation"] = uup.UsageLocation
	}
	if uup.GivenName != nil {
		objectMap["givenName"] = uup.GivenName
	}
	if uup.Surname != nil {
		objectMap["surname"] = uup.Surname
	}
	if uup.UserType != "" {
		objectMap["userType"] = uup.UserType
	}
	for k, v := range uup.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for UserUpdateParameters struct.
func (uup *UserUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "accountEnabled":
			if v != nil {
				var accountEnabled bool
				err = json.Unmarshal(*v, &accountEnabled)
				if err != nil {
					return err
				}
				uup.AccountEnabled = &accountEnabled
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				uup.DisplayName = &displayName
			}
		case "passwordProfile":
			if v != nil {
				var passwordProfile PasswordProfile
				err = json.Unmarshal(*v, &passwordProfile)
				if err != nil {
					return err
				}
				uup.PasswordProfile = &passwordProfile
			}
		case "userPrincipalName":
			if v != nil {
				var userPrincipalName string
				err = json.Unmarshal(*v, &userPrincipalName)
				if err != nil {
					return err
				}
				uup.UserPrincipalName = &userPrincipalName
			}
		case "mailNickname":
			if v != nil {
				var mailNickname string
				err = json.Unmarshal(*v, &mailNickname)
				if err != nil {
					return err
				}
				uup.MailNickname = &mailNickname
			}
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if uup.AdditionalProperties == nil {
					uup.AdditionalProperties = make(map[string]interface{})
				}
				uup.AdditionalProperties[k] = additionalProperties
			}
		case "immutableId":
			if v != nil {
				var immutableID string
				err = json.Unmarshal(*v, &immutableID)
				if err != nil {
					return err
				}
				uup.ImmutableID = &immutableID
			}
		case "usageLocation":
			if v != nil {
				var usageLocation string
				err = json.Unmarshal(*v, &usageLocation)
				if err != nil {
					return err
				}
				uup.UsageLocation = &usageLocation
			}
		case "givenName":
			if v != nil {
				var givenName string
				err = json.Unmarshal(*v, &givenName)
				if err != nil {
					return err
				}
				uup.GivenName = &givenName
			}
		case "surname":
			if v != nil {
				var surname string
				err = json.Unmarshal(*v, &surname)
				if err != nil {
					return err
				}
				uup.Surname = &surname
			}
		case "userType":
			if v != nil {
				var userType UserType
				err = json.Unmarshal(*v, &userType)
				if err != nil {
					return err
				}
				uup.UserType = userType
			}
		}
	}

	return nil
}
