package logic

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/xml"
	"reflect"
	"time"
	"unsafe"
)

const (
	rfc3339Format = "2006-01-02T15:04:05.0000000Z07:00"
)

// used to convert times from UTC to GMT before sending across the wire
var gmt = time.FixedZone("GMT", 0)

// internal type used for marshalling time in RFC1123 format
type timeRFC1123 struct {
	time.Time
}

// MarshalText implements the encoding.TextMarshaler interface for timeRFC1123.
func (t timeRFC1123) MarshalText() ([]byte, error) {
	return []byte(t.Format(time.RFC1123)), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for timeRFC1123.
func (t *timeRFC1123) UnmarshalText(data []byte) (err error) {
	t.Time, err = time.Parse(time.RFC1123, string(data))
	return
}

// internal type used for marshalling time in RFC3339 format
type timeRFC3339 struct {
	time.Time
}

// MarshalText implements the encoding.TextMarshaler interface for timeRFC3339.
func (t timeRFC3339) MarshalText() ([]byte, error) {
	return []byte(t.Format(rfc3339Format)), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for timeRFC3339.
func (t *timeRFC3339) UnmarshalText(data []byte) (err error) {
	t.Time, err = time.Parse(rfc3339Format, string(data))
	return
}

// internal type used for marshalling
type listCallbackURLParameters struct {
	NotAfter *timeRFC3339 `json:"NotAfter,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for ListCallbackURLParameters.
func (lcup ListCallbackURLParameters) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*ListCallbackURLParameters)(nil)).Elem().Size() != reflect.TypeOf((*listCallbackURLParameters)(nil)).Elem().Size() {
		panic("size mismatch between ListCallbackURLParameters and listCallbackURLParameters")
	}
	lcup2 := (*listCallbackURLParameters)(unsafe.Pointer(&lcup))
	return e.EncodeElement(*lcup2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for ListCallbackURLParameters.
func (lcup *ListCallbackURLParameters) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*ListCallbackURLParameters)(nil)).Elem().Size() != reflect.TypeOf((*listCallbackURLParameters)(nil)).Elem().Size() {
		panic("size mismatch between ListCallbackURLParameters and listCallbackURLParameters")
	}
	lcup2 := (*listCallbackURLParameters)(unsafe.Pointer(lcup))
	return d.DecodeElement(lcup2, &start)
}

// internal type used for marshalling
type integrationAccountSchemaProperties struct {
	SchemaType      SchemaType                     `json:"schemaType,omitempty"`
	TargetNamespace *string                        `json:"targetNamespace,omitempty"`
	CreatedTime     *timeRFC3339                   `json:"createdTime,omitempty"`
	ChangedTime     *timeRFC3339                   `json:"changedTime,omitempty"`
	Content         map[string]interface{}         `json:"content,omitempty"`
	ContentType     *string                        `json:"contentType,omitempty"`
	ContentLink     *IntegrationAccountContentLink `json:"contentLink,omitempty"`
	Metadata        map[string]interface{}         `json:"metadata,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountSchemaProperties.
func (iasp IntegrationAccountSchemaProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSchemaProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSchemaProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSchemaProperties and integrationAccountSchemaProperties")
	}
	iasp2 := (*integrationAccountSchemaProperties)(unsafe.Pointer(&iasp))
	return e.EncodeElement(*iasp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountSchemaProperties.
func (iasp *IntegrationAccountSchemaProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSchemaProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSchemaProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSchemaProperties and integrationAccountSchemaProperties")
	}
	iasp2 := (*integrationAccountSchemaProperties)(unsafe.Pointer(iasp))
	return d.DecodeElement(iasp2, &start)
}

// internal type used for marshalling
type integrationAccountMapProperties struct {
	MapType     MapType                        `json:"mapType,omitempty"`
	CreatedTime *timeRFC3339                   `json:"createdTime,omitempty"`
	ChangedTime *timeRFC3339                   `json:"changedTime,omitempty"`
	Content     map[string]interface{}         `json:"content,omitempty"`
	ContentType *string                        `json:"contentType,omitempty"`
	ContentLink *IntegrationAccountContentLink `json:"contentLink,omitempty"`
	Metadata    map[string]interface{}         `json:"metadata,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountMapProperties.
func (iamp IntegrationAccountMapProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountMapProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountMapProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountMapProperties and integrationAccountMapProperties")
	}
	iamp2 := (*integrationAccountMapProperties)(unsafe.Pointer(&iamp))
	return e.EncodeElement(*iamp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountMapProperties.
func (iamp *IntegrationAccountMapProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountMapProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountMapProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountMapProperties and integrationAccountMapProperties")
	}
	iamp2 := (*integrationAccountMapProperties)(unsafe.Pointer(iamp))
	return d.DecodeElement(iamp2, &start)
}

// internal type used for marshalling
type integrationAccountPartnerProperties struct {
	PartnerType PartnerType            `json:"partnerType,omitempty"`
	CreatedTime *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Content     *PartnerContent        `json:"content,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountPartnerProperties.
func (iapp IntegrationAccountPartnerProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountPartnerProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountPartnerProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountPartnerProperties and integrationAccountPartnerProperties")
	}
	iapp2 := (*integrationAccountPartnerProperties)(unsafe.Pointer(&iapp))
	return e.EncodeElement(*iapp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountPartnerProperties.
func (iapp *IntegrationAccountPartnerProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountPartnerProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountPartnerProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountPartnerProperties and integrationAccountPartnerProperties")
	}
	iapp2 := (*integrationAccountPartnerProperties)(unsafe.Pointer(iapp))
	return d.DecodeElement(iapp2, &start)
}

// internal type used for marshalling
type integrationAccountAgreementProperties struct {
	CreatedTime   *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime   *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
	AgreementType AgreementType          `json:"agreementType,omitempty"`
	HostPartner   *string                `json:"hostPartner,omitempty"`
	GuestPartner  *string                `json:"guestPartner,omitempty"`
	HostIdentity  *BusinessIdentity      `json:"hostIdentity,omitempty"`
	GuestIdentity *BusinessIdentity      `json:"guestIdentity,omitempty"`
	Content       *AgreementContent      `json:"content,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountAgreementProperties.
func (iaap IntegrationAccountAgreementProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountAgreementProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountAgreementProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountAgreementProperties and integrationAccountAgreementProperties")
	}
	iaap2 := (*integrationAccountAgreementProperties)(unsafe.Pointer(&iaap))
	return e.EncodeElement(*iaap2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountAgreementProperties.
func (iaap *IntegrationAccountAgreementProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountAgreementProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountAgreementProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountAgreementProperties and integrationAccountAgreementProperties")
	}
	iaap2 := (*integrationAccountAgreementProperties)(unsafe.Pointer(iaap))
	return d.DecodeElement(iaap2, &start)
}

// internal type used for marshalling
type integrationAccountCertificateProperties struct {
	CreatedTime       *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime       *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata          map[string]interface{} `json:"metadata,omitempty"`
	Key               *KeyVaultKeyReference  `json:"key,omitempty"`
	PublicCertificate *string                `json:"publicCertificate,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountCertificateProperties.
func (iacp IntegrationAccountCertificateProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountCertificateProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountCertificateProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountCertificateProperties and integrationAccountCertificateProperties")
	}
	iacp2 := (*integrationAccountCertificateProperties)(unsafe.Pointer(&iacp))
	return e.EncodeElement(*iacp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountCertificateProperties.
func (iacp *IntegrationAccountCertificateProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountCertificateProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountCertificateProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountCertificateProperties and integrationAccountCertificateProperties")
	}
	iacp2 := (*integrationAccountCertificateProperties)(unsafe.Pointer(iacp))
	return d.DecodeElement(iacp2, &start)
}
