package logic

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/xml"
	"reflect"
	"time"
	"unsafe"
)

const (
	rfc3339Format = "2006-01-02T15:04:05.0000000Z07:00"
)

// used to convert times from UTC to GMT before sending across the wire
var gmt = time.FixedZone("GMT", 0)

// internal type used for marshalling time in RFC1123 format
type timeRFC1123 struct {
	time.Time
}

// MarshalText implements the encoding.TextMarshaler interface for timeRFC1123.
func (t timeRFC1123) MarshalText() ([]byte, error) {
	return []byte(t.Format(time.RFC1123)), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for timeRFC1123.
func (t *timeRFC1123) UnmarshalText(data []byte) (err error) {
	t.Time, err = time.Parse(time.RFC1123, string(data))
	return
}

// internal type used for marshalling time in RFC3339 format
type timeRFC3339 struct {
	time.Time
}

// MarshalText implements the encoding.TextMarshaler interface for timeRFC3339.
func (t timeRFC3339) MarshalText() ([]byte, error) {
	return []byte(t.Format(rfc3339Format)), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for timeRFC3339.
func (t *timeRFC3339) UnmarshalText(data []byte) (err error) {
	t.Time, err = time.Parse(rfc3339Format, string(data))
	return
}

// internal type used for marshalling
type workflowProperties struct {
	ProvisioningState  WorkflowProvisioningStateType `json:"provisioningState,omitempty"`
	CreatedTime        *timeRFC3339                  `json:"createdTime,omitempty"`
	ChangedTime        *timeRFC3339                  `json:"changedTime,omitempty"`
	State              WorkflowStateType             `json:"state,omitempty"`
	Version            *string                       `json:"version,omitempty"`
	AccessEndpoint     *string                       `json:"accessEndpoint,omitempty"`
	Sku                *Sku                          `json:"sku,omitempty"`
	IntegrationAccount *ResourceReference            `json:"integrationAccount,omitempty"`
	Definition         map[string]interface{}        `json:"definition,omitempty"`
	Parameters         map[string]WorkflowParameter  `json:"parameters,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowProperties.
func (wp WorkflowProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowProperties and workflowProperties")
	}
	wp2 := (*workflowProperties)(unsafe.Pointer(&wp))
	return e.EncodeElement(*wp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowProperties.
func (wp *WorkflowProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowProperties and workflowProperties")
	}
	wp2 := (*workflowProperties)(unsafe.Pointer(wp))
	return d.DecodeElement(wp2, &start)
}

// internal type used for marshalling
type workflowVersionProperties struct {
	CreatedTime        *timeRFC3339                 `json:"createdTime,omitempty"`
	ChangedTime        *timeRFC3339                 `json:"changedTime,omitempty"`
	State              WorkflowStateType            `json:"state,omitempty"`
	Version            *string                      `json:"version,omitempty"`
	AccessEndpoint     *string                      `json:"accessEndpoint,omitempty"`
	Sku                *Sku                         `json:"sku,omitempty"`
	IntegrationAccount *ResourceReference           `json:"integrationAccount,omitempty"`
	Definition         map[string]interface{}       `json:"definition,omitempty"`
	Parameters         map[string]WorkflowParameter `json:"parameters,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowVersionProperties.
func (wvp WorkflowVersionProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowVersionProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowVersionProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowVersionProperties and workflowVersionProperties")
	}
	wvp2 := (*workflowVersionProperties)(unsafe.Pointer(&wvp))
	return e.EncodeElement(*wvp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowVersionProperties.
func (wvp *WorkflowVersionProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowVersionProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowVersionProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowVersionProperties and workflowVersionProperties")
	}
	wvp2 := (*workflowVersionProperties)(unsafe.Pointer(wvp))
	return d.DecodeElement(wvp2, &start)
}

// internal type used for marshalling
type workflowTriggerRecurrence struct {
	Frequency RecurrenceFrequencyType `json:"frequency,omitempty"`
	Interval  *int32                  `json:"interval,omitempty"`
	StartTime *timeRFC3339            `json:"startTime,omitempty"`
	EndTime   *timeRFC3339            `json:"endTime,omitempty"`
	TimeZone  *string                 `json:"timeZone,omitempty"`
	Schedule  *RecurrenceSchedule     `json:"schedule,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowTriggerRecurrence.
func (wtr WorkflowTriggerRecurrence) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowTriggerRecurrence)(nil)).Elem().Size() != reflect.TypeOf((*workflowTriggerRecurrence)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowTriggerRecurrence and workflowTriggerRecurrence")
	}
	wtr2 := (*workflowTriggerRecurrence)(unsafe.Pointer(&wtr))
	return e.EncodeElement(*wtr2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowTriggerRecurrence.
func (wtr *WorkflowTriggerRecurrence) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowTriggerRecurrence)(nil)).Elem().Size() != reflect.TypeOf((*workflowTriggerRecurrence)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowTriggerRecurrence and workflowTriggerRecurrence")
	}
	wtr2 := (*workflowTriggerRecurrence)(unsafe.Pointer(wtr))
	return d.DecodeElement(wtr2, &start)
}

// internal type used for marshalling
type workflowTriggerProperties struct {
	ProvisioningState WorkflowTriggerProvisioningStateType `json:"provisioningState,omitempty"`
	CreatedTime       *timeRFC3339                         `json:"createdTime,omitempty"`
	ChangedTime       *timeRFC3339                         `json:"changedTime,omitempty"`
	State             WorkflowStateType                    `json:"state,omitempty"`
	Status            WorkflowStatusType                   `json:"status,omitempty"`
	LastExecutionTime *timeRFC3339                         `json:"lastExecutionTime,omitempty"`
	NextExecutionTime *timeRFC3339                         `json:"nextExecutionTime,omitempty"`
	Recurrence        *WorkflowTriggerRecurrence           `json:"recurrence,omitempty"`
	Workflow          *ResourceReference                   `json:"workflow,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowTriggerProperties.
func (wtp WorkflowTriggerProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowTriggerProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowTriggerProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowTriggerProperties and workflowTriggerProperties")
	}
	wtp2 := (*workflowTriggerProperties)(unsafe.Pointer(&wtp))
	return e.EncodeElement(*wtp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowTriggerProperties.
func (wtp *WorkflowTriggerProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowTriggerProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowTriggerProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowTriggerProperties and workflowTriggerProperties")
	}
	wtp2 := (*workflowTriggerProperties)(unsafe.Pointer(wtp))
	return d.DecodeElement(wtp2, &start)
}

// internal type used for marshalling
type workflowTriggerHistoryProperties struct {
	StartTime   *timeRFC3339           `json:"startTime,omitempty"`
	EndTime     *timeRFC3339           `json:"endTime,omitempty"`
	Status      WorkflowStatusType     `json:"status,omitempty"`
	Code        *string                `json:"code,omitempty"`
	Error       map[string]interface{} `json:"error,omitempty"`
	TrackingID  *string                `json:"trackingId,omitempty"`
	Correlation *Correlation           `json:"correlation,omitempty"`
	InputsLink  *ContentLink           `json:"inputsLink,omitempty"`
	OutputsLink *ContentLink           `json:"outputsLink,omitempty"`
	Fired       *bool                  `json:"fired,omitempty"`
	Run         *ResourceReference     `json:"run,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowTriggerHistoryProperties.
func (wthp WorkflowTriggerHistoryProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowTriggerHistoryProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowTriggerHistoryProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowTriggerHistoryProperties and workflowTriggerHistoryProperties")
	}
	wthp2 := (*workflowTriggerHistoryProperties)(unsafe.Pointer(&wthp))
	return e.EncodeElement(*wthp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowTriggerHistoryProperties.
func (wthp *WorkflowTriggerHistoryProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowTriggerHistoryProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowTriggerHistoryProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowTriggerHistoryProperties and workflowTriggerHistoryProperties")
	}
	wthp2 := (*workflowTriggerHistoryProperties)(unsafe.Pointer(wthp))
	return d.DecodeElement(wthp2, &start)
}

// internal type used for marshalling
type workflowRunTrigger struct {
	Name              *string                `json:"name,omitempty"`
	Inputs            map[string]interface{} `json:"inputs,omitempty"`
	InputsLink        *ContentLink           `json:"inputsLink,omitempty"`
	Outputs           map[string]interface{} `json:"outputs,omitempty"`
	OutputsLink       *ContentLink           `json:"outputsLink,omitempty"`
	StartTime         *timeRFC3339           `json:"startTime,omitempty"`
	EndTime           *timeRFC3339           `json:"endTime,omitempty"`
	TrackingID        *string                `json:"trackingId,omitempty"`
	Correlation       *Correlation           `json:"correlation,omitempty"`
	Code              *string                `json:"code,omitempty"`
	Status            WorkflowStatusType     `json:"status,omitempty"`
	Error             map[string]interface{} `json:"error,omitempty"`
	TrackedProperties map[string]interface{} `json:"trackedProperties,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowRunTrigger.
func (wrt WorkflowRunTrigger) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowRunTrigger)(nil)).Elem().Size() != reflect.TypeOf((*workflowRunTrigger)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowRunTrigger and workflowRunTrigger")
	}
	wrt2 := (*workflowRunTrigger)(unsafe.Pointer(&wrt))
	return e.EncodeElement(*wrt2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowRunTrigger.
func (wrt *WorkflowRunTrigger) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowRunTrigger)(nil)).Elem().Size() != reflect.TypeOf((*workflowRunTrigger)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowRunTrigger and workflowRunTrigger")
	}
	wrt2 := (*workflowRunTrigger)(unsafe.Pointer(wrt))
	return d.DecodeElement(wrt2, &start)
}

// internal type used for marshalling
type workflowRunProperties struct {
	StartTime     *timeRFC3339                       `json:"startTime,omitempty"`
	EndTime       *timeRFC3339                       `json:"endTime,omitempty"`
	Status        WorkflowStatusType                 `json:"status,omitempty"`
	Code          *string                            `json:"code,omitempty"`
	Error         map[string]interface{}             `json:"error,omitempty"`
	CorrelationID *string                            `json:"correlationId,omitempty"`
	Correlation   *Correlation                       `json:"correlation,omitempty"`
	Workflow      *ResourceReference                 `json:"workflow,omitempty"`
	Trigger       *WorkflowRunTrigger                `json:"trigger,omitempty"`
	Outputs       map[string]WorkflowOutputParameter `json:"outputs,omitempty"`
	Response      *WorkflowRunTrigger                `json:"response,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowRunProperties.
func (wrp WorkflowRunProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowRunProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowRunProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowRunProperties and workflowRunProperties")
	}
	wrp2 := (*workflowRunProperties)(unsafe.Pointer(&wrp))
	return e.EncodeElement(*wrp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowRunProperties.
func (wrp *WorkflowRunProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowRunProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowRunProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowRunProperties and workflowRunProperties")
	}
	wrp2 := (*workflowRunProperties)(unsafe.Pointer(wrp))
	return d.DecodeElement(wrp2, &start)
}

// internal type used for marshalling
type retryHistory struct {
	StartTime        *timeRFC3339   `json:"startTime,omitempty"`
	EndTime          *timeRFC3339   `json:"endTime,omitempty"`
	Code             *string        `json:"code,omitempty"`
	ClientRequestID  *string        `json:"clientRequestId,omitempty"`
	ServiceRequestID *string        `json:"serviceRequestId,omitempty"`
	Error            *ErrorResponse `json:"error,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for RetryHistory.
func (rh RetryHistory) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*RetryHistory)(nil)).Elem().Size() != reflect.TypeOf((*retryHistory)(nil)).Elem().Size() {
		panic("size mismatch between RetryHistory and retryHistory")
	}
	rh2 := (*retryHistory)(unsafe.Pointer(&rh))
	return e.EncodeElement(*rh2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for RetryHistory.
func (rh *RetryHistory) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*RetryHistory)(nil)).Elem().Size() != reflect.TypeOf((*retryHistory)(nil)).Elem().Size() {
		panic("size mismatch between RetryHistory and retryHistory")
	}
	rh2 := (*retryHistory)(unsafe.Pointer(rh))
	return d.DecodeElement(rh2, &start)
}

// internal type used for marshalling
type workflowRunActionProperties struct {
	StartTime         *timeRFC3339           `json:"startTime,omitempty"`
	EndTime           *timeRFC3339           `json:"endTime,omitempty"`
	Status            WorkflowStatusType     `json:"status,omitempty"`
	Code              *string                `json:"code,omitempty"`
	Error             map[string]interface{} `json:"error,omitempty"`
	TrackingID        *string                `json:"trackingId,omitempty"`
	Correlation       *Correlation           `json:"correlation,omitempty"`
	InputsLink        *ContentLink           `json:"inputsLink,omitempty"`
	OutputsLink       *ContentLink           `json:"outputsLink,omitempty"`
	TrackedProperties map[string]interface{} `json:"trackedProperties,omitempty"`
	RetryHistory      []RetryHistory         `json:"retryHistory,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for WorkflowRunActionProperties.
func (wrap WorkflowRunActionProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowRunActionProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowRunActionProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowRunActionProperties and workflowRunActionProperties")
	}
	wrap2 := (*workflowRunActionProperties)(unsafe.Pointer(&wrap))
	return e.EncodeElement(*wrap2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for WorkflowRunActionProperties.
func (wrap *WorkflowRunActionProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*WorkflowRunActionProperties)(nil)).Elem().Size() != reflect.TypeOf((*workflowRunActionProperties)(nil)).Elem().Size() {
		panic("size mismatch between WorkflowRunActionProperties and workflowRunActionProperties")
	}
	wrap2 := (*workflowRunActionProperties)(unsafe.Pointer(wrap))
	return d.DecodeElement(wrap2, &start)
}

// internal type used for marshalling
type getCallbackURLParameters struct {
	NotAfter *timeRFC3339 `json:"notAfter,omitempty"`
	KeyType  KeyType      `json:"keyType,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for GetCallbackURLParameters.
func (gcup GetCallbackURLParameters) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*GetCallbackURLParameters)(nil)).Elem().Size() != reflect.TypeOf((*getCallbackURLParameters)(nil)).Elem().Size() {
		panic("size mismatch between GetCallbackURLParameters and getCallbackURLParameters")
	}
	gcup2 := (*getCallbackURLParameters)(unsafe.Pointer(&gcup))
	return e.EncodeElement(*gcup2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for GetCallbackURLParameters.
func (gcup *GetCallbackURLParameters) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*GetCallbackURLParameters)(nil)).Elem().Size() != reflect.TypeOf((*getCallbackURLParameters)(nil)).Elem().Size() {
		panic("size mismatch between GetCallbackURLParameters and getCallbackURLParameters")
	}
	gcup2 := (*getCallbackURLParameters)(unsafe.Pointer(gcup))
	return d.DecodeElement(gcup2, &start)
}

// internal type used for marshalling
type integrationAccountSchemaProperties struct {
	SchemaType      SchemaType             `json:"schemaType,omitempty"`
	TargetNamespace *string                `json:"targetNamespace,omitempty"`
	DocumentName    *string                `json:"documentName,omitempty"`
	FileName        *string                `json:"fileName,omitempty"`
	CreatedTime     *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime     *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata        map[string]interface{} `json:"metadata,omitempty"`
	Content         *string                `json:"content,omitempty"`
	ContentType     *string                `json:"contentType,omitempty"`
	ContentLink     *ContentLink           `json:"contentLink,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountSchemaProperties.
func (iasp IntegrationAccountSchemaProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSchemaProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSchemaProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSchemaProperties and integrationAccountSchemaProperties")
	}
	iasp2 := (*integrationAccountSchemaProperties)(unsafe.Pointer(&iasp))
	return e.EncodeElement(*iasp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountSchemaProperties.
func (iasp *IntegrationAccountSchemaProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSchemaProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSchemaProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSchemaProperties and integrationAccountSchemaProperties")
	}
	iasp2 := (*integrationAccountSchemaProperties)(unsafe.Pointer(iasp))
	return d.DecodeElement(iasp2, &start)
}

// internal type used for marshalling
type integrationAccountMapProperties struct {
	MapType          MapType                                          `json:"mapType,omitempty"`
	ParametersSchema *IntegrationAccountMapPropertiesParametersSchema `json:"parametersSchema,omitempty"`
	CreatedTime      *timeRFC3339                                     `json:"createdTime,omitempty"`
	ChangedTime      *timeRFC3339                                     `json:"changedTime,omitempty"`
	Content          *string                                          `json:"content,omitempty"`
	ContentType      *string                                          `json:"contentType,omitempty"`
	ContentLink      *ContentLink                                     `json:"contentLink,omitempty"`
	Metadata         map[string]interface{}                           `json:"metadata,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountMapProperties.
func (iamp IntegrationAccountMapProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountMapProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountMapProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountMapProperties and integrationAccountMapProperties")
	}
	iamp2 := (*integrationAccountMapProperties)(unsafe.Pointer(&iamp))
	return e.EncodeElement(*iamp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountMapProperties.
func (iamp *IntegrationAccountMapProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountMapProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountMapProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountMapProperties and integrationAccountMapProperties")
	}
	iamp2 := (*integrationAccountMapProperties)(unsafe.Pointer(iamp))
	return d.DecodeElement(iamp2, &start)
}

// internal type used for marshalling
type integrationAccountPartnerProperties struct {
	PartnerType PartnerType            `json:"partnerType,omitempty"`
	CreatedTime *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Content     PartnerContent         `json:"content,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountPartnerProperties.
func (iapp IntegrationAccountPartnerProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountPartnerProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountPartnerProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountPartnerProperties and integrationAccountPartnerProperties")
	}
	iapp2 := (*integrationAccountPartnerProperties)(unsafe.Pointer(&iapp))
	return e.EncodeElement(*iapp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountPartnerProperties.
func (iapp *IntegrationAccountPartnerProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountPartnerProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountPartnerProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountPartnerProperties and integrationAccountPartnerProperties")
	}
	iapp2 := (*integrationAccountPartnerProperties)(unsafe.Pointer(iapp))
	return d.DecodeElement(iapp2, &start)
}

// internal type used for marshalling
type integrationAccountAgreementProperties struct {
	CreatedTime   *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime   *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata      map[string]interface{} `json:"metadata,omitempty"`
	AgreementType AgreementType          `json:"agreementType,omitempty"`
	HostPartner   string                 `json:"hostPartner,omitempty"`
	GuestPartner  string                 `json:"guestPartner,omitempty"`
	HostIdentity  BusinessIdentity       `json:"hostIdentity,omitempty"`
	GuestIdentity BusinessIdentity       `json:"guestIdentity,omitempty"`
	Content       AgreementContent       `json:"content,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountAgreementProperties.
func (iaap IntegrationAccountAgreementProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountAgreementProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountAgreementProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountAgreementProperties and integrationAccountAgreementProperties")
	}
	iaap2 := (*integrationAccountAgreementProperties)(unsafe.Pointer(&iaap))
	return e.EncodeElement(*iaap2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountAgreementProperties.
func (iaap *IntegrationAccountAgreementProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountAgreementProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountAgreementProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountAgreementProperties and integrationAccountAgreementProperties")
	}
	iaap2 := (*integrationAccountAgreementProperties)(unsafe.Pointer(iaap))
	return d.DecodeElement(iaap2, &start)
}

// internal type used for marshalling
type integrationAccountCertificateProperties struct {
	CreatedTime       *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime       *timeRFC3339           `json:"changedTime,omitempty"`
	Metadata          map[string]interface{} `json:"metadata,omitempty"`
	Key               *KeyVaultKeyReference  `json:"key,omitempty"`
	PublicCertificate *string                `json:"publicCertificate,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountCertificateProperties.
func (iacp IntegrationAccountCertificateProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountCertificateProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountCertificateProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountCertificateProperties and integrationAccountCertificateProperties")
	}
	iacp2 := (*integrationAccountCertificateProperties)(unsafe.Pointer(&iacp))
	return e.EncodeElement(*iacp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountCertificateProperties.
func (iacp *IntegrationAccountCertificateProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountCertificateProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountCertificateProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountCertificateProperties and integrationAccountCertificateProperties")
	}
	iacp2 := (*integrationAccountCertificateProperties)(unsafe.Pointer(iacp))
	return d.DecodeElement(iacp2, &start)
}

// internal type used for marshalling
type integrationAccountSessionFilter struct {
	ChangedTime timeRFC3339 `json:"changedTime,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountSessionFilter.
func (iasf IntegrationAccountSessionFilter) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSessionFilter)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSessionFilter)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSessionFilter and integrationAccountSessionFilter")
	}
	iasf2 := (*integrationAccountSessionFilter)(unsafe.Pointer(&iasf))
	return e.EncodeElement(*iasf2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountSessionFilter.
func (iasf *IntegrationAccountSessionFilter) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSessionFilter)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSessionFilter)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSessionFilter and integrationAccountSessionFilter")
	}
	iasf2 := (*integrationAccountSessionFilter)(unsafe.Pointer(iasf))
	return d.DecodeElement(iasf2, &start)
}

// internal type used for marshalling
type integrationAccountSessionProperties struct {
	CreatedTime *timeRFC3339           `json:"createdTime,omitempty"`
	ChangedTime *timeRFC3339           `json:"changedTime,omitempty"`
	Content     map[string]interface{} `json:"content,omitempty"`
}

// MarshalXML implements the xml.Marshaler interface for IntegrationAccountSessionProperties.
func (iasp IntegrationAccountSessionProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSessionProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSessionProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSessionProperties and integrationAccountSessionProperties")
	}
	iasp2 := (*integrationAccountSessionProperties)(unsafe.Pointer(&iasp))
	return e.EncodeElement(*iasp2, start)
}

// UnmarshalXML implements the xml.Unmarshaler interface for IntegrationAccountSessionProperties.
func (iasp *IntegrationAccountSessionProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	if reflect.TypeOf((*IntegrationAccountSessionProperties)(nil)).Elem().Size() != reflect.TypeOf((*integrationAccountSessionProperties)(nil)).Elem().Size() {
		panic("size mismatch between IntegrationAccountSessionProperties and integrationAccountSessionProperties")
	}
	iasp2 := (*integrationAccountSessionProperties)(unsafe.Pointer(iasp))
	return d.DecodeElement(iasp2, &start)
}
