package machinelearningservices

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/machinelearningservices/mgmt/2022-05-01/machinelearningservices"

// AccountKeyDatastoreCredentials account key datastore credentials configuration.
type AccountKeyDatastoreCredentials struct {
	// Secrets - [Required] Storage account secrets.
	Secrets *AccountKeyDatastoreSecrets `json:"secrets,omitempty"`
	// CredentialsType - Possible values include: 'CredentialsTypeDatastoreCredentials', 'CredentialsTypeAccountKey1', 'CredentialsTypeCertificate1', 'CredentialsTypeNone1', 'CredentialsTypeSas1', 'CredentialsTypeServicePrincipal1'
	CredentialsType CredentialsTypeBasicDatastoreCredentials `json:"credentialsType,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) MarshalJSON() ([]byte, error) {
	akdc.CredentialsType = CredentialsTypeAccountKey1
	objectMap := make(map[string]interface{})
	if akdc.Secrets != nil {
		objectMap["secrets"] = akdc.Secrets
	}
	if akdc.CredentialsType != "" {
		objectMap["credentialsType"] = akdc.CredentialsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool) {
	return &akdc, true
}

// AsCertificateDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool) {
	return nil, false
}

// AsNoneDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool) {
	return nil, false
}

// AsSasDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool) {
	return nil, false
}

// AsDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsDatastoreCredentials() (*DatastoreCredentials, bool) {
	return nil, false
}

// AsBasicDatastoreCredentials is the BasicDatastoreCredentials implementation for AccountKeyDatastoreCredentials.
func (akdc AccountKeyDatastoreCredentials) AsBasicDatastoreCredentials() (BasicDatastoreCredentials, bool) {
	return &akdc, true
}

// AccountKeyDatastoreSecrets datastore account key secrets.
type AccountKeyDatastoreSecrets struct {
	// Key - Storage account key.
	Key *string `json:"key,omitempty"`
	// SecretsType - Possible values include: 'SecretsTypeDatastoreSecrets', 'SecretsTypeAccountKey', 'SecretsTypeCertificate', 'SecretsTypeSas', 'SecretsTypeServicePrincipal'
	SecretsType SecretsTypeBasicDatastoreSecrets `json:"secretsType,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) MarshalJSON() ([]byte, error) {
	akds.SecretsType = SecretsTypeAccountKey
	objectMap := make(map[string]interface{})
	if akds.Key != nil {
		objectMap["key"] = akds.Key
	}
	if akds.SecretsType != "" {
		objectMap["secretsType"] = akds.SecretsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreSecrets is the BasicDatastoreSecrets implementation for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) AsAccountKeyDatastoreSecrets() (*AccountKeyDatastoreSecrets, bool) {
	return &akds, true
}

// AsCertificateDatastoreSecrets is the BasicDatastoreSecrets implementation for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) AsCertificateDatastoreSecrets() (*CertificateDatastoreSecrets, bool) {
	return nil, false
}

// AsSasDatastoreSecrets is the BasicDatastoreSecrets implementation for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) AsSasDatastoreSecrets() (*SasDatastoreSecrets, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreSecrets is the BasicDatastoreSecrets implementation for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) AsServicePrincipalDatastoreSecrets() (*ServicePrincipalDatastoreSecrets, bool) {
	return nil, false
}

// AsDatastoreSecrets is the BasicDatastoreSecrets implementation for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) AsDatastoreSecrets() (*DatastoreSecrets, bool) {
	return nil, false
}

// AsBasicDatastoreSecrets is the BasicDatastoreSecrets implementation for AccountKeyDatastoreSecrets.
func (akds AccountKeyDatastoreSecrets) AsBasicDatastoreSecrets() (BasicDatastoreSecrets, bool) {
	return &akds, true
}

// AKS a Machine Learning compute based on AKS.
type AKS struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// Properties - AKS properties
	Properties *AKSProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AKS.
func (a AKS) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.ComputeType != "" {
		objectMap["computeType"] = a.ComputeType
	}
	if a.Description != nil {
		objectMap["description"] = a.Description
	}
	if a.ResourceID != nil {
		objectMap["resourceId"] = a.ResourceID
	}
	if a.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = a.DisableLocalAuth
	}
	if a.Properties != nil {
		objectMap["properties"] = a.Properties
	}
	return json.Marshal(objectMap)
}

// AksComputeSecrets secrets related to a Machine Learning compute based on AKS.
type AksComputeSecrets struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// UserKubeConfig - Content of kubeconfig file that can be used to connect to the Kubernetes cluster.
	UserKubeConfig *string `json:"userKubeConfig,omitempty"`
	// AdminKubeConfig - Content of kubeconfig file that can be used to connect to the Kubernetes cluster.
	AdminKubeConfig *string `json:"adminKubeConfig,omitempty"`
	// ImagePullSecretName - Image registry pull secret.
	ImagePullSecretName *string `json:"imagePullSecretName,omitempty"`
}

// AksComputeSecretsProperties properties of AksComputeSecrets
type AksComputeSecretsProperties struct {
	// UserKubeConfig - Content of kubeconfig file that can be used to connect to the Kubernetes cluster.
	UserKubeConfig *string `json:"userKubeConfig,omitempty"`
	// AdminKubeConfig - Content of kubeconfig file that can be used to connect to the Kubernetes cluster.
	AdminKubeConfig *string `json:"adminKubeConfig,omitempty"`
	// ImagePullSecretName - Image registry pull secret.
	ImagePullSecretName *string `json:"imagePullSecretName,omitempty"`
}

// AksNetworkingConfiguration advance configuration for AKS networking
type AksNetworkingConfiguration struct {
	// SubnetID - Virtual network subnet resource ID the compute nodes belong to
	SubnetID *string `json:"subnetId,omitempty"`
	// ServiceCidr - A CIDR notation IP range from which to assign service cluster IPs. It must not overlap with any Subnet IP ranges.
	ServiceCidr *string `json:"serviceCidr,omitempty"`
	// DNSServiceIP - An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes service address range specified in serviceCidr.
	DNSServiceIP *string `json:"dnsServiceIP,omitempty"`
	// DockerBridgeCidr - A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes service address range.
	DockerBridgeCidr *string `json:"dockerBridgeCidr,omitempty"`
}

// AKSProperties AKS properties
type AKSProperties struct {
	// ClusterFqdn - Cluster full qualified domain name
	ClusterFqdn *string `json:"clusterFqdn,omitempty"`
	// SystemServices - READ-ONLY; System services
	SystemServices *[]SystemService `json:"systemServices,omitempty"`
	// AgentCount - Number of agents
	AgentCount *int32 `json:"agentCount,omitempty"`
	// AgentVMSize - Agent virtual machine size
	AgentVMSize *string `json:"agentVmSize,omitempty"`
	// ClusterPurpose - Intended usage of the cluster. Possible values include: 'FastProd', 'DenseProd', 'DevTest'
	ClusterPurpose ClusterPurpose `json:"clusterPurpose,omitempty"`
	// SslConfiguration - SSL configuration
	SslConfiguration *SslConfiguration `json:"sslConfiguration,omitempty"`
	// AksNetworkingConfiguration - AKS networking configuration for vnet
	AksNetworkingConfiguration *AksNetworkingConfiguration `json:"aksNetworkingConfiguration,omitempty"`
	// LoadBalancerType - Load Balancer Type. Possible values include: 'PublicIP', 'InternalLoadBalancer'
	LoadBalancerType LoadBalancerType `json:"loadBalancerType,omitempty"`
	// LoadBalancerSubnet - Load Balancer Subnet
	LoadBalancerSubnet *string `json:"loadBalancerSubnet,omitempty"`
}

// MarshalJSON is the custom marshaler for AKSProperties.
func (a AKSProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.ClusterFqdn != nil {
		objectMap["clusterFqdn"] = a.ClusterFqdn
	}
	if a.AgentCount != nil {
		objectMap["agentCount"] = a.AgentCount
	}
	if a.AgentVMSize != nil {
		objectMap["agentVmSize"] = a.AgentVMSize
	}
	if a.ClusterPurpose != "" {
		objectMap["clusterPurpose"] = a.ClusterPurpose
	}
	if a.SslConfiguration != nil {
		objectMap["sslConfiguration"] = a.SslConfiguration
	}
	if a.AksNetworkingConfiguration != nil {
		objectMap["aksNetworkingConfiguration"] = a.AksNetworkingConfiguration
	}
	if a.LoadBalancerType != "" {
		objectMap["loadBalancerType"] = a.LoadBalancerType
	}
	if a.LoadBalancerSubnet != nil {
		objectMap["loadBalancerSubnet"] = a.LoadBalancerSubnet
	}
	return json.Marshal(objectMap)
}

// AKSSchema ...
type AKSSchema struct {
	// Properties - AKS properties
	Properties *AKSProperties `json:"properties,omitempty"`
}

// AmlCompute an Azure Machine Learning compute.
type AmlCompute struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// Properties - Properties of AmlCompute
	Properties *AmlComputeProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AmlCompute.
func (ac AmlCompute) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ac.ComputeType != "" {
		objectMap["computeType"] = ac.ComputeType
	}
	if ac.Description != nil {
		objectMap["description"] = ac.Description
	}
	if ac.ResourceID != nil {
		objectMap["resourceId"] = ac.ResourceID
	}
	if ac.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = ac.DisableLocalAuth
	}
	if ac.Properties != nil {
		objectMap["properties"] = ac.Properties
	}
	return json.Marshal(objectMap)
}

// AmlComputeNodeInformation compute node information related to a AmlCompute.
type AmlComputeNodeInformation struct {
	// NodeID - READ-ONLY; ID of the compute node.
	NodeID *string `json:"nodeId,omitempty"`
	// PrivateIPAddress - READ-ONLY; Private IP address of the compute node.
	PrivateIPAddress *string `json:"privateIpAddress,omitempty"`
	// PublicIPAddress - READ-ONLY; Public IP address of the compute node.
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`
	// Port - READ-ONLY; SSH port number of the node.
	Port *float64 `json:"port,omitempty"`
	// NodeState - READ-ONLY; State of the compute node. Values are idle, running, preparing, unusable, leaving and preempted. Possible values include: 'NodeStateIdle', 'NodeStateRunning', 'NodeStatePreparing', 'NodeStateUnusable', 'NodeStateLeaving', 'NodeStatePreempted'
	NodeState NodeState `json:"nodeState,omitempty"`
	// RunID - READ-ONLY; ID of the Experiment running on the node, if any else null.
	RunID *string `json:"runId,omitempty"`
}

// MarshalJSON is the custom marshaler for AmlComputeNodeInformation.
func (acni AmlComputeNodeInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AmlComputeNodesInformation result of AmlCompute Nodes
type AmlComputeNodesInformation struct {
	autorest.Response `json:"-"`
	// Nodes - READ-ONLY; The collection of returned AmlCompute nodes details.
	Nodes *[]AmlComputeNodeInformation `json:"nodes,omitempty"`
	// NextLink - READ-ONLY; The continuation token.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AmlComputeNodesInformation.
func (acni AmlComputeNodesInformation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AmlComputeNodesInformationIterator provides access to a complete listing of AmlComputeNodeInformation
// values.
type AmlComputeNodesInformationIterator struct {
	i    int
	page AmlComputeNodesInformationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AmlComputeNodesInformationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AmlComputeNodesInformationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AmlComputeNodesInformationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AmlComputeNodesInformationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AmlComputeNodesInformationIterator) Response() AmlComputeNodesInformation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AmlComputeNodesInformationIterator) Value() AmlComputeNodeInformation {
	if !iter.page.NotDone() {
		return AmlComputeNodeInformation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AmlComputeNodesInformationIterator type.
func NewAmlComputeNodesInformationIterator(page AmlComputeNodesInformationPage) AmlComputeNodesInformationIterator {
	return AmlComputeNodesInformationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (acni AmlComputeNodesInformation) IsEmpty() bool {
	return acni.Nodes == nil || len(*acni.Nodes) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (acni AmlComputeNodesInformation) hasNextLink() bool {
	return acni.NextLink != nil && len(*acni.NextLink) != 0
}

// amlComputeNodesInformationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (acni AmlComputeNodesInformation) amlComputeNodesInformationPreparer(ctx context.Context) (*http.Request, error) {
	if !acni.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(acni.NextLink)))
}

// AmlComputeNodesInformationPage contains a page of AmlComputeNodeInformation values.
type AmlComputeNodesInformationPage struct {
	fn   func(context.Context, AmlComputeNodesInformation) (AmlComputeNodesInformation, error)
	acni AmlComputeNodesInformation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AmlComputeNodesInformationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AmlComputeNodesInformationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.acni)
		if err != nil {
			return err
		}
		page.acni = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AmlComputeNodesInformationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AmlComputeNodesInformationPage) NotDone() bool {
	return !page.acni.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AmlComputeNodesInformationPage) Response() AmlComputeNodesInformation {
	return page.acni
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AmlComputeNodesInformationPage) Values() []AmlComputeNodeInformation {
	if page.acni.IsEmpty() {
		return nil
	}
	return *page.acni.Nodes
}

// Creates a new instance of the AmlComputeNodesInformationPage type.
func NewAmlComputeNodesInformationPage(cur AmlComputeNodesInformation, getNextPage func(context.Context, AmlComputeNodesInformation) (AmlComputeNodesInformation, error)) AmlComputeNodesInformationPage {
	return AmlComputeNodesInformationPage{
		fn:   getNextPage,
		acni: cur,
	}
}

// AmlComputeProperties AML Compute properties
type AmlComputeProperties struct {
	// OsType - Compute OS Type. Possible values include: 'OsTypeLinux', 'OsTypeWindows'
	OsType OsType `json:"osType,omitempty"`
	// VMSize - Virtual Machine Size
	VMSize *string `json:"vmSize,omitempty"`
	// VMPriority - Virtual Machine priority. Possible values include: 'Dedicated', 'LowPriority'
	VMPriority VMPriority `json:"vmPriority,omitempty"`
	// VirtualMachineImage - Virtual Machine image for AML Compute - windows only
	VirtualMachineImage *VirtualMachineImage `json:"virtualMachineImage,omitempty"`
	// IsolatedNetwork - Network is isolated or not
	IsolatedNetwork *bool `json:"isolatedNetwork,omitempty"`
	// ScaleSettings - Scale settings for AML Compute
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`
	// UserAccountCredentials - Credentials for an administrator user account that will be created on each compute node.
	UserAccountCredentials *UserAccountCredentials `json:"userAccountCredentials,omitempty"`
	// Subnet - Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceID `json:"subnet,omitempty"`
	// RemoteLoginPortPublicAccess - State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on all nodes of the cluster. Enabled - Indicates that the public ssh port is open on all nodes of the cluster. NotSpecified - Indicates that the public ssh port is closed on all nodes of the cluster if VNet is defined, else is open all public nodes. It can be default only during cluster creation time, after creation it will be either enabled or disabled. Possible values include: 'RemoteLoginPortPublicAccessEnabled', 'RemoteLoginPortPublicAccessDisabled', 'RemoteLoginPortPublicAccessNotSpecified'
	RemoteLoginPortPublicAccess RemoteLoginPortPublicAccess `json:"remoteLoginPortPublicAccess,omitempty"`
	// AllocationState - READ-ONLY; Allocation state of the compute. Possible values are: steady - Indicates that the compute is not resizing. There are no changes to the number of compute nodes in the compute in progress. A compute enters this state when it is created and when no operations are being performed on the compute to change the number of compute nodes. resizing - Indicates that the compute is resizing; that is, compute nodes are being added to or removed from the compute. Possible values include: 'Steady', 'Resizing'
	AllocationState AllocationState `json:"allocationState,omitempty"`
	// AllocationStateTransitionTime - READ-ONLY; The time at which the compute entered its current allocation state.
	AllocationStateTransitionTime *date.Time `json:"allocationStateTransitionTime,omitempty"`
	// Errors - READ-ONLY; Collection of errors encountered by various compute nodes during node setup.
	Errors *[]ErrorResponse `json:"errors,omitempty"`
	// CurrentNodeCount - READ-ONLY; The number of compute nodes currently assigned to the compute.
	CurrentNodeCount *int32 `json:"currentNodeCount,omitempty"`
	// TargetNodeCount - READ-ONLY; The target number of compute nodes for the compute. If the allocationState is resizing, this property denotes the target node count for the ongoing resize operation. If the allocationState is steady, this property denotes the target node count for the previous resize operation.
	TargetNodeCount *int32 `json:"targetNodeCount,omitempty"`
	// NodeStateCounts - READ-ONLY; Counts of various node states on the compute.
	NodeStateCounts *NodeStateCounts `json:"nodeStateCounts,omitempty"`
	// EnableNodePublicIP - Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty"`
	// PropertyBag - A property bag containing additional properties.
	PropertyBag interface{} `json:"propertyBag,omitempty"`
}

// MarshalJSON is the custom marshaler for AmlComputeProperties.
func (acp AmlComputeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if acp.OsType != "" {
		objectMap["osType"] = acp.OsType
	}
	if acp.VMSize != nil {
		objectMap["vmSize"] = acp.VMSize
	}
	if acp.VMPriority != "" {
		objectMap["vmPriority"] = acp.VMPriority
	}
	if acp.VirtualMachineImage != nil {
		objectMap["virtualMachineImage"] = acp.VirtualMachineImage
	}
	if acp.IsolatedNetwork != nil {
		objectMap["isolatedNetwork"] = acp.IsolatedNetwork
	}
	if acp.ScaleSettings != nil {
		objectMap["scaleSettings"] = acp.ScaleSettings
	}
	if acp.UserAccountCredentials != nil {
		objectMap["userAccountCredentials"] = acp.UserAccountCredentials
	}
	if acp.Subnet != nil {
		objectMap["subnet"] = acp.Subnet
	}
	if acp.RemoteLoginPortPublicAccess != "" {
		objectMap["remoteLoginPortPublicAccess"] = acp.RemoteLoginPortPublicAccess
	}
	if acp.EnableNodePublicIP != nil {
		objectMap["enableNodePublicIp"] = acp.EnableNodePublicIP
	}
	if acp.PropertyBag != nil {
		objectMap["propertyBag"] = acp.PropertyBag
	}
	return json.Marshal(objectMap)
}

// AmlComputeSchema properties(top level) of AmlCompute
type AmlComputeSchema struct {
	// Properties - Properties of AmlCompute
	Properties *AmlComputeProperties `json:"properties,omitempty"`
}

// AmlOperation azure Machine Learning workspace REST API operation
type AmlOperation struct {
	// Name - Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
	// Display - Display name of operation
	Display *AmlOperationDisplay `json:"display,omitempty"`
	// IsDataAction - Indicates whether the operation applies to data-plane
	IsDataAction *bool `json:"isDataAction,omitempty"`
}

// AmlOperationDisplay display name of operation
type AmlOperationDisplay struct {
	// Provider - The resource provider name: Microsoft.MachineLearningExperimentation
	Provider *string `json:"provider,omitempty"`
	// Resource - The resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - The operation that users can perform.
	Operation *string `json:"operation,omitempty"`
	// Description - The description for the operation.
	Description *string `json:"description,omitempty"`
}

// AmlOperationListResult an array of operations supported by the resource provider.
type AmlOperationListResult struct {
	autorest.Response `json:"-"`
	// Value - List of AML workspace operations supported by the AML workspace resource provider.
	Value *[]AmlOperation `json:"value,omitempty"`
}

// AmlToken AML Token identity configuration.
type AmlToken struct {
	// IdentityType - Possible values include: 'IdentityTypeIdentityConfiguration', 'IdentityTypeAMLToken', 'IdentityTypeManaged', 'IdentityTypeUserIdentity'
	IdentityType IdentityType `json:"identityType,omitempty"`
}

// MarshalJSON is the custom marshaler for AmlToken.
func (at AmlToken) MarshalJSON() ([]byte, error) {
	at.IdentityType = IdentityTypeAMLToken
	objectMap := make(map[string]interface{})
	if at.IdentityType != "" {
		objectMap["identityType"] = at.IdentityType
	}
	return json.Marshal(objectMap)
}

// AsAmlToken is the BasicIdentityConfiguration implementation for AmlToken.
func (at AmlToken) AsAmlToken() (*AmlToken, bool) {
	return &at, true
}

// AsManagedIdentity is the BasicIdentityConfiguration implementation for AmlToken.
func (at AmlToken) AsManagedIdentity() (*ManagedIdentity, bool) {
	return nil, false
}

// AsUserIdentity is the BasicIdentityConfiguration implementation for AmlToken.
func (at AmlToken) AsUserIdentity() (*UserIdentity, bool) {
	return nil, false
}

// AsIdentityConfiguration is the BasicIdentityConfiguration implementation for AmlToken.
func (at AmlToken) AsIdentityConfiguration() (*IdentityConfiguration, bool) {
	return nil, false
}

// AsBasicIdentityConfiguration is the BasicIdentityConfiguration implementation for AmlToken.
func (at AmlToken) AsBasicIdentityConfiguration() (BasicIdentityConfiguration, bool) {
	return &at, true
}

// AmlUserFeature features enabled for a workspace
type AmlUserFeature struct {
	// ID - Specifies the feature ID
	ID *string `json:"id,omitempty"`
	// DisplayName - Specifies the feature name
	DisplayName *string `json:"displayName,omitempty"`
	// Description - Describes the feature for user experience
	Description *string `json:"description,omitempty"`
}

// AssetBase ...
type AssetBase struct {
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AssetBase.
func (ab AssetBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ab.IsAnonymous != nil {
		objectMap["isAnonymous"] = ab.IsAnonymous
	}
	if ab.IsArchived != nil {
		objectMap["isArchived"] = ab.IsArchived
	}
	if ab.Description != nil {
		objectMap["description"] = ab.Description
	}
	if ab.Properties != nil {
		objectMap["properties"] = ab.Properties
	}
	if ab.Tags != nil {
		objectMap["tags"] = ab.Tags
	}
	return json.Marshal(objectMap)
}

// AssetContainer ...
type AssetContainer struct {
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// LatestVersion - READ-ONLY; The latest version inside this container.
	LatestVersion *string `json:"latestVersion,omitempty"`
	// NextVersion - READ-ONLY; The next auto incremental version
	NextVersion *string `json:"nextVersion,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AssetContainer.
func (ac AssetContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ac.IsArchived != nil {
		objectMap["isArchived"] = ac.IsArchived
	}
	if ac.Description != nil {
		objectMap["description"] = ac.Description
	}
	if ac.Properties != nil {
		objectMap["properties"] = ac.Properties
	}
	if ac.Tags != nil {
		objectMap["tags"] = ac.Tags
	}
	return json.Marshal(objectMap)
}

// AssetJobInput asset input type.
type AssetJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
}

// AssetJobOutput asset output type.
type AssetJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
}

// BasicAssetReferenceBase base definition for asset references.
type BasicAssetReferenceBase interface {
	AsDataPathAssetReference() (*DataPathAssetReference, bool)
	AsIDAssetReference() (*IDAssetReference, bool)
	AsOutputPathAssetReference() (*OutputPathAssetReference, bool)
	AsAssetReferenceBase() (*AssetReferenceBase, bool)
}

// AssetReferenceBase base definition for asset references.
type AssetReferenceBase struct {
	// ReferenceType - Possible values include: 'ReferenceTypeAssetReferenceBase', 'ReferenceTypeDataPath', 'ReferenceTypeID', 'ReferenceTypeOutputPath'
	ReferenceType ReferenceTypeBasicAssetReferenceBase `json:"referenceType,omitempty"`
}

func unmarshalBasicAssetReferenceBase(body []byte) (BasicAssetReferenceBase, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["referenceType"] {
	case string(ReferenceTypeDataPath):
		var dpar DataPathAssetReference
		err := json.Unmarshal(body, &dpar)
		return dpar, err
	case string(ReferenceTypeID):
		var iar IDAssetReference
		err := json.Unmarshal(body, &iar)
		return iar, err
	case string(ReferenceTypeOutputPath):
		var opar OutputPathAssetReference
		err := json.Unmarshal(body, &opar)
		return opar, err
	default:
		var arb AssetReferenceBase
		err := json.Unmarshal(body, &arb)
		return arb, err
	}
}
func unmarshalBasicAssetReferenceBaseArray(body []byte) ([]BasicAssetReferenceBase, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	arbArray := make([]BasicAssetReferenceBase, len(rawMessages))

	for index, rawMessage := range rawMessages {
		arb, err := unmarshalBasicAssetReferenceBase(*rawMessage)
		if err != nil {
			return nil, err
		}
		arbArray[index] = arb
	}
	return arbArray, nil
}

// MarshalJSON is the custom marshaler for AssetReferenceBase.
func (arb AssetReferenceBase) MarshalJSON() ([]byte, error) {
	arb.ReferenceType = ReferenceTypeAssetReferenceBase
	objectMap := make(map[string]interface{})
	if arb.ReferenceType != "" {
		objectMap["referenceType"] = arb.ReferenceType
	}
	return json.Marshal(objectMap)
}

// AsDataPathAssetReference is the BasicAssetReferenceBase implementation for AssetReferenceBase.
func (arb AssetReferenceBase) AsDataPathAssetReference() (*DataPathAssetReference, bool) {
	return nil, false
}

// AsIDAssetReference is the BasicAssetReferenceBase implementation for AssetReferenceBase.
func (arb AssetReferenceBase) AsIDAssetReference() (*IDAssetReference, bool) {
	return nil, false
}

// AsOutputPathAssetReference is the BasicAssetReferenceBase implementation for AssetReferenceBase.
func (arb AssetReferenceBase) AsOutputPathAssetReference() (*OutputPathAssetReference, bool) {
	return nil, false
}

// AsAssetReferenceBase is the BasicAssetReferenceBase implementation for AssetReferenceBase.
func (arb AssetReferenceBase) AsAssetReferenceBase() (*AssetReferenceBase, bool) {
	return &arb, true
}

// AsBasicAssetReferenceBase is the BasicAssetReferenceBase implementation for AssetReferenceBase.
func (arb AssetReferenceBase) AsBasicAssetReferenceBase() (BasicAssetReferenceBase, bool) {
	return &arb, true
}

// AssignedUser a user that can be assigned to a compute instance.
type AssignedUser struct {
	// ObjectID - User’s AAD Object Id.
	ObjectID *string `json:"objectId,omitempty"`
	// TenantID - User’s AAD Tenant Id.
	TenantID *string `json:"tenantId,omitempty"`
}

// AutoPauseProperties auto pause properties
type AutoPauseProperties struct {
	DelayInMinutes *int32 `json:"delayInMinutes,omitempty"`
	Enabled        *bool  `json:"enabled,omitempty"`
}

// AutoScaleProperties auto scale properties
type AutoScaleProperties struct {
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
	Enabled      *bool  `json:"enabled,omitempty"`
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`
}

// AzureBlobDatastore azure Blob datastore configuration.
type AzureBlobDatastore struct {
	// AccountName - Storage account name.
	AccountName *string `json:"accountName,omitempty"`
	// ContainerName - Storage account container name.
	ContainerName *string `json:"containerName,omitempty"`
	// Endpoint - Azure cloud endpoint for the storage account.
	Endpoint *string `json:"endpoint,omitempty"`
	// Protocol - Protocol used to communicate with the storage account.
	Protocol *string `json:"protocol,omitempty"`
	// ServiceDataAccessAuthIdentity - Indicates which identity to use to authenticate service data access to customer's storage. Possible values include: 'ServiceDataAccessAuthIdentityNone', 'ServiceDataAccessAuthIdentityWorkspaceSystemAssignedIdentity', 'ServiceDataAccessAuthIdentityWorkspaceUserAssignedIdentity'
	ServiceDataAccessAuthIdentity ServiceDataAccessAuthIdentity `json:"serviceDataAccessAuthIdentity,omitempty"`
	// Credentials - [Required] Account credentials.
	Credentials BasicDatastoreCredentials `json:"credentials,omitempty"`
	// IsDefault - READ-ONLY; Readonly property to indicate if datastore is the workspace default datastore
	IsDefault *bool `json:"isDefault,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
	// DatastoreType - Possible values include: 'DatastoreTypeDatastore', 'DatastoreTypeAzureBlob', 'DatastoreTypeAzureDataLakeGen1', 'DatastoreTypeAzureDataLakeGen2', 'DatastoreTypeAzureFile'
	DatastoreType DatastoreTypeBasicDatastore `json:"datastoreType,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureBlobDatastore.
func (abd AzureBlobDatastore) MarshalJSON() ([]byte, error) {
	abd.DatastoreType = DatastoreTypeAzureBlob
	objectMap := make(map[string]interface{})
	if abd.AccountName != nil {
		objectMap["accountName"] = abd.AccountName
	}
	if abd.ContainerName != nil {
		objectMap["containerName"] = abd.ContainerName
	}
	if abd.Endpoint != nil {
		objectMap["endpoint"] = abd.Endpoint
	}
	if abd.Protocol != nil {
		objectMap["protocol"] = abd.Protocol
	}
	if abd.ServiceDataAccessAuthIdentity != "" {
		objectMap["serviceDataAccessAuthIdentity"] = abd.ServiceDataAccessAuthIdentity
	}
	objectMap["credentials"] = abd.Credentials
	if abd.DatastoreType != "" {
		objectMap["datastoreType"] = abd.DatastoreType
	}
	if abd.Description != nil {
		objectMap["description"] = abd.Description
	}
	if abd.Properties != nil {
		objectMap["properties"] = abd.Properties
	}
	if abd.Tags != nil {
		objectMap["tags"] = abd.Tags
	}
	return json.Marshal(objectMap)
}

// AsAzureBlobDatastore is the BasicDatastore implementation for AzureBlobDatastore.
func (abd AzureBlobDatastore) AsAzureBlobDatastore() (*AzureBlobDatastore, bool) {
	return &abd, true
}

// AsAzureDataLakeGen1Datastore is the BasicDatastore implementation for AzureBlobDatastore.
func (abd AzureBlobDatastore) AsAzureDataLakeGen1Datastore() (*AzureDataLakeGen1Datastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen2Datastore is the BasicDatastore implementation for AzureBlobDatastore.
func (abd AzureBlobDatastore) AsAzureDataLakeGen2Datastore() (*AzureDataLakeGen2Datastore, bool) {
	return nil, false
}

// AsAzureFileDatastore is the BasicDatastore implementation for AzureBlobDatastore.
func (abd AzureBlobDatastore) AsAzureFileDatastore() (*AzureFileDatastore, bool) {
	return nil, false
}

// AsDatastore is the BasicDatastore implementation for AzureBlobDatastore.
func (abd AzureBlobDatastore) AsDatastore() (*Datastore, bool) {
	return nil, false
}

// AsBasicDatastore is the BasicDatastore implementation for AzureBlobDatastore.
func (abd AzureBlobDatastore) AsBasicDatastore() (BasicDatastore, bool) {
	return &abd, true
}

// UnmarshalJSON is the custom unmarshaler for AzureBlobDatastore struct.
func (abd *AzureBlobDatastore) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "accountName":
			if v != nil {
				var accountName string
				err = json.Unmarshal(*v, &accountName)
				if err != nil {
					return err
				}
				abd.AccountName = &accountName
			}
		case "containerName":
			if v != nil {
				var containerName string
				err = json.Unmarshal(*v, &containerName)
				if err != nil {
					return err
				}
				abd.ContainerName = &containerName
			}
		case "endpoint":
			if v != nil {
				var endpoint string
				err = json.Unmarshal(*v, &endpoint)
				if err != nil {
					return err
				}
				abd.Endpoint = &endpoint
			}
		case "protocol":
			if v != nil {
				var protocol string
				err = json.Unmarshal(*v, &protocol)
				if err != nil {
					return err
				}
				abd.Protocol = &protocol
			}
		case "serviceDataAccessAuthIdentity":
			if v != nil {
				var serviceDataAccessAuthIdentity ServiceDataAccessAuthIdentity
				err = json.Unmarshal(*v, &serviceDataAccessAuthIdentity)
				if err != nil {
					return err
				}
				abd.ServiceDataAccessAuthIdentity = serviceDataAccessAuthIdentity
			}
		case "credentials":
			if v != nil {
				credentials, err := unmarshalBasicDatastoreCredentials(*v)
				if err != nil {
					return err
				}
				abd.Credentials = credentials
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				abd.IsDefault = &isDefault
			}
		case "datastoreType":
			if v != nil {
				var datastoreType DatastoreTypeBasicDatastore
				err = json.Unmarshal(*v, &datastoreType)
				if err != nil {
					return err
				}
				abd.DatastoreType = datastoreType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				abd.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				abd.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				abd.Tags = tags
			}
		}
	}

	return nil
}

// AzureDataLakeGen1Datastore azure Data Lake Gen1 datastore configuration.
type AzureDataLakeGen1Datastore struct {
	// ServiceDataAccessAuthIdentity - Indicates which identity to use to authenticate service data access to customer's storage. Possible values include: 'ServiceDataAccessAuthIdentityNone', 'ServiceDataAccessAuthIdentityWorkspaceSystemAssignedIdentity', 'ServiceDataAccessAuthIdentityWorkspaceUserAssignedIdentity'
	ServiceDataAccessAuthIdentity ServiceDataAccessAuthIdentity `json:"serviceDataAccessAuthIdentity,omitempty"`
	// StoreName - [Required] Azure Data Lake store name.
	StoreName *string `json:"storeName,omitempty"`
	// Credentials - [Required] Account credentials.
	Credentials BasicDatastoreCredentials `json:"credentials,omitempty"`
	// IsDefault - READ-ONLY; Readonly property to indicate if datastore is the workspace default datastore
	IsDefault *bool `json:"isDefault,omitempty"`
	// DatastoreType - Possible values include: 'DatastoreTypeDatastore', 'DatastoreTypeAzureBlob', 'DatastoreTypeAzureDataLakeGen1', 'DatastoreTypeAzureDataLakeGen2', 'DatastoreTypeAzureFile'
	DatastoreType DatastoreTypeBasicDatastore `json:"datastoreType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) MarshalJSON() ([]byte, error) {
	adlg1d.DatastoreType = DatastoreTypeAzureDataLakeGen1
	objectMap := make(map[string]interface{})
	if adlg1d.ServiceDataAccessAuthIdentity != "" {
		objectMap["serviceDataAccessAuthIdentity"] = adlg1d.ServiceDataAccessAuthIdentity
	}
	if adlg1d.StoreName != nil {
		objectMap["storeName"] = adlg1d.StoreName
	}
	objectMap["credentials"] = adlg1d.Credentials
	if adlg1d.DatastoreType != "" {
		objectMap["datastoreType"] = adlg1d.DatastoreType
	}
	if adlg1d.Description != nil {
		objectMap["description"] = adlg1d.Description
	}
	if adlg1d.Properties != nil {
		objectMap["properties"] = adlg1d.Properties
	}
	if adlg1d.Tags != nil {
		objectMap["tags"] = adlg1d.Tags
	}
	return json.Marshal(objectMap)
}

// AsAzureBlobDatastore is the BasicDatastore implementation for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) AsAzureBlobDatastore() (*AzureBlobDatastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen1Datastore is the BasicDatastore implementation for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) AsAzureDataLakeGen1Datastore() (*AzureDataLakeGen1Datastore, bool) {
	return &adlg1d, true
}

// AsAzureDataLakeGen2Datastore is the BasicDatastore implementation for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) AsAzureDataLakeGen2Datastore() (*AzureDataLakeGen2Datastore, bool) {
	return nil, false
}

// AsAzureFileDatastore is the BasicDatastore implementation for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) AsAzureFileDatastore() (*AzureFileDatastore, bool) {
	return nil, false
}

// AsDatastore is the BasicDatastore implementation for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) AsDatastore() (*Datastore, bool) {
	return nil, false
}

// AsBasicDatastore is the BasicDatastore implementation for AzureDataLakeGen1Datastore.
func (adlg1d AzureDataLakeGen1Datastore) AsBasicDatastore() (BasicDatastore, bool) {
	return &adlg1d, true
}

// UnmarshalJSON is the custom unmarshaler for AzureDataLakeGen1Datastore struct.
func (adlg1d *AzureDataLakeGen1Datastore) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "serviceDataAccessAuthIdentity":
			if v != nil {
				var serviceDataAccessAuthIdentity ServiceDataAccessAuthIdentity
				err = json.Unmarshal(*v, &serviceDataAccessAuthIdentity)
				if err != nil {
					return err
				}
				adlg1d.ServiceDataAccessAuthIdentity = serviceDataAccessAuthIdentity
			}
		case "storeName":
			if v != nil {
				var storeName string
				err = json.Unmarshal(*v, &storeName)
				if err != nil {
					return err
				}
				adlg1d.StoreName = &storeName
			}
		case "credentials":
			if v != nil {
				credentials, err := unmarshalBasicDatastoreCredentials(*v)
				if err != nil {
					return err
				}
				adlg1d.Credentials = credentials
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				adlg1d.IsDefault = &isDefault
			}
		case "datastoreType":
			if v != nil {
				var datastoreType DatastoreTypeBasicDatastore
				err = json.Unmarshal(*v, &datastoreType)
				if err != nil {
					return err
				}
				adlg1d.DatastoreType = datastoreType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				adlg1d.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				adlg1d.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				adlg1d.Tags = tags
			}
		}
	}

	return nil
}

// AzureDataLakeGen2Datastore azure Data Lake Gen2 datastore configuration.
type AzureDataLakeGen2Datastore struct {
	// AccountName - [Required] Storage account name.
	AccountName *string `json:"accountName,omitempty"`
	// Endpoint - Azure cloud endpoint for the storage account.
	Endpoint *string `json:"endpoint,omitempty"`
	// Filesystem - [Required] The name of the Data Lake Gen2 filesystem.
	Filesystem *string `json:"filesystem,omitempty"`
	// Protocol - Protocol used to communicate with the storage account.
	Protocol *string `json:"protocol,omitempty"`
	// ServiceDataAccessAuthIdentity - Indicates which identity to use to authenticate service data access to customer's storage. Possible values include: 'ServiceDataAccessAuthIdentityNone', 'ServiceDataAccessAuthIdentityWorkspaceSystemAssignedIdentity', 'ServiceDataAccessAuthIdentityWorkspaceUserAssignedIdentity'
	ServiceDataAccessAuthIdentity ServiceDataAccessAuthIdentity `json:"serviceDataAccessAuthIdentity,omitempty"`
	// Credentials - [Required] Account credentials.
	Credentials BasicDatastoreCredentials `json:"credentials,omitempty"`
	// IsDefault - READ-ONLY; Readonly property to indicate if datastore is the workspace default datastore
	IsDefault *bool `json:"isDefault,omitempty"`
	// DatastoreType - Possible values include: 'DatastoreTypeDatastore', 'DatastoreTypeAzureBlob', 'DatastoreTypeAzureDataLakeGen1', 'DatastoreTypeAzureDataLakeGen2', 'DatastoreTypeAzureFile'
	DatastoreType DatastoreTypeBasicDatastore `json:"datastoreType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) MarshalJSON() ([]byte, error) {
	adlg2d.DatastoreType = DatastoreTypeAzureDataLakeGen2
	objectMap := make(map[string]interface{})
	if adlg2d.AccountName != nil {
		objectMap["accountName"] = adlg2d.AccountName
	}
	if adlg2d.Endpoint != nil {
		objectMap["endpoint"] = adlg2d.Endpoint
	}
	if adlg2d.Filesystem != nil {
		objectMap["filesystem"] = adlg2d.Filesystem
	}
	if adlg2d.Protocol != nil {
		objectMap["protocol"] = adlg2d.Protocol
	}
	if adlg2d.ServiceDataAccessAuthIdentity != "" {
		objectMap["serviceDataAccessAuthIdentity"] = adlg2d.ServiceDataAccessAuthIdentity
	}
	objectMap["credentials"] = adlg2d.Credentials
	if adlg2d.DatastoreType != "" {
		objectMap["datastoreType"] = adlg2d.DatastoreType
	}
	if adlg2d.Description != nil {
		objectMap["description"] = adlg2d.Description
	}
	if adlg2d.Properties != nil {
		objectMap["properties"] = adlg2d.Properties
	}
	if adlg2d.Tags != nil {
		objectMap["tags"] = adlg2d.Tags
	}
	return json.Marshal(objectMap)
}

// AsAzureBlobDatastore is the BasicDatastore implementation for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) AsAzureBlobDatastore() (*AzureBlobDatastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen1Datastore is the BasicDatastore implementation for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) AsAzureDataLakeGen1Datastore() (*AzureDataLakeGen1Datastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen2Datastore is the BasicDatastore implementation for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) AsAzureDataLakeGen2Datastore() (*AzureDataLakeGen2Datastore, bool) {
	return &adlg2d, true
}

// AsAzureFileDatastore is the BasicDatastore implementation for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) AsAzureFileDatastore() (*AzureFileDatastore, bool) {
	return nil, false
}

// AsDatastore is the BasicDatastore implementation for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) AsDatastore() (*Datastore, bool) {
	return nil, false
}

// AsBasicDatastore is the BasicDatastore implementation for AzureDataLakeGen2Datastore.
func (adlg2d AzureDataLakeGen2Datastore) AsBasicDatastore() (BasicDatastore, bool) {
	return &adlg2d, true
}

// UnmarshalJSON is the custom unmarshaler for AzureDataLakeGen2Datastore struct.
func (adlg2d *AzureDataLakeGen2Datastore) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "accountName":
			if v != nil {
				var accountName string
				err = json.Unmarshal(*v, &accountName)
				if err != nil {
					return err
				}
				adlg2d.AccountName = &accountName
			}
		case "endpoint":
			if v != nil {
				var endpoint string
				err = json.Unmarshal(*v, &endpoint)
				if err != nil {
					return err
				}
				adlg2d.Endpoint = &endpoint
			}
		case "filesystem":
			if v != nil {
				var filesystem string
				err = json.Unmarshal(*v, &filesystem)
				if err != nil {
					return err
				}
				adlg2d.Filesystem = &filesystem
			}
		case "protocol":
			if v != nil {
				var protocol string
				err = json.Unmarshal(*v, &protocol)
				if err != nil {
					return err
				}
				adlg2d.Protocol = &protocol
			}
		case "serviceDataAccessAuthIdentity":
			if v != nil {
				var serviceDataAccessAuthIdentity ServiceDataAccessAuthIdentity
				err = json.Unmarshal(*v, &serviceDataAccessAuthIdentity)
				if err != nil {
					return err
				}
				adlg2d.ServiceDataAccessAuthIdentity = serviceDataAccessAuthIdentity
			}
		case "credentials":
			if v != nil {
				credentials, err := unmarshalBasicDatastoreCredentials(*v)
				if err != nil {
					return err
				}
				adlg2d.Credentials = credentials
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				adlg2d.IsDefault = &isDefault
			}
		case "datastoreType":
			if v != nil {
				var datastoreType DatastoreTypeBasicDatastore
				err = json.Unmarshal(*v, &datastoreType)
				if err != nil {
					return err
				}
				adlg2d.DatastoreType = datastoreType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				adlg2d.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				adlg2d.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				adlg2d.Tags = tags
			}
		}
	}

	return nil
}

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AzureFileDatastore azure File datastore configuration.
type AzureFileDatastore struct {
	// AccountName - [Required] Storage account name.
	AccountName *string `json:"accountName,omitempty"`
	// Endpoint - Azure cloud endpoint for the storage account.
	Endpoint *string `json:"endpoint,omitempty"`
	// FileShareName - [Required] The name of the Azure file share that the datastore points to.
	FileShareName *string `json:"fileShareName,omitempty"`
	// Protocol - Protocol used to communicate with the storage account.
	Protocol *string `json:"protocol,omitempty"`
	// ServiceDataAccessAuthIdentity - Indicates which identity to use to authenticate service data access to customer's storage. Possible values include: 'ServiceDataAccessAuthIdentityNone', 'ServiceDataAccessAuthIdentityWorkspaceSystemAssignedIdentity', 'ServiceDataAccessAuthIdentityWorkspaceUserAssignedIdentity'
	ServiceDataAccessAuthIdentity ServiceDataAccessAuthIdentity `json:"serviceDataAccessAuthIdentity,omitempty"`
	// Credentials - [Required] Account credentials.
	Credentials BasicDatastoreCredentials `json:"credentials,omitempty"`
	// IsDefault - READ-ONLY; Readonly property to indicate if datastore is the workspace default datastore
	IsDefault *bool `json:"isDefault,omitempty"`
	// DatastoreType - Possible values include: 'DatastoreTypeDatastore', 'DatastoreTypeAzureBlob', 'DatastoreTypeAzureDataLakeGen1', 'DatastoreTypeAzureDataLakeGen2', 'DatastoreTypeAzureFile'
	DatastoreType DatastoreTypeBasicDatastore `json:"datastoreType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AzureFileDatastore.
func (afd AzureFileDatastore) MarshalJSON() ([]byte, error) {
	afd.DatastoreType = DatastoreTypeAzureFile
	objectMap := make(map[string]interface{})
	if afd.AccountName != nil {
		objectMap["accountName"] = afd.AccountName
	}
	if afd.Endpoint != nil {
		objectMap["endpoint"] = afd.Endpoint
	}
	if afd.FileShareName != nil {
		objectMap["fileShareName"] = afd.FileShareName
	}
	if afd.Protocol != nil {
		objectMap["protocol"] = afd.Protocol
	}
	if afd.ServiceDataAccessAuthIdentity != "" {
		objectMap["serviceDataAccessAuthIdentity"] = afd.ServiceDataAccessAuthIdentity
	}
	objectMap["credentials"] = afd.Credentials
	if afd.DatastoreType != "" {
		objectMap["datastoreType"] = afd.DatastoreType
	}
	if afd.Description != nil {
		objectMap["description"] = afd.Description
	}
	if afd.Properties != nil {
		objectMap["properties"] = afd.Properties
	}
	if afd.Tags != nil {
		objectMap["tags"] = afd.Tags
	}
	return json.Marshal(objectMap)
}

// AsAzureBlobDatastore is the BasicDatastore implementation for AzureFileDatastore.
func (afd AzureFileDatastore) AsAzureBlobDatastore() (*AzureBlobDatastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen1Datastore is the BasicDatastore implementation for AzureFileDatastore.
func (afd AzureFileDatastore) AsAzureDataLakeGen1Datastore() (*AzureDataLakeGen1Datastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen2Datastore is the BasicDatastore implementation for AzureFileDatastore.
func (afd AzureFileDatastore) AsAzureDataLakeGen2Datastore() (*AzureDataLakeGen2Datastore, bool) {
	return nil, false
}

// AsAzureFileDatastore is the BasicDatastore implementation for AzureFileDatastore.
func (afd AzureFileDatastore) AsAzureFileDatastore() (*AzureFileDatastore, bool) {
	return &afd, true
}

// AsDatastore is the BasicDatastore implementation for AzureFileDatastore.
func (afd AzureFileDatastore) AsDatastore() (*Datastore, bool) {
	return nil, false
}

// AsBasicDatastore is the BasicDatastore implementation for AzureFileDatastore.
func (afd AzureFileDatastore) AsBasicDatastore() (BasicDatastore, bool) {
	return &afd, true
}

// UnmarshalJSON is the custom unmarshaler for AzureFileDatastore struct.
func (afd *AzureFileDatastore) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "accountName":
			if v != nil {
				var accountName string
				err = json.Unmarshal(*v, &accountName)
				if err != nil {
					return err
				}
				afd.AccountName = &accountName
			}
		case "endpoint":
			if v != nil {
				var endpoint string
				err = json.Unmarshal(*v, &endpoint)
				if err != nil {
					return err
				}
				afd.Endpoint = &endpoint
			}
		case "fileShareName":
			if v != nil {
				var fileShareName string
				err = json.Unmarshal(*v, &fileShareName)
				if err != nil {
					return err
				}
				afd.FileShareName = &fileShareName
			}
		case "protocol":
			if v != nil {
				var protocol string
				err = json.Unmarshal(*v, &protocol)
				if err != nil {
					return err
				}
				afd.Protocol = &protocol
			}
		case "serviceDataAccessAuthIdentity":
			if v != nil {
				var serviceDataAccessAuthIdentity ServiceDataAccessAuthIdentity
				err = json.Unmarshal(*v, &serviceDataAccessAuthIdentity)
				if err != nil {
					return err
				}
				afd.ServiceDataAccessAuthIdentity = serviceDataAccessAuthIdentity
			}
		case "credentials":
			if v != nil {
				credentials, err := unmarshalBasicDatastoreCredentials(*v)
				if err != nil {
					return err
				}
				afd.Credentials = credentials
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				afd.IsDefault = &isDefault
			}
		case "datastoreType":
			if v != nil {
				var datastoreType DatastoreTypeBasicDatastore
				err = json.Unmarshal(*v, &datastoreType)
				if err != nil {
					return err
				}
				afd.DatastoreType = datastoreType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				afd.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				afd.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				afd.Tags = tags
			}
		}
	}

	return nil
}

// BanditPolicy defines an early termination policy based on slack criteria, and a frequency and delay
// interval for evaluation
type BanditPolicy struct {
	// SlackAmount - Absolute distance allowed from the best performing run.
	SlackAmount *float64 `json:"slackAmount,omitempty"`
	// SlackFactor - Ratio of the allowed distance from the best performing run.
	SlackFactor *float64 `json:"slackFactor,omitempty"`
	// DelayEvaluation - Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int32 `json:"delayEvaluation,omitempty"`
	// EvaluationInterval - Interval (number of runs) between policy evaluations.
	EvaluationInterval *int32 `json:"evaluationInterval,omitempty"`
	// PolicyType - Possible values include: 'PolicyTypeEarlyTerminationPolicy', 'PolicyTypeBandit', 'PolicyTypeMedianStopping', 'PolicyTypeTruncationSelection'
	PolicyType PolicyType `json:"policyType,omitempty"`
}

// MarshalJSON is the custom marshaler for BanditPolicy.
func (bp BanditPolicy) MarshalJSON() ([]byte, error) {
	bp.PolicyType = PolicyTypeBandit
	objectMap := make(map[string]interface{})
	if bp.SlackAmount != nil {
		objectMap["slackAmount"] = bp.SlackAmount
	}
	if bp.SlackFactor != nil {
		objectMap["slackFactor"] = bp.SlackFactor
	}
	if bp.DelayEvaluation != nil {
		objectMap["delayEvaluation"] = bp.DelayEvaluation
	}
	if bp.EvaluationInterval != nil {
		objectMap["evaluationInterval"] = bp.EvaluationInterval
	}
	if bp.PolicyType != "" {
		objectMap["policyType"] = bp.PolicyType
	}
	return json.Marshal(objectMap)
}

// AsBanditPolicy is the BasicEarlyTerminationPolicy implementation for BanditPolicy.
func (bp BanditPolicy) AsBanditPolicy() (*BanditPolicy, bool) {
	return &bp, true
}

// AsMedianStoppingPolicy is the BasicEarlyTerminationPolicy implementation for BanditPolicy.
func (bp BanditPolicy) AsMedianStoppingPolicy() (*MedianStoppingPolicy, bool) {
	return nil, false
}

// AsTruncationSelectionPolicy is the BasicEarlyTerminationPolicy implementation for BanditPolicy.
func (bp BanditPolicy) AsTruncationSelectionPolicy() (*TruncationSelectionPolicy, bool) {
	return nil, false
}

// AsEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for BanditPolicy.
func (bp BanditPolicy) AsEarlyTerminationPolicy() (*EarlyTerminationPolicy, bool) {
	return nil, false
}

// AsBasicEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for BanditPolicy.
func (bp BanditPolicy) AsBasicEarlyTerminationPolicy() (BasicEarlyTerminationPolicy, bool) {
	return &bp, true
}

// BatchDeployment batch inference settings per deployment.
type BatchDeployment struct {
	// Compute - Compute target for batch inference operation.
	Compute *string `json:"compute,omitempty"`
	// ErrorThreshold - Error threshold, if the error count for the entire input goes above this value,
	// the batch inference will be aborted. Range is [-1, int.MaxValue].
	// For FileDataset, this value is the count of file failures.
	// For TabularDataset, this value is the count of record failures.
	// If set to -1 (the lower bound), all failures during batch inference will be ignored.
	ErrorThreshold *int32 `json:"errorThreshold,omitempty"`
	// LoggingLevel - Logging level for batch inference operation. Possible values include: 'Info', 'Warning', 'Debug'
	LoggingLevel BatchLoggingLevel `json:"loggingLevel,omitempty"`
	// MaxConcurrencyPerInstance - Indicates maximum number of parallelism per instance.
	MaxConcurrencyPerInstance *int32 `json:"maxConcurrencyPerInstance,omitempty"`
	// MiniBatchSize - Size of the mini-batch passed to each batch invocation.
	// For FileDataset, this is the number of files per mini-batch.
	// For TabularDataset, this is the size of the records in bytes, per mini-batch.
	MiniBatchSize *int64 `json:"miniBatchSize,omitempty"`
	// Model - Reference to the model asset for the endpoint deployment.
	Model BasicAssetReferenceBase `json:"model,omitempty"`
	// OutputAction - Indicates how the output will be organized. Possible values include: 'SummaryOnly', 'AppendRow'
	OutputAction BatchOutputAction `json:"outputAction,omitempty"`
	// OutputFileName - Customized output file name for append_row output action.
	OutputFileName *string `json:"outputFileName,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state for the endpoint deployment. Possible values include: 'DeploymentProvisioningStateCreating', 'DeploymentProvisioningStateDeleting', 'DeploymentProvisioningStateScaling', 'DeploymentProvisioningStateUpdating', 'DeploymentProvisioningStateSucceeded', 'DeploymentProvisioningStateFailed', 'DeploymentProvisioningStateCanceled'
	ProvisioningState DeploymentProvisioningState `json:"provisioningState,omitempty"`
	// Resources - Indicates compute configuration for the job.
	// If not provided, will default to the defaults defined in ResourceConfiguration.
	Resources *ResourceConfiguration `json:"resources,omitempty"`
	// RetrySettings - Retry Settings for the batch inference operation.
	// If not provided, will default to the defaults defined in BatchRetrySettings.
	RetrySettings *BatchRetrySettings `json:"retrySettings,omitempty"`
	// CodeConfiguration - Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `json:"codeConfiguration,omitempty"`
	// Description - Description of the endpoint deployment.
	Description *string `json:"description,omitempty"`
	// EnvironmentID - ARM resource ID or AssetId of the environment specification for the endpoint deployment.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables configuration for the deployment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for BatchDeployment.
func (bd BatchDeployment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bd.Compute != nil {
		objectMap["compute"] = bd.Compute
	}
	if bd.ErrorThreshold != nil {
		objectMap["errorThreshold"] = bd.ErrorThreshold
	}
	if bd.LoggingLevel != "" {
		objectMap["loggingLevel"] = bd.LoggingLevel
	}
	if bd.MaxConcurrencyPerInstance != nil {
		objectMap["maxConcurrencyPerInstance"] = bd.MaxConcurrencyPerInstance
	}
	if bd.MiniBatchSize != nil {
		objectMap["miniBatchSize"] = bd.MiniBatchSize
	}
	objectMap["model"] = bd.Model
	if bd.OutputAction != "" {
		objectMap["outputAction"] = bd.OutputAction
	}
	if bd.OutputFileName != nil {
		objectMap["outputFileName"] = bd.OutputFileName
	}
	if bd.Resources != nil {
		objectMap["resources"] = bd.Resources
	}
	if bd.RetrySettings != nil {
		objectMap["retrySettings"] = bd.RetrySettings
	}
	if bd.CodeConfiguration != nil {
		objectMap["codeConfiguration"] = bd.CodeConfiguration
	}
	if bd.Description != nil {
		objectMap["description"] = bd.Description
	}
	if bd.EnvironmentID != nil {
		objectMap["environmentId"] = bd.EnvironmentID
	}
	if bd.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = bd.EnvironmentVariables
	}
	if bd.Properties != nil {
		objectMap["properties"] = bd.Properties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for BatchDeployment struct.
func (bd *BatchDeployment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "compute":
			if v != nil {
				var compute string
				err = json.Unmarshal(*v, &compute)
				if err != nil {
					return err
				}
				bd.Compute = &compute
			}
		case "errorThreshold":
			if v != nil {
				var errorThreshold int32
				err = json.Unmarshal(*v, &errorThreshold)
				if err != nil {
					return err
				}
				bd.ErrorThreshold = &errorThreshold
			}
		case "loggingLevel":
			if v != nil {
				var loggingLevel BatchLoggingLevel
				err = json.Unmarshal(*v, &loggingLevel)
				if err != nil {
					return err
				}
				bd.LoggingLevel = loggingLevel
			}
		case "maxConcurrencyPerInstance":
			if v != nil {
				var maxConcurrencyPerInstance int32
				err = json.Unmarshal(*v, &maxConcurrencyPerInstance)
				if err != nil {
					return err
				}
				bd.MaxConcurrencyPerInstance = &maxConcurrencyPerInstance
			}
		case "miniBatchSize":
			if v != nil {
				var miniBatchSize int64
				err = json.Unmarshal(*v, &miniBatchSize)
				if err != nil {
					return err
				}
				bd.MiniBatchSize = &miniBatchSize
			}
		case "model":
			if v != nil {
				model, err := unmarshalBasicAssetReferenceBase(*v)
				if err != nil {
					return err
				}
				bd.Model = model
			}
		case "outputAction":
			if v != nil {
				var outputAction BatchOutputAction
				err = json.Unmarshal(*v, &outputAction)
				if err != nil {
					return err
				}
				bd.OutputAction = outputAction
			}
		case "outputFileName":
			if v != nil {
				var outputFileName string
				err = json.Unmarshal(*v, &outputFileName)
				if err != nil {
					return err
				}
				bd.OutputFileName = &outputFileName
			}
		case "provisioningState":
			if v != nil {
				var provisioningState DeploymentProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				bd.ProvisioningState = provisioningState
			}
		case "resources":
			if v != nil {
				var resources ResourceConfiguration
				err = json.Unmarshal(*v, &resources)
				if err != nil {
					return err
				}
				bd.Resources = &resources
			}
		case "retrySettings":
			if v != nil {
				var retrySettings BatchRetrySettings
				err = json.Unmarshal(*v, &retrySettings)
				if err != nil {
					return err
				}
				bd.RetrySettings = &retrySettings
			}
		case "codeConfiguration":
			if v != nil {
				var codeConfiguration CodeConfiguration
				err = json.Unmarshal(*v, &codeConfiguration)
				if err != nil {
					return err
				}
				bd.CodeConfiguration = &codeConfiguration
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				bd.Description = &description
			}
		case "environmentId":
			if v != nil {
				var environmentID string
				err = json.Unmarshal(*v, &environmentID)
				if err != nil {
					return err
				}
				bd.EnvironmentID = &environmentID
			}
		case "environmentVariables":
			if v != nil {
				var environmentVariables map[string]*string
				err = json.Unmarshal(*v, &environmentVariables)
				if err != nil {
					return err
				}
				bd.EnvironmentVariables = environmentVariables
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				bd.Properties = properties
			}
		}
	}

	return nil
}

// BatchDeploymentsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type BatchDeploymentsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BatchDeploymentsClient) (BatchDeploymentTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BatchDeploymentsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BatchDeploymentsCreateOrUpdateFuture.Result.
func (future *BatchDeploymentsCreateOrUpdateFuture) result(client BatchDeploymentsClient) (bdtr BatchDeploymentTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.BatchDeploymentsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bdtr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.BatchDeploymentsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bdtr.Response.Response, err = future.GetResult(sender); err == nil && bdtr.Response.Response.StatusCode != http.StatusNoContent {
		bdtr, err = client.CreateOrUpdateResponder(bdtr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.BatchDeploymentsCreateOrUpdateFuture", "Result", bdtr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BatchDeploymentsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BatchDeploymentsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BatchDeploymentsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BatchDeploymentsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BatchDeploymentsDeleteFuture.Result.
func (future *BatchDeploymentsDeleteFuture) result(client BatchDeploymentsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.BatchDeploymentsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.BatchDeploymentsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// BatchDeploymentsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BatchDeploymentsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BatchDeploymentsClient) (BatchDeploymentTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BatchDeploymentsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BatchDeploymentsUpdateFuture.Result.
func (future *BatchDeploymentsUpdateFuture) result(client BatchDeploymentsClient) (bdtr BatchDeploymentTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.BatchDeploymentsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		bdtr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.BatchDeploymentsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if bdtr.Response.Response, err = future.GetResult(sender); err == nil && bdtr.Response.Response.StatusCode != http.StatusNoContent {
		bdtr, err = client.UpdateResponder(bdtr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.BatchDeploymentsUpdateFuture", "Result", bdtr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BatchDeploymentTrackedResource ...
type BatchDeploymentTrackedResource struct {
	autorest.Response `json:"-"`
	// Identity - Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *BatchDeployment `json:"properties,omitempty"`
	// Sku - Sku details required for ARM contract for Autoscaling.
	Sku *Sku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for BatchDeploymentTrackedResource.
func (bdtr BatchDeploymentTrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bdtr.Identity != nil {
		objectMap["identity"] = bdtr.Identity
	}
	if bdtr.Kind != nil {
		objectMap["kind"] = bdtr.Kind
	}
	if bdtr.Properties != nil {
		objectMap["properties"] = bdtr.Properties
	}
	if bdtr.Sku != nil {
		objectMap["sku"] = bdtr.Sku
	}
	if bdtr.Tags != nil {
		objectMap["tags"] = bdtr.Tags
	}
	if bdtr.Location != nil {
		objectMap["location"] = bdtr.Location
	}
	return json.Marshal(objectMap)
}

// BatchDeploymentTrackedResourceArmPaginatedResult a paginated list of BatchDeployment entities.
type BatchDeploymentTrackedResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of BatchDeployment objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type BatchDeployment.
	Value *[]BatchDeploymentTrackedResource `json:"value,omitempty"`
}

// BatchDeploymentTrackedResourceArmPaginatedResultIterator provides access to a complete listing of
// BatchDeploymentTrackedResource values.
type BatchDeploymentTrackedResourceArmPaginatedResultIterator struct {
	i    int
	page BatchDeploymentTrackedResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BatchDeploymentTrackedResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BatchDeploymentTrackedResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BatchDeploymentTrackedResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BatchDeploymentTrackedResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BatchDeploymentTrackedResourceArmPaginatedResultIterator) Response() BatchDeploymentTrackedResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BatchDeploymentTrackedResourceArmPaginatedResultIterator) Value() BatchDeploymentTrackedResource {
	if !iter.page.NotDone() {
		return BatchDeploymentTrackedResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BatchDeploymentTrackedResourceArmPaginatedResultIterator type.
func NewBatchDeploymentTrackedResourceArmPaginatedResultIterator(page BatchDeploymentTrackedResourceArmPaginatedResultPage) BatchDeploymentTrackedResourceArmPaginatedResultIterator {
	return BatchDeploymentTrackedResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (bdtrapr BatchDeploymentTrackedResourceArmPaginatedResult) IsEmpty() bool {
	return bdtrapr.Value == nil || len(*bdtrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (bdtrapr BatchDeploymentTrackedResourceArmPaginatedResult) hasNextLink() bool {
	return bdtrapr.NextLink != nil && len(*bdtrapr.NextLink) != 0
}

// batchDeploymentTrackedResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (bdtrapr BatchDeploymentTrackedResourceArmPaginatedResult) batchDeploymentTrackedResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !bdtrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(bdtrapr.NextLink)))
}

// BatchDeploymentTrackedResourceArmPaginatedResultPage contains a page of BatchDeploymentTrackedResource
// values.
type BatchDeploymentTrackedResourceArmPaginatedResultPage struct {
	fn      func(context.Context, BatchDeploymentTrackedResourceArmPaginatedResult) (BatchDeploymentTrackedResourceArmPaginatedResult, error)
	bdtrapr BatchDeploymentTrackedResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BatchDeploymentTrackedResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BatchDeploymentTrackedResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.bdtrapr)
		if err != nil {
			return err
		}
		page.bdtrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BatchDeploymentTrackedResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BatchDeploymentTrackedResourceArmPaginatedResultPage) NotDone() bool {
	return !page.bdtrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BatchDeploymentTrackedResourceArmPaginatedResultPage) Response() BatchDeploymentTrackedResourceArmPaginatedResult {
	return page.bdtrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BatchDeploymentTrackedResourceArmPaginatedResultPage) Values() []BatchDeploymentTrackedResource {
	if page.bdtrapr.IsEmpty() {
		return nil
	}
	return *page.bdtrapr.Value
}

// Creates a new instance of the BatchDeploymentTrackedResourceArmPaginatedResultPage type.
func NewBatchDeploymentTrackedResourceArmPaginatedResultPage(cur BatchDeploymentTrackedResourceArmPaginatedResult, getNextPage func(context.Context, BatchDeploymentTrackedResourceArmPaginatedResult) (BatchDeploymentTrackedResourceArmPaginatedResult, error)) BatchDeploymentTrackedResourceArmPaginatedResultPage {
	return BatchDeploymentTrackedResourceArmPaginatedResultPage{
		fn:      getNextPage,
		bdtrapr: cur,
	}
}

// BatchEndpoint batch endpoint configuration.
type BatchEndpoint struct {
	// Defaults - Default values for Batch Endpoint
	Defaults *BatchEndpointDefaults `json:"defaults,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state for the endpoint. Possible values include: 'EndpointProvisioningStateCreating', 'EndpointProvisioningStateDeleting', 'EndpointProvisioningStateSucceeded', 'EndpointProvisioningStateFailed', 'EndpointProvisioningStateUpdating', 'EndpointProvisioningStateCanceled'
	ProvisioningState EndpointProvisioningState `json:"provisioningState,omitempty"`
	// AuthMode - [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does. Possible values include: 'AMLToken', 'Key', 'AADToken'
	AuthMode EndpointAuthMode `json:"authMode,omitempty"`
	// Description - Description of the inference endpoint.
	Description *string `json:"description,omitempty"`
	// Keys - EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `json:"keys,omitempty"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
	// ScoringURI - READ-ONLY; Endpoint URI.
	ScoringURI *string `json:"scoringUri,omitempty"`
	// SwaggerURI - READ-ONLY; Endpoint Swagger URI.
	SwaggerURI *string `json:"swaggerUri,omitempty"`
}

// MarshalJSON is the custom marshaler for BatchEndpoint.
func (be BatchEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if be.Defaults != nil {
		objectMap["defaults"] = be.Defaults
	}
	if be.AuthMode != "" {
		objectMap["authMode"] = be.AuthMode
	}
	if be.Description != nil {
		objectMap["description"] = be.Description
	}
	if be.Keys != nil {
		objectMap["keys"] = be.Keys
	}
	if be.Properties != nil {
		objectMap["properties"] = be.Properties
	}
	return json.Marshal(objectMap)
}

// BatchEndpointDefaults batch endpoint default values
type BatchEndpointDefaults struct {
	// DeploymentName - Name of the deployment that will be default for the endpoint.
	// This deployment will end up getting 100% traffic when the endpoint scoring URL is invoked.
	DeploymentName *string `json:"deploymentName,omitempty"`
}

// BatchEndpointsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type BatchEndpointsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BatchEndpointsClient) (BatchEndpointTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BatchEndpointsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BatchEndpointsCreateOrUpdateFuture.Result.
func (future *BatchEndpointsCreateOrUpdateFuture) result(client BatchEndpointsClient) (betr BatchEndpointTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.BatchEndpointsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		betr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.BatchEndpointsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if betr.Response.Response, err = future.GetResult(sender); err == nil && betr.Response.Response.StatusCode != http.StatusNoContent {
		betr, err = client.CreateOrUpdateResponder(betr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.BatchEndpointsCreateOrUpdateFuture", "Result", betr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BatchEndpointsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BatchEndpointsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BatchEndpointsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BatchEndpointsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BatchEndpointsDeleteFuture.Result.
func (future *BatchEndpointsDeleteFuture) result(client BatchEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.BatchEndpointsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.BatchEndpointsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// BatchEndpointsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type BatchEndpointsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(BatchEndpointsClient) (BatchEndpointTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *BatchEndpointsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for BatchEndpointsUpdateFuture.Result.
func (future *BatchEndpointsUpdateFuture) result(client BatchEndpointsClient) (betr BatchEndpointTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.BatchEndpointsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		betr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.BatchEndpointsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if betr.Response.Response, err = future.GetResult(sender); err == nil && betr.Response.Response.StatusCode != http.StatusNoContent {
		betr, err = client.UpdateResponder(betr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.BatchEndpointsUpdateFuture", "Result", betr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BatchEndpointTrackedResource ...
type BatchEndpointTrackedResource struct {
	autorest.Response `json:"-"`
	// Identity - Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *BatchEndpoint `json:"properties,omitempty"`
	// Sku - Sku details required for ARM contract for Autoscaling.
	Sku *Sku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for BatchEndpointTrackedResource.
func (betr BatchEndpointTrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if betr.Identity != nil {
		objectMap["identity"] = betr.Identity
	}
	if betr.Kind != nil {
		objectMap["kind"] = betr.Kind
	}
	if betr.Properties != nil {
		objectMap["properties"] = betr.Properties
	}
	if betr.Sku != nil {
		objectMap["sku"] = betr.Sku
	}
	if betr.Tags != nil {
		objectMap["tags"] = betr.Tags
	}
	if betr.Location != nil {
		objectMap["location"] = betr.Location
	}
	return json.Marshal(objectMap)
}

// BatchEndpointTrackedResourceArmPaginatedResult a paginated list of BatchEndpoint entities.
type BatchEndpointTrackedResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of BatchEndpoint objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type BatchEndpoint.
	Value *[]BatchEndpointTrackedResource `json:"value,omitempty"`
}

// BatchEndpointTrackedResourceArmPaginatedResultIterator provides access to a complete listing of
// BatchEndpointTrackedResource values.
type BatchEndpointTrackedResourceArmPaginatedResultIterator struct {
	i    int
	page BatchEndpointTrackedResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *BatchEndpointTrackedResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BatchEndpointTrackedResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *BatchEndpointTrackedResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter BatchEndpointTrackedResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter BatchEndpointTrackedResourceArmPaginatedResultIterator) Response() BatchEndpointTrackedResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter BatchEndpointTrackedResourceArmPaginatedResultIterator) Value() BatchEndpointTrackedResource {
	if !iter.page.NotDone() {
		return BatchEndpointTrackedResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the BatchEndpointTrackedResourceArmPaginatedResultIterator type.
func NewBatchEndpointTrackedResourceArmPaginatedResultIterator(page BatchEndpointTrackedResourceArmPaginatedResultPage) BatchEndpointTrackedResourceArmPaginatedResultIterator {
	return BatchEndpointTrackedResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (betrapr BatchEndpointTrackedResourceArmPaginatedResult) IsEmpty() bool {
	return betrapr.Value == nil || len(*betrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (betrapr BatchEndpointTrackedResourceArmPaginatedResult) hasNextLink() bool {
	return betrapr.NextLink != nil && len(*betrapr.NextLink) != 0
}

// batchEndpointTrackedResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (betrapr BatchEndpointTrackedResourceArmPaginatedResult) batchEndpointTrackedResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !betrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(betrapr.NextLink)))
}

// BatchEndpointTrackedResourceArmPaginatedResultPage contains a page of BatchEndpointTrackedResource
// values.
type BatchEndpointTrackedResourceArmPaginatedResultPage struct {
	fn      func(context.Context, BatchEndpointTrackedResourceArmPaginatedResult) (BatchEndpointTrackedResourceArmPaginatedResult, error)
	betrapr BatchEndpointTrackedResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *BatchEndpointTrackedResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BatchEndpointTrackedResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.betrapr)
		if err != nil {
			return err
		}
		page.betrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *BatchEndpointTrackedResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page BatchEndpointTrackedResourceArmPaginatedResultPage) NotDone() bool {
	return !page.betrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page BatchEndpointTrackedResourceArmPaginatedResultPage) Response() BatchEndpointTrackedResourceArmPaginatedResult {
	return page.betrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page BatchEndpointTrackedResourceArmPaginatedResultPage) Values() []BatchEndpointTrackedResource {
	if page.betrapr.IsEmpty() {
		return nil
	}
	return *page.betrapr.Value
}

// Creates a new instance of the BatchEndpointTrackedResourceArmPaginatedResultPage type.
func NewBatchEndpointTrackedResourceArmPaginatedResultPage(cur BatchEndpointTrackedResourceArmPaginatedResult, getNextPage func(context.Context, BatchEndpointTrackedResourceArmPaginatedResult) (BatchEndpointTrackedResourceArmPaginatedResult, error)) BatchEndpointTrackedResourceArmPaginatedResultPage {
	return BatchEndpointTrackedResourceArmPaginatedResultPage{
		fn:      getNextPage,
		betrapr: cur,
	}
}

// BatchRetrySettings retry settings for a batch inference operation.
type BatchRetrySettings struct {
	// MaxRetries - Maximum retry count for a mini-batch
	MaxRetries *int32 `json:"maxRetries,omitempty"`
	// Timeout - Invocation timeout for a mini-batch, in ISO 8601 format.
	Timeout *string `json:"timeout,omitempty"`
}

// BayesianSamplingAlgorithm defines a Sampling Algorithm that generates values based on previous values
type BayesianSamplingAlgorithm struct {
	// SamplingAlgorithmType - Possible values include: 'SamplingAlgorithmTypeSamplingAlgorithm', 'SamplingAlgorithmTypeBayesian1', 'SamplingAlgorithmTypeGrid1', 'SamplingAlgorithmTypeRandom1'
	SamplingAlgorithmType SamplingAlgorithmTypeBasicSamplingAlgorithm `json:"samplingAlgorithmType,omitempty"`
}

// MarshalJSON is the custom marshaler for BayesianSamplingAlgorithm.
func (bsa BayesianSamplingAlgorithm) MarshalJSON() ([]byte, error) {
	bsa.SamplingAlgorithmType = SamplingAlgorithmTypeBayesian1
	objectMap := make(map[string]interface{})
	if bsa.SamplingAlgorithmType != "" {
		objectMap["samplingAlgorithmType"] = bsa.SamplingAlgorithmType
	}
	return json.Marshal(objectMap)
}

// AsBayesianSamplingAlgorithm is the BasicSamplingAlgorithm implementation for BayesianSamplingAlgorithm.
func (bsa BayesianSamplingAlgorithm) AsBayesianSamplingAlgorithm() (*BayesianSamplingAlgorithm, bool) {
	return &bsa, true
}

// AsGridSamplingAlgorithm is the BasicSamplingAlgorithm implementation for BayesianSamplingAlgorithm.
func (bsa BayesianSamplingAlgorithm) AsGridSamplingAlgorithm() (*GridSamplingAlgorithm, bool) {
	return nil, false
}

// AsRandomSamplingAlgorithm is the BasicSamplingAlgorithm implementation for BayesianSamplingAlgorithm.
func (bsa BayesianSamplingAlgorithm) AsRandomSamplingAlgorithm() (*RandomSamplingAlgorithm, bool) {
	return nil, false
}

// AsSamplingAlgorithm is the BasicSamplingAlgorithm implementation for BayesianSamplingAlgorithm.
func (bsa BayesianSamplingAlgorithm) AsSamplingAlgorithm() (*SamplingAlgorithm, bool) {
	return nil, false
}

// AsBasicSamplingAlgorithm is the BasicSamplingAlgorithm implementation for BayesianSamplingAlgorithm.
func (bsa BayesianSamplingAlgorithm) AsBasicSamplingAlgorithm() (BasicSamplingAlgorithm, bool) {
	return &bsa, true
}

// BuildContext configuration settings for Docker build context
type BuildContext struct {
	// ContextURI - [Required] URI of the Docker build context used to build the image. Supports blob URIs on environment creation and may return blob or Git URIs.
	// <seealso href="https://docs.docker.com/engine/reference/commandline/build/#extended-description" />
	ContextURI *string `json:"contextUri,omitempty"`
	// DockerfilePath - Path to the Dockerfile in the build context.
	// <seealso href="https://docs.docker.com/engine/reference/builder/" />
	DockerfilePath *string `json:"dockerfilePath,omitempty"`
}

// CertificateDatastoreCredentials certificate datastore credentials configuration.
type CertificateDatastoreCredentials struct {
	// AuthorityURL - Authority URL used for authentication.
	AuthorityURL *string `json:"authorityUrl,omitempty"`
	// ClientID - [Required] Service principal client ID.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// ResourceURL - Resource the service principal has access to.
	ResourceURL *string `json:"resourceUrl,omitempty"`
	// Secrets - [Required] Service principal secrets.
	Secrets *CertificateDatastoreSecrets `json:"secrets,omitempty"`
	// TenantID - [Required] ID of the tenant to which the service principal belongs.
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// Thumbprint - [Required] Thumbprint of the certificate used for authentication.
	Thumbprint *string `json:"thumbprint,omitempty"`
	// CredentialsType - Possible values include: 'CredentialsTypeDatastoreCredentials', 'CredentialsTypeAccountKey1', 'CredentialsTypeCertificate1', 'CredentialsTypeNone1', 'CredentialsTypeSas1', 'CredentialsTypeServicePrincipal1'
	CredentialsType CredentialsTypeBasicDatastoreCredentials `json:"credentialsType,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) MarshalJSON() ([]byte, error) {
	cdc.CredentialsType = CredentialsTypeCertificate1
	objectMap := make(map[string]interface{})
	if cdc.AuthorityURL != nil {
		objectMap["authorityUrl"] = cdc.AuthorityURL
	}
	if cdc.ClientID != nil {
		objectMap["clientId"] = cdc.ClientID
	}
	if cdc.ResourceURL != nil {
		objectMap["resourceUrl"] = cdc.ResourceURL
	}
	if cdc.Secrets != nil {
		objectMap["secrets"] = cdc.Secrets
	}
	if cdc.TenantID != nil {
		objectMap["tenantId"] = cdc.TenantID
	}
	if cdc.Thumbprint != nil {
		objectMap["thumbprint"] = cdc.Thumbprint
	}
	if cdc.CredentialsType != "" {
		objectMap["credentialsType"] = cdc.CredentialsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool) {
	return nil, false
}

// AsCertificateDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool) {
	return &cdc, true
}

// AsNoneDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool) {
	return nil, false
}

// AsSasDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool) {
	return nil, false
}

// AsDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsDatastoreCredentials() (*DatastoreCredentials, bool) {
	return nil, false
}

// AsBasicDatastoreCredentials is the BasicDatastoreCredentials implementation for CertificateDatastoreCredentials.
func (cdc CertificateDatastoreCredentials) AsBasicDatastoreCredentials() (BasicDatastoreCredentials, bool) {
	return &cdc, true
}

// CertificateDatastoreSecrets datastore certificate secrets.
type CertificateDatastoreSecrets struct {
	// Certificate - Service principal certificate.
	Certificate *string `json:"certificate,omitempty"`
	// SecretsType - Possible values include: 'SecretsTypeDatastoreSecrets', 'SecretsTypeAccountKey', 'SecretsTypeCertificate', 'SecretsTypeSas', 'SecretsTypeServicePrincipal'
	SecretsType SecretsTypeBasicDatastoreSecrets `json:"secretsType,omitempty"`
}

// MarshalJSON is the custom marshaler for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) MarshalJSON() ([]byte, error) {
	cds.SecretsType = SecretsTypeCertificate
	objectMap := make(map[string]interface{})
	if cds.Certificate != nil {
		objectMap["certificate"] = cds.Certificate
	}
	if cds.SecretsType != "" {
		objectMap["secretsType"] = cds.SecretsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreSecrets is the BasicDatastoreSecrets implementation for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) AsAccountKeyDatastoreSecrets() (*AccountKeyDatastoreSecrets, bool) {
	return nil, false
}

// AsCertificateDatastoreSecrets is the BasicDatastoreSecrets implementation for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) AsCertificateDatastoreSecrets() (*CertificateDatastoreSecrets, bool) {
	return &cds, true
}

// AsSasDatastoreSecrets is the BasicDatastoreSecrets implementation for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) AsSasDatastoreSecrets() (*SasDatastoreSecrets, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreSecrets is the BasicDatastoreSecrets implementation for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) AsServicePrincipalDatastoreSecrets() (*ServicePrincipalDatastoreSecrets, bool) {
	return nil, false
}

// AsDatastoreSecrets is the BasicDatastoreSecrets implementation for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) AsDatastoreSecrets() (*DatastoreSecrets, bool) {
	return nil, false
}

// AsBasicDatastoreSecrets is the BasicDatastoreSecrets implementation for CertificateDatastoreSecrets.
func (cds CertificateDatastoreSecrets) AsBasicDatastoreSecrets() (BasicDatastoreSecrets, bool) {
	return &cds, true
}

// ClusterUpdateParameters amlCompute update parameters.
type ClusterUpdateParameters struct {
	// ClusterUpdateProperties - The properties of the amlCompute.
	*ClusterUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ClusterUpdateParameters.
func (cup ClusterUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cup.ClusterUpdateProperties != nil {
		objectMap["properties"] = cup.ClusterUpdateProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ClusterUpdateParameters struct.
func (cup *ClusterUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var clusterUpdateProperties ClusterUpdateProperties
				err = json.Unmarshal(*v, &clusterUpdateProperties)
				if err != nil {
					return err
				}
				cup.ClusterUpdateProperties = &clusterUpdateProperties
			}
		}
	}

	return nil
}

// ClusterUpdateProperties the properties of a amlCompute that need to be updated.
type ClusterUpdateProperties struct {
	// Properties - Properties of ClusterUpdate
	Properties *ScaleSettingsInformation `json:"properties,omitempty"`
}

// CodeConfiguration configuration for a scoring code asset.
type CodeConfiguration struct {
	// CodeID - ARM resource ID of the code asset.
	CodeID *string `json:"codeId,omitempty"`
	// ScoringScript - [Required] The script to execute on startup. eg. "score.py"
	ScoringScript *string `json:"scoringScript,omitempty"`
}

// CodeContainer container for code asset versions.
type CodeContainer struct {
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// LatestVersion - READ-ONLY; The latest version inside this container.
	LatestVersion *string `json:"latestVersion,omitempty"`
	// NextVersion - READ-ONLY; The next auto incremental version
	NextVersion *string `json:"nextVersion,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for CodeContainer.
func (cc CodeContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cc.IsArchived != nil {
		objectMap["isArchived"] = cc.IsArchived
	}
	if cc.Description != nil {
		objectMap["description"] = cc.Description
	}
	if cc.Properties != nil {
		objectMap["properties"] = cc.Properties
	}
	if cc.Tags != nil {
		objectMap["tags"] = cc.Tags
	}
	return json.Marshal(objectMap)
}

// CodeContainerResource azure Resource Manager resource envelope.
type CodeContainerResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *CodeContainer `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for CodeContainerResource.
func (ccr CodeContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ccr.Properties != nil {
		objectMap["properties"] = ccr.Properties
	}
	return json.Marshal(objectMap)
}

// CodeContainerResourceArmPaginatedResult a paginated list of CodeContainer entities.
type CodeContainerResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of CodeContainer objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type CodeContainer.
	Value *[]CodeContainerResource `json:"value,omitempty"`
}

// CodeContainerResourceArmPaginatedResultIterator provides access to a complete listing of
// CodeContainerResource values.
type CodeContainerResourceArmPaginatedResultIterator struct {
	i    int
	page CodeContainerResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CodeContainerResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CodeContainerResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CodeContainerResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CodeContainerResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CodeContainerResourceArmPaginatedResultIterator) Response() CodeContainerResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CodeContainerResourceArmPaginatedResultIterator) Value() CodeContainerResource {
	if !iter.page.NotDone() {
		return CodeContainerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CodeContainerResourceArmPaginatedResultIterator type.
func NewCodeContainerResourceArmPaginatedResultIterator(page CodeContainerResourceArmPaginatedResultPage) CodeContainerResourceArmPaginatedResultIterator {
	return CodeContainerResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ccrapr CodeContainerResourceArmPaginatedResult) IsEmpty() bool {
	return ccrapr.Value == nil || len(*ccrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ccrapr CodeContainerResourceArmPaginatedResult) hasNextLink() bool {
	return ccrapr.NextLink != nil && len(*ccrapr.NextLink) != 0
}

// codeContainerResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ccrapr CodeContainerResourceArmPaginatedResult) codeContainerResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ccrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ccrapr.NextLink)))
}

// CodeContainerResourceArmPaginatedResultPage contains a page of CodeContainerResource values.
type CodeContainerResourceArmPaginatedResultPage struct {
	fn     func(context.Context, CodeContainerResourceArmPaginatedResult) (CodeContainerResourceArmPaginatedResult, error)
	ccrapr CodeContainerResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CodeContainerResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CodeContainerResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ccrapr)
		if err != nil {
			return err
		}
		page.ccrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CodeContainerResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CodeContainerResourceArmPaginatedResultPage) NotDone() bool {
	return !page.ccrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CodeContainerResourceArmPaginatedResultPage) Response() CodeContainerResourceArmPaginatedResult {
	return page.ccrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CodeContainerResourceArmPaginatedResultPage) Values() []CodeContainerResource {
	if page.ccrapr.IsEmpty() {
		return nil
	}
	return *page.ccrapr.Value
}

// Creates a new instance of the CodeContainerResourceArmPaginatedResultPage type.
func NewCodeContainerResourceArmPaginatedResultPage(cur CodeContainerResourceArmPaginatedResult, getNextPage func(context.Context, CodeContainerResourceArmPaginatedResult) (CodeContainerResourceArmPaginatedResult, error)) CodeContainerResourceArmPaginatedResultPage {
	return CodeContainerResourceArmPaginatedResultPage{
		fn:     getNextPage,
		ccrapr: cur,
	}
}

// CodeVersion code asset version details.
type CodeVersion struct {
	// CodeURI - Uri where code is located
	CodeURI *string `json:"codeUri,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for CodeVersion.
func (cv CodeVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cv.CodeURI != nil {
		objectMap["codeUri"] = cv.CodeURI
	}
	if cv.IsAnonymous != nil {
		objectMap["isAnonymous"] = cv.IsAnonymous
	}
	if cv.IsArchived != nil {
		objectMap["isArchived"] = cv.IsArchived
	}
	if cv.Description != nil {
		objectMap["description"] = cv.Description
	}
	if cv.Properties != nil {
		objectMap["properties"] = cv.Properties
	}
	if cv.Tags != nil {
		objectMap["tags"] = cv.Tags
	}
	return json.Marshal(objectMap)
}

// CodeVersionResource azure Resource Manager resource envelope.
type CodeVersionResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *CodeVersion `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for CodeVersionResource.
func (cvr CodeVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cvr.Properties != nil {
		objectMap["properties"] = cvr.Properties
	}
	return json.Marshal(objectMap)
}

// CodeVersionResourceArmPaginatedResult a paginated list of CodeVersion entities.
type CodeVersionResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of CodeVersion objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type CodeVersion.
	Value *[]CodeVersionResource `json:"value,omitempty"`
}

// CodeVersionResourceArmPaginatedResultIterator provides access to a complete listing of
// CodeVersionResource values.
type CodeVersionResourceArmPaginatedResultIterator struct {
	i    int
	page CodeVersionResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CodeVersionResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CodeVersionResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CodeVersionResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CodeVersionResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CodeVersionResourceArmPaginatedResultIterator) Response() CodeVersionResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CodeVersionResourceArmPaginatedResultIterator) Value() CodeVersionResource {
	if !iter.page.NotDone() {
		return CodeVersionResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CodeVersionResourceArmPaginatedResultIterator type.
func NewCodeVersionResourceArmPaginatedResultIterator(page CodeVersionResourceArmPaginatedResultPage) CodeVersionResourceArmPaginatedResultIterator {
	return CodeVersionResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cvrapr CodeVersionResourceArmPaginatedResult) IsEmpty() bool {
	return cvrapr.Value == nil || len(*cvrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cvrapr CodeVersionResourceArmPaginatedResult) hasNextLink() bool {
	return cvrapr.NextLink != nil && len(*cvrapr.NextLink) != 0
}

// codeVersionResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cvrapr CodeVersionResourceArmPaginatedResult) codeVersionResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !cvrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cvrapr.NextLink)))
}

// CodeVersionResourceArmPaginatedResultPage contains a page of CodeVersionResource values.
type CodeVersionResourceArmPaginatedResultPage struct {
	fn     func(context.Context, CodeVersionResourceArmPaginatedResult) (CodeVersionResourceArmPaginatedResult, error)
	cvrapr CodeVersionResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CodeVersionResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CodeVersionResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cvrapr)
		if err != nil {
			return err
		}
		page.cvrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CodeVersionResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CodeVersionResourceArmPaginatedResultPage) NotDone() bool {
	return !page.cvrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CodeVersionResourceArmPaginatedResultPage) Response() CodeVersionResourceArmPaginatedResult {
	return page.cvrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CodeVersionResourceArmPaginatedResultPage) Values() []CodeVersionResource {
	if page.cvrapr.IsEmpty() {
		return nil
	}
	return *page.cvrapr.Value
}

// Creates a new instance of the CodeVersionResourceArmPaginatedResultPage type.
func NewCodeVersionResourceArmPaginatedResultPage(cur CodeVersionResourceArmPaginatedResult, getNextPage func(context.Context, CodeVersionResourceArmPaginatedResult) (CodeVersionResourceArmPaginatedResult, error)) CodeVersionResourceArmPaginatedResultPage {
	return CodeVersionResourceArmPaginatedResultPage{
		fn:     getNextPage,
		cvrapr: cur,
	}
}

// CommandJob command job definition.
type CommandJob struct {
	// CodeID - ARM resource ID of the code asset.
	CodeID *string `json:"codeId,omitempty"`
	// Command - [Required] The command to execute on startup of the job. eg. "python train.py"
	Command *string `json:"command,omitempty"`
	// Distribution - Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	Distribution BasicDistributionConfiguration `json:"distribution,omitempty"`
	// EnvironmentID - [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables included in the job.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Inputs - Mapping of input data bindings used in the job.
	Inputs map[string]BasicJobInput `json:"inputs"`
	// Limits - Command Job limit.
	Limits *CommandJobLimits `json:"limits,omitempty"`
	// Outputs - Mapping of output data bindings used in the job.
	Outputs map[string]BasicJobOutput `json:"outputs"`
	// Parameters - READ-ONLY; Input parameters.
	Parameters interface{} `json:"parameters,omitempty"`
	// Resources - Compute Resource configuration for the job.
	Resources *ResourceConfiguration `json:"resources,omitempty"`
	// ComputeID - ARM resource ID of the compute resource.
	ComputeID *string `json:"computeId,omitempty"`
	// DisplayName - Display name of job.
	DisplayName *string `json:"displayName,omitempty"`
	// ExperimentName - The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `json:"experimentName,omitempty"`
	// Identity - Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity BasicIdentityConfiguration `json:"identity,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Services - List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]*JobService `json:"services"`
	// Status - READ-ONLY; Status of the job. Possible values include: 'JobStatusNotStarted', 'JobStatusStarting', 'JobStatusProvisioning', 'JobStatusPreparing', 'JobStatusQueued', 'JobStatusRunning', 'JobStatusFinalizing', 'JobStatusCancelRequested', 'JobStatusCompleted', 'JobStatusFailed', 'JobStatusCanceled', 'JobStatusNotResponding', 'JobStatusPaused', 'JobStatusUnknown'
	Status JobStatus `json:"status,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
	// JobType - Possible values include: 'JobTypeJobBase', 'JobTypeCommand1', 'JobTypePipeline1', 'JobTypeSweep1'
	JobType JobTypeBasicJobBase `json:"jobType,omitempty"`
}

// MarshalJSON is the custom marshaler for CommandJob.
func (cj CommandJob) MarshalJSON() ([]byte, error) {
	cj.JobType = JobTypeCommand1
	objectMap := make(map[string]interface{})
	if cj.CodeID != nil {
		objectMap["codeId"] = cj.CodeID
	}
	if cj.Command != nil {
		objectMap["command"] = cj.Command
	}
	objectMap["distribution"] = cj.Distribution
	if cj.EnvironmentID != nil {
		objectMap["environmentId"] = cj.EnvironmentID
	}
	if cj.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = cj.EnvironmentVariables
	}
	if cj.Inputs != nil {
		objectMap["inputs"] = cj.Inputs
	}
	if cj.Limits != nil {
		objectMap["limits"] = cj.Limits
	}
	if cj.Outputs != nil {
		objectMap["outputs"] = cj.Outputs
	}
	if cj.Resources != nil {
		objectMap["resources"] = cj.Resources
	}
	if cj.ComputeID != nil {
		objectMap["computeId"] = cj.ComputeID
	}
	if cj.DisplayName != nil {
		objectMap["displayName"] = cj.DisplayName
	}
	if cj.ExperimentName != nil {
		objectMap["experimentName"] = cj.ExperimentName
	}
	objectMap["identity"] = cj.Identity
	if cj.IsArchived != nil {
		objectMap["isArchived"] = cj.IsArchived
	}
	if cj.Services != nil {
		objectMap["services"] = cj.Services
	}
	if cj.JobType != "" {
		objectMap["jobType"] = cj.JobType
	}
	if cj.Description != nil {
		objectMap["description"] = cj.Description
	}
	if cj.Properties != nil {
		objectMap["properties"] = cj.Properties
	}
	if cj.Tags != nil {
		objectMap["tags"] = cj.Tags
	}
	return json.Marshal(objectMap)
}

// AsCommandJob is the BasicJobBase implementation for CommandJob.
func (cj CommandJob) AsCommandJob() (*CommandJob, bool) {
	return &cj, true
}

// AsPipelineJob is the BasicJobBase implementation for CommandJob.
func (cj CommandJob) AsPipelineJob() (*PipelineJob, bool) {
	return nil, false
}

// AsSweepJob is the BasicJobBase implementation for CommandJob.
func (cj CommandJob) AsSweepJob() (*SweepJob, bool) {
	return nil, false
}

// AsJobBase is the BasicJobBase implementation for CommandJob.
func (cj CommandJob) AsJobBase() (*JobBase, bool) {
	return nil, false
}

// AsBasicJobBase is the BasicJobBase implementation for CommandJob.
func (cj CommandJob) AsBasicJobBase() (BasicJobBase, bool) {
	return &cj, true
}

// UnmarshalJSON is the custom unmarshaler for CommandJob struct.
func (cj *CommandJob) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "codeId":
			if v != nil {
				var codeID string
				err = json.Unmarshal(*v, &codeID)
				if err != nil {
					return err
				}
				cj.CodeID = &codeID
			}
		case "command":
			if v != nil {
				var command string
				err = json.Unmarshal(*v, &command)
				if err != nil {
					return err
				}
				cj.Command = &command
			}
		case "distribution":
			if v != nil {
				distribution, err := unmarshalBasicDistributionConfiguration(*v)
				if err != nil {
					return err
				}
				cj.Distribution = distribution
			}
		case "environmentId":
			if v != nil {
				var environmentID string
				err = json.Unmarshal(*v, &environmentID)
				if err != nil {
					return err
				}
				cj.EnvironmentID = &environmentID
			}
		case "environmentVariables":
			if v != nil {
				var environmentVariables map[string]*string
				err = json.Unmarshal(*v, &environmentVariables)
				if err != nil {
					return err
				}
				cj.EnvironmentVariables = environmentVariables
			}
		case "inputs":
			if v != nil {
				var inputs map[string]BasicJobInput
				err = json.Unmarshal(*v, &inputs)
				if err != nil {
					return err
				}
				cj.Inputs = inputs
			}
		case "limits":
			if v != nil {
				var limits CommandJobLimits
				err = json.Unmarshal(*v, &limits)
				if err != nil {
					return err
				}
				cj.Limits = &limits
			}
		case "outputs":
			if v != nil {
				var outputs map[string]BasicJobOutput
				err = json.Unmarshal(*v, &outputs)
				if err != nil {
					return err
				}
				cj.Outputs = outputs
			}
		case "parameters":
			if v != nil {
				var parameters interface{}
				err = json.Unmarshal(*v, &parameters)
				if err != nil {
					return err
				}
				cj.Parameters = parameters
			}
		case "resources":
			if v != nil {
				var resources ResourceConfiguration
				err = json.Unmarshal(*v, &resources)
				if err != nil {
					return err
				}
				cj.Resources = &resources
			}
		case "computeId":
			if v != nil {
				var computeID string
				err = json.Unmarshal(*v, &computeID)
				if err != nil {
					return err
				}
				cj.ComputeID = &computeID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				cj.DisplayName = &displayName
			}
		case "experimentName":
			if v != nil {
				var experimentName string
				err = json.Unmarshal(*v, &experimentName)
				if err != nil {
					return err
				}
				cj.ExperimentName = &experimentName
			}
		case "identity":
			if v != nil {
				identity, err := unmarshalBasicIdentityConfiguration(*v)
				if err != nil {
					return err
				}
				cj.Identity = identity
			}
		case "isArchived":
			if v != nil {
				var isArchived bool
				err = json.Unmarshal(*v, &isArchived)
				if err != nil {
					return err
				}
				cj.IsArchived = &isArchived
			}
		case "services":
			if v != nil {
				var services map[string]*JobService
				err = json.Unmarshal(*v, &services)
				if err != nil {
					return err
				}
				cj.Services = services
			}
		case "status":
			if v != nil {
				var status JobStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				cj.Status = status
			}
		case "jobType":
			if v != nil {
				var jobType JobTypeBasicJobBase
				err = json.Unmarshal(*v, &jobType)
				if err != nil {
					return err
				}
				cj.JobType = jobType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				cj.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				cj.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cj.Tags = tags
			}
		}
	}

	return nil
}

// CommandJobLimits command Job limit class.
type CommandJobLimits struct {
	// Timeout - The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `json:"timeout,omitempty"`
	// JobLimitsType - Possible values include: 'JobLimitsTypeJobLimits', 'JobLimitsTypeCommand', 'JobLimitsTypeSweep'
	JobLimitsType JobLimitsTypeBasicJobLimits `json:"jobLimitsType,omitempty"`
}

// MarshalJSON is the custom marshaler for CommandJobLimits.
func (cjl CommandJobLimits) MarshalJSON() ([]byte, error) {
	cjl.JobLimitsType = JobLimitsTypeCommand
	objectMap := make(map[string]interface{})
	if cjl.Timeout != nil {
		objectMap["timeout"] = cjl.Timeout
	}
	if cjl.JobLimitsType != "" {
		objectMap["jobLimitsType"] = cjl.JobLimitsType
	}
	return json.Marshal(objectMap)
}

// AsCommandJobLimits is the BasicJobLimits implementation for CommandJobLimits.
func (cjl CommandJobLimits) AsCommandJobLimits() (*CommandJobLimits, bool) {
	return &cjl, true
}

// AsSweepJobLimits is the BasicJobLimits implementation for CommandJobLimits.
func (cjl CommandJobLimits) AsSweepJobLimits() (*SweepJobLimits, bool) {
	return nil, false
}

// AsJobLimits is the BasicJobLimits implementation for CommandJobLimits.
func (cjl CommandJobLimits) AsJobLimits() (*JobLimits, bool) {
	return nil, false
}

// AsBasicJobLimits is the BasicJobLimits implementation for CommandJobLimits.
func (cjl CommandJobLimits) AsBasicJobLimits() (BasicJobLimits, bool) {
	return &cjl, true
}

// ComponentContainer component container definition.
// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
type ComponentContainer struct {
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// LatestVersion - READ-ONLY; The latest version inside this container.
	LatestVersion *string `json:"latestVersion,omitempty"`
	// NextVersion - READ-ONLY; The next auto incremental version
	NextVersion *string `json:"nextVersion,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ComponentContainer.
func (cc ComponentContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cc.IsArchived != nil {
		objectMap["isArchived"] = cc.IsArchived
	}
	if cc.Description != nil {
		objectMap["description"] = cc.Description
	}
	if cc.Properties != nil {
		objectMap["properties"] = cc.Properties
	}
	if cc.Tags != nil {
		objectMap["tags"] = cc.Tags
	}
	return json.Marshal(objectMap)
}

// ComponentContainerResource azure Resource Manager resource envelope.
type ComponentContainerResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *ComponentContainer `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ComponentContainerResource.
func (ccr ComponentContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ccr.Properties != nil {
		objectMap["properties"] = ccr.Properties
	}
	return json.Marshal(objectMap)
}

// ComponentContainerResourceArmPaginatedResult a paginated list of ComponentContainer entities.
type ComponentContainerResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of ComponentContainer objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type ComponentContainer.
	Value *[]ComponentContainerResource `json:"value,omitempty"`
}

// ComponentContainerResourceArmPaginatedResultIterator provides access to a complete listing of
// ComponentContainerResource values.
type ComponentContainerResourceArmPaginatedResultIterator struct {
	i    int
	page ComponentContainerResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ComponentContainerResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ComponentContainerResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ComponentContainerResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ComponentContainerResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ComponentContainerResourceArmPaginatedResultIterator) Response() ComponentContainerResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ComponentContainerResourceArmPaginatedResultIterator) Value() ComponentContainerResource {
	if !iter.page.NotDone() {
		return ComponentContainerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ComponentContainerResourceArmPaginatedResultIterator type.
func NewComponentContainerResourceArmPaginatedResultIterator(page ComponentContainerResourceArmPaginatedResultPage) ComponentContainerResourceArmPaginatedResultIterator {
	return ComponentContainerResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ccrapr ComponentContainerResourceArmPaginatedResult) IsEmpty() bool {
	return ccrapr.Value == nil || len(*ccrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ccrapr ComponentContainerResourceArmPaginatedResult) hasNextLink() bool {
	return ccrapr.NextLink != nil && len(*ccrapr.NextLink) != 0
}

// componentContainerResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ccrapr ComponentContainerResourceArmPaginatedResult) componentContainerResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ccrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ccrapr.NextLink)))
}

// ComponentContainerResourceArmPaginatedResultPage contains a page of ComponentContainerResource values.
type ComponentContainerResourceArmPaginatedResultPage struct {
	fn     func(context.Context, ComponentContainerResourceArmPaginatedResult) (ComponentContainerResourceArmPaginatedResult, error)
	ccrapr ComponentContainerResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ComponentContainerResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ComponentContainerResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ccrapr)
		if err != nil {
			return err
		}
		page.ccrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ComponentContainerResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ComponentContainerResourceArmPaginatedResultPage) NotDone() bool {
	return !page.ccrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ComponentContainerResourceArmPaginatedResultPage) Response() ComponentContainerResourceArmPaginatedResult {
	return page.ccrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ComponentContainerResourceArmPaginatedResultPage) Values() []ComponentContainerResource {
	if page.ccrapr.IsEmpty() {
		return nil
	}
	return *page.ccrapr.Value
}

// Creates a new instance of the ComponentContainerResourceArmPaginatedResultPage type.
func NewComponentContainerResourceArmPaginatedResultPage(cur ComponentContainerResourceArmPaginatedResult, getNextPage func(context.Context, ComponentContainerResourceArmPaginatedResult) (ComponentContainerResourceArmPaginatedResult, error)) ComponentContainerResourceArmPaginatedResultPage {
	return ComponentContainerResourceArmPaginatedResultPage{
		fn:     getNextPage,
		ccrapr: cur,
	}
}

// ComponentVersion definition of a component version: defines resources that span component types.
type ComponentVersion struct {
	// ComponentSpec - Defines Component definition details.
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/reference-yaml-component-command" />
	ComponentSpec interface{} `json:"componentSpec,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ComponentVersion.
func (cv ComponentVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cv.ComponentSpec != nil {
		objectMap["componentSpec"] = cv.ComponentSpec
	}
	if cv.IsAnonymous != nil {
		objectMap["isAnonymous"] = cv.IsAnonymous
	}
	if cv.IsArchived != nil {
		objectMap["isArchived"] = cv.IsArchived
	}
	if cv.Description != nil {
		objectMap["description"] = cv.Description
	}
	if cv.Properties != nil {
		objectMap["properties"] = cv.Properties
	}
	if cv.Tags != nil {
		objectMap["tags"] = cv.Tags
	}
	return json.Marshal(objectMap)
}

// ComponentVersionResource azure Resource Manager resource envelope.
type ComponentVersionResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *ComponentVersion `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ComponentVersionResource.
func (cvr ComponentVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cvr.Properties != nil {
		objectMap["properties"] = cvr.Properties
	}
	return json.Marshal(objectMap)
}

// ComponentVersionResourceArmPaginatedResult a paginated list of ComponentVersion entities.
type ComponentVersionResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of ComponentVersion objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type ComponentVersion.
	Value *[]ComponentVersionResource `json:"value,omitempty"`
}

// ComponentVersionResourceArmPaginatedResultIterator provides access to a complete listing of
// ComponentVersionResource values.
type ComponentVersionResourceArmPaginatedResultIterator struct {
	i    int
	page ComponentVersionResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ComponentVersionResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ComponentVersionResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ComponentVersionResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ComponentVersionResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ComponentVersionResourceArmPaginatedResultIterator) Response() ComponentVersionResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ComponentVersionResourceArmPaginatedResultIterator) Value() ComponentVersionResource {
	if !iter.page.NotDone() {
		return ComponentVersionResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ComponentVersionResourceArmPaginatedResultIterator type.
func NewComponentVersionResourceArmPaginatedResultIterator(page ComponentVersionResourceArmPaginatedResultPage) ComponentVersionResourceArmPaginatedResultIterator {
	return ComponentVersionResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cvrapr ComponentVersionResourceArmPaginatedResult) IsEmpty() bool {
	return cvrapr.Value == nil || len(*cvrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cvrapr ComponentVersionResourceArmPaginatedResult) hasNextLink() bool {
	return cvrapr.NextLink != nil && len(*cvrapr.NextLink) != 0
}

// componentVersionResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cvrapr ComponentVersionResourceArmPaginatedResult) componentVersionResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !cvrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cvrapr.NextLink)))
}

// ComponentVersionResourceArmPaginatedResultPage contains a page of ComponentVersionResource values.
type ComponentVersionResourceArmPaginatedResultPage struct {
	fn     func(context.Context, ComponentVersionResourceArmPaginatedResult) (ComponentVersionResourceArmPaginatedResult, error)
	cvrapr ComponentVersionResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ComponentVersionResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ComponentVersionResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cvrapr)
		if err != nil {
			return err
		}
		page.cvrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ComponentVersionResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ComponentVersionResourceArmPaginatedResultPage) NotDone() bool {
	return !page.cvrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ComponentVersionResourceArmPaginatedResultPage) Response() ComponentVersionResourceArmPaginatedResult {
	return page.cvrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ComponentVersionResourceArmPaginatedResultPage) Values() []ComponentVersionResource {
	if page.cvrapr.IsEmpty() {
		return nil
	}
	return *page.cvrapr.Value
}

// Creates a new instance of the ComponentVersionResourceArmPaginatedResultPage type.
func NewComponentVersionResourceArmPaginatedResultPage(cur ComponentVersionResourceArmPaginatedResult, getNextPage func(context.Context, ComponentVersionResourceArmPaginatedResult) (ComponentVersionResourceArmPaginatedResult, error)) ComponentVersionResourceArmPaginatedResultPage {
	return ComponentVersionResourceArmPaginatedResultPage{
		fn:     getNextPage,
		cvrapr: cur,
	}
}

// BasicCompute machine Learning compute object.
type BasicCompute interface {
	AsDataFactory() (*DataFactory, bool)
	AsSynapseSpark() (*SynapseSpark, bool)
	AsCompute() (*Compute, bool)
}

// Compute machine Learning compute object.
type Compute struct {
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeCompute', 'ComputeTypeDataFactory1', 'ComputeTypeSynapseSpark1'
	ComputeType ComputeTypeBasicCompute `json:"computeType,omitempty"`
}

func unmarshalBasicCompute(body []byte) (BasicCompute, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["computeType"] {
	case string(ComputeTypeDataFactory1):
		var df DataFactory
		err := json.Unmarshal(body, &df)
		return df, err
	case string(ComputeTypeSynapseSpark1):
		var ss SynapseSpark
		err := json.Unmarshal(body, &ss)
		return ss, err
	default:
		var c Compute
		err := json.Unmarshal(body, &c)
		return c, err
	}
}
func unmarshalBasicComputeArray(body []byte) ([]BasicCompute, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	cArray := make([]BasicCompute, len(rawMessages))

	for index, rawMessage := range rawMessages {
		c, err := unmarshalBasicCompute(*rawMessage)
		if err != nil {
			return nil, err
		}
		cArray[index] = c
	}
	return cArray, nil
}

// MarshalJSON is the custom marshaler for Compute.
func (c Compute) MarshalJSON() ([]byte, error) {
	c.ComputeType = ComputeTypeCompute
	objectMap := make(map[string]interface{})
	if c.Description != nil {
		objectMap["description"] = c.Description
	}
	if c.ResourceID != nil {
		objectMap["resourceId"] = c.ResourceID
	}
	if c.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = c.DisableLocalAuth
	}
	if c.ComputeType != "" {
		objectMap["computeType"] = c.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsDataFactory is the BasicCompute implementation for Compute.
func (c Compute) AsDataFactory() (*DataFactory, bool) {
	return nil, false
}

// AsSynapseSpark is the BasicCompute implementation for Compute.
func (c Compute) AsSynapseSpark() (*SynapseSpark, bool) {
	return nil, false
}

// AsCompute is the BasicCompute implementation for Compute.
func (c Compute) AsCompute() (*Compute, bool) {
	return &c, true
}

// AsBasicCompute is the BasicCompute implementation for Compute.
func (c Compute) AsBasicCompute() (BasicCompute, bool) {
	return &c, true
}

// ComputeCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ComputeCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ComputeClient) (ComputeResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ComputeCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ComputeCreateOrUpdateFuture.Result.
func (future *ComputeCreateOrUpdateFuture) result(client ComputeClient) (cr ComputeResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.ComputeCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cr.Response.Response, err = future.GetResult(sender); err == nil && cr.Response.Response.StatusCode != http.StatusNoContent {
		cr, err = client.CreateOrUpdateResponder(cr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeCreateOrUpdateFuture", "Result", cr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ComputeDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ComputeDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ComputeClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ComputeDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ComputeDeleteFuture.Result.
func (future *ComputeDeleteFuture) result(client ComputeClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.ComputeDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ComputeInstance an Azure Machine Learning compute instance.
type ComputeInstance struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// Properties - Properties of ComputeInstance
	Properties *ComputeInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeInstance.
func (ci ComputeInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ci.ComputeType != "" {
		objectMap["computeType"] = ci.ComputeType
	}
	if ci.Description != nil {
		objectMap["description"] = ci.Description
	}
	if ci.ResourceID != nil {
		objectMap["resourceId"] = ci.ResourceID
	}
	if ci.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = ci.DisableLocalAuth
	}
	if ci.Properties != nil {
		objectMap["properties"] = ci.Properties
	}
	return json.Marshal(objectMap)
}

// ComputeInstanceApplication defines an Aml Instance application and its connectivity endpoint URI.
type ComputeInstanceApplication struct {
	// DisplayName - Name of the ComputeInstance application.
	DisplayName *string `json:"displayName,omitempty"`
	// EndpointURI - Application' endpoint URI.
	EndpointURI *string `json:"endpointUri,omitempty"`
}

// ComputeInstanceConnectivityEndpoints defines all connectivity endpoints and properties for an
// ComputeInstance.
type ComputeInstanceConnectivityEndpoints struct {
	// PublicIPAddress - READ-ONLY; Public IP Address of this ComputeInstance.
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`
	// PrivateIPAddress - READ-ONLY; Private IP Address of this ComputeInstance (local to the VNET in which the compute instance is deployed).
	PrivateIPAddress *string `json:"privateIpAddress,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeInstanceConnectivityEndpoints.
func (cice ComputeInstanceConnectivityEndpoints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ComputeInstanceContainer defines an Aml Instance container.
type ComputeInstanceContainer struct {
	// Name - Name of the ComputeInstance container.
	Name *string `json:"name,omitempty"`
	// Autosave - Auto save settings. Possible values include: 'None', 'Local', 'Remote'
	Autosave Autosave `json:"autosave,omitempty"`
	// Gpu - Information of GPU.
	Gpu *string `json:"gpu,omitempty"`
	// Network - network of this container. Possible values include: 'Bridge', 'Host'
	Network Network `json:"network,omitempty"`
	// Environment - Environment information of this container.
	Environment *ComputeInstanceEnvironmentInfo `json:"environment,omitempty"`
	// Services - READ-ONLY; services of this containers.
	Services *[]interface{} `json:"services,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeInstanceContainer.
func (cic ComputeInstanceContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cic.Name != nil {
		objectMap["name"] = cic.Name
	}
	if cic.Autosave != "" {
		objectMap["autosave"] = cic.Autosave
	}
	if cic.Gpu != nil {
		objectMap["gpu"] = cic.Gpu
	}
	if cic.Network != "" {
		objectMap["network"] = cic.Network
	}
	if cic.Environment != nil {
		objectMap["environment"] = cic.Environment
	}
	return json.Marshal(objectMap)
}

// ComputeInstanceCreatedBy describes information on user who created this ComputeInstance.
type ComputeInstanceCreatedBy struct {
	// UserName - READ-ONLY; Name of the user.
	UserName *string `json:"userName,omitempty"`
	// UserOrgID - READ-ONLY; Uniquely identifies user' Azure Active Directory organization.
	UserOrgID *string `json:"userOrgId,omitempty"`
	// UserID - READ-ONLY; Uniquely identifies the user within his/her organization.
	UserID *string `json:"userId,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeInstanceCreatedBy.
func (cicb ComputeInstanceCreatedBy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ComputeInstanceDataDisk defines an Aml Instance DataDisk.
type ComputeInstanceDataDisk struct {
	// Caching - Caching type of Data Disk. Possible values include: 'CachingNone', 'CachingReadOnly', 'CachingReadWrite'
	Caching Caching `json:"caching,omitempty"`
	// DiskSizeGB - The initial disk size in gigabytes.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
	// Lun - The lun is used to uniquely identify each data disk. If attaching multiple disks, each should have a distinct lun.
	Lun *int32 `json:"lun,omitempty"`
	// StorageAccountType - type of this storage account. Possible values include: 'StandardLRS', 'PremiumLRS'
	StorageAccountType StorageAccountType `json:"storageAccountType,omitempty"`
}

// ComputeInstanceDataMount defines an Aml Instance DataMount.
type ComputeInstanceDataMount struct {
	// Source - Source of the ComputeInstance data mount.
	Source *string `json:"source,omitempty"`
	// SourceType - Data source type. Possible values include: 'SourceTypeDataset', 'SourceTypeDatastore', 'SourceTypeURI'
	SourceType SourceType `json:"sourceType,omitempty"`
	// MountName - name of the ComputeInstance data mount.
	MountName *string `json:"mountName,omitempty"`
	// MountAction - Mount Action. Possible values include: 'Mount', 'Unmount'
	MountAction MountAction `json:"mountAction,omitempty"`
	// CreatedBy - who this data mount created by.
	CreatedBy *string `json:"createdBy,omitempty"`
	// MountPath - Path of this data mount.
	MountPath *string `json:"mountPath,omitempty"`
	// MountState - Mount state. Possible values include: 'MountRequested', 'Mounted', 'MountFailed', 'UnmountRequested', 'UnmountFailed', 'Unmounted'
	MountState MountState `json:"mountState,omitempty"`
	// MountedOn - The time when the disk mounted.
	MountedOn *date.Time `json:"mountedOn,omitempty"`
	// Error - Error of this data mount.
	Error *string `json:"error,omitempty"`
}

// ComputeInstanceEnvironmentInfo environment information
type ComputeInstanceEnvironmentInfo struct {
	// Name - name of environment.
	Name *string `json:"name,omitempty"`
	// Version - version of environment.
	Version *string `json:"version,omitempty"`
}

// ComputeInstanceLastOperation the last operation on ComputeInstance.
type ComputeInstanceLastOperation struct {
	// OperationName - Name of the last operation. Possible values include: 'OperationNameCreate', 'OperationNameStart', 'OperationNameStop', 'OperationNameRestart', 'OperationNameReimage', 'OperationNameDelete'
	OperationName OperationName `json:"operationName,omitempty"`
	// OperationTime - Time of the last operation.
	OperationTime *date.Time `json:"operationTime,omitempty"`
	// OperationStatus - Operation status. Possible values include: 'OperationStatusInProgress', 'OperationStatusSucceeded', 'OperationStatusCreateFailed', 'OperationStatusStartFailed', 'OperationStatusStopFailed', 'OperationStatusRestartFailed', 'OperationStatusReimageFailed', 'OperationStatusDeleteFailed'
	OperationStatus OperationStatus `json:"operationStatus,omitempty"`
	// OperationTrigger - Trigger of operation. Possible values include: 'User', 'Schedule', 'IdleShutdown'
	OperationTrigger OperationTrigger `json:"operationTrigger,omitempty"`
}

// ComputeInstanceProperties compute Instance properties
type ComputeInstanceProperties struct {
	// VMSize - Virtual Machine Size
	VMSize *string `json:"vmSize,omitempty"`
	// Subnet - Virtual network subnet resource ID the compute nodes belong to.
	Subnet *ResourceID `json:"subnet,omitempty"`
	// ApplicationSharingPolicy - Policy for sharing applications on this compute instance among users of parent workspace. If Personal, only the creator can access applications on this compute instance. When Shared, any workspace user can access applications on this instance depending on his/her assigned role. Possible values include: 'Personal', 'Shared'
	ApplicationSharingPolicy ApplicationSharingPolicy `json:"applicationSharingPolicy,omitempty"`
	// SSHSettings - Specifies policy and settings for SSH access.
	SSHSettings *ComputeInstanceSSHSettings `json:"sshSettings,omitempty"`
	// ConnectivityEndpoints - READ-ONLY; Describes all connectivity endpoints available for this ComputeInstance.
	ConnectivityEndpoints *ComputeInstanceConnectivityEndpoints `json:"connectivityEndpoints,omitempty"`
	// Applications - READ-ONLY; Describes available applications and their endpoints on this ComputeInstance.
	Applications *[]ComputeInstanceApplication `json:"applications,omitempty"`
	// CreatedBy - READ-ONLY; Describes information on user who created this ComputeInstance.
	CreatedBy *ComputeInstanceCreatedBy `json:"createdBy,omitempty"`
	// Errors - READ-ONLY; Collection of errors encountered on this ComputeInstance.
	Errors *[]ErrorResponse `json:"errors,omitempty"`
	// State - READ-ONLY; The current state of this ComputeInstance. Possible values include: 'Creating', 'CreateFailed', 'Deleting', 'Running', 'Restarting', 'JobRunning', 'SettingUp', 'SetupFailed', 'Starting', 'Stopped', 'Stopping', 'UserSettingUp', 'UserSetupFailed', 'Unknown', 'Unusable'
	State ComputeInstanceState `json:"state,omitempty"`
	// ComputeInstanceAuthorizationType - The Compute Instance Authorization type. Available values are personal (default). Possible values include: 'ComputeInstanceAuthorizationTypePersonal'
	ComputeInstanceAuthorizationType ComputeInstanceAuthorizationType `json:"computeInstanceAuthorizationType,omitempty"`
	// PersonalComputeInstanceSettings - Settings for a personal compute instance.
	PersonalComputeInstanceSettings *PersonalComputeInstanceSettings `json:"personalComputeInstanceSettings,omitempty"`
	// SetupScripts - Details of customized scripts to execute for setting up the cluster.
	SetupScripts *SetupScripts `json:"setupScripts,omitempty"`
	// LastOperation - READ-ONLY; The last operation on ComputeInstance.
	LastOperation *ComputeInstanceLastOperation `json:"lastOperation,omitempty"`
	// Schedules - READ-ONLY; The list of schedules to be applied on the computes.
	Schedules *ComputeSchedules `json:"schedules,omitempty"`
	// EnableNodePublicIP - Enable or disable node public IP address provisioning. Possible values are: Possible values are: true - Indicates that the compute nodes will have public IPs provisioned. false - Indicates that the compute nodes will have a private endpoint and no public IPs.
	EnableNodePublicIP *bool `json:"enableNodePublicIp,omitempty"`
	// Containers - READ-ONLY; Describes informations of containers on this ComputeInstance.
	Containers *[]ComputeInstanceContainer `json:"containers,omitempty"`
	// DataDisks - READ-ONLY; Describes informations of dataDisks on this ComputeInstance.
	DataDisks *[]ComputeInstanceDataDisk `json:"dataDisks,omitempty"`
	// DataMounts - READ-ONLY; Describes informations of dataMounts on this ComputeInstance.
	DataMounts *[]ComputeInstanceDataMount `json:"dataMounts,omitempty"`
	// Versions - READ-ONLY; ComputeInstance version.
	Versions *ComputeInstanceVersion `json:"versions,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeInstanceProperties.
func (cip ComputeInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cip.VMSize != nil {
		objectMap["vmSize"] = cip.VMSize
	}
	if cip.Subnet != nil {
		objectMap["subnet"] = cip.Subnet
	}
	if cip.ApplicationSharingPolicy != "" {
		objectMap["applicationSharingPolicy"] = cip.ApplicationSharingPolicy
	}
	if cip.SSHSettings != nil {
		objectMap["sshSettings"] = cip.SSHSettings
	}
	if cip.ComputeInstanceAuthorizationType != "" {
		objectMap["computeInstanceAuthorizationType"] = cip.ComputeInstanceAuthorizationType
	}
	if cip.PersonalComputeInstanceSettings != nil {
		objectMap["personalComputeInstanceSettings"] = cip.PersonalComputeInstanceSettings
	}
	if cip.SetupScripts != nil {
		objectMap["setupScripts"] = cip.SetupScripts
	}
	if cip.EnableNodePublicIP != nil {
		objectMap["enableNodePublicIp"] = cip.EnableNodePublicIP
	}
	return json.Marshal(objectMap)
}

// ComputeInstanceSchema properties(top level) of ComputeInstance
type ComputeInstanceSchema struct {
	// Properties - Properties of ComputeInstance
	Properties *ComputeInstanceProperties `json:"properties,omitempty"`
}

// ComputeInstanceSSHSettings specifies policy and settings for SSH access.
type ComputeInstanceSSHSettings struct {
	// SSHPublicAccess - State of the public SSH port. Possible values are: Disabled - Indicates that the public ssh port is closed on this instance. Enabled - Indicates that the public ssh port is open and accessible according to the VNet/subnet policy if applicable. Possible values include: 'SSHPublicAccessEnabled', 'SSHPublicAccessDisabled'
	SSHPublicAccess SSHPublicAccess `json:"sshPublicAccess,omitempty"`
	// AdminUserName - READ-ONLY; Describes the admin user name.
	AdminUserName *string `json:"adminUserName,omitempty"`
	// SSHPort - READ-ONLY; Describes the port for connecting through SSH.
	SSHPort *int32 `json:"sshPort,omitempty"`
	// AdminPublicKey - Specifies the SSH rsa public key file as a string. Use "ssh-keygen -t rsa -b 2048" to generate your SSH key pairs.
	AdminPublicKey *string `json:"adminPublicKey,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeInstanceSSHSettings.
func (ciss ComputeInstanceSSHSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ciss.SSHPublicAccess != "" {
		objectMap["sshPublicAccess"] = ciss.SSHPublicAccess
	}
	if ciss.AdminPublicKey != nil {
		objectMap["adminPublicKey"] = ciss.AdminPublicKey
	}
	return json.Marshal(objectMap)
}

// ComputeInstanceVersion version of computeInstance.
type ComputeInstanceVersion struct {
	// Runtime - Runtime of compute instance.
	Runtime *string `json:"runtime,omitempty"`
}

// ComputeResource machine Learning compute object wrapped into ARM resource envelope.
type ComputeResource struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Properties - Compute properties
	Properties BasicCompute `json:"properties,omitempty"`
	// Identity - The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Location - Specifies the location of the resource.
	Location *string `json:"location,omitempty"`
	// Tags - Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags"`
	// Sku - The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeResource.
func (cr ComputeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = cr.Properties
	if cr.Identity != nil {
		objectMap["identity"] = cr.Identity
	}
	if cr.Location != nil {
		objectMap["location"] = cr.Location
	}
	if cr.Tags != nil {
		objectMap["tags"] = cr.Tags
	}
	if cr.Sku != nil {
		objectMap["sku"] = cr.Sku
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ComputeResource struct.
func (cr *ComputeResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				cr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicCompute(*v)
				if err != nil {
					return err
				}
				cr.Properties = properties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				cr.Identity = &identity
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cr.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cr.Tags = tags
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				cr.Sku = &sku
			}
		}
	}

	return nil
}

// ComputeResourceSchema ...
type ComputeResourceSchema struct {
	// Properties - Compute properties
	Properties BasicCompute `json:"properties,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ComputeResourceSchema struct.
func (crs *ComputeResourceSchema) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicCompute(*v)
				if err != nil {
					return err
				}
				crs.Properties = properties
			}
		}
	}

	return nil
}

// ComputeRestartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ComputeRestartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ComputeClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ComputeRestartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ComputeRestartFuture.Result.
func (future *ComputeRestartFuture) result(client ComputeClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeRestartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.ComputeRestartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ComputeSchedules the list of schedules to be applied on the computes
type ComputeSchedules struct {
	// ComputeStartStop - The list of compute start stop schedules to be applied.
	ComputeStartStop *[]ComputeStartStopSchedule `json:"computeStartStop,omitempty"`
}

// BasicComputeSecrets secrets related to a Machine Learning compute. Might differ for every type of compute.
type BasicComputeSecrets interface {
	AsComputeSecrets() (*ComputeSecrets, bool)
}

// ComputeSecrets secrets related to a Machine Learning compute. Might differ for every type of compute.
type ComputeSecrets struct {
	autorest.Response `json:"-"`
	// ComputeType - Possible values include: 'ComputeTypeComputeSecrets'
	ComputeType ComputeTypeBasicComputeSecrets `json:"computeType,omitempty"`
}

func unmarshalBasicComputeSecrets(body []byte) (BasicComputeSecrets, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["computeType"] {
	default:
		var cs ComputeSecrets
		err := json.Unmarshal(body, &cs)
		return cs, err
	}
}
func unmarshalBasicComputeSecretsArray(body []byte) ([]BasicComputeSecrets, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	csArray := make([]BasicComputeSecrets, len(rawMessages))

	for index, rawMessage := range rawMessages {
		cs, err := unmarshalBasicComputeSecrets(*rawMessage)
		if err != nil {
			return nil, err
		}
		csArray[index] = cs
	}
	return csArray, nil
}

// MarshalJSON is the custom marshaler for ComputeSecrets.
func (cs ComputeSecrets) MarshalJSON() ([]byte, error) {
	cs.ComputeType = ComputeTypeComputeSecrets
	objectMap := make(map[string]interface{})
	if cs.ComputeType != "" {
		objectMap["computeType"] = cs.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsComputeSecrets is the BasicComputeSecrets implementation for ComputeSecrets.
func (cs ComputeSecrets) AsComputeSecrets() (*ComputeSecrets, bool) {
	return &cs, true
}

// AsBasicComputeSecrets is the BasicComputeSecrets implementation for ComputeSecrets.
func (cs ComputeSecrets) AsBasicComputeSecrets() (BasicComputeSecrets, bool) {
	return &cs, true
}

// ComputeSecretsModel ...
type ComputeSecretsModel struct {
	autorest.Response `json:"-"`
	Value             BasicComputeSecrets `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for ComputeSecretsModel struct.
func (csm *ComputeSecretsModel) UnmarshalJSON(body []byte) error {
	cs, err := unmarshalBasicComputeSecrets(body)
	if err != nil {
		return err
	}
	csm.Value = cs

	return nil
}

// ComputeStartFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ComputeStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ComputeClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ComputeStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ComputeStartFuture.Result.
func (future *ComputeStartFuture) result(client ComputeClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.ComputeStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ComputeStartStopSchedule compute start stop schedule properties
type ComputeStartStopSchedule struct {
	// ID - READ-ONLY; Schedule id.
	ID *string `json:"id,omitempty"`
	// ProvisioningStatus - READ-ONLY; The current deployment state of schedule. Possible values include: 'Completed', 'Provisioning', 'Failed'
	ProvisioningStatus ProvisioningStatus `json:"provisioningStatus,omitempty"`
	// Action - Possible values include: 'Start', 'Stop'
	Action   ComputePowerAction `json:"action,omitempty"`
	Schedule *ScheduleBase      `json:"schedule,omitempty"`
}

// MarshalJSON is the custom marshaler for ComputeStartStopSchedule.
func (csss ComputeStartStopSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if csss.Action != "" {
		objectMap["action"] = csss.Action
	}
	if csss.Schedule != nil {
		objectMap["schedule"] = csss.Schedule
	}
	return json.Marshal(objectMap)
}

// ComputeStopFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ComputeStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ComputeClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ComputeStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ComputeStopFuture.Result.
func (future *ComputeStopFuture) result(client ComputeClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.ComputeStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ComputeUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ComputeUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ComputeClient) (ComputeResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ComputeUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ComputeUpdateFuture.Result.
func (future *ComputeUpdateFuture) result(client ComputeClient) (cr ComputeResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.ComputeUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cr.Response.Response, err = future.GetResult(sender); err == nil && cr.Response.Response.StatusCode != http.StatusNoContent {
		cr, err = client.UpdateResponder(cr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.ComputeUpdateFuture", "Result", cr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ContainerResourceRequirements resource requirements for each container instance within an online
// deployment.
type ContainerResourceRequirements struct {
	// ContainerResourceLimits - Container resource limit info:
	ContainerResourceLimits *ContainerResourceSettings `json:"containerResourceLimits,omitempty"`
	// ContainerResourceRequests - Container resource request info:
	ContainerResourceRequests *ContainerResourceSettings `json:"containerResourceRequests,omitempty"`
}

// ContainerResourceSettings ...
type ContainerResourceSettings struct {
	// CPU - Number of vCPUs request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	CPU *string `json:"cpu,omitempty"`
	// Gpu - Number of Nvidia GPU cards request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Gpu *string `json:"gpu,omitempty"`
	// Memory - Memory size request/limit for container. More info:
	// https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
	Memory *string `json:"memory,omitempty"`
}

// CosmosDbSettings ...
type CosmosDbSettings struct {
	// CollectionsThroughput - The throughput of the collections in cosmosdb database
	CollectionsThroughput *int32 `json:"collectionsThroughput,omitempty"`
}

// CustomModelJobInput ...
type CustomModelJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - [Required] Specifies the type of job. Possible values include: 'JobInputTypeLiteral', 'JobInputTypeURIFile', 'JobInputTypeURIFolder', 'JobInputTypeMltable', 'JobInputTypeCustomModel', 'JobInputTypeMlflowModel', 'JobInputTypeTritonModel'
	JobInputType JobInputType `json:"jobInputType,omitempty"`
}

// CustomModelJobOutput ...
type CustomModelJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - [Required] Specifies the type of job. Possible values include: 'JobOutputTypeURIFile', 'JobOutputTypeURIFolder', 'JobOutputTypeMltable', 'JobOutputTypeCustomModel', 'JobOutputTypeMlflowModel', 'JobOutputTypeTritonModel'
	JobOutputType JobOutputType `json:"jobOutputType,omitempty"`
}

// Databricks a DataFactory compute.
type Databricks struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                 `json:"disableLocalAuth,omitempty"`
	Properties       *DatabricksProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Databricks.
func (d Databricks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ComputeType != "" {
		objectMap["computeType"] = d.ComputeType
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.ResourceID != nil {
		objectMap["resourceId"] = d.ResourceID
	}
	if d.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = d.DisableLocalAuth
	}
	if d.Properties != nil {
		objectMap["properties"] = d.Properties
	}
	return json.Marshal(objectMap)
}

// DatabricksComputeSecrets secrets related to a Machine Learning compute based on Databricks.
type DatabricksComputeSecrets struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// DatabricksAccessToken - access token for databricks account.
	DatabricksAccessToken *string `json:"databricksAccessToken,omitempty"`
}

// DatabricksComputeSecretsProperties properties of Databricks Compute Secrets
type DatabricksComputeSecretsProperties struct {
	// DatabricksAccessToken - access token for databricks account.
	DatabricksAccessToken *string `json:"databricksAccessToken,omitempty"`
}

// DatabricksProperties properties of Databricks
type DatabricksProperties struct {
	// DatabricksAccessToken - Databricks access token
	DatabricksAccessToken *string `json:"databricksAccessToken,omitempty"`
	// WorkspaceURL - Workspace Url
	WorkspaceURL *string `json:"workspaceUrl,omitempty"`
}

// DatabricksSchema ...
type DatabricksSchema struct {
	Properties *DatabricksProperties `json:"properties,omitempty"`
}

// DataContainer container for data asset versions.
type DataContainer struct {
	// DataType - [Required] Specifies the type of data. Possible values include: 'URIFile', 'URIFolder', 'Mltable'
	DataType DataType `json:"dataType,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// LatestVersion - READ-ONLY; The latest version inside this container.
	LatestVersion *string `json:"latestVersion,omitempty"`
	// NextVersion - READ-ONLY; The next auto incremental version
	NextVersion *string `json:"nextVersion,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for DataContainer.
func (dc DataContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dc.DataType != "" {
		objectMap["dataType"] = dc.DataType
	}
	if dc.IsArchived != nil {
		objectMap["isArchived"] = dc.IsArchived
	}
	if dc.Description != nil {
		objectMap["description"] = dc.Description
	}
	if dc.Properties != nil {
		objectMap["properties"] = dc.Properties
	}
	if dc.Tags != nil {
		objectMap["tags"] = dc.Tags
	}
	return json.Marshal(objectMap)
}

// DataContainerResource azure Resource Manager resource envelope.
type DataContainerResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *DataContainer `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for DataContainerResource.
func (dcr DataContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcr.Properties != nil {
		objectMap["properties"] = dcr.Properties
	}
	return json.Marshal(objectMap)
}

// DataContainerResourceArmPaginatedResult a paginated list of DataContainer entities.
type DataContainerResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of DataContainer objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type DataContainer.
	Value *[]DataContainerResource `json:"value,omitempty"`
}

// DataContainerResourceArmPaginatedResultIterator provides access to a complete listing of
// DataContainerResource values.
type DataContainerResourceArmPaginatedResultIterator struct {
	i    int
	page DataContainerResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataContainerResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataContainerResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataContainerResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataContainerResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataContainerResourceArmPaginatedResultIterator) Response() DataContainerResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataContainerResourceArmPaginatedResultIterator) Value() DataContainerResource {
	if !iter.page.NotDone() {
		return DataContainerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataContainerResourceArmPaginatedResultIterator type.
func NewDataContainerResourceArmPaginatedResultIterator(page DataContainerResourceArmPaginatedResultPage) DataContainerResourceArmPaginatedResultIterator {
	return DataContainerResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dcrapr DataContainerResourceArmPaginatedResult) IsEmpty() bool {
	return dcrapr.Value == nil || len(*dcrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dcrapr DataContainerResourceArmPaginatedResult) hasNextLink() bool {
	return dcrapr.NextLink != nil && len(*dcrapr.NextLink) != 0
}

// dataContainerResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dcrapr DataContainerResourceArmPaginatedResult) dataContainerResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !dcrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dcrapr.NextLink)))
}

// DataContainerResourceArmPaginatedResultPage contains a page of DataContainerResource values.
type DataContainerResourceArmPaginatedResultPage struct {
	fn     func(context.Context, DataContainerResourceArmPaginatedResult) (DataContainerResourceArmPaginatedResult, error)
	dcrapr DataContainerResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataContainerResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataContainerResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dcrapr)
		if err != nil {
			return err
		}
		page.dcrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataContainerResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataContainerResourceArmPaginatedResultPage) NotDone() bool {
	return !page.dcrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataContainerResourceArmPaginatedResultPage) Response() DataContainerResourceArmPaginatedResult {
	return page.dcrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataContainerResourceArmPaginatedResultPage) Values() []DataContainerResource {
	if page.dcrapr.IsEmpty() {
		return nil
	}
	return *page.dcrapr.Value
}

// Creates a new instance of the DataContainerResourceArmPaginatedResultPage type.
func NewDataContainerResourceArmPaginatedResultPage(cur DataContainerResourceArmPaginatedResult, getNextPage func(context.Context, DataContainerResourceArmPaginatedResult) (DataContainerResourceArmPaginatedResult, error)) DataContainerResourceArmPaginatedResultPage {
	return DataContainerResourceArmPaginatedResultPage{
		fn:     getNextPage,
		dcrapr: cur,
	}
}

// DataFactory a DataFactory compute.
type DataFactory struct {
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeCompute', 'ComputeTypeDataFactory1', 'ComputeTypeSynapseSpark1'
	ComputeType ComputeTypeBasicCompute `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for DataFactory.
func (df DataFactory) MarshalJSON() ([]byte, error) {
	df.ComputeType = ComputeTypeDataFactory1
	objectMap := make(map[string]interface{})
	if df.Description != nil {
		objectMap["description"] = df.Description
	}
	if df.ResourceID != nil {
		objectMap["resourceId"] = df.ResourceID
	}
	if df.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = df.DisableLocalAuth
	}
	if df.ComputeType != "" {
		objectMap["computeType"] = df.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsDataFactory is the BasicCompute implementation for DataFactory.
func (df DataFactory) AsDataFactory() (*DataFactory, bool) {
	return &df, true
}

// AsSynapseSpark is the BasicCompute implementation for DataFactory.
func (df DataFactory) AsSynapseSpark() (*SynapseSpark, bool) {
	return nil, false
}

// AsCompute is the BasicCompute implementation for DataFactory.
func (df DataFactory) AsCompute() (*Compute, bool) {
	return nil, false
}

// AsBasicCompute is the BasicCompute implementation for DataFactory.
func (df DataFactory) AsBasicCompute() (BasicCompute, bool) {
	return &df, true
}

// DataLakeAnalytics a DataLakeAnalytics compute.
type DataLakeAnalytics struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                        `json:"disableLocalAuth,omitempty"`
	Properties       *DataLakeAnalyticsProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for DataLakeAnalytics.
func (dla DataLakeAnalytics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dla.ComputeType != "" {
		objectMap["computeType"] = dla.ComputeType
	}
	if dla.Description != nil {
		objectMap["description"] = dla.Description
	}
	if dla.ResourceID != nil {
		objectMap["resourceId"] = dla.ResourceID
	}
	if dla.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = dla.DisableLocalAuth
	}
	if dla.Properties != nil {
		objectMap["properties"] = dla.Properties
	}
	return json.Marshal(objectMap)
}

// DataLakeAnalyticsProperties ...
type DataLakeAnalyticsProperties struct {
	// DataLakeStoreAccountName - DataLake Store Account Name
	DataLakeStoreAccountName *string `json:"dataLakeStoreAccountName,omitempty"`
}

// DataLakeAnalyticsSchema ...
type DataLakeAnalyticsSchema struct {
	Properties *DataLakeAnalyticsProperties `json:"properties,omitempty"`
}

// DataPathAssetReference reference to an asset via its path in a datastore.
type DataPathAssetReference struct {
	// DatastoreID - ARM resource ID of the datastore where the asset is located.
	DatastoreID *string `json:"datastoreId,omitempty"`
	// Path - The path of the file/directory in the datastore.
	Path *string `json:"path,omitempty"`
	// ReferenceType - Possible values include: 'ReferenceTypeAssetReferenceBase', 'ReferenceTypeDataPath', 'ReferenceTypeID', 'ReferenceTypeOutputPath'
	ReferenceType ReferenceTypeBasicAssetReferenceBase `json:"referenceType,omitempty"`
}

// MarshalJSON is the custom marshaler for DataPathAssetReference.
func (dpar DataPathAssetReference) MarshalJSON() ([]byte, error) {
	dpar.ReferenceType = ReferenceTypeDataPath
	objectMap := make(map[string]interface{})
	if dpar.DatastoreID != nil {
		objectMap["datastoreId"] = dpar.DatastoreID
	}
	if dpar.Path != nil {
		objectMap["path"] = dpar.Path
	}
	if dpar.ReferenceType != "" {
		objectMap["referenceType"] = dpar.ReferenceType
	}
	return json.Marshal(objectMap)
}

// AsDataPathAssetReference is the BasicAssetReferenceBase implementation for DataPathAssetReference.
func (dpar DataPathAssetReference) AsDataPathAssetReference() (*DataPathAssetReference, bool) {
	return &dpar, true
}

// AsIDAssetReference is the BasicAssetReferenceBase implementation for DataPathAssetReference.
func (dpar DataPathAssetReference) AsIDAssetReference() (*IDAssetReference, bool) {
	return nil, false
}

// AsOutputPathAssetReference is the BasicAssetReferenceBase implementation for DataPathAssetReference.
func (dpar DataPathAssetReference) AsOutputPathAssetReference() (*OutputPathAssetReference, bool) {
	return nil, false
}

// AsAssetReferenceBase is the BasicAssetReferenceBase implementation for DataPathAssetReference.
func (dpar DataPathAssetReference) AsAssetReferenceBase() (*AssetReferenceBase, bool) {
	return nil, false
}

// AsBasicAssetReferenceBase is the BasicAssetReferenceBase implementation for DataPathAssetReference.
func (dpar DataPathAssetReference) AsBasicAssetReferenceBase() (BasicAssetReferenceBase, bool) {
	return &dpar, true
}

// BasicDatastore base definition for datastore contents configuration.
type BasicDatastore interface {
	AsAzureBlobDatastore() (*AzureBlobDatastore, bool)
	AsAzureDataLakeGen1Datastore() (*AzureDataLakeGen1Datastore, bool)
	AsAzureDataLakeGen2Datastore() (*AzureDataLakeGen2Datastore, bool)
	AsAzureFileDatastore() (*AzureFileDatastore, bool)
	AsDatastore() (*Datastore, bool)
}

// Datastore base definition for datastore contents configuration.
type Datastore struct {
	// Credentials - [Required] Account credentials.
	Credentials BasicDatastoreCredentials `json:"credentials,omitempty"`
	// IsDefault - READ-ONLY; Readonly property to indicate if datastore is the workspace default datastore
	IsDefault *bool `json:"isDefault,omitempty"`
	// DatastoreType - Possible values include: 'DatastoreTypeDatastore', 'DatastoreTypeAzureBlob', 'DatastoreTypeAzureDataLakeGen1', 'DatastoreTypeAzureDataLakeGen2', 'DatastoreTypeAzureFile'
	DatastoreType DatastoreTypeBasicDatastore `json:"datastoreType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

func unmarshalBasicDatastore(body []byte) (BasicDatastore, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["datastoreType"] {
	case string(DatastoreTypeAzureBlob):
		var abd AzureBlobDatastore
		err := json.Unmarshal(body, &abd)
		return abd, err
	case string(DatastoreTypeAzureDataLakeGen1):
		var adlg1d AzureDataLakeGen1Datastore
		err := json.Unmarshal(body, &adlg1d)
		return adlg1d, err
	case string(DatastoreTypeAzureDataLakeGen2):
		var adlg2d AzureDataLakeGen2Datastore
		err := json.Unmarshal(body, &adlg2d)
		return adlg2d, err
	case string(DatastoreTypeAzureFile):
		var afd AzureFileDatastore
		err := json.Unmarshal(body, &afd)
		return afd, err
	default:
		var d Datastore
		err := json.Unmarshal(body, &d)
		return d, err
	}
}
func unmarshalBasicDatastoreArray(body []byte) ([]BasicDatastore, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dArray := make([]BasicDatastore, len(rawMessages))

	for index, rawMessage := range rawMessages {
		d, err := unmarshalBasicDatastore(*rawMessage)
		if err != nil {
			return nil, err
		}
		dArray[index] = d
	}
	return dArray, nil
}

// MarshalJSON is the custom marshaler for Datastore.
func (d Datastore) MarshalJSON() ([]byte, error) {
	d.DatastoreType = DatastoreTypeDatastore
	objectMap := make(map[string]interface{})
	objectMap["credentials"] = d.Credentials
	if d.DatastoreType != "" {
		objectMap["datastoreType"] = d.DatastoreType
	}
	if d.Description != nil {
		objectMap["description"] = d.Description
	}
	if d.Properties != nil {
		objectMap["properties"] = d.Properties
	}
	if d.Tags != nil {
		objectMap["tags"] = d.Tags
	}
	return json.Marshal(objectMap)
}

// AsAzureBlobDatastore is the BasicDatastore implementation for Datastore.
func (d Datastore) AsAzureBlobDatastore() (*AzureBlobDatastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen1Datastore is the BasicDatastore implementation for Datastore.
func (d Datastore) AsAzureDataLakeGen1Datastore() (*AzureDataLakeGen1Datastore, bool) {
	return nil, false
}

// AsAzureDataLakeGen2Datastore is the BasicDatastore implementation for Datastore.
func (d Datastore) AsAzureDataLakeGen2Datastore() (*AzureDataLakeGen2Datastore, bool) {
	return nil, false
}

// AsAzureFileDatastore is the BasicDatastore implementation for Datastore.
func (d Datastore) AsAzureFileDatastore() (*AzureFileDatastore, bool) {
	return nil, false
}

// AsDatastore is the BasicDatastore implementation for Datastore.
func (d Datastore) AsDatastore() (*Datastore, bool) {
	return &d, true
}

// AsBasicDatastore is the BasicDatastore implementation for Datastore.
func (d Datastore) AsBasicDatastore() (BasicDatastore, bool) {
	return &d, true
}

// UnmarshalJSON is the custom unmarshaler for Datastore struct.
func (d *Datastore) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "credentials":
			if v != nil {
				credentials, err := unmarshalBasicDatastoreCredentials(*v)
				if err != nil {
					return err
				}
				d.Credentials = credentials
			}
		case "isDefault":
			if v != nil {
				var isDefault bool
				err = json.Unmarshal(*v, &isDefault)
				if err != nil {
					return err
				}
				d.IsDefault = &isDefault
			}
		case "datastoreType":
			if v != nil {
				var datastoreType DatastoreTypeBasicDatastore
				err = json.Unmarshal(*v, &datastoreType)
				if err != nil {
					return err
				}
				d.DatastoreType = datastoreType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				d.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				d.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				d.Tags = tags
			}
		}
	}

	return nil
}

// BasicDatastoreCredentials base definition for datastore credentials.
type BasicDatastoreCredentials interface {
	AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool)
	AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool)
	AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool)
	AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool)
	AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool)
	AsDatastoreCredentials() (*DatastoreCredentials, bool)
}

// DatastoreCredentials base definition for datastore credentials.
type DatastoreCredentials struct {
	// CredentialsType - Possible values include: 'CredentialsTypeDatastoreCredentials', 'CredentialsTypeAccountKey1', 'CredentialsTypeCertificate1', 'CredentialsTypeNone1', 'CredentialsTypeSas1', 'CredentialsTypeServicePrincipal1'
	CredentialsType CredentialsTypeBasicDatastoreCredentials `json:"credentialsType,omitempty"`
}

func unmarshalBasicDatastoreCredentials(body []byte) (BasicDatastoreCredentials, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["credentialsType"] {
	case string(CredentialsTypeAccountKey1):
		var akdc AccountKeyDatastoreCredentials
		err := json.Unmarshal(body, &akdc)
		return akdc, err
	case string(CredentialsTypeCertificate1):
		var cdc CertificateDatastoreCredentials
		err := json.Unmarshal(body, &cdc)
		return cdc, err
	case string(CredentialsTypeNone1):
		var ndc NoneDatastoreCredentials
		err := json.Unmarshal(body, &ndc)
		return ndc, err
	case string(CredentialsTypeSas1):
		var sdc SasDatastoreCredentials
		err := json.Unmarshal(body, &sdc)
		return sdc, err
	case string(CredentialsTypeServicePrincipal1):
		var spdc ServicePrincipalDatastoreCredentials
		err := json.Unmarshal(body, &spdc)
		return spdc, err
	default:
		var dc DatastoreCredentials
		err := json.Unmarshal(body, &dc)
		return dc, err
	}
}
func unmarshalBasicDatastoreCredentialsArray(body []byte) ([]BasicDatastoreCredentials, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dcArray := make([]BasicDatastoreCredentials, len(rawMessages))

	for index, rawMessage := range rawMessages {
		dc, err := unmarshalBasicDatastoreCredentials(*rawMessage)
		if err != nil {
			return nil, err
		}
		dcArray[index] = dc
	}
	return dcArray, nil
}

// MarshalJSON is the custom marshaler for DatastoreCredentials.
func (dc DatastoreCredentials) MarshalJSON() ([]byte, error) {
	dc.CredentialsType = CredentialsTypeDatastoreCredentials
	objectMap := make(map[string]interface{})
	if dc.CredentialsType != "" {
		objectMap["credentialsType"] = dc.CredentialsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool) {
	return nil, false
}

// AsCertificateDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool) {
	return nil, false
}

// AsNoneDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool) {
	return nil, false
}

// AsSasDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool) {
	return nil, false
}

// AsDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsDatastoreCredentials() (*DatastoreCredentials, bool) {
	return &dc, true
}

// AsBasicDatastoreCredentials is the BasicDatastoreCredentials implementation for DatastoreCredentials.
func (dc DatastoreCredentials) AsBasicDatastoreCredentials() (BasicDatastoreCredentials, bool) {
	return &dc, true
}

// DatastoreResource azure Resource Manager resource envelope.
type DatastoreResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties BasicDatastore `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for DatastoreResource.
func (dr DatastoreResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = dr.Properties
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DatastoreResource struct.
func (dr *DatastoreResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicDatastore(*v)
				if err != nil {
					return err
				}
				dr.Properties = properties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dr.SystemData = &systemData
			}
		}
	}

	return nil
}

// DatastoreResourceArmPaginatedResult a paginated list of Datastore entities.
type DatastoreResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of Datastore objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type Datastore.
	Value *[]DatastoreResource `json:"value,omitempty"`
}

// DatastoreResourceArmPaginatedResultIterator provides access to a complete listing of DatastoreResource
// values.
type DatastoreResourceArmPaginatedResultIterator struct {
	i    int
	page DatastoreResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DatastoreResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DatastoreResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DatastoreResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DatastoreResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DatastoreResourceArmPaginatedResultIterator) Response() DatastoreResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DatastoreResourceArmPaginatedResultIterator) Value() DatastoreResource {
	if !iter.page.NotDone() {
		return DatastoreResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DatastoreResourceArmPaginatedResultIterator type.
func NewDatastoreResourceArmPaginatedResultIterator(page DatastoreResourceArmPaginatedResultPage) DatastoreResourceArmPaginatedResultIterator {
	return DatastoreResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (drapr DatastoreResourceArmPaginatedResult) IsEmpty() bool {
	return drapr.Value == nil || len(*drapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (drapr DatastoreResourceArmPaginatedResult) hasNextLink() bool {
	return drapr.NextLink != nil && len(*drapr.NextLink) != 0
}

// datastoreResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (drapr DatastoreResourceArmPaginatedResult) datastoreResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !drapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(drapr.NextLink)))
}

// DatastoreResourceArmPaginatedResultPage contains a page of DatastoreResource values.
type DatastoreResourceArmPaginatedResultPage struct {
	fn    func(context.Context, DatastoreResourceArmPaginatedResult) (DatastoreResourceArmPaginatedResult, error)
	drapr DatastoreResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DatastoreResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DatastoreResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.drapr)
		if err != nil {
			return err
		}
		page.drapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DatastoreResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DatastoreResourceArmPaginatedResultPage) NotDone() bool {
	return !page.drapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DatastoreResourceArmPaginatedResultPage) Response() DatastoreResourceArmPaginatedResult {
	return page.drapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DatastoreResourceArmPaginatedResultPage) Values() []DatastoreResource {
	if page.drapr.IsEmpty() {
		return nil
	}
	return *page.drapr.Value
}

// Creates a new instance of the DatastoreResourceArmPaginatedResultPage type.
func NewDatastoreResourceArmPaginatedResultPage(cur DatastoreResourceArmPaginatedResult, getNextPage func(context.Context, DatastoreResourceArmPaginatedResult) (DatastoreResourceArmPaginatedResult, error)) DatastoreResourceArmPaginatedResultPage {
	return DatastoreResourceArmPaginatedResultPage{
		fn:    getNextPage,
		drapr: cur,
	}
}

// BasicDatastoreSecrets base definition for datastore secrets.
type BasicDatastoreSecrets interface {
	AsAccountKeyDatastoreSecrets() (*AccountKeyDatastoreSecrets, bool)
	AsCertificateDatastoreSecrets() (*CertificateDatastoreSecrets, bool)
	AsSasDatastoreSecrets() (*SasDatastoreSecrets, bool)
	AsServicePrincipalDatastoreSecrets() (*ServicePrincipalDatastoreSecrets, bool)
	AsDatastoreSecrets() (*DatastoreSecrets, bool)
}

// DatastoreSecrets base definition for datastore secrets.
type DatastoreSecrets struct {
	autorest.Response `json:"-"`
	// SecretsType - Possible values include: 'SecretsTypeDatastoreSecrets', 'SecretsTypeAccountKey', 'SecretsTypeCertificate', 'SecretsTypeSas', 'SecretsTypeServicePrincipal'
	SecretsType SecretsTypeBasicDatastoreSecrets `json:"secretsType,omitempty"`
}

func unmarshalBasicDatastoreSecrets(body []byte) (BasicDatastoreSecrets, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["secretsType"] {
	case string(SecretsTypeAccountKey):
		var akds AccountKeyDatastoreSecrets
		err := json.Unmarshal(body, &akds)
		return akds, err
	case string(SecretsTypeCertificate):
		var cds CertificateDatastoreSecrets
		err := json.Unmarshal(body, &cds)
		return cds, err
	case string(SecretsTypeSas):
		var sds SasDatastoreSecrets
		err := json.Unmarshal(body, &sds)
		return sds, err
	case string(SecretsTypeServicePrincipal):
		var spds ServicePrincipalDatastoreSecrets
		err := json.Unmarshal(body, &spds)
		return spds, err
	default:
		var ds DatastoreSecrets
		err := json.Unmarshal(body, &ds)
		return ds, err
	}
}
func unmarshalBasicDatastoreSecretsArray(body []byte) ([]BasicDatastoreSecrets, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dsArray := make([]BasicDatastoreSecrets, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ds, err := unmarshalBasicDatastoreSecrets(*rawMessage)
		if err != nil {
			return nil, err
		}
		dsArray[index] = ds
	}
	return dsArray, nil
}

// MarshalJSON is the custom marshaler for DatastoreSecrets.
func (ds DatastoreSecrets) MarshalJSON() ([]byte, error) {
	ds.SecretsType = SecretsTypeDatastoreSecrets
	objectMap := make(map[string]interface{})
	if ds.SecretsType != "" {
		objectMap["secretsType"] = ds.SecretsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreSecrets is the BasicDatastoreSecrets implementation for DatastoreSecrets.
func (ds DatastoreSecrets) AsAccountKeyDatastoreSecrets() (*AccountKeyDatastoreSecrets, bool) {
	return nil, false
}

// AsCertificateDatastoreSecrets is the BasicDatastoreSecrets implementation for DatastoreSecrets.
func (ds DatastoreSecrets) AsCertificateDatastoreSecrets() (*CertificateDatastoreSecrets, bool) {
	return nil, false
}

// AsSasDatastoreSecrets is the BasicDatastoreSecrets implementation for DatastoreSecrets.
func (ds DatastoreSecrets) AsSasDatastoreSecrets() (*SasDatastoreSecrets, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreSecrets is the BasicDatastoreSecrets implementation for DatastoreSecrets.
func (ds DatastoreSecrets) AsServicePrincipalDatastoreSecrets() (*ServicePrincipalDatastoreSecrets, bool) {
	return nil, false
}

// AsDatastoreSecrets is the BasicDatastoreSecrets implementation for DatastoreSecrets.
func (ds DatastoreSecrets) AsDatastoreSecrets() (*DatastoreSecrets, bool) {
	return &ds, true
}

// AsBasicDatastoreSecrets is the BasicDatastoreSecrets implementation for DatastoreSecrets.
func (ds DatastoreSecrets) AsBasicDatastoreSecrets() (BasicDatastoreSecrets, bool) {
	return &ds, true
}

// DatastoreSecretsModel ...
type DatastoreSecretsModel struct {
	autorest.Response `json:"-"`
	Value             BasicDatastoreSecrets `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for DatastoreSecretsModel struct.
func (dsm *DatastoreSecretsModel) UnmarshalJSON(body []byte) error {
	ds, err := unmarshalBasicDatastoreSecrets(body)
	if err != nil {
		return err
	}
	dsm.Value = ds

	return nil
}

// BasicDataVersionBase data version base definition
type BasicDataVersionBase interface {
	AsMLTableData() (*MLTableData, bool)
	AsURIFileDataVersion() (*URIFileDataVersion, bool)
	AsURIFolderDataVersion() (*URIFolderDataVersion, bool)
	AsDataVersionBase() (*DataVersionBase, bool)
}

// DataVersionBase data version base definition
type DataVersionBase struct {
	// DataURI - [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220501.Assets.DataVersionBase.DataType
	DataURI *string `json:"dataUri,omitempty"`
	// DataType - Possible values include: 'DataTypeDataVersionBase', 'DataTypeMltable', 'DataTypeURIFile', 'DataTypeURIFolder'
	DataType DataTypeBasicDataVersionBase `json:"dataType,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

func unmarshalBasicDataVersionBase(body []byte) (BasicDataVersionBase, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["dataType"] {
	case string(DataTypeMltable):
		var mtd MLTableData
		err := json.Unmarshal(body, &mtd)
		return mtd, err
	case string(DataTypeURIFile):
		var ufdv URIFileDataVersion
		err := json.Unmarshal(body, &ufdv)
		return ufdv, err
	case string(DataTypeURIFolder):
		var ufdv URIFolderDataVersion
		err := json.Unmarshal(body, &ufdv)
		return ufdv, err
	default:
		var dvb DataVersionBase
		err := json.Unmarshal(body, &dvb)
		return dvb, err
	}
}
func unmarshalBasicDataVersionBaseArray(body []byte) ([]BasicDataVersionBase, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dvbArray := make([]BasicDataVersionBase, len(rawMessages))

	for index, rawMessage := range rawMessages {
		dvb, err := unmarshalBasicDataVersionBase(*rawMessage)
		if err != nil {
			return nil, err
		}
		dvbArray[index] = dvb
	}
	return dvbArray, nil
}

// MarshalJSON is the custom marshaler for DataVersionBase.
func (dvb DataVersionBase) MarshalJSON() ([]byte, error) {
	dvb.DataType = DataTypeDataVersionBase
	objectMap := make(map[string]interface{})
	if dvb.DataURI != nil {
		objectMap["dataUri"] = dvb.DataURI
	}
	if dvb.DataType != "" {
		objectMap["dataType"] = dvb.DataType
	}
	if dvb.IsAnonymous != nil {
		objectMap["isAnonymous"] = dvb.IsAnonymous
	}
	if dvb.IsArchived != nil {
		objectMap["isArchived"] = dvb.IsArchived
	}
	if dvb.Description != nil {
		objectMap["description"] = dvb.Description
	}
	if dvb.Properties != nil {
		objectMap["properties"] = dvb.Properties
	}
	if dvb.Tags != nil {
		objectMap["tags"] = dvb.Tags
	}
	return json.Marshal(objectMap)
}

// AsMLTableData is the BasicDataVersionBase implementation for DataVersionBase.
func (dvb DataVersionBase) AsMLTableData() (*MLTableData, bool) {
	return nil, false
}

// AsURIFileDataVersion is the BasicDataVersionBase implementation for DataVersionBase.
func (dvb DataVersionBase) AsURIFileDataVersion() (*URIFileDataVersion, bool) {
	return nil, false
}

// AsURIFolderDataVersion is the BasicDataVersionBase implementation for DataVersionBase.
func (dvb DataVersionBase) AsURIFolderDataVersion() (*URIFolderDataVersion, bool) {
	return nil, false
}

// AsDataVersionBase is the BasicDataVersionBase implementation for DataVersionBase.
func (dvb DataVersionBase) AsDataVersionBase() (*DataVersionBase, bool) {
	return &dvb, true
}

// AsBasicDataVersionBase is the BasicDataVersionBase implementation for DataVersionBase.
func (dvb DataVersionBase) AsBasicDataVersionBase() (BasicDataVersionBase, bool) {
	return &dvb, true
}

// DataVersionBaseResource azure Resource Manager resource envelope.
type DataVersionBaseResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties BasicDataVersionBase `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for DataVersionBaseResource.
func (dvbr DataVersionBaseResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = dvbr.Properties
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataVersionBaseResource struct.
func (dvbr *DataVersionBaseResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicDataVersionBase(*v)
				if err != nil {
					return err
				}
				dvbr.Properties = properties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				dvbr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				dvbr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				dvbr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				dvbr.SystemData = &systemData
			}
		}
	}

	return nil
}

// DataVersionBaseResourceArmPaginatedResult a paginated list of DataVersionBase entities.
type DataVersionBaseResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of DataVersionBase objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type DataVersionBase.
	Value *[]DataVersionBaseResource `json:"value,omitempty"`
}

// DataVersionBaseResourceArmPaginatedResultIterator provides access to a complete listing of
// DataVersionBaseResource values.
type DataVersionBaseResourceArmPaginatedResultIterator struct {
	i    int
	page DataVersionBaseResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataVersionBaseResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataVersionBaseResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataVersionBaseResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataVersionBaseResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataVersionBaseResourceArmPaginatedResultIterator) Response() DataVersionBaseResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataVersionBaseResourceArmPaginatedResultIterator) Value() DataVersionBaseResource {
	if !iter.page.NotDone() {
		return DataVersionBaseResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataVersionBaseResourceArmPaginatedResultIterator type.
func NewDataVersionBaseResourceArmPaginatedResultIterator(page DataVersionBaseResourceArmPaginatedResultPage) DataVersionBaseResourceArmPaginatedResultIterator {
	return DataVersionBaseResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dvbrapr DataVersionBaseResourceArmPaginatedResult) IsEmpty() bool {
	return dvbrapr.Value == nil || len(*dvbrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dvbrapr DataVersionBaseResourceArmPaginatedResult) hasNextLink() bool {
	return dvbrapr.NextLink != nil && len(*dvbrapr.NextLink) != 0
}

// dataVersionBaseResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dvbrapr DataVersionBaseResourceArmPaginatedResult) dataVersionBaseResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !dvbrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dvbrapr.NextLink)))
}

// DataVersionBaseResourceArmPaginatedResultPage contains a page of DataVersionBaseResource values.
type DataVersionBaseResourceArmPaginatedResultPage struct {
	fn      func(context.Context, DataVersionBaseResourceArmPaginatedResult) (DataVersionBaseResourceArmPaginatedResult, error)
	dvbrapr DataVersionBaseResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataVersionBaseResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataVersionBaseResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dvbrapr)
		if err != nil {
			return err
		}
		page.dvbrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataVersionBaseResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataVersionBaseResourceArmPaginatedResultPage) NotDone() bool {
	return !page.dvbrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataVersionBaseResourceArmPaginatedResultPage) Response() DataVersionBaseResourceArmPaginatedResult {
	return page.dvbrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataVersionBaseResourceArmPaginatedResultPage) Values() []DataVersionBaseResource {
	if page.dvbrapr.IsEmpty() {
		return nil
	}
	return *page.dvbrapr.Value
}

// Creates a new instance of the DataVersionBaseResourceArmPaginatedResultPage type.
func NewDataVersionBaseResourceArmPaginatedResultPage(cur DataVersionBaseResourceArmPaginatedResult, getNextPage func(context.Context, DataVersionBaseResourceArmPaginatedResult) (DataVersionBaseResourceArmPaginatedResult, error)) DataVersionBaseResourceArmPaginatedResultPage {
	return DataVersionBaseResourceArmPaginatedResultPage{
		fn:      getNextPage,
		dvbrapr: cur,
	}
}

// DefaultScaleSettings ...
type DefaultScaleSettings struct {
	// ScaleType - Possible values include: 'ScaleTypeOnlineScaleSettings', 'ScaleTypeDefault', 'ScaleTypeTargetUtilization'
	ScaleType ScaleTypeBasicOnlineScaleSettings `json:"scaleType,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultScaleSettings.
func (dss DefaultScaleSettings) MarshalJSON() ([]byte, error) {
	dss.ScaleType = ScaleTypeDefault
	objectMap := make(map[string]interface{})
	if dss.ScaleType != "" {
		objectMap["scaleType"] = dss.ScaleType
	}
	return json.Marshal(objectMap)
}

// AsDefaultScaleSettings is the BasicOnlineScaleSettings implementation for DefaultScaleSettings.
func (dss DefaultScaleSettings) AsDefaultScaleSettings() (*DefaultScaleSettings, bool) {
	return &dss, true
}

// AsTargetUtilizationScaleSettings is the BasicOnlineScaleSettings implementation for DefaultScaleSettings.
func (dss DefaultScaleSettings) AsTargetUtilizationScaleSettings() (*TargetUtilizationScaleSettings, bool) {
	return nil, false
}

// AsOnlineScaleSettings is the BasicOnlineScaleSettings implementation for DefaultScaleSettings.
func (dss DefaultScaleSettings) AsOnlineScaleSettings() (*OnlineScaleSettings, bool) {
	return nil, false
}

// AsBasicOnlineScaleSettings is the BasicOnlineScaleSettings implementation for DefaultScaleSettings.
func (dss DefaultScaleSettings) AsBasicOnlineScaleSettings() (BasicOnlineScaleSettings, bool) {
	return &dss, true
}

// DeploymentLogs ...
type DeploymentLogs struct {
	autorest.Response `json:"-"`
	// Content - The retrieved online deployment logs.
	Content *string `json:"content,omitempty"`
}

// DeploymentLogsRequest ...
type DeploymentLogsRequest struct {
	// ContainerType - The type of container to retrieve logs from. Possible values include: 'StorageInitializer', 'InferenceServer'
	ContainerType ContainerType `json:"containerType,omitempty"`
	// Tail - The maximum number of lines to tail.
	Tail *int32 `json:"tail,omitempty"`
}

// DiagnoseRequestProperties ...
type DiagnoseRequestProperties struct {
	// Udr - Setting for diagnosing user defined routing
	Udr map[string]interface{} `json:"udr"`
	// Nsg - Setting for diagnosing network security group
	Nsg map[string]interface{} `json:"nsg"`
	// ResourceLock - Setting for diagnosing resource lock
	ResourceLock map[string]interface{} `json:"resourceLock"`
	// DNSResolution - Setting for diagnosing dns resolution
	DNSResolution map[string]interface{} `json:"dnsResolution"`
	// StorageAccount - Setting for diagnosing dependent storage account
	StorageAccount map[string]interface{} `json:"storageAccount"`
	// KeyVault - Setting for diagnosing dependent key vault
	KeyVault map[string]interface{} `json:"keyVault"`
	// ContainerRegistry - Setting for diagnosing dependent container registry
	ContainerRegistry map[string]interface{} `json:"containerRegistry"`
	// ApplicationInsights - Setting for diagnosing dependent application insights
	ApplicationInsights map[string]interface{} `json:"applicationInsights"`
	// Others - Setting for diagnosing unclassified category of problems
	Others map[string]interface{} `json:"others"`
}

// MarshalJSON is the custom marshaler for DiagnoseRequestProperties.
func (drp DiagnoseRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if drp.Udr != nil {
		objectMap["udr"] = drp.Udr
	}
	if drp.Nsg != nil {
		objectMap["nsg"] = drp.Nsg
	}
	if drp.ResourceLock != nil {
		objectMap["resourceLock"] = drp.ResourceLock
	}
	if drp.DNSResolution != nil {
		objectMap["dnsResolution"] = drp.DNSResolution
	}
	if drp.StorageAccount != nil {
		objectMap["storageAccount"] = drp.StorageAccount
	}
	if drp.KeyVault != nil {
		objectMap["keyVault"] = drp.KeyVault
	}
	if drp.ContainerRegistry != nil {
		objectMap["containerRegistry"] = drp.ContainerRegistry
	}
	if drp.ApplicationInsights != nil {
		objectMap["applicationInsights"] = drp.ApplicationInsights
	}
	if drp.Others != nil {
		objectMap["others"] = drp.Others
	}
	return json.Marshal(objectMap)
}

// DiagnoseResponseResult ...
type DiagnoseResponseResult struct {
	autorest.Response `json:"-"`
	Value             *DiagnoseResponseResultValue `json:"value,omitempty"`
}

// DiagnoseResponseResultValue ...
type DiagnoseResponseResultValue struct {
	UserDefinedRouteResults    *[]DiagnoseResult `json:"userDefinedRouteResults,omitempty"`
	NetworkSecurityRuleResults *[]DiagnoseResult `json:"networkSecurityRuleResults,omitempty"`
	ResourceLockResults        *[]DiagnoseResult `json:"resourceLockResults,omitempty"`
	DNSResolutionResults       *[]DiagnoseResult `json:"dnsResolutionResults,omitempty"`
	StorageAccountResults      *[]DiagnoseResult `json:"storageAccountResults,omitempty"`
	KeyVaultResults            *[]DiagnoseResult `json:"keyVaultResults,omitempty"`
	ContainerRegistryResults   *[]DiagnoseResult `json:"containerRegistryResults,omitempty"`
	ApplicationInsightsResults *[]DiagnoseResult `json:"applicationInsightsResults,omitempty"`
	OtherResults               *[]DiagnoseResult `json:"otherResults,omitempty"`
}

// DiagnoseResult result of Diagnose
type DiagnoseResult struct {
	// Code - READ-ONLY; Code for workspace setup error
	Code *string `json:"code,omitempty"`
	// Level - READ-ONLY; Level of workspace setup error. Possible values include: 'DiagnoseResultLevelWarning', 'DiagnoseResultLevelError', 'DiagnoseResultLevelInformation'
	Level DiagnoseResultLevel `json:"level,omitempty"`
	// Message - READ-ONLY; Message of workspace setup error
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for DiagnoseResult.
func (dr DiagnoseResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DiagnoseWorkspaceParameters parameters to diagnose a workspace
type DiagnoseWorkspaceParameters struct {
	// Value - Value of Parameters
	Value *DiagnoseRequestProperties `json:"value,omitempty"`
}

// BasicDistributionConfiguration base definition for job distribution configuration.
type BasicDistributionConfiguration interface {
	AsMpi() (*Mpi, bool)
	AsPyTorch() (*PyTorch, bool)
	AsTensorFlow() (*TensorFlow, bool)
	AsDistributionConfiguration() (*DistributionConfiguration, bool)
}

// DistributionConfiguration base definition for job distribution configuration.
type DistributionConfiguration struct {
	// DistributionType - Possible values include: 'DistributionTypeDistributionConfiguration', 'DistributionTypeMpi1', 'DistributionTypePyTorch1', 'DistributionTypeTensorFlow1'
	DistributionType DistributionTypeBasicDistributionConfiguration `json:"distributionType,omitempty"`
}

func unmarshalBasicDistributionConfiguration(body []byte) (BasicDistributionConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["distributionType"] {
	case string(DistributionTypeMpi1):
		var mVar Mpi
		err := json.Unmarshal(body, &mVar)
		return mVar, err
	case string(DistributionTypePyTorch1):
		var pt PyTorch
		err := json.Unmarshal(body, &pt)
		return pt, err
	case string(DistributionTypeTensorFlow1):
		var tf TensorFlow
		err := json.Unmarshal(body, &tf)
		return tf, err
	default:
		var dc DistributionConfiguration
		err := json.Unmarshal(body, &dc)
		return dc, err
	}
}
func unmarshalBasicDistributionConfigurationArray(body []byte) ([]BasicDistributionConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	dcArray := make([]BasicDistributionConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		dc, err := unmarshalBasicDistributionConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		dcArray[index] = dc
	}
	return dcArray, nil
}

// MarshalJSON is the custom marshaler for DistributionConfiguration.
func (dc DistributionConfiguration) MarshalJSON() ([]byte, error) {
	dc.DistributionType = DistributionTypeDistributionConfiguration
	objectMap := make(map[string]interface{})
	if dc.DistributionType != "" {
		objectMap["distributionType"] = dc.DistributionType
	}
	return json.Marshal(objectMap)
}

// AsMpi is the BasicDistributionConfiguration implementation for DistributionConfiguration.
func (dc DistributionConfiguration) AsMpi() (*Mpi, bool) {
	return nil, false
}

// AsPyTorch is the BasicDistributionConfiguration implementation for DistributionConfiguration.
func (dc DistributionConfiguration) AsPyTorch() (*PyTorch, bool) {
	return nil, false
}

// AsTensorFlow is the BasicDistributionConfiguration implementation for DistributionConfiguration.
func (dc DistributionConfiguration) AsTensorFlow() (*TensorFlow, bool) {
	return nil, false
}

// AsDistributionConfiguration is the BasicDistributionConfiguration implementation for DistributionConfiguration.
func (dc DistributionConfiguration) AsDistributionConfiguration() (*DistributionConfiguration, bool) {
	return &dc, true
}

// AsBasicDistributionConfiguration is the BasicDistributionConfiguration implementation for DistributionConfiguration.
func (dc DistributionConfiguration) AsBasicDistributionConfiguration() (BasicDistributionConfiguration, bool) {
	return &dc, true
}

// BasicEarlyTerminationPolicy early termination policies enable canceling poor-performing runs before they complete
type BasicEarlyTerminationPolicy interface {
	AsBanditPolicy() (*BanditPolicy, bool)
	AsMedianStoppingPolicy() (*MedianStoppingPolicy, bool)
	AsTruncationSelectionPolicy() (*TruncationSelectionPolicy, bool)
	AsEarlyTerminationPolicy() (*EarlyTerminationPolicy, bool)
}

// EarlyTerminationPolicy early termination policies enable canceling poor-performing runs before they complete
type EarlyTerminationPolicy struct {
	// DelayEvaluation - Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int32 `json:"delayEvaluation,omitempty"`
	// EvaluationInterval - Interval (number of runs) between policy evaluations.
	EvaluationInterval *int32 `json:"evaluationInterval,omitempty"`
	// PolicyType - Possible values include: 'PolicyTypeEarlyTerminationPolicy', 'PolicyTypeBandit', 'PolicyTypeMedianStopping', 'PolicyTypeTruncationSelection'
	PolicyType PolicyType `json:"policyType,omitempty"`
}

func unmarshalBasicEarlyTerminationPolicy(body []byte) (BasicEarlyTerminationPolicy, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["policyType"] {
	case string(PolicyTypeBandit):
		var bp BanditPolicy
		err := json.Unmarshal(body, &bp)
		return bp, err
	case string(PolicyTypeMedianStopping):
		var msp MedianStoppingPolicy
		err := json.Unmarshal(body, &msp)
		return msp, err
	case string(PolicyTypeTruncationSelection):
		var tsp TruncationSelectionPolicy
		err := json.Unmarshal(body, &tsp)
		return tsp, err
	default:
		var etp EarlyTerminationPolicy
		err := json.Unmarshal(body, &etp)
		return etp, err
	}
}
func unmarshalBasicEarlyTerminationPolicyArray(body []byte) ([]BasicEarlyTerminationPolicy, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	etpArray := make([]BasicEarlyTerminationPolicy, len(rawMessages))

	for index, rawMessage := range rawMessages {
		etp, err := unmarshalBasicEarlyTerminationPolicy(*rawMessage)
		if err != nil {
			return nil, err
		}
		etpArray[index] = etp
	}
	return etpArray, nil
}

// MarshalJSON is the custom marshaler for EarlyTerminationPolicy.
func (etp EarlyTerminationPolicy) MarshalJSON() ([]byte, error) {
	etp.PolicyType = PolicyTypeEarlyTerminationPolicy
	objectMap := make(map[string]interface{})
	if etp.DelayEvaluation != nil {
		objectMap["delayEvaluation"] = etp.DelayEvaluation
	}
	if etp.EvaluationInterval != nil {
		objectMap["evaluationInterval"] = etp.EvaluationInterval
	}
	if etp.PolicyType != "" {
		objectMap["policyType"] = etp.PolicyType
	}
	return json.Marshal(objectMap)
}

// AsBanditPolicy is the BasicEarlyTerminationPolicy implementation for EarlyTerminationPolicy.
func (etp EarlyTerminationPolicy) AsBanditPolicy() (*BanditPolicy, bool) {
	return nil, false
}

// AsMedianStoppingPolicy is the BasicEarlyTerminationPolicy implementation for EarlyTerminationPolicy.
func (etp EarlyTerminationPolicy) AsMedianStoppingPolicy() (*MedianStoppingPolicy, bool) {
	return nil, false
}

// AsTruncationSelectionPolicy is the BasicEarlyTerminationPolicy implementation for EarlyTerminationPolicy.
func (etp EarlyTerminationPolicy) AsTruncationSelectionPolicy() (*TruncationSelectionPolicy, bool) {
	return nil, false
}

// AsEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for EarlyTerminationPolicy.
func (etp EarlyTerminationPolicy) AsEarlyTerminationPolicy() (*EarlyTerminationPolicy, bool) {
	return &etp, true
}

// AsBasicEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for EarlyTerminationPolicy.
func (etp EarlyTerminationPolicy) AsBasicEarlyTerminationPolicy() (BasicEarlyTerminationPolicy, bool) {
	return &etp, true
}

// EncryptionKeyVaultProperties ...
type EncryptionKeyVaultProperties struct {
	// KeyVaultArmID - The ArmId of the keyVault where the customer owned encryption key is present.
	KeyVaultArmID *string `json:"keyVaultArmId,omitempty"`
	// KeyIdentifier - Key vault uri to access the encryption key.
	KeyIdentifier *string `json:"keyIdentifier,omitempty"`
	// IdentityClientID - For future use - The client id of the identity which will be used to access key vault.
	IdentityClientID *string `json:"identityClientId,omitempty"`
}

// EncryptionProperty ...
type EncryptionProperty struct {
	// Status - Indicates whether or not the encryption is enabled for the workspace. Possible values include: 'Enabled', 'Disabled'
	Status EncryptionStatus `json:"status,omitempty"`
	// Identity - The identity that will be used to access the key vault for encryption at rest.
	Identity *IdentityForCmk `json:"identity,omitempty"`
	// KeyVaultProperties - Customer Key vault properties.
	KeyVaultProperties *EncryptionKeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

// EndpointAuthKeys keys for endpoint authentication.
type EndpointAuthKeys struct {
	autorest.Response `json:"-"`
	// PrimaryKey - The primary key.
	PrimaryKey *string `json:"primaryKey,omitempty"`
	// SecondaryKey - The secondary key.
	SecondaryKey *string `json:"secondaryKey,omitempty"`
}

// EndpointAuthToken service Token
type EndpointAuthToken struct {
	autorest.Response `json:"-"`
	// AccessToken - Access token for endpoint authentication.
	AccessToken *string `json:"accessToken,omitempty"`
	// ExpiryTimeUtc - Access token expiry time (UTC).
	ExpiryTimeUtc *int64 `json:"expiryTimeUtc,omitempty"`
	// RefreshAfterTimeUtc - Refresh access token after time (UTC).
	RefreshAfterTimeUtc *int64 `json:"refreshAfterTimeUtc,omitempty"`
	// TokenType - Access token type.
	TokenType *string `json:"tokenType,omitempty"`
}

// EndpointDeploymentPropertiesBase base definition for endpoint deployment.
type EndpointDeploymentPropertiesBase struct {
	// CodeConfiguration - Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `json:"codeConfiguration,omitempty"`
	// Description - Description of the endpoint deployment.
	Description *string `json:"description,omitempty"`
	// EnvironmentID - ARM resource ID or AssetId of the environment specification for the endpoint deployment.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables configuration for the deployment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for EndpointDeploymentPropertiesBase.
func (edpb EndpointDeploymentPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if edpb.CodeConfiguration != nil {
		objectMap["codeConfiguration"] = edpb.CodeConfiguration
	}
	if edpb.Description != nil {
		objectMap["description"] = edpb.Description
	}
	if edpb.EnvironmentID != nil {
		objectMap["environmentId"] = edpb.EnvironmentID
	}
	if edpb.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = edpb.EnvironmentVariables
	}
	if edpb.Properties != nil {
		objectMap["properties"] = edpb.Properties
	}
	return json.Marshal(objectMap)
}

// EndpointPropertiesBase inference Endpoint base definition
type EndpointPropertiesBase struct {
	// AuthMode - [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does. Possible values include: 'AMLToken', 'Key', 'AADToken'
	AuthMode EndpointAuthMode `json:"authMode,omitempty"`
	// Description - Description of the inference endpoint.
	Description *string `json:"description,omitempty"`
	// Keys - EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `json:"keys,omitempty"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
	// ScoringURI - READ-ONLY; Endpoint URI.
	ScoringURI *string `json:"scoringUri,omitempty"`
	// SwaggerURI - READ-ONLY; Endpoint Swagger URI.
	SwaggerURI *string `json:"swaggerUri,omitempty"`
}

// MarshalJSON is the custom marshaler for EndpointPropertiesBase.
func (epb EndpointPropertiesBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if epb.AuthMode != "" {
		objectMap["authMode"] = epb.AuthMode
	}
	if epb.Description != nil {
		objectMap["description"] = epb.Description
	}
	if epb.Keys != nil {
		objectMap["keys"] = epb.Keys
	}
	if epb.Properties != nil {
		objectMap["properties"] = epb.Properties
	}
	return json.Marshal(objectMap)
}

// EnvironmentContainer container for environment specification versions.
type EnvironmentContainer struct {
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// LatestVersion - READ-ONLY; The latest version inside this container.
	LatestVersion *string `json:"latestVersion,omitempty"`
	// NextVersion - READ-ONLY; The next auto incremental version
	NextVersion *string `json:"nextVersion,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for EnvironmentContainer.
func (ec EnvironmentContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ec.IsArchived != nil {
		objectMap["isArchived"] = ec.IsArchived
	}
	if ec.Description != nil {
		objectMap["description"] = ec.Description
	}
	if ec.Properties != nil {
		objectMap["properties"] = ec.Properties
	}
	if ec.Tags != nil {
		objectMap["tags"] = ec.Tags
	}
	return json.Marshal(objectMap)
}

// EnvironmentContainerResource azure Resource Manager resource envelope.
type EnvironmentContainerResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *EnvironmentContainer `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for EnvironmentContainerResource.
func (ecr EnvironmentContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ecr.Properties != nil {
		objectMap["properties"] = ecr.Properties
	}
	return json.Marshal(objectMap)
}

// EnvironmentContainerResourceArmPaginatedResult a paginated list of EnvironmentContainer entities.
type EnvironmentContainerResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of EnvironmentContainer objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type EnvironmentContainer.
	Value *[]EnvironmentContainerResource `json:"value,omitempty"`
}

// EnvironmentContainerResourceArmPaginatedResultIterator provides access to a complete listing of
// EnvironmentContainerResource values.
type EnvironmentContainerResourceArmPaginatedResultIterator struct {
	i    int
	page EnvironmentContainerResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EnvironmentContainerResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnvironmentContainerResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EnvironmentContainerResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EnvironmentContainerResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EnvironmentContainerResourceArmPaginatedResultIterator) Response() EnvironmentContainerResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EnvironmentContainerResourceArmPaginatedResultIterator) Value() EnvironmentContainerResource {
	if !iter.page.NotDone() {
		return EnvironmentContainerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EnvironmentContainerResourceArmPaginatedResultIterator type.
func NewEnvironmentContainerResourceArmPaginatedResultIterator(page EnvironmentContainerResourceArmPaginatedResultPage) EnvironmentContainerResourceArmPaginatedResultIterator {
	return EnvironmentContainerResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ecrapr EnvironmentContainerResourceArmPaginatedResult) IsEmpty() bool {
	return ecrapr.Value == nil || len(*ecrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ecrapr EnvironmentContainerResourceArmPaginatedResult) hasNextLink() bool {
	return ecrapr.NextLink != nil && len(*ecrapr.NextLink) != 0
}

// environmentContainerResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ecrapr EnvironmentContainerResourceArmPaginatedResult) environmentContainerResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ecrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ecrapr.NextLink)))
}

// EnvironmentContainerResourceArmPaginatedResultPage contains a page of EnvironmentContainerResource
// values.
type EnvironmentContainerResourceArmPaginatedResultPage struct {
	fn     func(context.Context, EnvironmentContainerResourceArmPaginatedResult) (EnvironmentContainerResourceArmPaginatedResult, error)
	ecrapr EnvironmentContainerResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EnvironmentContainerResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnvironmentContainerResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ecrapr)
		if err != nil {
			return err
		}
		page.ecrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EnvironmentContainerResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EnvironmentContainerResourceArmPaginatedResultPage) NotDone() bool {
	return !page.ecrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EnvironmentContainerResourceArmPaginatedResultPage) Response() EnvironmentContainerResourceArmPaginatedResult {
	return page.ecrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EnvironmentContainerResourceArmPaginatedResultPage) Values() []EnvironmentContainerResource {
	if page.ecrapr.IsEmpty() {
		return nil
	}
	return *page.ecrapr.Value
}

// Creates a new instance of the EnvironmentContainerResourceArmPaginatedResultPage type.
func NewEnvironmentContainerResourceArmPaginatedResultPage(cur EnvironmentContainerResourceArmPaginatedResult, getNextPage func(context.Context, EnvironmentContainerResourceArmPaginatedResult) (EnvironmentContainerResourceArmPaginatedResult, error)) EnvironmentContainerResourceArmPaginatedResultPage {
	return EnvironmentContainerResourceArmPaginatedResultPage{
		fn:     getNextPage,
		ecrapr: cur,
	}
}

// EnvironmentVersion environment version details.
type EnvironmentVersion struct {
	// Build - Configuration settings for Docker build context.
	Build *BuildContext `json:"build,omitempty"`
	// CondaFile - Standard configuration file used by Conda that lets you install any kind of package, including Python, R, and C/C++ packages.
	// <see href="https://repo2docker.readthedocs.io/en/latest/config_files.html#environment-yml-install-a-conda-environment" />
	CondaFile *string `json:"condaFile,omitempty"`
	// EnvironmentType - READ-ONLY; Environment type is either user managed or curated by the Azure ML service
	// <see href="https://docs.microsoft.com/en-us/azure/machine-learning/resource-curated-environments" />. Possible values include: 'Curated', 'UserCreated'
	EnvironmentType EnvironmentType `json:"environmentType,omitempty"`
	// Image - Name of the image that will be used for the environment.
	// <seealso href="https://docs.microsoft.com/en-us/azure/machine-learning/how-to-deploy-custom-docker-image#use-a-custom-base-image" />
	Image *string `json:"image,omitempty"`
	// InferenceConfig - Defines configuration specific to inference.
	InferenceConfig *InferenceContainerProperties `json:"inferenceConfig,omitempty"`
	// OsType - The OS type of the environment. Possible values include: 'Linux', 'Windows'
	OsType OperatingSystemType `json:"osType,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for EnvironmentVersion.
func (ev EnvironmentVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ev.Build != nil {
		objectMap["build"] = ev.Build
	}
	if ev.CondaFile != nil {
		objectMap["condaFile"] = ev.CondaFile
	}
	if ev.Image != nil {
		objectMap["image"] = ev.Image
	}
	if ev.InferenceConfig != nil {
		objectMap["inferenceConfig"] = ev.InferenceConfig
	}
	if ev.OsType != "" {
		objectMap["osType"] = ev.OsType
	}
	if ev.IsAnonymous != nil {
		objectMap["isAnonymous"] = ev.IsAnonymous
	}
	if ev.IsArchived != nil {
		objectMap["isArchived"] = ev.IsArchived
	}
	if ev.Description != nil {
		objectMap["description"] = ev.Description
	}
	if ev.Properties != nil {
		objectMap["properties"] = ev.Properties
	}
	if ev.Tags != nil {
		objectMap["tags"] = ev.Tags
	}
	return json.Marshal(objectMap)
}

// EnvironmentVersionResource azure Resource Manager resource envelope.
type EnvironmentVersionResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *EnvironmentVersion `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for EnvironmentVersionResource.
func (evr EnvironmentVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if evr.Properties != nil {
		objectMap["properties"] = evr.Properties
	}
	return json.Marshal(objectMap)
}

// EnvironmentVersionResourceArmPaginatedResult a paginated list of EnvironmentVersion entities.
type EnvironmentVersionResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of EnvironmentVersion objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type EnvironmentVersion.
	Value *[]EnvironmentVersionResource `json:"value,omitempty"`
}

// EnvironmentVersionResourceArmPaginatedResultIterator provides access to a complete listing of
// EnvironmentVersionResource values.
type EnvironmentVersionResourceArmPaginatedResultIterator struct {
	i    int
	page EnvironmentVersionResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EnvironmentVersionResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnvironmentVersionResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EnvironmentVersionResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EnvironmentVersionResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EnvironmentVersionResourceArmPaginatedResultIterator) Response() EnvironmentVersionResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EnvironmentVersionResourceArmPaginatedResultIterator) Value() EnvironmentVersionResource {
	if !iter.page.NotDone() {
		return EnvironmentVersionResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EnvironmentVersionResourceArmPaginatedResultIterator type.
func NewEnvironmentVersionResourceArmPaginatedResultIterator(page EnvironmentVersionResourceArmPaginatedResultPage) EnvironmentVersionResourceArmPaginatedResultIterator {
	return EnvironmentVersionResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (evrapr EnvironmentVersionResourceArmPaginatedResult) IsEmpty() bool {
	return evrapr.Value == nil || len(*evrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (evrapr EnvironmentVersionResourceArmPaginatedResult) hasNextLink() bool {
	return evrapr.NextLink != nil && len(*evrapr.NextLink) != 0
}

// environmentVersionResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (evrapr EnvironmentVersionResourceArmPaginatedResult) environmentVersionResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !evrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(evrapr.NextLink)))
}

// EnvironmentVersionResourceArmPaginatedResultPage contains a page of EnvironmentVersionResource values.
type EnvironmentVersionResourceArmPaginatedResultPage struct {
	fn     func(context.Context, EnvironmentVersionResourceArmPaginatedResult) (EnvironmentVersionResourceArmPaginatedResult, error)
	evrapr EnvironmentVersionResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EnvironmentVersionResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EnvironmentVersionResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.evrapr)
		if err != nil {
			return err
		}
		page.evrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EnvironmentVersionResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EnvironmentVersionResourceArmPaginatedResultPage) NotDone() bool {
	return !page.evrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EnvironmentVersionResourceArmPaginatedResultPage) Response() EnvironmentVersionResourceArmPaginatedResult {
	return page.evrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EnvironmentVersionResourceArmPaginatedResultPage) Values() []EnvironmentVersionResource {
	if page.evrapr.IsEmpty() {
		return nil
	}
	return *page.evrapr.Value
}

// Creates a new instance of the EnvironmentVersionResourceArmPaginatedResultPage type.
func NewEnvironmentVersionResourceArmPaginatedResultPage(cur EnvironmentVersionResourceArmPaginatedResult, getNextPage func(context.Context, EnvironmentVersionResourceArmPaginatedResult) (EnvironmentVersionResourceArmPaginatedResult, error)) EnvironmentVersionResourceArmPaginatedResultPage {
	return EnvironmentVersionResourceArmPaginatedResultPage{
		fn:     getNextPage,
		evrapr: cur,
	}
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// EstimatedVMPrice the estimated price info for using a VM of a particular OS type, tier, etc.
type EstimatedVMPrice struct {
	// RetailPrice - The price charged for using the VM.
	RetailPrice *float64 `json:"retailPrice,omitempty"`
	// OsType - Operating system type used by the VM. Possible values include: 'VMPriceOSTypeLinux', 'VMPriceOSTypeWindows'
	OsType VMPriceOSType `json:"osType,omitempty"`
	// VMTier - The type of the VM. Possible values include: 'VMTierStandard', 'VMTierLowPriority', 'VMTierSpot'
	VMTier VMTier `json:"vmTier,omitempty"`
}

// EstimatedVMPrices the estimated price info for using a VM.
type EstimatedVMPrices struct {
	// BillingCurrency - Three lettered code specifying the currency of the VM price. Example: USD
	BillingCurrency *string `json:"billingCurrency,omitempty"`
	// UnitOfMeasure - The unit of time measurement for the specified VM price. Example: OneHour
	UnitOfMeasure *string `json:"unitOfMeasure,omitempty"`
	// Values - The list of estimated prices for using a VM of a particular OS type, tier, etc.
	Values *[]EstimatedVMPrice `json:"values,omitempty"`
}

// ExternalFQDNResponse ...
type ExternalFQDNResponse struct {
	autorest.Response `json:"-"`
	Value             *[]FQDNEndpoints `json:"value,omitempty"`
}

// FlavorData ...
type FlavorData struct {
	// Data - Model flavor-specific data.
	Data map[string]*string `json:"data"`
}

// MarshalJSON is the custom marshaler for FlavorData.
func (fd FlavorData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fd.Data != nil {
		objectMap["data"] = fd.Data
	}
	return json.Marshal(objectMap)
}

// FQDNEndpoint ...
type FQDNEndpoint struct {
	DomainName      *string               `json:"domainName,omitempty"`
	EndpointDetails *[]FQDNEndpointDetail `json:"endpointDetails,omitempty"`
}

// FQDNEndpointDetail ...
type FQDNEndpointDetail struct {
	Port *int32 `json:"port,omitempty"`
}

// FQDNEndpoints ...
type FQDNEndpoints struct {
	Properties *FQDNEndpointsProperties `json:"properties,omitempty"`
}

// FQDNEndpointsProperties ...
type FQDNEndpointsProperties struct {
	Category  *string         `json:"category,omitempty"`
	Endpoints *[]FQDNEndpoint `json:"endpoints,omitempty"`
}

// GridSamplingAlgorithm defines a Sampling Algorithm that exhaustively generates every value combination
// in the space
type GridSamplingAlgorithm struct {
	// SamplingAlgorithmType - Possible values include: 'SamplingAlgorithmTypeSamplingAlgorithm', 'SamplingAlgorithmTypeBayesian1', 'SamplingAlgorithmTypeGrid1', 'SamplingAlgorithmTypeRandom1'
	SamplingAlgorithmType SamplingAlgorithmTypeBasicSamplingAlgorithm `json:"samplingAlgorithmType,omitempty"`
}

// MarshalJSON is the custom marshaler for GridSamplingAlgorithm.
func (gsa GridSamplingAlgorithm) MarshalJSON() ([]byte, error) {
	gsa.SamplingAlgorithmType = SamplingAlgorithmTypeGrid1
	objectMap := make(map[string]interface{})
	if gsa.SamplingAlgorithmType != "" {
		objectMap["samplingAlgorithmType"] = gsa.SamplingAlgorithmType
	}
	return json.Marshal(objectMap)
}

// AsBayesianSamplingAlgorithm is the BasicSamplingAlgorithm implementation for GridSamplingAlgorithm.
func (gsa GridSamplingAlgorithm) AsBayesianSamplingAlgorithm() (*BayesianSamplingAlgorithm, bool) {
	return nil, false
}

// AsGridSamplingAlgorithm is the BasicSamplingAlgorithm implementation for GridSamplingAlgorithm.
func (gsa GridSamplingAlgorithm) AsGridSamplingAlgorithm() (*GridSamplingAlgorithm, bool) {
	return &gsa, true
}

// AsRandomSamplingAlgorithm is the BasicSamplingAlgorithm implementation for GridSamplingAlgorithm.
func (gsa GridSamplingAlgorithm) AsRandomSamplingAlgorithm() (*RandomSamplingAlgorithm, bool) {
	return nil, false
}

// AsSamplingAlgorithm is the BasicSamplingAlgorithm implementation for GridSamplingAlgorithm.
func (gsa GridSamplingAlgorithm) AsSamplingAlgorithm() (*SamplingAlgorithm, bool) {
	return nil, false
}

// AsBasicSamplingAlgorithm is the BasicSamplingAlgorithm implementation for GridSamplingAlgorithm.
func (gsa GridSamplingAlgorithm) AsBasicSamplingAlgorithm() (BasicSamplingAlgorithm, bool) {
	return &gsa, true
}

// HDInsight a HDInsight compute.
type HDInsight struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                `json:"disableLocalAuth,omitempty"`
	Properties       *HDInsightProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for HDInsight.
func (hi HDInsight) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hi.ComputeType != "" {
		objectMap["computeType"] = hi.ComputeType
	}
	if hi.Description != nil {
		objectMap["description"] = hi.Description
	}
	if hi.ResourceID != nil {
		objectMap["resourceId"] = hi.ResourceID
	}
	if hi.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = hi.DisableLocalAuth
	}
	if hi.Properties != nil {
		objectMap["properties"] = hi.Properties
	}
	return json.Marshal(objectMap)
}

// HDInsightProperties hDInsight compute properties
type HDInsightProperties struct {
	// SSHPort - Port open for ssh connections on the master node of the cluster.
	SSHPort *int32 `json:"sshPort,omitempty"`
	// Address - Public IP address of the master node of the cluster.
	Address *string `json:"address,omitempty"`
	// AdministratorAccount - Admin credentials for master node of the cluster
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`
}

// HDInsightSchema ...
type HDInsightSchema struct {
	Properties *HDInsightProperties `json:"properties,omitempty"`
}

// IDAssetReference reference to an asset via its ARM resource ID.
type IDAssetReference struct {
	// AssetID - [Required] ARM resource ID of the asset.
	AssetID *string `json:"assetId,omitempty"`
	// ReferenceType - Possible values include: 'ReferenceTypeAssetReferenceBase', 'ReferenceTypeDataPath', 'ReferenceTypeID', 'ReferenceTypeOutputPath'
	ReferenceType ReferenceTypeBasicAssetReferenceBase `json:"referenceType,omitempty"`
}

// MarshalJSON is the custom marshaler for IDAssetReference.
func (iar IDAssetReference) MarshalJSON() ([]byte, error) {
	iar.ReferenceType = ReferenceTypeID
	objectMap := make(map[string]interface{})
	if iar.AssetID != nil {
		objectMap["assetId"] = iar.AssetID
	}
	if iar.ReferenceType != "" {
		objectMap["referenceType"] = iar.ReferenceType
	}
	return json.Marshal(objectMap)
}

// AsDataPathAssetReference is the BasicAssetReferenceBase implementation for IDAssetReference.
func (iar IDAssetReference) AsDataPathAssetReference() (*DataPathAssetReference, bool) {
	return nil, false
}

// AsIDAssetReference is the BasicAssetReferenceBase implementation for IDAssetReference.
func (iar IDAssetReference) AsIDAssetReference() (*IDAssetReference, bool) {
	return &iar, true
}

// AsOutputPathAssetReference is the BasicAssetReferenceBase implementation for IDAssetReference.
func (iar IDAssetReference) AsOutputPathAssetReference() (*OutputPathAssetReference, bool) {
	return nil, false
}

// AsAssetReferenceBase is the BasicAssetReferenceBase implementation for IDAssetReference.
func (iar IDAssetReference) AsAssetReferenceBase() (*AssetReferenceBase, bool) {
	return nil, false
}

// AsBasicAssetReferenceBase is the BasicAssetReferenceBase implementation for IDAssetReference.
func (iar IDAssetReference) AsBasicAssetReferenceBase() (BasicAssetReferenceBase, bool) {
	return &iar, true
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// BasicIdentityConfiguration base definition for identity configuration.
type BasicIdentityConfiguration interface {
	AsAmlToken() (*AmlToken, bool)
	AsManagedIdentity() (*ManagedIdentity, bool)
	AsUserIdentity() (*UserIdentity, bool)
	AsIdentityConfiguration() (*IdentityConfiguration, bool)
}

// IdentityConfiguration base definition for identity configuration.
type IdentityConfiguration struct {
	// IdentityType - Possible values include: 'IdentityTypeIdentityConfiguration', 'IdentityTypeAMLToken', 'IdentityTypeManaged', 'IdentityTypeUserIdentity'
	IdentityType IdentityType `json:"identityType,omitempty"`
}

func unmarshalBasicIdentityConfiguration(body []byte) (BasicIdentityConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["identityType"] {
	case string(IdentityTypeAMLToken):
		var at AmlToken
		err := json.Unmarshal(body, &at)
		return at, err
	case string(IdentityTypeManaged):
		var mi ManagedIdentity
		err := json.Unmarshal(body, &mi)
		return mi, err
	case string(IdentityTypeUserIdentity):
		var UI UserIdentity
		err := json.Unmarshal(body, &UI)
		return UI, err
	default:
		var ic IdentityConfiguration
		err := json.Unmarshal(body, &ic)
		return ic, err
	}
}
func unmarshalBasicIdentityConfigurationArray(body []byte) ([]BasicIdentityConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	icArray := make([]BasicIdentityConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ic, err := unmarshalBasicIdentityConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		icArray[index] = ic
	}
	return icArray, nil
}

// MarshalJSON is the custom marshaler for IdentityConfiguration.
func (ic IdentityConfiguration) MarshalJSON() ([]byte, error) {
	ic.IdentityType = IdentityTypeIdentityConfiguration
	objectMap := make(map[string]interface{})
	if ic.IdentityType != "" {
		objectMap["identityType"] = ic.IdentityType
	}
	return json.Marshal(objectMap)
}

// AsAmlToken is the BasicIdentityConfiguration implementation for IdentityConfiguration.
func (ic IdentityConfiguration) AsAmlToken() (*AmlToken, bool) {
	return nil, false
}

// AsManagedIdentity is the BasicIdentityConfiguration implementation for IdentityConfiguration.
func (ic IdentityConfiguration) AsManagedIdentity() (*ManagedIdentity, bool) {
	return nil, false
}

// AsUserIdentity is the BasicIdentityConfiguration implementation for IdentityConfiguration.
func (ic IdentityConfiguration) AsUserIdentity() (*UserIdentity, bool) {
	return nil, false
}

// AsIdentityConfiguration is the BasicIdentityConfiguration implementation for IdentityConfiguration.
func (ic IdentityConfiguration) AsIdentityConfiguration() (*IdentityConfiguration, bool) {
	return &ic, true
}

// AsBasicIdentityConfiguration is the BasicIdentityConfiguration implementation for IdentityConfiguration.
func (ic IdentityConfiguration) AsBasicIdentityConfiguration() (BasicIdentityConfiguration, bool) {
	return &ic, true
}

// IdentityForCmk identity that will be used to access key vault for encryption at rest
type IdentityForCmk struct {
	// UserAssignedIdentity - The ArmId of the user assigned identity that will be used to access the customer managed key vault
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// InferenceContainerProperties ...
type InferenceContainerProperties struct {
	// LivenessRoute - The route to check the liveness of the inference server container.
	LivenessRoute *Route `json:"livenessRoute,omitempty"`
	// ReadinessRoute - The route to check the readiness of the inference server container.
	ReadinessRoute *Route `json:"readinessRoute,omitempty"`
	// ScoringRoute - The port to send the scoring requests to, within the inference server container.
	ScoringRoute *Route `json:"scoringRoute,omitempty"`
}

// InstanceTypeSchema instance type schema.
type InstanceTypeSchema struct {
	// NodeSelector - Node Selector
	NodeSelector map[string]*string `json:"nodeSelector"`
	// Resources - Resource requests/limits for this instance type
	Resources *InstanceTypeSchemaResources `json:"resources,omitempty"`
}

// MarshalJSON is the custom marshaler for InstanceTypeSchema.
func (its InstanceTypeSchema) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if its.NodeSelector != nil {
		objectMap["nodeSelector"] = its.NodeSelector
	}
	if its.Resources != nil {
		objectMap["resources"] = its.Resources
	}
	return json.Marshal(objectMap)
}

// InstanceTypeSchemaResources resource requests/limits for this instance type
type InstanceTypeSchemaResources struct {
	// Requests - Resource requests for this instance type
	Requests map[string]*string `json:"requests"`
	// Limits - Resource limits for this instance type
	Limits map[string]*string `json:"limits"`
}

// MarshalJSON is the custom marshaler for InstanceTypeSchemaResources.
func (its InstanceTypeSchemaResources) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if its.Requests != nil {
		objectMap["requests"] = its.Requests
	}
	if its.Limits != nil {
		objectMap["limits"] = its.Limits
	}
	return json.Marshal(objectMap)
}

// BasicJobBase base definition for a job.
type BasicJobBase interface {
	AsCommandJob() (*CommandJob, bool)
	AsPipelineJob() (*PipelineJob, bool)
	AsSweepJob() (*SweepJob, bool)
	AsJobBase() (*JobBase, bool)
}

// JobBase base definition for a job.
type JobBase struct {
	// ComputeID - ARM resource ID of the compute resource.
	ComputeID *string `json:"computeId,omitempty"`
	// DisplayName - Display name of job.
	DisplayName *string `json:"displayName,omitempty"`
	// ExperimentName - The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `json:"experimentName,omitempty"`
	// Identity - Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity BasicIdentityConfiguration `json:"identity,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Services - List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]*JobService `json:"services"`
	// Status - READ-ONLY; Status of the job. Possible values include: 'JobStatusNotStarted', 'JobStatusStarting', 'JobStatusProvisioning', 'JobStatusPreparing', 'JobStatusQueued', 'JobStatusRunning', 'JobStatusFinalizing', 'JobStatusCancelRequested', 'JobStatusCompleted', 'JobStatusFailed', 'JobStatusCanceled', 'JobStatusNotResponding', 'JobStatusPaused', 'JobStatusUnknown'
	Status JobStatus `json:"status,omitempty"`
	// JobType - Possible values include: 'JobTypeJobBase', 'JobTypeCommand1', 'JobTypePipeline1', 'JobTypeSweep1'
	JobType JobTypeBasicJobBase `json:"jobType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

func unmarshalBasicJobBase(body []byte) (BasicJobBase, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["jobType"] {
	case string(JobTypeCommand1):
		var cj CommandJob
		err := json.Unmarshal(body, &cj)
		return cj, err
	case string(JobTypePipeline1):
		var pj PipelineJob
		err := json.Unmarshal(body, &pj)
		return pj, err
	case string(JobTypeSweep1):
		var sj SweepJob
		err := json.Unmarshal(body, &sj)
		return sj, err
	default:
		var jb JobBase
		err := json.Unmarshal(body, &jb)
		return jb, err
	}
}
func unmarshalBasicJobBaseArray(body []byte) ([]BasicJobBase, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jbArray := make([]BasicJobBase, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jb, err := unmarshalBasicJobBase(*rawMessage)
		if err != nil {
			return nil, err
		}
		jbArray[index] = jb
	}
	return jbArray, nil
}

// MarshalJSON is the custom marshaler for JobBase.
func (jb JobBase) MarshalJSON() ([]byte, error) {
	jb.JobType = JobTypeJobBase
	objectMap := make(map[string]interface{})
	if jb.ComputeID != nil {
		objectMap["computeId"] = jb.ComputeID
	}
	if jb.DisplayName != nil {
		objectMap["displayName"] = jb.DisplayName
	}
	if jb.ExperimentName != nil {
		objectMap["experimentName"] = jb.ExperimentName
	}
	objectMap["identity"] = jb.Identity
	if jb.IsArchived != nil {
		objectMap["isArchived"] = jb.IsArchived
	}
	if jb.Services != nil {
		objectMap["services"] = jb.Services
	}
	if jb.JobType != "" {
		objectMap["jobType"] = jb.JobType
	}
	if jb.Description != nil {
		objectMap["description"] = jb.Description
	}
	if jb.Properties != nil {
		objectMap["properties"] = jb.Properties
	}
	if jb.Tags != nil {
		objectMap["tags"] = jb.Tags
	}
	return json.Marshal(objectMap)
}

// AsCommandJob is the BasicJobBase implementation for JobBase.
func (jb JobBase) AsCommandJob() (*CommandJob, bool) {
	return nil, false
}

// AsPipelineJob is the BasicJobBase implementation for JobBase.
func (jb JobBase) AsPipelineJob() (*PipelineJob, bool) {
	return nil, false
}

// AsSweepJob is the BasicJobBase implementation for JobBase.
func (jb JobBase) AsSweepJob() (*SweepJob, bool) {
	return nil, false
}

// AsJobBase is the BasicJobBase implementation for JobBase.
func (jb JobBase) AsJobBase() (*JobBase, bool) {
	return &jb, true
}

// AsBasicJobBase is the BasicJobBase implementation for JobBase.
func (jb JobBase) AsBasicJobBase() (BasicJobBase, bool) {
	return &jb, true
}

// UnmarshalJSON is the custom unmarshaler for JobBase struct.
func (jb *JobBase) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "computeId":
			if v != nil {
				var computeID string
				err = json.Unmarshal(*v, &computeID)
				if err != nil {
					return err
				}
				jb.ComputeID = &computeID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				jb.DisplayName = &displayName
			}
		case "experimentName":
			if v != nil {
				var experimentName string
				err = json.Unmarshal(*v, &experimentName)
				if err != nil {
					return err
				}
				jb.ExperimentName = &experimentName
			}
		case "identity":
			if v != nil {
				identity, err := unmarshalBasicIdentityConfiguration(*v)
				if err != nil {
					return err
				}
				jb.Identity = identity
			}
		case "isArchived":
			if v != nil {
				var isArchived bool
				err = json.Unmarshal(*v, &isArchived)
				if err != nil {
					return err
				}
				jb.IsArchived = &isArchived
			}
		case "services":
			if v != nil {
				var services map[string]*JobService
				err = json.Unmarshal(*v, &services)
				if err != nil {
					return err
				}
				jb.Services = services
			}
		case "status":
			if v != nil {
				var status JobStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				jb.Status = status
			}
		case "jobType":
			if v != nil {
				var jobType JobTypeBasicJobBase
				err = json.Unmarshal(*v, &jobType)
				if err != nil {
					return err
				}
				jb.JobType = jobType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				jb.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				jb.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				jb.Tags = tags
			}
		}
	}

	return nil
}

// JobBaseResource azure Resource Manager resource envelope.
type JobBaseResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties BasicJobBase `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for JobBaseResource.
func (jbr JobBaseResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = jbr.Properties
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for JobBaseResource struct.
func (jbr *JobBaseResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicJobBase(*v)
				if err != nil {
					return err
				}
				jbr.Properties = properties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				jbr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				jbr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				jbr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				jbr.SystemData = &systemData
			}
		}
	}

	return nil
}

// JobBaseResourceArmPaginatedResult a paginated list of JobBase entities.
type JobBaseResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of JobBase objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type JobBase.
	Value *[]JobBaseResource `json:"value,omitempty"`
}

// JobBaseResourceArmPaginatedResultIterator provides access to a complete listing of JobBaseResource
// values.
type JobBaseResourceArmPaginatedResultIterator struct {
	i    int
	page JobBaseResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *JobBaseResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobBaseResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *JobBaseResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter JobBaseResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter JobBaseResourceArmPaginatedResultIterator) Response() JobBaseResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter JobBaseResourceArmPaginatedResultIterator) Value() JobBaseResource {
	if !iter.page.NotDone() {
		return JobBaseResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the JobBaseResourceArmPaginatedResultIterator type.
func NewJobBaseResourceArmPaginatedResultIterator(page JobBaseResourceArmPaginatedResultPage) JobBaseResourceArmPaginatedResultIterator {
	return JobBaseResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (jbrapr JobBaseResourceArmPaginatedResult) IsEmpty() bool {
	return jbrapr.Value == nil || len(*jbrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (jbrapr JobBaseResourceArmPaginatedResult) hasNextLink() bool {
	return jbrapr.NextLink != nil && len(*jbrapr.NextLink) != 0
}

// jobBaseResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (jbrapr JobBaseResourceArmPaginatedResult) jobBaseResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !jbrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(jbrapr.NextLink)))
}

// JobBaseResourceArmPaginatedResultPage contains a page of JobBaseResource values.
type JobBaseResourceArmPaginatedResultPage struct {
	fn     func(context.Context, JobBaseResourceArmPaginatedResult) (JobBaseResourceArmPaginatedResult, error)
	jbrapr JobBaseResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *JobBaseResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/JobBaseResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.jbrapr)
		if err != nil {
			return err
		}
		page.jbrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *JobBaseResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page JobBaseResourceArmPaginatedResultPage) NotDone() bool {
	return !page.jbrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page JobBaseResourceArmPaginatedResultPage) Response() JobBaseResourceArmPaginatedResult {
	return page.jbrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page JobBaseResourceArmPaginatedResultPage) Values() []JobBaseResource {
	if page.jbrapr.IsEmpty() {
		return nil
	}
	return *page.jbrapr.Value
}

// Creates a new instance of the JobBaseResourceArmPaginatedResultPage type.
func NewJobBaseResourceArmPaginatedResultPage(cur JobBaseResourceArmPaginatedResult, getNextPage func(context.Context, JobBaseResourceArmPaginatedResult) (JobBaseResourceArmPaginatedResult, error)) JobBaseResourceArmPaginatedResultPage {
	return JobBaseResourceArmPaginatedResultPage{
		fn:     getNextPage,
		jbrapr: cur,
	}
}

// BasicJobInput command job definition.
type BasicJobInput interface {
	AsLiteralJobInput() (*LiteralJobInput, bool)
	AsJobInput() (*JobInput, bool)
}

// JobInput command job definition.
type JobInput struct {
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - Possible values include: 'JobInputTypeJobInput', 'JobInputTypeLiteral1'
	JobInputType JobInputTypeBasicJobInput `json:"jobInputType,omitempty"`
}

func unmarshalBasicJobInput(body []byte) (BasicJobInput, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["jobInputType"] {
	case string(JobInputTypeLiteral1):
		var lji LiteralJobInput
		err := json.Unmarshal(body, &lji)
		return lji, err
	default:
		var ji JobInput
		err := json.Unmarshal(body, &ji)
		return ji, err
	}
}
func unmarshalBasicJobInputArray(body []byte) ([]BasicJobInput, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jiArray := make([]BasicJobInput, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ji, err := unmarshalBasicJobInput(*rawMessage)
		if err != nil {
			return nil, err
		}
		jiArray[index] = ji
	}
	return jiArray, nil
}

// MarshalJSON is the custom marshaler for JobInput.
func (ji JobInput) MarshalJSON() ([]byte, error) {
	ji.JobInputType = JobInputTypeJobInput
	objectMap := make(map[string]interface{})
	if ji.Description != nil {
		objectMap["description"] = ji.Description
	}
	if ji.JobInputType != "" {
		objectMap["jobInputType"] = ji.JobInputType
	}
	return json.Marshal(objectMap)
}

// AsLiteralJobInput is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsLiteralJobInput() (*LiteralJobInput, bool) {
	return nil, false
}

// AsJobInput is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsJobInput() (*JobInput, bool) {
	return &ji, true
}

// AsBasicJobInput is the BasicJobInput implementation for JobInput.
func (ji JobInput) AsBasicJobInput() (BasicJobInput, bool) {
	return &ji, true
}

// BasicJobLimits ...
type BasicJobLimits interface {
	AsCommandJobLimits() (*CommandJobLimits, bool)
	AsSweepJobLimits() (*SweepJobLimits, bool)
	AsJobLimits() (*JobLimits, bool)
}

// JobLimits ...
type JobLimits struct {
	// Timeout - The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `json:"timeout,omitempty"`
	// JobLimitsType - Possible values include: 'JobLimitsTypeJobLimits', 'JobLimitsTypeCommand', 'JobLimitsTypeSweep'
	JobLimitsType JobLimitsTypeBasicJobLimits `json:"jobLimitsType,omitempty"`
}

func unmarshalBasicJobLimits(body []byte) (BasicJobLimits, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["jobLimitsType"] {
	case string(JobLimitsTypeCommand):
		var cjl CommandJobLimits
		err := json.Unmarshal(body, &cjl)
		return cjl, err
	case string(JobLimitsTypeSweep):
		var sjl SweepJobLimits
		err := json.Unmarshal(body, &sjl)
		return sjl, err
	default:
		var jl JobLimits
		err := json.Unmarshal(body, &jl)
		return jl, err
	}
}
func unmarshalBasicJobLimitsArray(body []byte) ([]BasicJobLimits, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	jlArray := make([]BasicJobLimits, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jl, err := unmarshalBasicJobLimits(*rawMessage)
		if err != nil {
			return nil, err
		}
		jlArray[index] = jl
	}
	return jlArray, nil
}

// MarshalJSON is the custom marshaler for JobLimits.
func (jl JobLimits) MarshalJSON() ([]byte, error) {
	jl.JobLimitsType = JobLimitsTypeJobLimits
	objectMap := make(map[string]interface{})
	if jl.Timeout != nil {
		objectMap["timeout"] = jl.Timeout
	}
	if jl.JobLimitsType != "" {
		objectMap["jobLimitsType"] = jl.JobLimitsType
	}
	return json.Marshal(objectMap)
}

// AsCommandJobLimits is the BasicJobLimits implementation for JobLimits.
func (jl JobLimits) AsCommandJobLimits() (*CommandJobLimits, bool) {
	return nil, false
}

// AsSweepJobLimits is the BasicJobLimits implementation for JobLimits.
func (jl JobLimits) AsSweepJobLimits() (*SweepJobLimits, bool) {
	return nil, false
}

// AsJobLimits is the BasicJobLimits implementation for JobLimits.
func (jl JobLimits) AsJobLimits() (*JobLimits, bool) {
	return &jl, true
}

// AsBasicJobLimits is the BasicJobLimits implementation for JobLimits.
func (jl JobLimits) AsBasicJobLimits() (BasicJobLimits, bool) {
	return &jl, true
}

// BasicJobOutput job output definition container information on where to find job output/logs.
type BasicJobOutput interface {
	AsJobOutput() (*JobOutput, bool)
}

// JobOutput job output definition container information on where to find job output/logs.
type JobOutput struct {
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - Possible values include: 'JobOutputTypeJobOutput'
	JobOutputType JobOutputTypeBasicJobOutput `json:"jobOutputType,omitempty"`
}

func unmarshalBasicJobOutput(body []byte) (BasicJobOutput, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["jobOutputType"] {
	default:
		var jo JobOutput
		err := json.Unmarshal(body, &jo)
		return jo, err
	}
}
func unmarshalBasicJobOutputArray(body []byte) ([]BasicJobOutput, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	joArray := make([]BasicJobOutput, len(rawMessages))

	for index, rawMessage := range rawMessages {
		jo, err := unmarshalBasicJobOutput(*rawMessage)
		if err != nil {
			return nil, err
		}
		joArray[index] = jo
	}
	return joArray, nil
}

// MarshalJSON is the custom marshaler for JobOutput.
func (jo JobOutput) MarshalJSON() ([]byte, error) {
	jo.JobOutputType = JobOutputTypeJobOutput
	objectMap := make(map[string]interface{})
	if jo.Description != nil {
		objectMap["description"] = jo.Description
	}
	if jo.JobOutputType != "" {
		objectMap["jobOutputType"] = jo.JobOutputType
	}
	return json.Marshal(objectMap)
}

// AsJobOutput is the BasicJobOutput implementation for JobOutput.
func (jo JobOutput) AsJobOutput() (*JobOutput, bool) {
	return &jo, true
}

// AsBasicJobOutput is the BasicJobOutput implementation for JobOutput.
func (jo JobOutput) AsBasicJobOutput() (BasicJobOutput, bool) {
	return &jo, true
}

// JobsCancelFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type JobsCancelFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(JobsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *JobsCancelFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for JobsCancelFuture.Result.
func (future *JobsCancelFuture) result(client JobsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.JobsCancelFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.JobsCancelFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// JobsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type JobsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(JobsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *JobsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for JobsDeleteFuture.Result.
func (future *JobsDeleteFuture) result(client JobsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.JobsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.JobsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// JobService job endpoint definition
type JobService struct {
	// Endpoint - Url for endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// ErrorMessage - READ-ONLY; Any error in the service.
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// JobServiceType - Endpoint type.
	JobServiceType *string `json:"jobServiceType,omitempty"`
	// Port - Port for endpoint.
	Port *int32 `json:"port,omitempty"`
	// Properties - Additional properties to set on the endpoint.
	Properties map[string]*string `json:"properties"`
	// Status - READ-ONLY; Status of endpoint.
	Status *string `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for JobService.
func (js JobService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if js.Endpoint != nil {
		objectMap["endpoint"] = js.Endpoint
	}
	if js.JobServiceType != nil {
		objectMap["jobServiceType"] = js.JobServiceType
	}
	if js.Port != nil {
		objectMap["port"] = js.Port
	}
	if js.Properties != nil {
		objectMap["properties"] = js.Properties
	}
	return json.Marshal(objectMap)
}

// Kubernetes a Machine Learning compute based on Kubernetes Compute.
type Kubernetes struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// Properties - Properties of Kubernetes
	Properties *KubernetesProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Kubernetes.
func (kVar Kubernetes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kVar.ComputeType != "" {
		objectMap["computeType"] = kVar.ComputeType
	}
	if kVar.Description != nil {
		objectMap["description"] = kVar.Description
	}
	if kVar.ResourceID != nil {
		objectMap["resourceId"] = kVar.ResourceID
	}
	if kVar.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = kVar.DisableLocalAuth
	}
	if kVar.Properties != nil {
		objectMap["properties"] = kVar.Properties
	}
	return json.Marshal(objectMap)
}

// KubernetesOnlineDeployment properties specific to a KubernetesOnlineDeployment.
type KubernetesOnlineDeployment struct {
	// ContainerResourceRequirements - The resource requirements for the container (cpu and memory).
	ContainerResourceRequirements *ContainerResourceRequirements `json:"containerResourceRequirements,omitempty"`
	// AppInsightsEnabled - If true, enables Application Insights logging.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// InstanceType - Compute instance type.
	InstanceType *string `json:"instanceType,omitempty"`
	// LivenessProbe - Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `json:"livenessProbe,omitempty"`
	// Model - The URI path to the model.
	Model *string `json:"model,omitempty"`
	// ModelMountPath - The path to mount the model in custom container.
	ModelMountPath *string `json:"modelMountPath,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state for the endpoint deployment. Possible values include: 'DeploymentProvisioningStateCreating', 'DeploymentProvisioningStateDeleting', 'DeploymentProvisioningStateScaling', 'DeploymentProvisioningStateUpdating', 'DeploymentProvisioningStateSucceeded', 'DeploymentProvisioningStateFailed', 'DeploymentProvisioningStateCanceled'
	ProvisioningState DeploymentProvisioningState `json:"provisioningState,omitempty"`
	// ReadinessProbe - Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `json:"readinessProbe,omitempty"`
	// RequestSettings - Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `json:"requestSettings,omitempty"`
	// ScaleSettings - Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings BasicOnlineScaleSettings `json:"scaleSettings,omitempty"`
	// CodeConfiguration - Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `json:"codeConfiguration,omitempty"`
	// Description - Description of the endpoint deployment.
	Description *string `json:"description,omitempty"`
	// EnvironmentID - ARM resource ID or AssetId of the environment specification for the endpoint deployment.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables configuration for the deployment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
	// EndpointComputeType - Possible values include: 'EndpointComputeTypeOnlineDeployment', 'EndpointComputeTypeKubernetes1', 'EndpointComputeTypeManaged1'
	EndpointComputeType EndpointComputeTypeBasicOnlineDeployment `json:"endpointComputeType,omitempty"`
}

// MarshalJSON is the custom marshaler for KubernetesOnlineDeployment.
func (kod KubernetesOnlineDeployment) MarshalJSON() ([]byte, error) {
	kod.EndpointComputeType = EndpointComputeTypeKubernetes1
	objectMap := make(map[string]interface{})
	if kod.ContainerResourceRequirements != nil {
		objectMap["containerResourceRequirements"] = kod.ContainerResourceRequirements
	}
	if kod.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = kod.AppInsightsEnabled
	}
	if kod.InstanceType != nil {
		objectMap["instanceType"] = kod.InstanceType
	}
	if kod.LivenessProbe != nil {
		objectMap["livenessProbe"] = kod.LivenessProbe
	}
	if kod.Model != nil {
		objectMap["model"] = kod.Model
	}
	if kod.ModelMountPath != nil {
		objectMap["modelMountPath"] = kod.ModelMountPath
	}
	if kod.ReadinessProbe != nil {
		objectMap["readinessProbe"] = kod.ReadinessProbe
	}
	if kod.RequestSettings != nil {
		objectMap["requestSettings"] = kod.RequestSettings
	}
	objectMap["scaleSettings"] = kod.ScaleSettings
	if kod.EndpointComputeType != "" {
		objectMap["endpointComputeType"] = kod.EndpointComputeType
	}
	if kod.CodeConfiguration != nil {
		objectMap["codeConfiguration"] = kod.CodeConfiguration
	}
	if kod.Description != nil {
		objectMap["description"] = kod.Description
	}
	if kod.EnvironmentID != nil {
		objectMap["environmentId"] = kod.EnvironmentID
	}
	if kod.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = kod.EnvironmentVariables
	}
	if kod.Properties != nil {
		objectMap["properties"] = kod.Properties
	}
	return json.Marshal(objectMap)
}

// AsKubernetesOnlineDeployment is the BasicOnlineDeployment implementation for KubernetesOnlineDeployment.
func (kod KubernetesOnlineDeployment) AsKubernetesOnlineDeployment() (*KubernetesOnlineDeployment, bool) {
	return &kod, true
}

// AsManagedOnlineDeployment is the BasicOnlineDeployment implementation for KubernetesOnlineDeployment.
func (kod KubernetesOnlineDeployment) AsManagedOnlineDeployment() (*ManagedOnlineDeployment, bool) {
	return nil, false
}

// AsOnlineDeployment is the BasicOnlineDeployment implementation for KubernetesOnlineDeployment.
func (kod KubernetesOnlineDeployment) AsOnlineDeployment() (*OnlineDeployment, bool) {
	return nil, false
}

// AsBasicOnlineDeployment is the BasicOnlineDeployment implementation for KubernetesOnlineDeployment.
func (kod KubernetesOnlineDeployment) AsBasicOnlineDeployment() (BasicOnlineDeployment, bool) {
	return &kod, true
}

// UnmarshalJSON is the custom unmarshaler for KubernetesOnlineDeployment struct.
func (kod *KubernetesOnlineDeployment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "containerResourceRequirements":
			if v != nil {
				var containerResourceRequirements ContainerResourceRequirements
				err = json.Unmarshal(*v, &containerResourceRequirements)
				if err != nil {
					return err
				}
				kod.ContainerResourceRequirements = &containerResourceRequirements
			}
		case "appInsightsEnabled":
			if v != nil {
				var appInsightsEnabled bool
				err = json.Unmarshal(*v, &appInsightsEnabled)
				if err != nil {
					return err
				}
				kod.AppInsightsEnabled = &appInsightsEnabled
			}
		case "instanceType":
			if v != nil {
				var instanceType string
				err = json.Unmarshal(*v, &instanceType)
				if err != nil {
					return err
				}
				kod.InstanceType = &instanceType
			}
		case "livenessProbe":
			if v != nil {
				var livenessProbe ProbeSettings
				err = json.Unmarshal(*v, &livenessProbe)
				if err != nil {
					return err
				}
				kod.LivenessProbe = &livenessProbe
			}
		case "model":
			if v != nil {
				var model string
				err = json.Unmarshal(*v, &model)
				if err != nil {
					return err
				}
				kod.Model = &model
			}
		case "modelMountPath":
			if v != nil {
				var modelMountPath string
				err = json.Unmarshal(*v, &modelMountPath)
				if err != nil {
					return err
				}
				kod.ModelMountPath = &modelMountPath
			}
		case "provisioningState":
			if v != nil {
				var provisioningState DeploymentProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				kod.ProvisioningState = provisioningState
			}
		case "readinessProbe":
			if v != nil {
				var readinessProbe ProbeSettings
				err = json.Unmarshal(*v, &readinessProbe)
				if err != nil {
					return err
				}
				kod.ReadinessProbe = &readinessProbe
			}
		case "requestSettings":
			if v != nil {
				var requestSettings OnlineRequestSettings
				err = json.Unmarshal(*v, &requestSettings)
				if err != nil {
					return err
				}
				kod.RequestSettings = &requestSettings
			}
		case "scaleSettings":
			if v != nil {
				scaleSettings, err := unmarshalBasicOnlineScaleSettings(*v)
				if err != nil {
					return err
				}
				kod.ScaleSettings = scaleSettings
			}
		case "endpointComputeType":
			if v != nil {
				var endpointComputeType EndpointComputeTypeBasicOnlineDeployment
				err = json.Unmarshal(*v, &endpointComputeType)
				if err != nil {
					return err
				}
				kod.EndpointComputeType = endpointComputeType
			}
		case "codeConfiguration":
			if v != nil {
				var codeConfiguration CodeConfiguration
				err = json.Unmarshal(*v, &codeConfiguration)
				if err != nil {
					return err
				}
				kod.CodeConfiguration = &codeConfiguration
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				kod.Description = &description
			}
		case "environmentId":
			if v != nil {
				var environmentID string
				err = json.Unmarshal(*v, &environmentID)
				if err != nil {
					return err
				}
				kod.EnvironmentID = &environmentID
			}
		case "environmentVariables":
			if v != nil {
				var environmentVariables map[string]*string
				err = json.Unmarshal(*v, &environmentVariables)
				if err != nil {
					return err
				}
				kod.EnvironmentVariables = environmentVariables
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				kod.Properties = properties
			}
		}
	}

	return nil
}

// KubernetesProperties kubernetes properties
type KubernetesProperties struct {
	// RelayConnectionString - Relay connection string.
	RelayConnectionString *string `json:"relayConnectionString,omitempty"`
	// ServiceBusConnectionString - ServiceBus connection string.
	ServiceBusConnectionString *string `json:"serviceBusConnectionString,omitempty"`
	// ExtensionPrincipalID - Extension principal-id.
	ExtensionPrincipalID *string `json:"extensionPrincipalId,omitempty"`
	// ExtensionInstanceReleaseTrain - Extension instance release train.
	ExtensionInstanceReleaseTrain *string `json:"extensionInstanceReleaseTrain,omitempty"`
	// VcName - VC name.
	VcName *string `json:"vcName,omitempty"`
	// Namespace - Compute namespace
	Namespace *string `json:"namespace,omitempty"`
	// DefaultInstanceType - Default instance type
	DefaultInstanceType *string `json:"defaultInstanceType,omitempty"`
	// InstanceTypes - Instance Type Schema
	InstanceTypes map[string]*InstanceTypeSchema `json:"instanceTypes"`
}

// MarshalJSON is the custom marshaler for KubernetesProperties.
func (kp KubernetesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if kp.RelayConnectionString != nil {
		objectMap["relayConnectionString"] = kp.RelayConnectionString
	}
	if kp.ServiceBusConnectionString != nil {
		objectMap["serviceBusConnectionString"] = kp.ServiceBusConnectionString
	}
	if kp.ExtensionPrincipalID != nil {
		objectMap["extensionPrincipalId"] = kp.ExtensionPrincipalID
	}
	if kp.ExtensionInstanceReleaseTrain != nil {
		objectMap["extensionInstanceReleaseTrain"] = kp.ExtensionInstanceReleaseTrain
	}
	if kp.VcName != nil {
		objectMap["vcName"] = kp.VcName
	}
	if kp.Namespace != nil {
		objectMap["namespace"] = kp.Namespace
	}
	if kp.DefaultInstanceType != nil {
		objectMap["defaultInstanceType"] = kp.DefaultInstanceType
	}
	if kp.InstanceTypes != nil {
		objectMap["instanceTypes"] = kp.InstanceTypes
	}
	return json.Marshal(objectMap)
}

// KubernetesSchema kubernetes Compute Schema
type KubernetesSchema struct {
	// Properties - Properties of Kubernetes
	Properties *KubernetesProperties `json:"properties,omitempty"`
}

// ListAmlUserFeatureResult the List Aml user feature operation response.
type ListAmlUserFeatureResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of AML user facing features.
	Value *[]AmlUserFeature `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URI to fetch the next page of AML user features information. Call ListNext() with this to fetch the next page of AML user features information.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ListAmlUserFeatureResult.
func (laufr ListAmlUserFeatureResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListAmlUserFeatureResultIterator provides access to a complete listing of AmlUserFeature values.
type ListAmlUserFeatureResultIterator struct {
	i    int
	page ListAmlUserFeatureResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListAmlUserFeatureResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListAmlUserFeatureResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListAmlUserFeatureResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListAmlUserFeatureResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListAmlUserFeatureResultIterator) Response() ListAmlUserFeatureResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListAmlUserFeatureResultIterator) Value() AmlUserFeature {
	if !iter.page.NotDone() {
		return AmlUserFeature{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListAmlUserFeatureResultIterator type.
func NewListAmlUserFeatureResultIterator(page ListAmlUserFeatureResultPage) ListAmlUserFeatureResultIterator {
	return ListAmlUserFeatureResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (laufr ListAmlUserFeatureResult) IsEmpty() bool {
	return laufr.Value == nil || len(*laufr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (laufr ListAmlUserFeatureResult) hasNextLink() bool {
	return laufr.NextLink != nil && len(*laufr.NextLink) != 0
}

// listAmlUserFeatureResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (laufr ListAmlUserFeatureResult) listAmlUserFeatureResultPreparer(ctx context.Context) (*http.Request, error) {
	if !laufr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(laufr.NextLink)))
}

// ListAmlUserFeatureResultPage contains a page of AmlUserFeature values.
type ListAmlUserFeatureResultPage struct {
	fn    func(context.Context, ListAmlUserFeatureResult) (ListAmlUserFeatureResult, error)
	laufr ListAmlUserFeatureResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListAmlUserFeatureResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListAmlUserFeatureResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.laufr)
		if err != nil {
			return err
		}
		page.laufr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListAmlUserFeatureResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListAmlUserFeatureResultPage) NotDone() bool {
	return !page.laufr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListAmlUserFeatureResultPage) Response() ListAmlUserFeatureResult {
	return page.laufr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListAmlUserFeatureResultPage) Values() []AmlUserFeature {
	if page.laufr.IsEmpty() {
		return nil
	}
	return *page.laufr.Value
}

// Creates a new instance of the ListAmlUserFeatureResultPage type.
func NewListAmlUserFeatureResultPage(cur ListAmlUserFeatureResult, getNextPage func(context.Context, ListAmlUserFeatureResult) (ListAmlUserFeatureResult, error)) ListAmlUserFeatureResultPage {
	return ListAmlUserFeatureResultPage{
		fn:    getNextPage,
		laufr: cur,
	}
}

// ListNotebookKeysResult ...
type ListNotebookKeysResult struct {
	autorest.Response `json:"-"`
	// PrimaryAccessKey - READ-ONLY
	PrimaryAccessKey *string `json:"primaryAccessKey,omitempty"`
	// SecondaryAccessKey - READ-ONLY
	SecondaryAccessKey *string `json:"secondaryAccessKey,omitempty"`
}

// MarshalJSON is the custom marshaler for ListNotebookKeysResult.
func (lnkr ListNotebookKeysResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListStorageAccountKeysResult ...
type ListStorageAccountKeysResult struct {
	autorest.Response `json:"-"`
	// UserStorageKey - READ-ONLY
	UserStorageKey *string `json:"userStorageKey,omitempty"`
}

// MarshalJSON is the custom marshaler for ListStorageAccountKeysResult.
func (lsakr ListStorageAccountKeysResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListUsagesResult the List Usages operation response.
type ListUsagesResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of AML resource usages.
	Value *[]Usage `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URI to fetch the next page of AML resource usage information. Call ListNext() with this to fetch the next page of AML resource usage information.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ListUsagesResult.
func (lur ListUsagesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListUsagesResultIterator provides access to a complete listing of Usage values.
type ListUsagesResultIterator struct {
	i    int
	page ListUsagesResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListUsagesResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListUsagesResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListUsagesResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListUsagesResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListUsagesResultIterator) Response() ListUsagesResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListUsagesResultIterator) Value() Usage {
	if !iter.page.NotDone() {
		return Usage{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListUsagesResultIterator type.
func NewListUsagesResultIterator(page ListUsagesResultPage) ListUsagesResultIterator {
	return ListUsagesResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lur ListUsagesResult) IsEmpty() bool {
	return lur.Value == nil || len(*lur.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lur ListUsagesResult) hasNextLink() bool {
	return lur.NextLink != nil && len(*lur.NextLink) != 0
}

// listUsagesResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lur ListUsagesResult) listUsagesResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lur.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lur.NextLink)))
}

// ListUsagesResultPage contains a page of Usage values.
type ListUsagesResultPage struct {
	fn  func(context.Context, ListUsagesResult) (ListUsagesResult, error)
	lur ListUsagesResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListUsagesResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListUsagesResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lur)
		if err != nil {
			return err
		}
		page.lur = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListUsagesResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListUsagesResultPage) NotDone() bool {
	return !page.lur.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListUsagesResultPage) Response() ListUsagesResult {
	return page.lur
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListUsagesResultPage) Values() []Usage {
	if page.lur.IsEmpty() {
		return nil
	}
	return *page.lur.Value
}

// Creates a new instance of the ListUsagesResultPage type.
func NewListUsagesResultPage(cur ListUsagesResult, getNextPage func(context.Context, ListUsagesResult) (ListUsagesResult, error)) ListUsagesResultPage {
	return ListUsagesResultPage{
		fn:  getNextPage,
		lur: cur,
	}
}

// ListWorkspaceKeysResult ...
type ListWorkspaceKeysResult struct {
	autorest.Response `json:"-"`
	// UserStorageKey - READ-ONLY
	UserStorageKey *string `json:"userStorageKey,omitempty"`
	// UserStorageResourceID - READ-ONLY
	UserStorageResourceID *string `json:"userStorageResourceId,omitempty"`
	// AppInsightsInstrumentationKey - READ-ONLY
	AppInsightsInstrumentationKey *string `json:"appInsightsInstrumentationKey,omitempty"`
	// ContainerRegistryCredentials - READ-ONLY
	ContainerRegistryCredentials *RegistryListCredentialsResult `json:"containerRegistryCredentials,omitempty"`
	// NotebookAccessKeys - READ-ONLY
	NotebookAccessKeys *ListNotebookKeysResult `json:"notebookAccessKeys,omitempty"`
}

// MarshalJSON is the custom marshaler for ListWorkspaceKeysResult.
func (lwkr ListWorkspaceKeysResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListWorkspaceQuotas the List WorkspaceQuotasByVMFamily operation response.
type ListWorkspaceQuotas struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of Workspace Quotas by VM Family
	Value *[]ResourceQuota `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URI to fetch the next page of workspace quota information by VM Family. Call ListNext() with this to fetch the next page of Workspace Quota information.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ListWorkspaceQuotas.
func (lwq ListWorkspaceQuotas) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ListWorkspaceQuotasIterator provides access to a complete listing of ResourceQuota values.
type ListWorkspaceQuotasIterator struct {
	i    int
	page ListWorkspaceQuotasPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListWorkspaceQuotasIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListWorkspaceQuotasIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListWorkspaceQuotasIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListWorkspaceQuotasIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListWorkspaceQuotasIterator) Response() ListWorkspaceQuotas {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListWorkspaceQuotasIterator) Value() ResourceQuota {
	if !iter.page.NotDone() {
		return ResourceQuota{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListWorkspaceQuotasIterator type.
func NewListWorkspaceQuotasIterator(page ListWorkspaceQuotasPage) ListWorkspaceQuotasIterator {
	return ListWorkspaceQuotasIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lwq ListWorkspaceQuotas) IsEmpty() bool {
	return lwq.Value == nil || len(*lwq.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lwq ListWorkspaceQuotas) hasNextLink() bool {
	return lwq.NextLink != nil && len(*lwq.NextLink) != 0
}

// listWorkspaceQuotasPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lwq ListWorkspaceQuotas) listWorkspaceQuotasPreparer(ctx context.Context) (*http.Request, error) {
	if !lwq.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lwq.NextLink)))
}

// ListWorkspaceQuotasPage contains a page of ResourceQuota values.
type ListWorkspaceQuotasPage struct {
	fn  func(context.Context, ListWorkspaceQuotas) (ListWorkspaceQuotas, error)
	lwq ListWorkspaceQuotas
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListWorkspaceQuotasPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListWorkspaceQuotasPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lwq)
		if err != nil {
			return err
		}
		page.lwq = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListWorkspaceQuotasPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListWorkspaceQuotasPage) NotDone() bool {
	return !page.lwq.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListWorkspaceQuotasPage) Response() ListWorkspaceQuotas {
	return page.lwq
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListWorkspaceQuotasPage) Values() []ResourceQuota {
	if page.lwq.IsEmpty() {
		return nil
	}
	return *page.lwq.Value
}

// Creates a new instance of the ListWorkspaceQuotasPage type.
func NewListWorkspaceQuotasPage(cur ListWorkspaceQuotas, getNextPage func(context.Context, ListWorkspaceQuotas) (ListWorkspaceQuotas, error)) ListWorkspaceQuotasPage {
	return ListWorkspaceQuotasPage{
		fn:  getNextPage,
		lwq: cur,
	}
}

// LiteralJobInput literal input type.
type LiteralJobInput struct {
	// Value - [Required] Literal value for the input.
	Value *string `json:"value,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - Possible values include: 'JobInputTypeJobInput', 'JobInputTypeLiteral1'
	JobInputType JobInputTypeBasicJobInput `json:"jobInputType,omitempty"`
}

// MarshalJSON is the custom marshaler for LiteralJobInput.
func (lji LiteralJobInput) MarshalJSON() ([]byte, error) {
	lji.JobInputType = JobInputTypeLiteral1
	objectMap := make(map[string]interface{})
	if lji.Value != nil {
		objectMap["value"] = lji.Value
	}
	if lji.Description != nil {
		objectMap["description"] = lji.Description
	}
	if lji.JobInputType != "" {
		objectMap["jobInputType"] = lji.JobInputType
	}
	return json.Marshal(objectMap)
}

// AsLiteralJobInput is the BasicJobInput implementation for LiteralJobInput.
func (lji LiteralJobInput) AsLiteralJobInput() (*LiteralJobInput, bool) {
	return &lji, true
}

// AsJobInput is the BasicJobInput implementation for LiteralJobInput.
func (lji LiteralJobInput) AsJobInput() (*JobInput, bool) {
	return nil, false
}

// AsBasicJobInput is the BasicJobInput implementation for LiteralJobInput.
func (lji LiteralJobInput) AsBasicJobInput() (BasicJobInput, bool) {
	return &lji, true
}

// ManagedIdentity managed identity configuration.
type ManagedIdentity struct {
	// ClientID - Specifies a user-assigned identity by client ID. For system-assigned, do not set this field.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// ObjectID - Specifies a user-assigned identity by object ID. For system-assigned, do not set this field.
	ObjectID *uuid.UUID `json:"objectId,omitempty"`
	// ResourceID - Specifies a user-assigned identity by ARM resource ID. For system-assigned, do not set this field.
	ResourceID *string `json:"resourceId,omitempty"`
	// IdentityType - Possible values include: 'IdentityTypeIdentityConfiguration', 'IdentityTypeAMLToken', 'IdentityTypeManaged', 'IdentityTypeUserIdentity'
	IdentityType IdentityType `json:"identityType,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagedIdentity.
func (mi ManagedIdentity) MarshalJSON() ([]byte, error) {
	mi.IdentityType = IdentityTypeManaged
	objectMap := make(map[string]interface{})
	if mi.ClientID != nil {
		objectMap["clientId"] = mi.ClientID
	}
	if mi.ObjectID != nil {
		objectMap["objectId"] = mi.ObjectID
	}
	if mi.ResourceID != nil {
		objectMap["resourceId"] = mi.ResourceID
	}
	if mi.IdentityType != "" {
		objectMap["identityType"] = mi.IdentityType
	}
	return json.Marshal(objectMap)
}

// AsAmlToken is the BasicIdentityConfiguration implementation for ManagedIdentity.
func (mi ManagedIdentity) AsAmlToken() (*AmlToken, bool) {
	return nil, false
}

// AsManagedIdentity is the BasicIdentityConfiguration implementation for ManagedIdentity.
func (mi ManagedIdentity) AsManagedIdentity() (*ManagedIdentity, bool) {
	return &mi, true
}

// AsUserIdentity is the BasicIdentityConfiguration implementation for ManagedIdentity.
func (mi ManagedIdentity) AsUserIdentity() (*UserIdentity, bool) {
	return nil, false
}

// AsIdentityConfiguration is the BasicIdentityConfiguration implementation for ManagedIdentity.
func (mi ManagedIdentity) AsIdentityConfiguration() (*IdentityConfiguration, bool) {
	return nil, false
}

// AsBasicIdentityConfiguration is the BasicIdentityConfiguration implementation for ManagedIdentity.
func (mi ManagedIdentity) AsBasicIdentityConfiguration() (BasicIdentityConfiguration, bool) {
	return &mi, true
}

// ManagedIdentityAuthTypeWorkspaceConnectionProperties ...
type ManagedIdentityAuthTypeWorkspaceConnectionProperties struct {
	Credentials *WorkspaceConnectionManagedIdentity `json:"credentials,omitempty"`
	// Category - Possible values include: 'PythonFeed', 'ContainerRegistry', 'Git'
	Category ConnectionCategory `json:"category,omitempty"`
	Target   *string            `json:"target,omitempty"`
	// Value - Value details of the workspace connection.
	Value *string `json:"value,omitempty"`
	// ValueFormat - format for the workspace connection value. Possible values include: 'JSON'
	ValueFormat ValueFormat `json:"valueFormat,omitempty"`
	// AuthType - Possible values include: 'AuthTypeWorkspaceConnectionPropertiesV2', 'AuthTypePAT', 'AuthTypeSAS', 'AuthTypeUsernamePassword', 'AuthTypeNone', 'AuthTypeManagedIdentity'
	AuthType AuthType `json:"authType,omitempty"`
}

// MarshalJSON is the custom marshaler for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	miatwcp.AuthType = AuthTypeManagedIdentity
	objectMap := make(map[string]interface{})
	if miatwcp.Credentials != nil {
		objectMap["credentials"] = miatwcp.Credentials
	}
	if miatwcp.Category != "" {
		objectMap["category"] = miatwcp.Category
	}
	if miatwcp.Target != nil {
		objectMap["target"] = miatwcp.Target
	}
	if miatwcp.Value != nil {
		objectMap["value"] = miatwcp.Value
	}
	if miatwcp.ValueFormat != "" {
		objectMap["valueFormat"] = miatwcp.ValueFormat
	}
	if miatwcp.AuthType != "" {
		objectMap["authType"] = miatwcp.AuthType
	}
	return json.Marshal(objectMap)
}

// AsPATAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsSASAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsUsernamePasswordAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsNoneAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsManagedIdentityAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool) {
	return &miatwcp, true
}

// AsWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool) {
	return nil, false
}

// AsBasicWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for ManagedIdentityAuthTypeWorkspaceConnectionProperties.
func (miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties) AsBasicWorkspaceConnectionPropertiesV2() (BasicWorkspaceConnectionPropertiesV2, bool) {
	return &miatwcp, true
}

// ManagedOnlineDeployment properties specific to a ManagedOnlineDeployment.
type ManagedOnlineDeployment struct {
	// AppInsightsEnabled - If true, enables Application Insights logging.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// InstanceType - Compute instance type.
	InstanceType *string `json:"instanceType,omitempty"`
	// LivenessProbe - Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `json:"livenessProbe,omitempty"`
	// Model - The URI path to the model.
	Model *string `json:"model,omitempty"`
	// ModelMountPath - The path to mount the model in custom container.
	ModelMountPath *string `json:"modelMountPath,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state for the endpoint deployment. Possible values include: 'DeploymentProvisioningStateCreating', 'DeploymentProvisioningStateDeleting', 'DeploymentProvisioningStateScaling', 'DeploymentProvisioningStateUpdating', 'DeploymentProvisioningStateSucceeded', 'DeploymentProvisioningStateFailed', 'DeploymentProvisioningStateCanceled'
	ProvisioningState DeploymentProvisioningState `json:"provisioningState,omitempty"`
	// ReadinessProbe - Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `json:"readinessProbe,omitempty"`
	// RequestSettings - Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `json:"requestSettings,omitempty"`
	// ScaleSettings - Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings BasicOnlineScaleSettings `json:"scaleSettings,omitempty"`
	// EndpointComputeType - Possible values include: 'EndpointComputeTypeOnlineDeployment', 'EndpointComputeTypeKubernetes1', 'EndpointComputeTypeManaged1'
	EndpointComputeType EndpointComputeTypeBasicOnlineDeployment `json:"endpointComputeType,omitempty"`
	// CodeConfiguration - Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `json:"codeConfiguration,omitempty"`
	// Description - Description of the endpoint deployment.
	Description *string `json:"description,omitempty"`
	// EnvironmentID - ARM resource ID or AssetId of the environment specification for the endpoint deployment.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables configuration for the deployment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
}

// MarshalJSON is the custom marshaler for ManagedOnlineDeployment.
func (mod ManagedOnlineDeployment) MarshalJSON() ([]byte, error) {
	mod.EndpointComputeType = EndpointComputeTypeManaged1
	objectMap := make(map[string]interface{})
	if mod.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = mod.AppInsightsEnabled
	}
	if mod.InstanceType != nil {
		objectMap["instanceType"] = mod.InstanceType
	}
	if mod.LivenessProbe != nil {
		objectMap["livenessProbe"] = mod.LivenessProbe
	}
	if mod.Model != nil {
		objectMap["model"] = mod.Model
	}
	if mod.ModelMountPath != nil {
		objectMap["modelMountPath"] = mod.ModelMountPath
	}
	if mod.ReadinessProbe != nil {
		objectMap["readinessProbe"] = mod.ReadinessProbe
	}
	if mod.RequestSettings != nil {
		objectMap["requestSettings"] = mod.RequestSettings
	}
	objectMap["scaleSettings"] = mod.ScaleSettings
	if mod.EndpointComputeType != "" {
		objectMap["endpointComputeType"] = mod.EndpointComputeType
	}
	if mod.CodeConfiguration != nil {
		objectMap["codeConfiguration"] = mod.CodeConfiguration
	}
	if mod.Description != nil {
		objectMap["description"] = mod.Description
	}
	if mod.EnvironmentID != nil {
		objectMap["environmentId"] = mod.EnvironmentID
	}
	if mod.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = mod.EnvironmentVariables
	}
	if mod.Properties != nil {
		objectMap["properties"] = mod.Properties
	}
	return json.Marshal(objectMap)
}

// AsKubernetesOnlineDeployment is the BasicOnlineDeployment implementation for ManagedOnlineDeployment.
func (mod ManagedOnlineDeployment) AsKubernetesOnlineDeployment() (*KubernetesOnlineDeployment, bool) {
	return nil, false
}

// AsManagedOnlineDeployment is the BasicOnlineDeployment implementation for ManagedOnlineDeployment.
func (mod ManagedOnlineDeployment) AsManagedOnlineDeployment() (*ManagedOnlineDeployment, bool) {
	return &mod, true
}

// AsOnlineDeployment is the BasicOnlineDeployment implementation for ManagedOnlineDeployment.
func (mod ManagedOnlineDeployment) AsOnlineDeployment() (*OnlineDeployment, bool) {
	return nil, false
}

// AsBasicOnlineDeployment is the BasicOnlineDeployment implementation for ManagedOnlineDeployment.
func (mod ManagedOnlineDeployment) AsBasicOnlineDeployment() (BasicOnlineDeployment, bool) {
	return &mod, true
}

// UnmarshalJSON is the custom unmarshaler for ManagedOnlineDeployment struct.
func (mod *ManagedOnlineDeployment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "appInsightsEnabled":
			if v != nil {
				var appInsightsEnabled bool
				err = json.Unmarshal(*v, &appInsightsEnabled)
				if err != nil {
					return err
				}
				mod.AppInsightsEnabled = &appInsightsEnabled
			}
		case "instanceType":
			if v != nil {
				var instanceType string
				err = json.Unmarshal(*v, &instanceType)
				if err != nil {
					return err
				}
				mod.InstanceType = &instanceType
			}
		case "livenessProbe":
			if v != nil {
				var livenessProbe ProbeSettings
				err = json.Unmarshal(*v, &livenessProbe)
				if err != nil {
					return err
				}
				mod.LivenessProbe = &livenessProbe
			}
		case "model":
			if v != nil {
				var model string
				err = json.Unmarshal(*v, &model)
				if err != nil {
					return err
				}
				mod.Model = &model
			}
		case "modelMountPath":
			if v != nil {
				var modelMountPath string
				err = json.Unmarshal(*v, &modelMountPath)
				if err != nil {
					return err
				}
				mod.ModelMountPath = &modelMountPath
			}
		case "provisioningState":
			if v != nil {
				var provisioningState DeploymentProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				mod.ProvisioningState = provisioningState
			}
		case "readinessProbe":
			if v != nil {
				var readinessProbe ProbeSettings
				err = json.Unmarshal(*v, &readinessProbe)
				if err != nil {
					return err
				}
				mod.ReadinessProbe = &readinessProbe
			}
		case "requestSettings":
			if v != nil {
				var requestSettings OnlineRequestSettings
				err = json.Unmarshal(*v, &requestSettings)
				if err != nil {
					return err
				}
				mod.RequestSettings = &requestSettings
			}
		case "scaleSettings":
			if v != nil {
				scaleSettings, err := unmarshalBasicOnlineScaleSettings(*v)
				if err != nil {
					return err
				}
				mod.ScaleSettings = scaleSettings
			}
		case "endpointComputeType":
			if v != nil {
				var endpointComputeType EndpointComputeTypeBasicOnlineDeployment
				err = json.Unmarshal(*v, &endpointComputeType)
				if err != nil {
					return err
				}
				mod.EndpointComputeType = endpointComputeType
			}
		case "codeConfiguration":
			if v != nil {
				var codeConfiguration CodeConfiguration
				err = json.Unmarshal(*v, &codeConfiguration)
				if err != nil {
					return err
				}
				mod.CodeConfiguration = &codeConfiguration
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				mod.Description = &description
			}
		case "environmentId":
			if v != nil {
				var environmentID string
				err = json.Unmarshal(*v, &environmentID)
				if err != nil {
					return err
				}
				mod.EnvironmentID = &environmentID
			}
		case "environmentVariables":
			if v != nil {
				var environmentVariables map[string]*string
				err = json.Unmarshal(*v, &environmentVariables)
				if err != nil {
					return err
				}
				mod.EnvironmentVariables = environmentVariables
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				mod.Properties = properties
			}
		}
	}

	return nil
}

// ManagedServiceIdentity managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// PrincipalID - READ-ONLY; The service principal ID of the system assigned identity. This property will only be provided for a system assigned identity.
	PrincipalID *uuid.UUID `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of the system assigned identity. This property will only be provided for a system assigned identity.
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// Type - Possible values include: 'ManagedServiceIdentityTypeNone', 'ManagedServiceIdentityTypeSystemAssigned', 'ManagedServiceIdentityTypeUserAssigned', 'ManagedServiceIdentityTypeSystemAssignedUserAssigned'
	Type                   ManagedServiceIdentityType       `json:"type,omitempty"`
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for ManagedServiceIdentity.
func (msi ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if msi.Type != "" {
		objectMap["type"] = msi.Type
	}
	if msi.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = msi.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// MedianStoppingPolicy defines an early termination policy based on running averages of the primary metric
// of all runs
type MedianStoppingPolicy struct {
	// DelayEvaluation - Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int32 `json:"delayEvaluation,omitempty"`
	// EvaluationInterval - Interval (number of runs) between policy evaluations.
	EvaluationInterval *int32 `json:"evaluationInterval,omitempty"`
	// PolicyType - Possible values include: 'PolicyTypeEarlyTerminationPolicy', 'PolicyTypeBandit', 'PolicyTypeMedianStopping', 'PolicyTypeTruncationSelection'
	PolicyType PolicyType `json:"policyType,omitempty"`
}

// MarshalJSON is the custom marshaler for MedianStoppingPolicy.
func (msp MedianStoppingPolicy) MarshalJSON() ([]byte, error) {
	msp.PolicyType = PolicyTypeMedianStopping
	objectMap := make(map[string]interface{})
	if msp.DelayEvaluation != nil {
		objectMap["delayEvaluation"] = msp.DelayEvaluation
	}
	if msp.EvaluationInterval != nil {
		objectMap["evaluationInterval"] = msp.EvaluationInterval
	}
	if msp.PolicyType != "" {
		objectMap["policyType"] = msp.PolicyType
	}
	return json.Marshal(objectMap)
}

// AsBanditPolicy is the BasicEarlyTerminationPolicy implementation for MedianStoppingPolicy.
func (msp MedianStoppingPolicy) AsBanditPolicy() (*BanditPolicy, bool) {
	return nil, false
}

// AsMedianStoppingPolicy is the BasicEarlyTerminationPolicy implementation for MedianStoppingPolicy.
func (msp MedianStoppingPolicy) AsMedianStoppingPolicy() (*MedianStoppingPolicy, bool) {
	return &msp, true
}

// AsTruncationSelectionPolicy is the BasicEarlyTerminationPolicy implementation for MedianStoppingPolicy.
func (msp MedianStoppingPolicy) AsTruncationSelectionPolicy() (*TruncationSelectionPolicy, bool) {
	return nil, false
}

// AsEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for MedianStoppingPolicy.
func (msp MedianStoppingPolicy) AsEarlyTerminationPolicy() (*EarlyTerminationPolicy, bool) {
	return nil, false
}

// AsBasicEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for MedianStoppingPolicy.
func (msp MedianStoppingPolicy) AsBasicEarlyTerminationPolicy() (BasicEarlyTerminationPolicy, bool) {
	return &msp, true
}

// MLFlowModelJobInput ...
type MLFlowModelJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - [Required] Specifies the type of job. Possible values include: 'JobInputTypeLiteral', 'JobInputTypeURIFile', 'JobInputTypeURIFolder', 'JobInputTypeMltable', 'JobInputTypeCustomModel', 'JobInputTypeMlflowModel', 'JobInputTypeTritonModel'
	JobInputType JobInputType `json:"jobInputType,omitempty"`
}

// MLFlowModelJobOutput ...
type MLFlowModelJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - [Required] Specifies the type of job. Possible values include: 'JobOutputTypeURIFile', 'JobOutputTypeURIFolder', 'JobOutputTypeMltable', 'JobOutputTypeCustomModel', 'JobOutputTypeMlflowModel', 'JobOutputTypeTritonModel'
	JobOutputType JobOutputType `json:"jobOutputType,omitempty"`
}

// MLTableData mLTable data definition
type MLTableData struct {
	// ReferencedUris - Uris referenced in the MLTable definition (required for lineage)
	ReferencedUris *[]string `json:"referencedUris,omitempty"`
	// DataURI - [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220501.Assets.DataVersionBase.DataType
	DataURI *string `json:"dataUri,omitempty"`
	// DataType - Possible values include: 'DataTypeDataVersionBase', 'DataTypeMltable', 'DataTypeURIFile', 'DataTypeURIFolder'
	DataType DataTypeBasicDataVersionBase `json:"dataType,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for MLTableData.
func (mtd MLTableData) MarshalJSON() ([]byte, error) {
	mtd.DataType = DataTypeMltable
	objectMap := make(map[string]interface{})
	if mtd.ReferencedUris != nil {
		objectMap["referencedUris"] = mtd.ReferencedUris
	}
	if mtd.DataURI != nil {
		objectMap["dataUri"] = mtd.DataURI
	}
	if mtd.DataType != "" {
		objectMap["dataType"] = mtd.DataType
	}
	if mtd.IsAnonymous != nil {
		objectMap["isAnonymous"] = mtd.IsAnonymous
	}
	if mtd.IsArchived != nil {
		objectMap["isArchived"] = mtd.IsArchived
	}
	if mtd.Description != nil {
		objectMap["description"] = mtd.Description
	}
	if mtd.Properties != nil {
		objectMap["properties"] = mtd.Properties
	}
	if mtd.Tags != nil {
		objectMap["tags"] = mtd.Tags
	}
	return json.Marshal(objectMap)
}

// AsMLTableData is the BasicDataVersionBase implementation for MLTableData.
func (mtd MLTableData) AsMLTableData() (*MLTableData, bool) {
	return &mtd, true
}

// AsURIFileDataVersion is the BasicDataVersionBase implementation for MLTableData.
func (mtd MLTableData) AsURIFileDataVersion() (*URIFileDataVersion, bool) {
	return nil, false
}

// AsURIFolderDataVersion is the BasicDataVersionBase implementation for MLTableData.
func (mtd MLTableData) AsURIFolderDataVersion() (*URIFolderDataVersion, bool) {
	return nil, false
}

// AsDataVersionBase is the BasicDataVersionBase implementation for MLTableData.
func (mtd MLTableData) AsDataVersionBase() (*DataVersionBase, bool) {
	return nil, false
}

// AsBasicDataVersionBase is the BasicDataVersionBase implementation for MLTableData.
func (mtd MLTableData) AsBasicDataVersionBase() (BasicDataVersionBase, bool) {
	return &mtd, true
}

// MLTableJobInput ...
type MLTableJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - [Required] Specifies the type of job. Possible values include: 'JobInputTypeLiteral', 'JobInputTypeURIFile', 'JobInputTypeURIFolder', 'JobInputTypeMltable', 'JobInputTypeCustomModel', 'JobInputTypeMlflowModel', 'JobInputTypeTritonModel'
	JobInputType JobInputType `json:"jobInputType,omitempty"`
}

// MLTableJobOutput ...
type MLTableJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - [Required] Specifies the type of job. Possible values include: 'JobOutputTypeURIFile', 'JobOutputTypeURIFolder', 'JobOutputTypeMltable', 'JobOutputTypeCustomModel', 'JobOutputTypeMlflowModel', 'JobOutputTypeTritonModel'
	JobOutputType JobOutputType `json:"jobOutputType,omitempty"`
}

// ModelContainer ...
type ModelContainer struct {
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// LatestVersion - READ-ONLY; The latest version inside this container.
	LatestVersion *string `json:"latestVersion,omitempty"`
	// NextVersion - READ-ONLY; The next auto incremental version
	NextVersion *string `json:"nextVersion,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ModelContainer.
func (mc ModelContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mc.IsArchived != nil {
		objectMap["isArchived"] = mc.IsArchived
	}
	if mc.Description != nil {
		objectMap["description"] = mc.Description
	}
	if mc.Properties != nil {
		objectMap["properties"] = mc.Properties
	}
	if mc.Tags != nil {
		objectMap["tags"] = mc.Tags
	}
	return json.Marshal(objectMap)
}

// ModelContainerResource azure Resource Manager resource envelope.
type ModelContainerResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *ModelContainer `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ModelContainerResource.
func (mcr ModelContainerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mcr.Properties != nil {
		objectMap["properties"] = mcr.Properties
	}
	return json.Marshal(objectMap)
}

// ModelContainerResourceArmPaginatedResult a paginated list of ModelContainer entities.
type ModelContainerResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of ModelContainer objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type ModelContainer.
	Value *[]ModelContainerResource `json:"value,omitempty"`
}

// ModelContainerResourceArmPaginatedResultIterator provides access to a complete listing of
// ModelContainerResource values.
type ModelContainerResourceArmPaginatedResultIterator struct {
	i    int
	page ModelContainerResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ModelContainerResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ModelContainerResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ModelContainerResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ModelContainerResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ModelContainerResourceArmPaginatedResultIterator) Response() ModelContainerResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ModelContainerResourceArmPaginatedResultIterator) Value() ModelContainerResource {
	if !iter.page.NotDone() {
		return ModelContainerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ModelContainerResourceArmPaginatedResultIterator type.
func NewModelContainerResourceArmPaginatedResultIterator(page ModelContainerResourceArmPaginatedResultPage) ModelContainerResourceArmPaginatedResultIterator {
	return ModelContainerResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mcrapr ModelContainerResourceArmPaginatedResult) IsEmpty() bool {
	return mcrapr.Value == nil || len(*mcrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mcrapr ModelContainerResourceArmPaginatedResult) hasNextLink() bool {
	return mcrapr.NextLink != nil && len(*mcrapr.NextLink) != 0
}

// modelContainerResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mcrapr ModelContainerResourceArmPaginatedResult) modelContainerResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !mcrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mcrapr.NextLink)))
}

// ModelContainerResourceArmPaginatedResultPage contains a page of ModelContainerResource values.
type ModelContainerResourceArmPaginatedResultPage struct {
	fn     func(context.Context, ModelContainerResourceArmPaginatedResult) (ModelContainerResourceArmPaginatedResult, error)
	mcrapr ModelContainerResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ModelContainerResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ModelContainerResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mcrapr)
		if err != nil {
			return err
		}
		page.mcrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ModelContainerResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ModelContainerResourceArmPaginatedResultPage) NotDone() bool {
	return !page.mcrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ModelContainerResourceArmPaginatedResultPage) Response() ModelContainerResourceArmPaginatedResult {
	return page.mcrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ModelContainerResourceArmPaginatedResultPage) Values() []ModelContainerResource {
	if page.mcrapr.IsEmpty() {
		return nil
	}
	return *page.mcrapr.Value
}

// Creates a new instance of the ModelContainerResourceArmPaginatedResultPage type.
func NewModelContainerResourceArmPaginatedResultPage(cur ModelContainerResourceArmPaginatedResult, getNextPage func(context.Context, ModelContainerResourceArmPaginatedResult) (ModelContainerResourceArmPaginatedResult, error)) ModelContainerResourceArmPaginatedResultPage {
	return ModelContainerResourceArmPaginatedResultPage{
		fn:     getNextPage,
		mcrapr: cur,
	}
}

// ModelVersion model asset version details.
type ModelVersion struct {
	// Flavors - Mapping of model flavors to their properties.
	Flavors map[string]*FlavorData `json:"flavors"`
	// JobName - Name of the training job which produced this model
	JobName *string `json:"jobName,omitempty"`
	// ModelType - The storage format for this entity. Used for NCD.
	ModelType *string `json:"modelType,omitempty"`
	// ModelURI - The URI path to the model contents.
	ModelURI *string `json:"modelUri,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ModelVersion.
func (mv ModelVersion) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mv.Flavors != nil {
		objectMap["flavors"] = mv.Flavors
	}
	if mv.JobName != nil {
		objectMap["jobName"] = mv.JobName
	}
	if mv.ModelType != nil {
		objectMap["modelType"] = mv.ModelType
	}
	if mv.ModelURI != nil {
		objectMap["modelUri"] = mv.ModelURI
	}
	if mv.IsAnonymous != nil {
		objectMap["isAnonymous"] = mv.IsAnonymous
	}
	if mv.IsArchived != nil {
		objectMap["isArchived"] = mv.IsArchived
	}
	if mv.Description != nil {
		objectMap["description"] = mv.Description
	}
	if mv.Properties != nil {
		objectMap["properties"] = mv.Properties
	}
	if mv.Tags != nil {
		objectMap["tags"] = mv.Tags
	}
	return json.Marshal(objectMap)
}

// ModelVersionResource azure Resource Manager resource envelope.
type ModelVersionResource struct {
	autorest.Response `json:"-"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *ModelVersion `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ModelVersionResource.
func (mvr ModelVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mvr.Properties != nil {
		objectMap["properties"] = mvr.Properties
	}
	return json.Marshal(objectMap)
}

// ModelVersionResourceArmPaginatedResult a paginated list of ModelVersion entities.
type ModelVersionResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of ModelVersion objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type ModelVersion.
	Value *[]ModelVersionResource `json:"value,omitempty"`
}

// ModelVersionResourceArmPaginatedResultIterator provides access to a complete listing of
// ModelVersionResource values.
type ModelVersionResourceArmPaginatedResultIterator struct {
	i    int
	page ModelVersionResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ModelVersionResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ModelVersionResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ModelVersionResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ModelVersionResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ModelVersionResourceArmPaginatedResultIterator) Response() ModelVersionResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ModelVersionResourceArmPaginatedResultIterator) Value() ModelVersionResource {
	if !iter.page.NotDone() {
		return ModelVersionResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ModelVersionResourceArmPaginatedResultIterator type.
func NewModelVersionResourceArmPaginatedResultIterator(page ModelVersionResourceArmPaginatedResultPage) ModelVersionResourceArmPaginatedResultIterator {
	return ModelVersionResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mvrapr ModelVersionResourceArmPaginatedResult) IsEmpty() bool {
	return mvrapr.Value == nil || len(*mvrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mvrapr ModelVersionResourceArmPaginatedResult) hasNextLink() bool {
	return mvrapr.NextLink != nil && len(*mvrapr.NextLink) != 0
}

// modelVersionResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mvrapr ModelVersionResourceArmPaginatedResult) modelVersionResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !mvrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mvrapr.NextLink)))
}

// ModelVersionResourceArmPaginatedResultPage contains a page of ModelVersionResource values.
type ModelVersionResourceArmPaginatedResultPage struct {
	fn     func(context.Context, ModelVersionResourceArmPaginatedResult) (ModelVersionResourceArmPaginatedResult, error)
	mvrapr ModelVersionResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ModelVersionResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ModelVersionResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mvrapr)
		if err != nil {
			return err
		}
		page.mvrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ModelVersionResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ModelVersionResourceArmPaginatedResultPage) NotDone() bool {
	return !page.mvrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ModelVersionResourceArmPaginatedResultPage) Response() ModelVersionResourceArmPaginatedResult {
	return page.mvrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ModelVersionResourceArmPaginatedResultPage) Values() []ModelVersionResource {
	if page.mvrapr.IsEmpty() {
		return nil
	}
	return *page.mvrapr.Value
}

// Creates a new instance of the ModelVersionResourceArmPaginatedResultPage type.
func NewModelVersionResourceArmPaginatedResultPage(cur ModelVersionResourceArmPaginatedResult, getNextPage func(context.Context, ModelVersionResourceArmPaginatedResult) (ModelVersionResourceArmPaginatedResult, error)) ModelVersionResourceArmPaginatedResultPage {
	return ModelVersionResourceArmPaginatedResultPage{
		fn:     getNextPage,
		mvrapr: cur,
	}
}

// Mpi MPI distribution configuration.
type Mpi struct {
	// ProcessCountPerInstance - Number of processes per MPI node.
	ProcessCountPerInstance *int32 `json:"processCountPerInstance,omitempty"`
	// DistributionType - Possible values include: 'DistributionTypeDistributionConfiguration', 'DistributionTypeMpi1', 'DistributionTypePyTorch1', 'DistributionTypeTensorFlow1'
	DistributionType DistributionTypeBasicDistributionConfiguration `json:"distributionType,omitempty"`
}

// MarshalJSON is the custom marshaler for Mpi.
func (mVar Mpi) MarshalJSON() ([]byte, error) {
	mVar.DistributionType = DistributionTypeMpi1
	objectMap := make(map[string]interface{})
	if mVar.ProcessCountPerInstance != nil {
		objectMap["processCountPerInstance"] = mVar.ProcessCountPerInstance
	}
	if mVar.DistributionType != "" {
		objectMap["distributionType"] = mVar.DistributionType
	}
	return json.Marshal(objectMap)
}

// AsMpi is the BasicDistributionConfiguration implementation for Mpi.
func (mVar Mpi) AsMpi() (*Mpi, bool) {
	return &mVar, true
}

// AsPyTorch is the BasicDistributionConfiguration implementation for Mpi.
func (mVar Mpi) AsPyTorch() (*PyTorch, bool) {
	return nil, false
}

// AsTensorFlow is the BasicDistributionConfiguration implementation for Mpi.
func (mVar Mpi) AsTensorFlow() (*TensorFlow, bool) {
	return nil, false
}

// AsDistributionConfiguration is the BasicDistributionConfiguration implementation for Mpi.
func (mVar Mpi) AsDistributionConfiguration() (*DistributionConfiguration, bool) {
	return nil, false
}

// AsBasicDistributionConfiguration is the BasicDistributionConfiguration implementation for Mpi.
func (mVar Mpi) AsBasicDistributionConfiguration() (BasicDistributionConfiguration, bool) {
	return &mVar, true
}

// NodeStateCounts counts of various compute node states on the amlCompute.
type NodeStateCounts struct {
	// IdleNodeCount - READ-ONLY; Number of compute nodes in idle state.
	IdleNodeCount *int32 `json:"idleNodeCount,omitempty"`
	// RunningNodeCount - READ-ONLY; Number of compute nodes which are running jobs.
	RunningNodeCount *int32 `json:"runningNodeCount,omitempty"`
	// PreparingNodeCount - READ-ONLY; Number of compute nodes which are being prepared.
	PreparingNodeCount *int32 `json:"preparingNodeCount,omitempty"`
	// UnusableNodeCount - READ-ONLY; Number of compute nodes which are in unusable state.
	UnusableNodeCount *int32 `json:"unusableNodeCount,omitempty"`
	// LeavingNodeCount - READ-ONLY; Number of compute nodes which are leaving the amlCompute.
	LeavingNodeCount *int32 `json:"leavingNodeCount,omitempty"`
	// PreemptedNodeCount - READ-ONLY; Number of compute nodes which are in preempted state.
	PreemptedNodeCount *int32 `json:"preemptedNodeCount,omitempty"`
}

// MarshalJSON is the custom marshaler for NodeStateCounts.
func (nsc NodeStateCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// NoneAuthTypeWorkspaceConnectionProperties ...
type NoneAuthTypeWorkspaceConnectionProperties struct {
	// Category - Possible values include: 'PythonFeed', 'ContainerRegistry', 'Git'
	Category ConnectionCategory `json:"category,omitempty"`
	Target   *string            `json:"target,omitempty"`
	// Value - Value details of the workspace connection.
	Value *string `json:"value,omitempty"`
	// ValueFormat - format for the workspace connection value. Possible values include: 'JSON'
	ValueFormat ValueFormat `json:"valueFormat,omitempty"`
	// AuthType - Possible values include: 'AuthTypeWorkspaceConnectionPropertiesV2', 'AuthTypePAT', 'AuthTypeSAS', 'AuthTypeUsernamePassword', 'AuthTypeNone', 'AuthTypeManagedIdentity'
	AuthType AuthType `json:"authType,omitempty"`
}

// MarshalJSON is the custom marshaler for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	natwcp.AuthType = AuthTypeNone
	objectMap := make(map[string]interface{})
	if natwcp.Category != "" {
		objectMap["category"] = natwcp.Category
	}
	if natwcp.Target != nil {
		objectMap["target"] = natwcp.Target
	}
	if natwcp.Value != nil {
		objectMap["value"] = natwcp.Value
	}
	if natwcp.ValueFormat != "" {
		objectMap["valueFormat"] = natwcp.ValueFormat
	}
	if natwcp.AuthType != "" {
		objectMap["authType"] = natwcp.AuthType
	}
	return json.Marshal(objectMap)
}

// AsPATAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsSASAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsUsernamePasswordAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsNoneAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool) {
	return &natwcp, true
}

// AsManagedIdentityAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool) {
	return nil, false
}

// AsBasicWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for NoneAuthTypeWorkspaceConnectionProperties.
func (natwcp NoneAuthTypeWorkspaceConnectionProperties) AsBasicWorkspaceConnectionPropertiesV2() (BasicWorkspaceConnectionPropertiesV2, bool) {
	return &natwcp, true
}

// NoneDatastoreCredentials empty/none datastore credentials.
type NoneDatastoreCredentials struct {
	// CredentialsType - Possible values include: 'CredentialsTypeDatastoreCredentials', 'CredentialsTypeAccountKey1', 'CredentialsTypeCertificate1', 'CredentialsTypeNone1', 'CredentialsTypeSas1', 'CredentialsTypeServicePrincipal1'
	CredentialsType CredentialsTypeBasicDatastoreCredentials `json:"credentialsType,omitempty"`
}

// MarshalJSON is the custom marshaler for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) MarshalJSON() ([]byte, error) {
	ndc.CredentialsType = CredentialsTypeNone1
	objectMap := make(map[string]interface{})
	if ndc.CredentialsType != "" {
		objectMap["credentialsType"] = ndc.CredentialsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool) {
	return nil, false
}

// AsCertificateDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool) {
	return nil, false
}

// AsNoneDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool) {
	return &ndc, true
}

// AsSasDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool) {
	return nil, false
}

// AsDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsDatastoreCredentials() (*DatastoreCredentials, bool) {
	return nil, false
}

// AsBasicDatastoreCredentials is the BasicDatastoreCredentials implementation for NoneDatastoreCredentials.
func (ndc NoneDatastoreCredentials) AsBasicDatastoreCredentials() (BasicDatastoreCredentials, bool) {
	return &ndc, true
}

// NotebookAccessTokenResult ...
type NotebookAccessTokenResult struct {
	autorest.Response `json:"-"`
	// NotebookResourceID - READ-ONLY
	NotebookResourceID *string `json:"notebookResourceId,omitempty"`
	// HostName - READ-ONLY
	HostName *string `json:"hostName,omitempty"`
	// PublicDNS - READ-ONLY
	PublicDNS *string `json:"publicDns,omitempty"`
	// AccessToken - READ-ONLY
	AccessToken *string `json:"accessToken,omitempty"`
	// TokenType - READ-ONLY
	TokenType *string `json:"tokenType,omitempty"`
	// ExpiresIn - READ-ONLY
	ExpiresIn *int32 `json:"expiresIn,omitempty"`
	// RefreshToken - READ-ONLY
	RefreshToken *string `json:"refreshToken,omitempty"`
	// Scope - READ-ONLY
	Scope *string `json:"scope,omitempty"`
}

// MarshalJSON is the custom marshaler for NotebookAccessTokenResult.
func (natr NotebookAccessTokenResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// NotebookPreparationError ...
type NotebookPreparationError struct {
	ErrorMessage *string `json:"errorMessage,omitempty"`
	StatusCode   *int32  `json:"statusCode,omitempty"`
}

// NotebookResourceInfo ...
type NotebookResourceInfo struct {
	autorest.Response `json:"-"`
	Fqdn              *string `json:"fqdn,omitempty"`
	// ResourceID - the data plane resourceId that used to initialize notebook component
	ResourceID *string `json:"resourceId,omitempty"`
	// NotebookPreparationError - The error that occurs when preparing notebook.
	NotebookPreparationError *NotebookPreparationError `json:"notebookPreparationError,omitempty"`
}

// Objective optimization objective.
type Objective struct {
	// Goal - [Required] Defines supported metric goals for hyperparameter tuning. Possible values include: 'Minimize', 'Maximize'
	Goal Goal `json:"goal,omitempty"`
	// PrimaryMetric - [Required] Name of the metric to optimize.
	PrimaryMetric *string `json:"primaryMetric,omitempty"`
}

// BasicOnlineDeployment ...
type BasicOnlineDeployment interface {
	AsKubernetesOnlineDeployment() (*KubernetesOnlineDeployment, bool)
	AsManagedOnlineDeployment() (*ManagedOnlineDeployment, bool)
	AsOnlineDeployment() (*OnlineDeployment, bool)
}

// OnlineDeployment ...
type OnlineDeployment struct {
	// AppInsightsEnabled - If true, enables Application Insights logging.
	AppInsightsEnabled *bool `json:"appInsightsEnabled,omitempty"`
	// InstanceType - Compute instance type.
	InstanceType *string `json:"instanceType,omitempty"`
	// LivenessProbe - Liveness probe monitors the health of the container regularly.
	LivenessProbe *ProbeSettings `json:"livenessProbe,omitempty"`
	// Model - The URI path to the model.
	Model *string `json:"model,omitempty"`
	// ModelMountPath - The path to mount the model in custom container.
	ModelMountPath *string `json:"modelMountPath,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state for the endpoint deployment. Possible values include: 'DeploymentProvisioningStateCreating', 'DeploymentProvisioningStateDeleting', 'DeploymentProvisioningStateScaling', 'DeploymentProvisioningStateUpdating', 'DeploymentProvisioningStateSucceeded', 'DeploymentProvisioningStateFailed', 'DeploymentProvisioningStateCanceled'
	ProvisioningState DeploymentProvisioningState `json:"provisioningState,omitempty"`
	// ReadinessProbe - Readiness probe validates if the container is ready to serve traffic. The properties and defaults are the same as liveness probe.
	ReadinessProbe *ProbeSettings `json:"readinessProbe,omitempty"`
	// RequestSettings - Request settings for the deployment.
	RequestSettings *OnlineRequestSettings `json:"requestSettings,omitempty"`
	// ScaleSettings - Scale settings for the deployment.
	// If it is null or not provided,
	// it defaults to TargetUtilizationScaleSettings for KubernetesOnlineDeployment
	// and to DefaultScaleSettings for ManagedOnlineDeployment.
	ScaleSettings BasicOnlineScaleSettings `json:"scaleSettings,omitempty"`
	// EndpointComputeType - Possible values include: 'EndpointComputeTypeOnlineDeployment', 'EndpointComputeTypeKubernetes1', 'EndpointComputeTypeManaged1'
	EndpointComputeType EndpointComputeTypeBasicOnlineDeployment `json:"endpointComputeType,omitempty"`
	// CodeConfiguration - Code configuration for the endpoint deployment.
	CodeConfiguration *CodeConfiguration `json:"codeConfiguration,omitempty"`
	// Description - Description of the endpoint deployment.
	Description *string `json:"description,omitempty"`
	// EnvironmentID - ARM resource ID or AssetId of the environment specification for the endpoint deployment.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables configuration for the deployment.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
}

func unmarshalBasicOnlineDeployment(body []byte) (BasicOnlineDeployment, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["endpointComputeType"] {
	case string(EndpointComputeTypeKubernetes1):
		var kod KubernetesOnlineDeployment
		err := json.Unmarshal(body, &kod)
		return kod, err
	case string(EndpointComputeTypeManaged1):
		var mod ManagedOnlineDeployment
		err := json.Unmarshal(body, &mod)
		return mod, err
	default:
		var od OnlineDeployment
		err := json.Unmarshal(body, &od)
		return od, err
	}
}
func unmarshalBasicOnlineDeploymentArray(body []byte) ([]BasicOnlineDeployment, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	odArray := make([]BasicOnlineDeployment, len(rawMessages))

	for index, rawMessage := range rawMessages {
		od, err := unmarshalBasicOnlineDeployment(*rawMessage)
		if err != nil {
			return nil, err
		}
		odArray[index] = od
	}
	return odArray, nil
}

// MarshalJSON is the custom marshaler for OnlineDeployment.
func (od OnlineDeployment) MarshalJSON() ([]byte, error) {
	od.EndpointComputeType = EndpointComputeTypeOnlineDeployment
	objectMap := make(map[string]interface{})
	if od.AppInsightsEnabled != nil {
		objectMap["appInsightsEnabled"] = od.AppInsightsEnabled
	}
	if od.InstanceType != nil {
		objectMap["instanceType"] = od.InstanceType
	}
	if od.LivenessProbe != nil {
		objectMap["livenessProbe"] = od.LivenessProbe
	}
	if od.Model != nil {
		objectMap["model"] = od.Model
	}
	if od.ModelMountPath != nil {
		objectMap["modelMountPath"] = od.ModelMountPath
	}
	if od.ReadinessProbe != nil {
		objectMap["readinessProbe"] = od.ReadinessProbe
	}
	if od.RequestSettings != nil {
		objectMap["requestSettings"] = od.RequestSettings
	}
	objectMap["scaleSettings"] = od.ScaleSettings
	if od.EndpointComputeType != "" {
		objectMap["endpointComputeType"] = od.EndpointComputeType
	}
	if od.CodeConfiguration != nil {
		objectMap["codeConfiguration"] = od.CodeConfiguration
	}
	if od.Description != nil {
		objectMap["description"] = od.Description
	}
	if od.EnvironmentID != nil {
		objectMap["environmentId"] = od.EnvironmentID
	}
	if od.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = od.EnvironmentVariables
	}
	if od.Properties != nil {
		objectMap["properties"] = od.Properties
	}
	return json.Marshal(objectMap)
}

// AsKubernetesOnlineDeployment is the BasicOnlineDeployment implementation for OnlineDeployment.
func (od OnlineDeployment) AsKubernetesOnlineDeployment() (*KubernetesOnlineDeployment, bool) {
	return nil, false
}

// AsManagedOnlineDeployment is the BasicOnlineDeployment implementation for OnlineDeployment.
func (od OnlineDeployment) AsManagedOnlineDeployment() (*ManagedOnlineDeployment, bool) {
	return nil, false
}

// AsOnlineDeployment is the BasicOnlineDeployment implementation for OnlineDeployment.
func (od OnlineDeployment) AsOnlineDeployment() (*OnlineDeployment, bool) {
	return &od, true
}

// AsBasicOnlineDeployment is the BasicOnlineDeployment implementation for OnlineDeployment.
func (od OnlineDeployment) AsBasicOnlineDeployment() (BasicOnlineDeployment, bool) {
	return &od, true
}

// UnmarshalJSON is the custom unmarshaler for OnlineDeployment struct.
func (od *OnlineDeployment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "appInsightsEnabled":
			if v != nil {
				var appInsightsEnabled bool
				err = json.Unmarshal(*v, &appInsightsEnabled)
				if err != nil {
					return err
				}
				od.AppInsightsEnabled = &appInsightsEnabled
			}
		case "instanceType":
			if v != nil {
				var instanceType string
				err = json.Unmarshal(*v, &instanceType)
				if err != nil {
					return err
				}
				od.InstanceType = &instanceType
			}
		case "livenessProbe":
			if v != nil {
				var livenessProbe ProbeSettings
				err = json.Unmarshal(*v, &livenessProbe)
				if err != nil {
					return err
				}
				od.LivenessProbe = &livenessProbe
			}
		case "model":
			if v != nil {
				var model string
				err = json.Unmarshal(*v, &model)
				if err != nil {
					return err
				}
				od.Model = &model
			}
		case "modelMountPath":
			if v != nil {
				var modelMountPath string
				err = json.Unmarshal(*v, &modelMountPath)
				if err != nil {
					return err
				}
				od.ModelMountPath = &modelMountPath
			}
		case "provisioningState":
			if v != nil {
				var provisioningState DeploymentProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				od.ProvisioningState = provisioningState
			}
		case "readinessProbe":
			if v != nil {
				var readinessProbe ProbeSettings
				err = json.Unmarshal(*v, &readinessProbe)
				if err != nil {
					return err
				}
				od.ReadinessProbe = &readinessProbe
			}
		case "requestSettings":
			if v != nil {
				var requestSettings OnlineRequestSettings
				err = json.Unmarshal(*v, &requestSettings)
				if err != nil {
					return err
				}
				od.RequestSettings = &requestSettings
			}
		case "scaleSettings":
			if v != nil {
				scaleSettings, err := unmarshalBasicOnlineScaleSettings(*v)
				if err != nil {
					return err
				}
				od.ScaleSettings = scaleSettings
			}
		case "endpointComputeType":
			if v != nil {
				var endpointComputeType EndpointComputeTypeBasicOnlineDeployment
				err = json.Unmarshal(*v, &endpointComputeType)
				if err != nil {
					return err
				}
				od.EndpointComputeType = endpointComputeType
			}
		case "codeConfiguration":
			if v != nil {
				var codeConfiguration CodeConfiguration
				err = json.Unmarshal(*v, &codeConfiguration)
				if err != nil {
					return err
				}
				od.CodeConfiguration = &codeConfiguration
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				od.Description = &description
			}
		case "environmentId":
			if v != nil {
				var environmentID string
				err = json.Unmarshal(*v, &environmentID)
				if err != nil {
					return err
				}
				od.EnvironmentID = &environmentID
			}
		case "environmentVariables":
			if v != nil {
				var environmentVariables map[string]*string
				err = json.Unmarshal(*v, &environmentVariables)
				if err != nil {
					return err
				}
				od.EnvironmentVariables = environmentVariables
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				od.Properties = properties
			}
		}
	}

	return nil
}

// OnlineDeploymentsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type OnlineDeploymentsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineDeploymentsClient) (OnlineDeploymentTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineDeploymentsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineDeploymentsCreateOrUpdateFuture.Result.
func (future *OnlineDeploymentsCreateOrUpdateFuture) result(client OnlineDeploymentsClient) (odtr OnlineDeploymentTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineDeploymentsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		odtr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineDeploymentsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if odtr.Response.Response, err = future.GetResult(sender); err == nil && odtr.Response.Response.StatusCode != http.StatusNoContent {
		odtr, err = client.CreateOrUpdateResponder(odtr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineDeploymentsCreateOrUpdateFuture", "Result", odtr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OnlineDeploymentsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type OnlineDeploymentsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineDeploymentsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineDeploymentsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineDeploymentsDeleteFuture.Result.
func (future *OnlineDeploymentsDeleteFuture) result(client OnlineDeploymentsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineDeploymentsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineDeploymentsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// OnlineDeploymentsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type OnlineDeploymentsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineDeploymentsClient) (OnlineDeploymentTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineDeploymentsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineDeploymentsUpdateFuture.Result.
func (future *OnlineDeploymentsUpdateFuture) result(client OnlineDeploymentsClient) (odtr OnlineDeploymentTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineDeploymentsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		odtr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineDeploymentsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if odtr.Response.Response, err = future.GetResult(sender); err == nil && odtr.Response.Response.StatusCode != http.StatusNoContent {
		odtr, err = client.UpdateResponder(odtr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineDeploymentsUpdateFuture", "Result", odtr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OnlineDeploymentTrackedResource ...
type OnlineDeploymentTrackedResource struct {
	autorest.Response `json:"-"`
	// Identity - Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`
	// Properties - [Required] Additional attributes of the entity.
	Properties BasicOnlineDeployment `json:"properties,omitempty"`
	// Sku - Sku details required for ARM contract for Autoscaling.
	Sku *Sku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for OnlineDeploymentTrackedResource.
func (odtr OnlineDeploymentTrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if odtr.Identity != nil {
		objectMap["identity"] = odtr.Identity
	}
	if odtr.Kind != nil {
		objectMap["kind"] = odtr.Kind
	}
	objectMap["properties"] = odtr.Properties
	if odtr.Sku != nil {
		objectMap["sku"] = odtr.Sku
	}
	if odtr.Tags != nil {
		objectMap["tags"] = odtr.Tags
	}
	if odtr.Location != nil {
		objectMap["location"] = odtr.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OnlineDeploymentTrackedResource struct.
func (odtr *OnlineDeploymentTrackedResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				odtr.Identity = &identity
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				odtr.Kind = &kind
			}
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicOnlineDeployment(*v)
				if err != nil {
					return err
				}
				odtr.Properties = properties
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				odtr.Sku = &sku
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				odtr.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				odtr.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				odtr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				odtr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				odtr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				odtr.SystemData = &systemData
			}
		}
	}

	return nil
}

// OnlineDeploymentTrackedResourceArmPaginatedResult a paginated list of OnlineDeployment entities.
type OnlineDeploymentTrackedResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of OnlineDeployment objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type OnlineDeployment.
	Value *[]OnlineDeploymentTrackedResource `json:"value,omitempty"`
}

// OnlineDeploymentTrackedResourceArmPaginatedResultIterator provides access to a complete listing of
// OnlineDeploymentTrackedResource values.
type OnlineDeploymentTrackedResourceArmPaginatedResultIterator struct {
	i    int
	page OnlineDeploymentTrackedResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OnlineDeploymentTrackedResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OnlineDeploymentTrackedResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OnlineDeploymentTrackedResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OnlineDeploymentTrackedResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OnlineDeploymentTrackedResourceArmPaginatedResultIterator) Response() OnlineDeploymentTrackedResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OnlineDeploymentTrackedResourceArmPaginatedResultIterator) Value() OnlineDeploymentTrackedResource {
	if !iter.page.NotDone() {
		return OnlineDeploymentTrackedResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OnlineDeploymentTrackedResourceArmPaginatedResultIterator type.
func NewOnlineDeploymentTrackedResourceArmPaginatedResultIterator(page OnlineDeploymentTrackedResourceArmPaginatedResultPage) OnlineDeploymentTrackedResourceArmPaginatedResultIterator {
	return OnlineDeploymentTrackedResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (odtrapr OnlineDeploymentTrackedResourceArmPaginatedResult) IsEmpty() bool {
	return odtrapr.Value == nil || len(*odtrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (odtrapr OnlineDeploymentTrackedResourceArmPaginatedResult) hasNextLink() bool {
	return odtrapr.NextLink != nil && len(*odtrapr.NextLink) != 0
}

// onlineDeploymentTrackedResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (odtrapr OnlineDeploymentTrackedResourceArmPaginatedResult) onlineDeploymentTrackedResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !odtrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(odtrapr.NextLink)))
}

// OnlineDeploymentTrackedResourceArmPaginatedResultPage contains a page of OnlineDeploymentTrackedResource
// values.
type OnlineDeploymentTrackedResourceArmPaginatedResultPage struct {
	fn      func(context.Context, OnlineDeploymentTrackedResourceArmPaginatedResult) (OnlineDeploymentTrackedResourceArmPaginatedResult, error)
	odtrapr OnlineDeploymentTrackedResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OnlineDeploymentTrackedResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OnlineDeploymentTrackedResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.odtrapr)
		if err != nil {
			return err
		}
		page.odtrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OnlineDeploymentTrackedResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OnlineDeploymentTrackedResourceArmPaginatedResultPage) NotDone() bool {
	return !page.odtrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OnlineDeploymentTrackedResourceArmPaginatedResultPage) Response() OnlineDeploymentTrackedResourceArmPaginatedResult {
	return page.odtrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OnlineDeploymentTrackedResourceArmPaginatedResultPage) Values() []OnlineDeploymentTrackedResource {
	if page.odtrapr.IsEmpty() {
		return nil
	}
	return *page.odtrapr.Value
}

// Creates a new instance of the OnlineDeploymentTrackedResourceArmPaginatedResultPage type.
func NewOnlineDeploymentTrackedResourceArmPaginatedResultPage(cur OnlineDeploymentTrackedResourceArmPaginatedResult, getNextPage func(context.Context, OnlineDeploymentTrackedResourceArmPaginatedResult) (OnlineDeploymentTrackedResourceArmPaginatedResult, error)) OnlineDeploymentTrackedResourceArmPaginatedResultPage {
	return OnlineDeploymentTrackedResourceArmPaginatedResultPage{
		fn:      getNextPage,
		odtrapr: cur,
	}
}

// OnlineEndpoint online endpoint configuration
type OnlineEndpoint struct {
	// Compute - ARM resource ID of the compute if it exists.
	// optional
	Compute *string `json:"compute,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state for the endpoint. Possible values include: 'EndpointProvisioningStateCreating', 'EndpointProvisioningStateDeleting', 'EndpointProvisioningStateSucceeded', 'EndpointProvisioningStateFailed', 'EndpointProvisioningStateUpdating', 'EndpointProvisioningStateCanceled'
	ProvisioningState EndpointProvisioningState `json:"provisioningState,omitempty"`
	// Traffic - Percentage of traffic from endpoint to divert to each deployment. Traffic values need to sum to 100.
	Traffic map[string]*int32 `json:"traffic"`
	// AuthMode - [Required] Use 'Key' for key based authentication and 'AMLToken' for Azure Machine Learning token-based authentication. 'Key' doesn't expire but 'AMLToken' does. Possible values include: 'AMLToken', 'Key', 'AADToken'
	AuthMode EndpointAuthMode `json:"authMode,omitempty"`
	// Description - Description of the inference endpoint.
	Description *string `json:"description,omitempty"`
	// Keys - EndpointAuthKeys to set initially on an Endpoint.
	// This property will always be returned as null. AuthKey values must be retrieved using the ListKeys API.
	Keys *EndpointAuthKeys `json:"keys,omitempty"`
	// Properties - Property dictionary. Properties can be added, but not removed or altered.
	Properties map[string]*string `json:"properties"`
	// ScoringURI - READ-ONLY; Endpoint URI.
	ScoringURI *string `json:"scoringUri,omitempty"`
	// SwaggerURI - READ-ONLY; Endpoint Swagger URI.
	SwaggerURI *string `json:"swaggerUri,omitempty"`
}

// MarshalJSON is the custom marshaler for OnlineEndpoint.
func (oe OnlineEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oe.Compute != nil {
		objectMap["compute"] = oe.Compute
	}
	if oe.Traffic != nil {
		objectMap["traffic"] = oe.Traffic
	}
	if oe.AuthMode != "" {
		objectMap["authMode"] = oe.AuthMode
	}
	if oe.Description != nil {
		objectMap["description"] = oe.Description
	}
	if oe.Keys != nil {
		objectMap["keys"] = oe.Keys
	}
	if oe.Properties != nil {
		objectMap["properties"] = oe.Properties
	}
	return json.Marshal(objectMap)
}

// OnlineEndpointsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type OnlineEndpointsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineEndpointsClient) (OnlineEndpointTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineEndpointsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineEndpointsCreateOrUpdateFuture.Result.
func (future *OnlineEndpointsCreateOrUpdateFuture) result(client OnlineEndpointsClient) (oetr OnlineEndpointTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineEndpointsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		oetr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineEndpointsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if oetr.Response.Response, err = future.GetResult(sender); err == nil && oetr.Response.Response.StatusCode != http.StatusNoContent {
		oetr, err = client.CreateOrUpdateResponder(oetr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineEndpointsCreateOrUpdateFuture", "Result", oetr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OnlineEndpointsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type OnlineEndpointsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineEndpointsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineEndpointsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineEndpointsDeleteFuture.Result.
func (future *OnlineEndpointsDeleteFuture) result(client OnlineEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineEndpointsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineEndpointsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// OnlineEndpointsRegenerateKeysFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type OnlineEndpointsRegenerateKeysFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineEndpointsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineEndpointsRegenerateKeysFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineEndpointsRegenerateKeysFuture.Result.
func (future *OnlineEndpointsRegenerateKeysFuture) result(client OnlineEndpointsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineEndpointsRegenerateKeysFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineEndpointsRegenerateKeysFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// OnlineEndpointsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type OnlineEndpointsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OnlineEndpointsClient) (OnlineEndpointTrackedResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OnlineEndpointsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OnlineEndpointsUpdateFuture.Result.
func (future *OnlineEndpointsUpdateFuture) result(client OnlineEndpointsClient) (oetr OnlineEndpointTrackedResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineEndpointsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		oetr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.OnlineEndpointsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if oetr.Response.Response, err = future.GetResult(sender); err == nil && oetr.Response.Response.StatusCode != http.StatusNoContent {
		oetr, err = client.UpdateResponder(oetr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.OnlineEndpointsUpdateFuture", "Result", oetr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OnlineEndpointTrackedResource ...
type OnlineEndpointTrackedResource struct {
	autorest.Response `json:"-"`
	// Identity - Managed service identity (system assigned and/or user assigned identities)
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type.
	Kind *string `json:"kind,omitempty"`
	// Properties - [Required] Additional attributes of the entity.
	Properties *OnlineEndpoint `json:"properties,omitempty"`
	// Sku - Sku details required for ARM contract for Autoscaling.
	Sku *Sku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for OnlineEndpointTrackedResource.
func (oetr OnlineEndpointTrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oetr.Identity != nil {
		objectMap["identity"] = oetr.Identity
	}
	if oetr.Kind != nil {
		objectMap["kind"] = oetr.Kind
	}
	if oetr.Properties != nil {
		objectMap["properties"] = oetr.Properties
	}
	if oetr.Sku != nil {
		objectMap["sku"] = oetr.Sku
	}
	if oetr.Tags != nil {
		objectMap["tags"] = oetr.Tags
	}
	if oetr.Location != nil {
		objectMap["location"] = oetr.Location
	}
	return json.Marshal(objectMap)
}

// OnlineEndpointTrackedResourceArmPaginatedResult a paginated list of OnlineEndpoint entities.
type OnlineEndpointTrackedResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of OnlineEndpoint objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type OnlineEndpoint.
	Value *[]OnlineEndpointTrackedResource `json:"value,omitempty"`
}

// OnlineEndpointTrackedResourceArmPaginatedResultIterator provides access to a complete listing of
// OnlineEndpointTrackedResource values.
type OnlineEndpointTrackedResourceArmPaginatedResultIterator struct {
	i    int
	page OnlineEndpointTrackedResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OnlineEndpointTrackedResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OnlineEndpointTrackedResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OnlineEndpointTrackedResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OnlineEndpointTrackedResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OnlineEndpointTrackedResourceArmPaginatedResultIterator) Response() OnlineEndpointTrackedResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OnlineEndpointTrackedResourceArmPaginatedResultIterator) Value() OnlineEndpointTrackedResource {
	if !iter.page.NotDone() {
		return OnlineEndpointTrackedResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OnlineEndpointTrackedResourceArmPaginatedResultIterator type.
func NewOnlineEndpointTrackedResourceArmPaginatedResultIterator(page OnlineEndpointTrackedResourceArmPaginatedResultPage) OnlineEndpointTrackedResourceArmPaginatedResultIterator {
	return OnlineEndpointTrackedResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (oetrapr OnlineEndpointTrackedResourceArmPaginatedResult) IsEmpty() bool {
	return oetrapr.Value == nil || len(*oetrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (oetrapr OnlineEndpointTrackedResourceArmPaginatedResult) hasNextLink() bool {
	return oetrapr.NextLink != nil && len(*oetrapr.NextLink) != 0
}

// onlineEndpointTrackedResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (oetrapr OnlineEndpointTrackedResourceArmPaginatedResult) onlineEndpointTrackedResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !oetrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(oetrapr.NextLink)))
}

// OnlineEndpointTrackedResourceArmPaginatedResultPage contains a page of OnlineEndpointTrackedResource
// values.
type OnlineEndpointTrackedResourceArmPaginatedResultPage struct {
	fn      func(context.Context, OnlineEndpointTrackedResourceArmPaginatedResult) (OnlineEndpointTrackedResourceArmPaginatedResult, error)
	oetrapr OnlineEndpointTrackedResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OnlineEndpointTrackedResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OnlineEndpointTrackedResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.oetrapr)
		if err != nil {
			return err
		}
		page.oetrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OnlineEndpointTrackedResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OnlineEndpointTrackedResourceArmPaginatedResultPage) NotDone() bool {
	return !page.oetrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OnlineEndpointTrackedResourceArmPaginatedResultPage) Response() OnlineEndpointTrackedResourceArmPaginatedResult {
	return page.oetrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OnlineEndpointTrackedResourceArmPaginatedResultPage) Values() []OnlineEndpointTrackedResource {
	if page.oetrapr.IsEmpty() {
		return nil
	}
	return *page.oetrapr.Value
}

// Creates a new instance of the OnlineEndpointTrackedResourceArmPaginatedResultPage type.
func NewOnlineEndpointTrackedResourceArmPaginatedResultPage(cur OnlineEndpointTrackedResourceArmPaginatedResult, getNextPage func(context.Context, OnlineEndpointTrackedResourceArmPaginatedResult) (OnlineEndpointTrackedResourceArmPaginatedResult, error)) OnlineEndpointTrackedResourceArmPaginatedResultPage {
	return OnlineEndpointTrackedResourceArmPaginatedResultPage{
		fn:      getNextPage,
		oetrapr: cur,
	}
}

// OnlineRequestSettings online deployment scoring requests configuration.
type OnlineRequestSettings struct {
	// MaxConcurrentRequestsPerInstance - The number of maximum concurrent requests per node allowed per deployment. Defaults to 1.
	MaxConcurrentRequestsPerInstance *int32 `json:"maxConcurrentRequestsPerInstance,omitempty"`
	// MaxQueueWait - The maximum amount of time a request will stay in the queue in ISO 8601 format.
	// Defaults to 500ms.
	MaxQueueWait *string `json:"maxQueueWait,omitempty"`
	// RequestTimeout - The scoring timeout in ISO 8601 format.
	// Defaults to 5000ms.
	RequestTimeout *string `json:"requestTimeout,omitempty"`
}

// BasicOnlineScaleSettings online deployment scaling configuration.
type BasicOnlineScaleSettings interface {
	AsDefaultScaleSettings() (*DefaultScaleSettings, bool)
	AsTargetUtilizationScaleSettings() (*TargetUtilizationScaleSettings, bool)
	AsOnlineScaleSettings() (*OnlineScaleSettings, bool)
}

// OnlineScaleSettings online deployment scaling configuration.
type OnlineScaleSettings struct {
	// ScaleType - Possible values include: 'ScaleTypeOnlineScaleSettings', 'ScaleTypeDefault', 'ScaleTypeTargetUtilization'
	ScaleType ScaleTypeBasicOnlineScaleSettings `json:"scaleType,omitempty"`
}

func unmarshalBasicOnlineScaleSettings(body []byte) (BasicOnlineScaleSettings, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["scaleType"] {
	case string(ScaleTypeDefault):
		var dss DefaultScaleSettings
		err := json.Unmarshal(body, &dss)
		return dss, err
	case string(ScaleTypeTargetUtilization):
		var tuss TargetUtilizationScaleSettings
		err := json.Unmarshal(body, &tuss)
		return tuss, err
	default:
		var oss OnlineScaleSettings
		err := json.Unmarshal(body, &oss)
		return oss, err
	}
}
func unmarshalBasicOnlineScaleSettingsArray(body []byte) ([]BasicOnlineScaleSettings, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ossArray := make([]BasicOnlineScaleSettings, len(rawMessages))

	for index, rawMessage := range rawMessages {
		oss, err := unmarshalBasicOnlineScaleSettings(*rawMessage)
		if err != nil {
			return nil, err
		}
		ossArray[index] = oss
	}
	return ossArray, nil
}

// MarshalJSON is the custom marshaler for OnlineScaleSettings.
func (oss OnlineScaleSettings) MarshalJSON() ([]byte, error) {
	oss.ScaleType = ScaleTypeOnlineScaleSettings
	objectMap := make(map[string]interface{})
	if oss.ScaleType != "" {
		objectMap["scaleType"] = oss.ScaleType
	}
	return json.Marshal(objectMap)
}

// AsDefaultScaleSettings is the BasicOnlineScaleSettings implementation for OnlineScaleSettings.
func (oss OnlineScaleSettings) AsDefaultScaleSettings() (*DefaultScaleSettings, bool) {
	return nil, false
}

// AsTargetUtilizationScaleSettings is the BasicOnlineScaleSettings implementation for OnlineScaleSettings.
func (oss OnlineScaleSettings) AsTargetUtilizationScaleSettings() (*TargetUtilizationScaleSettings, bool) {
	return nil, false
}

// AsOnlineScaleSettings is the BasicOnlineScaleSettings implementation for OnlineScaleSettings.
func (oss OnlineScaleSettings) AsOnlineScaleSettings() (*OnlineScaleSettings, bool) {
	return &oss, true
}

// AsBasicOnlineScaleSettings is the BasicOnlineScaleSettings implementation for OnlineScaleSettings.
func (oss OnlineScaleSettings) AsBasicOnlineScaleSettings() (BasicOnlineScaleSettings, bool) {
	return &oss, true
}

// OutputPathAssetReference reference to an asset via its path in a job output.
type OutputPathAssetReference struct {
	// JobID - ARM resource ID of the job.
	JobID *string `json:"jobId,omitempty"`
	// Path - The path of the file/directory in the job output.
	Path *string `json:"path,omitempty"`
	// ReferenceType - Possible values include: 'ReferenceTypeAssetReferenceBase', 'ReferenceTypeDataPath', 'ReferenceTypeID', 'ReferenceTypeOutputPath'
	ReferenceType ReferenceTypeBasicAssetReferenceBase `json:"referenceType,omitempty"`
}

// MarshalJSON is the custom marshaler for OutputPathAssetReference.
func (opar OutputPathAssetReference) MarshalJSON() ([]byte, error) {
	opar.ReferenceType = ReferenceTypeOutputPath
	objectMap := make(map[string]interface{})
	if opar.JobID != nil {
		objectMap["jobId"] = opar.JobID
	}
	if opar.Path != nil {
		objectMap["path"] = opar.Path
	}
	if opar.ReferenceType != "" {
		objectMap["referenceType"] = opar.ReferenceType
	}
	return json.Marshal(objectMap)
}

// AsDataPathAssetReference is the BasicAssetReferenceBase implementation for OutputPathAssetReference.
func (opar OutputPathAssetReference) AsDataPathAssetReference() (*DataPathAssetReference, bool) {
	return nil, false
}

// AsIDAssetReference is the BasicAssetReferenceBase implementation for OutputPathAssetReference.
func (opar OutputPathAssetReference) AsIDAssetReference() (*IDAssetReference, bool) {
	return nil, false
}

// AsOutputPathAssetReference is the BasicAssetReferenceBase implementation for OutputPathAssetReference.
func (opar OutputPathAssetReference) AsOutputPathAssetReference() (*OutputPathAssetReference, bool) {
	return &opar, true
}

// AsAssetReferenceBase is the BasicAssetReferenceBase implementation for OutputPathAssetReference.
func (opar OutputPathAssetReference) AsAssetReferenceBase() (*AssetReferenceBase, bool) {
	return nil, false
}

// AsBasicAssetReferenceBase is the BasicAssetReferenceBase implementation for OutputPathAssetReference.
func (opar OutputPathAssetReference) AsBasicAssetReferenceBase() (BasicAssetReferenceBase, bool) {
	return &opar, true
}

// PaginatedComputeResourcesList paginated list of Machine Learning compute objects wrapped in ARM resource
// envelope.
type PaginatedComputeResourcesList struct {
	autorest.Response `json:"-"`
	// Value - An array of Machine Learning compute objects wrapped in ARM resource envelope.
	Value *[]ComputeResource `json:"value,omitempty"`
	// NextLink - A continuation link (absolute URI) to the next page of results in the list.
	NextLink *string `json:"nextLink,omitempty"`
}

// PaginatedComputeResourcesListIterator provides access to a complete listing of ComputeResource values.
type PaginatedComputeResourcesListIterator struct {
	i    int
	page PaginatedComputeResourcesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaginatedComputeResourcesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedComputeResourcesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaginatedComputeResourcesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaginatedComputeResourcesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaginatedComputeResourcesListIterator) Response() PaginatedComputeResourcesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaginatedComputeResourcesListIterator) Value() ComputeResource {
	if !iter.page.NotDone() {
		return ComputeResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaginatedComputeResourcesListIterator type.
func NewPaginatedComputeResourcesListIterator(page PaginatedComputeResourcesListPage) PaginatedComputeResourcesListIterator {
	return PaginatedComputeResourcesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pcrl PaginatedComputeResourcesList) IsEmpty() bool {
	return pcrl.Value == nil || len(*pcrl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pcrl PaginatedComputeResourcesList) hasNextLink() bool {
	return pcrl.NextLink != nil && len(*pcrl.NextLink) != 0
}

// paginatedComputeResourcesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pcrl PaginatedComputeResourcesList) paginatedComputeResourcesListPreparer(ctx context.Context) (*http.Request, error) {
	if !pcrl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pcrl.NextLink)))
}

// PaginatedComputeResourcesListPage contains a page of ComputeResource values.
type PaginatedComputeResourcesListPage struct {
	fn   func(context.Context, PaginatedComputeResourcesList) (PaginatedComputeResourcesList, error)
	pcrl PaginatedComputeResourcesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaginatedComputeResourcesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaginatedComputeResourcesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pcrl)
		if err != nil {
			return err
		}
		page.pcrl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaginatedComputeResourcesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaginatedComputeResourcesListPage) NotDone() bool {
	return !page.pcrl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaginatedComputeResourcesListPage) Response() PaginatedComputeResourcesList {
	return page.pcrl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaginatedComputeResourcesListPage) Values() []ComputeResource {
	if page.pcrl.IsEmpty() {
		return nil
	}
	return *page.pcrl.Value
}

// Creates a new instance of the PaginatedComputeResourcesListPage type.
func NewPaginatedComputeResourcesListPage(cur PaginatedComputeResourcesList, getNextPage func(context.Context, PaginatedComputeResourcesList) (PaginatedComputeResourcesList, error)) PaginatedComputeResourcesListPage {
	return PaginatedComputeResourcesListPage{
		fn:   getNextPage,
		pcrl: cur,
	}
}

// PartialBatchDeployment mutable batch inference settings per deployment.
type PartialBatchDeployment struct {
	// Description - Description of the endpoint deployment.
	Description *string `json:"description,omitempty"`
}

// PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties strictly used in update requests.
type PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties struct {
	// Properties - Additional attributes of the entity.
	Properties *PartialBatchDeployment `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties.
func (pbdpmtrwp PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pbdpmtrwp.Properties != nil {
		objectMap["properties"] = pbdpmtrwp.Properties
	}
	if pbdpmtrwp.Tags != nil {
		objectMap["tags"] = pbdpmtrwp.Tags
	}
	return json.Marshal(objectMap)
}

// PartialManagedServiceIdentity managed service identity (system assigned and/or user assigned identities)
type PartialManagedServiceIdentity struct {
	// Type - Managed service identity (system assigned and/or user assigned identities). Possible values include: 'ManagedServiceIdentityTypeNone', 'ManagedServiceIdentityTypeSystemAssigned', 'ManagedServiceIdentityTypeUserAssigned', 'ManagedServiceIdentityTypeSystemAssignedUserAssigned'
	Type ManagedServiceIdentityType `json:"type,omitempty"`
	// UserAssignedIdentities - The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}. The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities map[string]interface{} `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for PartialManagedServiceIdentity.
func (pmsi PartialManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmsi.Type != "" {
		objectMap["type"] = pmsi.Type
	}
	if pmsi.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = pmsi.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// PartialMinimalTrackedResource strictly used in update requests.
type PartialMinimalTrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PartialMinimalTrackedResource.
func (pmtr PartialMinimalTrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmtr.Tags != nil {
		objectMap["tags"] = pmtr.Tags
	}
	return json.Marshal(objectMap)
}

// PartialMinimalTrackedResourceWithIdentity strictly used in update requests.
type PartialMinimalTrackedResourceWithIdentity struct {
	// Identity - Managed service identity (system assigned and/or user assigned identities)
	Identity *PartialManagedServiceIdentity `json:"identity,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PartialMinimalTrackedResourceWithIdentity.
func (pmtrwi PartialMinimalTrackedResourceWithIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmtrwi.Identity != nil {
		objectMap["identity"] = pmtrwi.Identity
	}
	if pmtrwi.Tags != nil {
		objectMap["tags"] = pmtrwi.Tags
	}
	return json.Marshal(objectMap)
}

// PartialMinimalTrackedResourceWithSku strictly used in update requests.
type PartialMinimalTrackedResourceWithSku struct {
	// Sku - Sku details required for ARM contract for Autoscaling.
	Sku *PartialSku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PartialMinimalTrackedResourceWithSku.
func (pmtrws PartialMinimalTrackedResourceWithSku) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmtrws.Sku != nil {
		objectMap["sku"] = pmtrws.Sku
	}
	if pmtrws.Tags != nil {
		objectMap["tags"] = pmtrws.Tags
	}
	return json.Marshal(objectMap)
}

// PartialSku common SKU definition.
type PartialSku struct {
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code.
	Name *string `json:"name,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Tier - This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT. Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
}

// Password ...
type Password struct {
	// Name - READ-ONLY
	Name *string `json:"name,omitempty"`
	// Value - READ-ONLY
	Value *string `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for Password.
func (p Password) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PATAuthTypeWorkspaceConnectionProperties ...
type PATAuthTypeWorkspaceConnectionProperties struct {
	Credentials *WorkspaceConnectionPersonalAccessToken `json:"credentials,omitempty"`
	// Category - Possible values include: 'PythonFeed', 'ContainerRegistry', 'Git'
	Category ConnectionCategory `json:"category,omitempty"`
	Target   *string            `json:"target,omitempty"`
	// Value - Value details of the workspace connection.
	Value *string `json:"value,omitempty"`
	// ValueFormat - format for the workspace connection value. Possible values include: 'JSON'
	ValueFormat ValueFormat `json:"valueFormat,omitempty"`
	// AuthType - Possible values include: 'AuthTypeWorkspaceConnectionPropertiesV2', 'AuthTypePAT', 'AuthTypeSAS', 'AuthTypeUsernamePassword', 'AuthTypeNone', 'AuthTypeManagedIdentity'
	AuthType AuthType `json:"authType,omitempty"`
}

// MarshalJSON is the custom marshaler for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	patwcp.AuthType = AuthTypePAT
	objectMap := make(map[string]interface{})
	if patwcp.Credentials != nil {
		objectMap["credentials"] = patwcp.Credentials
	}
	if patwcp.Category != "" {
		objectMap["category"] = patwcp.Category
	}
	if patwcp.Target != nil {
		objectMap["target"] = patwcp.Target
	}
	if patwcp.Value != nil {
		objectMap["value"] = patwcp.Value
	}
	if patwcp.ValueFormat != "" {
		objectMap["valueFormat"] = patwcp.ValueFormat
	}
	if patwcp.AuthType != "" {
		objectMap["authType"] = patwcp.AuthType
	}
	return json.Marshal(objectMap)
}

// AsPATAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool) {
	return &patwcp, true
}

// AsSASAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsUsernamePasswordAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsNoneAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsManagedIdentityAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool) {
	return nil, false
}

// AsBasicWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for PATAuthTypeWorkspaceConnectionProperties.
func (patwcp PATAuthTypeWorkspaceConnectionProperties) AsBasicWorkspaceConnectionPropertiesV2() (BasicWorkspaceConnectionPropertiesV2, bool) {
	return &patwcp, true
}

// PersonalComputeInstanceSettings settings for a personal compute instance.
type PersonalComputeInstanceSettings struct {
	// AssignedUser - A user explicitly assigned to a personal compute instance.
	AssignedUser *AssignedUser `json:"assignedUser,omitempty"`
}

// PipelineJob pipeline Job definition: defines generic to MFE attributes.
type PipelineJob struct {
	// Inputs - Inputs for the pipeline job.
	Inputs map[string]BasicJobInput `json:"inputs"`
	// Jobs - Jobs construct the Pipeline Job.
	Jobs map[string]interface{} `json:"jobs"`
	// Outputs - Outputs for the pipeline job
	Outputs map[string]BasicJobOutput `json:"outputs"`
	// Settings - Pipeline settings, for things like ContinueRunOnStepFailure etc.
	Settings interface{} `json:"settings,omitempty"`
	// ComputeID - ARM resource ID of the compute resource.
	ComputeID *string `json:"computeId,omitempty"`
	// DisplayName - Display name of job.
	DisplayName *string `json:"displayName,omitempty"`
	// ExperimentName - The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `json:"experimentName,omitempty"`
	// Identity - Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity BasicIdentityConfiguration `json:"identity,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Services - List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]*JobService `json:"services"`
	// Status - READ-ONLY; Status of the job. Possible values include: 'JobStatusNotStarted', 'JobStatusStarting', 'JobStatusProvisioning', 'JobStatusPreparing', 'JobStatusQueued', 'JobStatusRunning', 'JobStatusFinalizing', 'JobStatusCancelRequested', 'JobStatusCompleted', 'JobStatusFailed', 'JobStatusCanceled', 'JobStatusNotResponding', 'JobStatusPaused', 'JobStatusUnknown'
	Status JobStatus `json:"status,omitempty"`
	// JobType - Possible values include: 'JobTypeJobBase', 'JobTypeCommand1', 'JobTypePipeline1', 'JobTypeSweep1'
	JobType JobTypeBasicJobBase `json:"jobType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PipelineJob.
func (pj PipelineJob) MarshalJSON() ([]byte, error) {
	pj.JobType = JobTypePipeline1
	objectMap := make(map[string]interface{})
	if pj.Inputs != nil {
		objectMap["inputs"] = pj.Inputs
	}
	if pj.Jobs != nil {
		objectMap["jobs"] = pj.Jobs
	}
	if pj.Outputs != nil {
		objectMap["outputs"] = pj.Outputs
	}
	if pj.Settings != nil {
		objectMap["settings"] = pj.Settings
	}
	if pj.ComputeID != nil {
		objectMap["computeId"] = pj.ComputeID
	}
	if pj.DisplayName != nil {
		objectMap["displayName"] = pj.DisplayName
	}
	if pj.ExperimentName != nil {
		objectMap["experimentName"] = pj.ExperimentName
	}
	objectMap["identity"] = pj.Identity
	if pj.IsArchived != nil {
		objectMap["isArchived"] = pj.IsArchived
	}
	if pj.Services != nil {
		objectMap["services"] = pj.Services
	}
	if pj.JobType != "" {
		objectMap["jobType"] = pj.JobType
	}
	if pj.Description != nil {
		objectMap["description"] = pj.Description
	}
	if pj.Properties != nil {
		objectMap["properties"] = pj.Properties
	}
	if pj.Tags != nil {
		objectMap["tags"] = pj.Tags
	}
	return json.Marshal(objectMap)
}

// AsCommandJob is the BasicJobBase implementation for PipelineJob.
func (pj PipelineJob) AsCommandJob() (*CommandJob, bool) {
	return nil, false
}

// AsPipelineJob is the BasicJobBase implementation for PipelineJob.
func (pj PipelineJob) AsPipelineJob() (*PipelineJob, bool) {
	return &pj, true
}

// AsSweepJob is the BasicJobBase implementation for PipelineJob.
func (pj PipelineJob) AsSweepJob() (*SweepJob, bool) {
	return nil, false
}

// AsJobBase is the BasicJobBase implementation for PipelineJob.
func (pj PipelineJob) AsJobBase() (*JobBase, bool) {
	return nil, false
}

// AsBasicJobBase is the BasicJobBase implementation for PipelineJob.
func (pj PipelineJob) AsBasicJobBase() (BasicJobBase, bool) {
	return &pj, true
}

// UnmarshalJSON is the custom unmarshaler for PipelineJob struct.
func (pj *PipelineJob) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "inputs":
			if v != nil {
				var inputs map[string]BasicJobInput
				err = json.Unmarshal(*v, &inputs)
				if err != nil {
					return err
				}
				pj.Inputs = inputs
			}
		case "jobs":
			if v != nil {
				var jobs map[string]interface{}
				err = json.Unmarshal(*v, &jobs)
				if err != nil {
					return err
				}
				pj.Jobs = jobs
			}
		case "outputs":
			if v != nil {
				var outputs map[string]BasicJobOutput
				err = json.Unmarshal(*v, &outputs)
				if err != nil {
					return err
				}
				pj.Outputs = outputs
			}
		case "settings":
			if v != nil {
				var settings interface{}
				err = json.Unmarshal(*v, &settings)
				if err != nil {
					return err
				}
				pj.Settings = settings
			}
		case "computeId":
			if v != nil {
				var computeID string
				err = json.Unmarshal(*v, &computeID)
				if err != nil {
					return err
				}
				pj.ComputeID = &computeID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				pj.DisplayName = &displayName
			}
		case "experimentName":
			if v != nil {
				var experimentName string
				err = json.Unmarshal(*v, &experimentName)
				if err != nil {
					return err
				}
				pj.ExperimentName = &experimentName
			}
		case "identity":
			if v != nil {
				identity, err := unmarshalBasicIdentityConfiguration(*v)
				if err != nil {
					return err
				}
				pj.Identity = identity
			}
		case "isArchived":
			if v != nil {
				var isArchived bool
				err = json.Unmarshal(*v, &isArchived)
				if err != nil {
					return err
				}
				pj.IsArchived = &isArchived
			}
		case "services":
			if v != nil {
				var services map[string]*JobService
				err = json.Unmarshal(*v, &services)
				if err != nil {
					return err
				}
				pj.Services = services
			}
		case "status":
			if v != nil {
				var status JobStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				pj.Status = status
			}
		case "jobType":
			if v != nil {
				var jobType JobTypeBasicJobBase
				err = json.Unmarshal(*v, &jobType)
				if err != nil {
					return err
				}
				pj.JobType = jobType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				pj.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				pj.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pj.Tags = tags
			}
		}
	}

	return nil
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// PrivateEndpoint the Private Endpoint resource.
type PrivateEndpoint struct {
	// ID - READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty"`
	// SubnetArmID - READ-ONLY; The ARM identifier for Subnet resource that private endpoint links to
	SubnetArmID *string `json:"subnetArmId,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpoint.
func (peVar PrivateEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PrivateEndpointConnection the Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	autorest.Response `json:"-"`
	// PrivateEndpointConnectionProperties - Resource properties.
	*PrivateEndpointConnectionProperties `json:"properties,omitempty"`
	// Identity - The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Location - Specifies the location of the resource.
	Location *string `json:"location,omitempty"`
	// Tags - Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags"`
	// Sku - The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateEndpointConnection.
func (pec PrivateEndpointConnection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pec.PrivateEndpointConnectionProperties != nil {
		objectMap["properties"] = pec.PrivateEndpointConnectionProperties
	}
	if pec.Identity != nil {
		objectMap["identity"] = pec.Identity
	}
	if pec.Location != nil {
		objectMap["location"] = pec.Location
	}
	if pec.Tags != nil {
		objectMap["tags"] = pec.Tags
	}
	if pec.Sku != nil {
		objectMap["sku"] = pec.Sku
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateEndpointConnection struct.
func (pec *PrivateEndpointConnection) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateEndpointConnectionProperties PrivateEndpointConnectionProperties
				err = json.Unmarshal(*v, &privateEndpointConnectionProperties)
				if err != nil {
					return err
				}
				pec.PrivateEndpointConnectionProperties = &privateEndpointConnectionProperties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				pec.Identity = &identity
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pec.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pec.Tags = tags
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				pec.Sku = &sku
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pec.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pec.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pec.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pec.SystemData = &systemData
			}
		}
	}

	return nil
}

// PrivateEndpointConnectionListResult list of private endpoint connection associated with the specified
// workspace
type PrivateEndpointConnectionListResult struct {
	autorest.Response `json:"-"`
	// Value - Array of private endpoint connections
	Value *[]PrivateEndpointConnection `json:"value,omitempty"`
}

// PrivateEndpointConnectionProperties properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// PrivateEndpoint - The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty"`
	// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer and provider.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`
	// ProvisioningState - The provisioning state of the private endpoint connection resource. Possible values include: 'PrivateEndpointConnectionProvisioningStateSucceeded', 'PrivateEndpointConnectionProvisioningStateCreating', 'PrivateEndpointConnectionProvisioningStateDeleting', 'PrivateEndpointConnectionProvisioningStateFailed'
	ProvisioningState PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty"`
}

// PrivateLinkResource a private link resource
type PrivateLinkResource struct {
	// PrivateLinkResourceProperties - Resource properties.
	*PrivateLinkResourceProperties `json:"properties,omitempty"`
	// Identity - The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Location - Specifies the location of the resource.
	Location *string `json:"location,omitempty"`
	// Tags - Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags"`
	// Sku - The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkResource.
func (plr PrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plr.PrivateLinkResourceProperties != nil {
		objectMap["properties"] = plr.PrivateLinkResourceProperties
	}
	if plr.Identity != nil {
		objectMap["identity"] = plr.Identity
	}
	if plr.Location != nil {
		objectMap["location"] = plr.Location
	}
	if plr.Tags != nil {
		objectMap["tags"] = plr.Tags
	}
	if plr.Sku != nil {
		objectMap["sku"] = plr.Sku
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PrivateLinkResource struct.
func (plr *PrivateLinkResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var privateLinkResourceProperties PrivateLinkResourceProperties
				err = json.Unmarshal(*v, &privateLinkResourceProperties)
				if err != nil {
					return err
				}
				plr.PrivateLinkResourceProperties = &privateLinkResourceProperties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				plr.Identity = &identity
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				plr.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				plr.Tags = tags
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				plr.Sku = &sku
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				plr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				plr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				plr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				plr.SystemData = &systemData
			}
		}
	}

	return nil
}

// PrivateLinkResourceListResult a list of private link resources
type PrivateLinkResourceListResult struct {
	autorest.Response `json:"-"`
	// Value - Array of private link resources
	Value *[]PrivateLinkResource `json:"value,omitempty"`
}

// PrivateLinkResourceProperties properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// GroupID - READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty"`
	// RequiredMembers - READ-ONLY; The private link resource required member names.
	RequiredMembers *[]string `json:"requiredMembers,omitempty"`
	// RequiredZoneNames - The private link resource Private link DNS zone name.
	RequiredZoneNames *[]string `json:"requiredZoneNames,omitempty"`
}

// MarshalJSON is the custom marshaler for PrivateLinkResourceProperties.
func (plrp PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plrp.RequiredZoneNames != nil {
		objectMap["requiredZoneNames"] = plrp.RequiredZoneNames
	}
	return json.Marshal(objectMap)
}

// PrivateLinkServiceConnectionState a collection of information about the state of the connection between
// service consumer and provider.
type PrivateLinkServiceConnectionState struct {
	// Status - Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service. Possible values include: 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
	Status PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
	// Description - The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`
	// ActionsRequired - A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`
}

// ProbeSettings deployment container liveness/readiness probe configuration.
type ProbeSettings struct {
	// FailureThreshold - The number of failures to allow before returning an unhealthy status.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`
	// InitialDelay - The delay before the first probe in ISO 8601 format.
	InitialDelay *string `json:"initialDelay,omitempty"`
	// Period - The length of time between probes in ISO 8601 format.
	Period *string `json:"period,omitempty"`
	// SuccessThreshold - The number of successful probes before returning a healthy status.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`
	// Timeout - The probe timeout in ISO 8601 format.
	Timeout *string `json:"timeout,omitempty"`
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PyTorch pyTorch distribution configuration.
type PyTorch struct {
	// ProcessCountPerInstance - Number of processes per node.
	ProcessCountPerInstance *int32 `json:"processCountPerInstance,omitempty"`
	// DistributionType - Possible values include: 'DistributionTypeDistributionConfiguration', 'DistributionTypeMpi1', 'DistributionTypePyTorch1', 'DistributionTypeTensorFlow1'
	DistributionType DistributionTypeBasicDistributionConfiguration `json:"distributionType,omitempty"`
}

// MarshalJSON is the custom marshaler for PyTorch.
func (pt PyTorch) MarshalJSON() ([]byte, error) {
	pt.DistributionType = DistributionTypePyTorch1
	objectMap := make(map[string]interface{})
	if pt.ProcessCountPerInstance != nil {
		objectMap["processCountPerInstance"] = pt.ProcessCountPerInstance
	}
	if pt.DistributionType != "" {
		objectMap["distributionType"] = pt.DistributionType
	}
	return json.Marshal(objectMap)
}

// AsMpi is the BasicDistributionConfiguration implementation for PyTorch.
func (pt PyTorch) AsMpi() (*Mpi, bool) {
	return nil, false
}

// AsPyTorch is the BasicDistributionConfiguration implementation for PyTorch.
func (pt PyTorch) AsPyTorch() (*PyTorch, bool) {
	return &pt, true
}

// AsTensorFlow is the BasicDistributionConfiguration implementation for PyTorch.
func (pt PyTorch) AsTensorFlow() (*TensorFlow, bool) {
	return nil, false
}

// AsDistributionConfiguration is the BasicDistributionConfiguration implementation for PyTorch.
func (pt PyTorch) AsDistributionConfiguration() (*DistributionConfiguration, bool) {
	return nil, false
}

// AsBasicDistributionConfiguration is the BasicDistributionConfiguration implementation for PyTorch.
func (pt PyTorch) AsBasicDistributionConfiguration() (BasicDistributionConfiguration, bool) {
	return &pt, true
}

// QuotaBaseProperties the properties for Quota update or retrieval.
type QuotaBaseProperties struct {
	// ID - Specifies the resource ID.
	ID *string `json:"id,omitempty"`
	// Type - Specifies the resource type.
	Type *string `json:"type,omitempty"`
	// Limit - The maximum permitted quota of the resource.
	Limit *int64 `json:"limit,omitempty"`
	// Unit - An enum describing the unit of quota measurement. Possible values include: 'Count'
	Unit QuotaUnit `json:"unit,omitempty"`
}

// QuotaUpdateParameters quota update parameters.
type QuotaUpdateParameters struct {
	// Value - The list for update quota.
	Value *[]QuotaBaseProperties `json:"value,omitempty"`
	// Location - Region of workspace quota to be updated.
	Location *string `json:"location,omitempty"`
}

// RandomSamplingAlgorithm defines a Sampling Algorithm that generates values randomly
type RandomSamplingAlgorithm struct {
	// Rule - The specific type of random algorithm. Possible values include: 'Random', 'Sobol'
	Rule RandomSamplingAlgorithmRule `json:"rule,omitempty"`
	// Seed - An optional integer to use as the seed for random number generation
	Seed *int32 `json:"seed,omitempty"`
	// SamplingAlgorithmType - Possible values include: 'SamplingAlgorithmTypeSamplingAlgorithm', 'SamplingAlgorithmTypeBayesian1', 'SamplingAlgorithmTypeGrid1', 'SamplingAlgorithmTypeRandom1'
	SamplingAlgorithmType SamplingAlgorithmTypeBasicSamplingAlgorithm `json:"samplingAlgorithmType,omitempty"`
}

// MarshalJSON is the custom marshaler for RandomSamplingAlgorithm.
func (rsaVar RandomSamplingAlgorithm) MarshalJSON() ([]byte, error) {
	rsaVar.SamplingAlgorithmType = SamplingAlgorithmTypeRandom1
	objectMap := make(map[string]interface{})
	if rsaVar.Rule != "" {
		objectMap["rule"] = rsaVar.Rule
	}
	if rsaVar.Seed != nil {
		objectMap["seed"] = rsaVar.Seed
	}
	if rsaVar.SamplingAlgorithmType != "" {
		objectMap["samplingAlgorithmType"] = rsaVar.SamplingAlgorithmType
	}
	return json.Marshal(objectMap)
}

// AsBayesianSamplingAlgorithm is the BasicSamplingAlgorithm implementation for RandomSamplingAlgorithm.
func (rsaVar RandomSamplingAlgorithm) AsBayesianSamplingAlgorithm() (*BayesianSamplingAlgorithm, bool) {
	return nil, false
}

// AsGridSamplingAlgorithm is the BasicSamplingAlgorithm implementation for RandomSamplingAlgorithm.
func (rsaVar RandomSamplingAlgorithm) AsGridSamplingAlgorithm() (*GridSamplingAlgorithm, bool) {
	return nil, false
}

// AsRandomSamplingAlgorithm is the BasicSamplingAlgorithm implementation for RandomSamplingAlgorithm.
func (rsaVar RandomSamplingAlgorithm) AsRandomSamplingAlgorithm() (*RandomSamplingAlgorithm, bool) {
	return &rsaVar, true
}

// AsSamplingAlgorithm is the BasicSamplingAlgorithm implementation for RandomSamplingAlgorithm.
func (rsaVar RandomSamplingAlgorithm) AsSamplingAlgorithm() (*SamplingAlgorithm, bool) {
	return nil, false
}

// AsBasicSamplingAlgorithm is the BasicSamplingAlgorithm implementation for RandomSamplingAlgorithm.
func (rsaVar RandomSamplingAlgorithm) AsBasicSamplingAlgorithm() (BasicSamplingAlgorithm, bool) {
	return &rsaVar, true
}

// RegenerateEndpointKeysRequest ...
type RegenerateEndpointKeysRequest struct {
	// KeyType - [Required] Specification for which type of key to generate. Primary or Secondary. Possible values include: 'Primary', 'Secondary'
	KeyType KeyType `json:"keyType,omitempty"`
	// KeyValue - The value the key is set to.
	KeyValue *string `json:"keyValue,omitempty"`
}

// RegistryListCredentialsResult ...
type RegistryListCredentialsResult struct {
	// Location - READ-ONLY
	Location *string `json:"location,omitempty"`
	// Username - READ-ONLY
	Username  *string     `json:"username,omitempty"`
	Passwords *[]Password `json:"passwords,omitempty"`
}

// MarshalJSON is the custom marshaler for RegistryListCredentialsResult.
func (rlcr RegistryListCredentialsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rlcr.Passwords != nil {
		objectMap["passwords"] = rlcr.Passwords
	}
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceBase ...
type ResourceBase struct {
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ResourceBase.
func (rb ResourceBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rb.Description != nil {
		objectMap["description"] = rb.Description
	}
	if rb.Properties != nil {
		objectMap["properties"] = rb.Properties
	}
	if rb.Tags != nil {
		objectMap["tags"] = rb.Tags
	}
	return json.Marshal(objectMap)
}

// ResourceConfiguration ...
type ResourceConfiguration struct {
	// InstanceCount - Optional number of instances or nodes used by the compute target.
	InstanceCount *int32 `json:"instanceCount,omitempty"`
	// InstanceType - Optional type of VM used as supported by the compute target.
	InstanceType *string `json:"instanceType,omitempty"`
	// Properties - Additional properties bag.
	Properties map[string]interface{} `json:"properties"`
}

// MarshalJSON is the custom marshaler for ResourceConfiguration.
func (rc ResourceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rc.InstanceCount != nil {
		objectMap["instanceCount"] = rc.InstanceCount
	}
	if rc.InstanceType != nil {
		objectMap["instanceType"] = rc.InstanceType
	}
	if rc.Properties != nil {
		objectMap["properties"] = rc.Properties
	}
	return json.Marshal(objectMap)
}

// ResourceID represents a resource ID. For example, for a subnet, it is the resource URL for the subnet.
type ResourceID struct {
	// ID - The ID of the resource
	ID *string `json:"id,omitempty"`
}

// ResourceModelWithAllowedPropertySet the resource model definition containing the full set of allowed
// properties for a resource. Except properties bag, there cannot be a top level property outside of this
// set.
type ResourceModelWithAllowedPropertySet struct {
	// ManagedBy - The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string `json:"managedBy,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
	// Etag - READ-ONLY; The etag field is *not* required. If it is provided in the response body, it must also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
	Etag     *string                                      `json:"etag,omitempty"`
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`
	Sku      *ResourceModelWithAllowedPropertySetSku      `json:"sku,omitempty"`
	Plan     *ResourceModelWithAllowedPropertySetPlan     `json:"plan,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySet.
func (rmwaps ResourceModelWithAllowedPropertySet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.ManagedBy != nil {
		objectMap["managedBy"] = rmwaps.ManagedBy
	}
	if rmwaps.Kind != nil {
		objectMap["kind"] = rmwaps.Kind
	}
	if rmwaps.Identity != nil {
		objectMap["identity"] = rmwaps.Identity
	}
	if rmwaps.Sku != nil {
		objectMap["sku"] = rmwaps.Sku
	}
	if rmwaps.Plan != nil {
		objectMap["plan"] = rmwaps.Plan
	}
	if rmwaps.Tags != nil {
		objectMap["tags"] = rmwaps.Tags
	}
	if rmwaps.Location != nil {
		objectMap["location"] = rmwaps.Location
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetIdentity ...
type ResourceModelWithAllowedPropertySetIdentity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySetIdentity.
func (rmwaps ResourceModelWithAllowedPropertySetIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.Type != "" {
		objectMap["type"] = rmwaps.Type
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetPlan ...
type ResourceModelWithAllowedPropertySetPlan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ResourceModelWithAllowedPropertySetSku ...
type ResourceModelWithAllowedPropertySetSku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// ResourceName the Resource Name.
type ResourceName struct {
	// Value - READ-ONLY; The name of the resource.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - READ-ONLY; The localized name of the resource.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceName.
func (rn ResourceName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceQuota the quota assigned to a resource.
type ResourceQuota struct {
	// ID - READ-ONLY; Specifies the resource ID.
	ID *string `json:"id,omitempty"`
	// AmlWorkspaceLocation - READ-ONLY; Region of the AML workspace in the id.
	AmlWorkspaceLocation *string `json:"amlWorkspaceLocation,omitempty"`
	// Type - READ-ONLY; Specifies the resource type.
	Type *string `json:"type,omitempty"`
	// Name - READ-ONLY; Name of the resource.
	Name *ResourceName `json:"name,omitempty"`
	// Limit - READ-ONLY; The maximum permitted quota of the resource.
	Limit *int64 `json:"limit,omitempty"`
	// Unit - READ-ONLY; An enum describing the unit of quota measurement. Possible values include: 'Count'
	Unit QuotaUnit `json:"unit,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceQuota.
func (rq ResourceQuota) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Route ...
type Route struct {
	// Path - [Required] The path for the route.
	Path *string `json:"path,omitempty"`
	// Port - [Required] The port for the route.
	Port *int32 `json:"port,omitempty"`
}

// BasicSamplingAlgorithm the Sampling Algorithm used to generate hyperparameter values, along with properties to
// configure the algorithm
type BasicSamplingAlgorithm interface {
	AsBayesianSamplingAlgorithm() (*BayesianSamplingAlgorithm, bool)
	AsGridSamplingAlgorithm() (*GridSamplingAlgorithm, bool)
	AsRandomSamplingAlgorithm() (*RandomSamplingAlgorithm, bool)
	AsSamplingAlgorithm() (*SamplingAlgorithm, bool)
}

// SamplingAlgorithm the Sampling Algorithm used to generate hyperparameter values, along with properties to
// configure the algorithm
type SamplingAlgorithm struct {
	// SamplingAlgorithmType - Possible values include: 'SamplingAlgorithmTypeSamplingAlgorithm', 'SamplingAlgorithmTypeBayesian1', 'SamplingAlgorithmTypeGrid1', 'SamplingAlgorithmTypeRandom1'
	SamplingAlgorithmType SamplingAlgorithmTypeBasicSamplingAlgorithm `json:"samplingAlgorithmType,omitempty"`
}

func unmarshalBasicSamplingAlgorithm(body []byte) (BasicSamplingAlgorithm, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["samplingAlgorithmType"] {
	case string(SamplingAlgorithmTypeBayesian1):
		var bsa BayesianSamplingAlgorithm
		err := json.Unmarshal(body, &bsa)
		return bsa, err
	case string(SamplingAlgorithmTypeGrid1):
		var gsa GridSamplingAlgorithm
		err := json.Unmarshal(body, &gsa)
		return gsa, err
	case string(SamplingAlgorithmTypeRandom1):
		var rsaVar RandomSamplingAlgorithm
		err := json.Unmarshal(body, &rsaVar)
		return rsaVar, err
	default:
		var sa SamplingAlgorithm
		err := json.Unmarshal(body, &sa)
		return sa, err
	}
}
func unmarshalBasicSamplingAlgorithmArray(body []byte) ([]BasicSamplingAlgorithm, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	saArray := make([]BasicSamplingAlgorithm, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sa, err := unmarshalBasicSamplingAlgorithm(*rawMessage)
		if err != nil {
			return nil, err
		}
		saArray[index] = sa
	}
	return saArray, nil
}

// MarshalJSON is the custom marshaler for SamplingAlgorithm.
func (sa SamplingAlgorithm) MarshalJSON() ([]byte, error) {
	sa.SamplingAlgorithmType = SamplingAlgorithmTypeSamplingAlgorithm
	objectMap := make(map[string]interface{})
	if sa.SamplingAlgorithmType != "" {
		objectMap["samplingAlgorithmType"] = sa.SamplingAlgorithmType
	}
	return json.Marshal(objectMap)
}

// AsBayesianSamplingAlgorithm is the BasicSamplingAlgorithm implementation for SamplingAlgorithm.
func (sa SamplingAlgorithm) AsBayesianSamplingAlgorithm() (*BayesianSamplingAlgorithm, bool) {
	return nil, false
}

// AsGridSamplingAlgorithm is the BasicSamplingAlgorithm implementation for SamplingAlgorithm.
func (sa SamplingAlgorithm) AsGridSamplingAlgorithm() (*GridSamplingAlgorithm, bool) {
	return nil, false
}

// AsRandomSamplingAlgorithm is the BasicSamplingAlgorithm implementation for SamplingAlgorithm.
func (sa SamplingAlgorithm) AsRandomSamplingAlgorithm() (*RandomSamplingAlgorithm, bool) {
	return nil, false
}

// AsSamplingAlgorithm is the BasicSamplingAlgorithm implementation for SamplingAlgorithm.
func (sa SamplingAlgorithm) AsSamplingAlgorithm() (*SamplingAlgorithm, bool) {
	return &sa, true
}

// AsBasicSamplingAlgorithm is the BasicSamplingAlgorithm implementation for SamplingAlgorithm.
func (sa SamplingAlgorithm) AsBasicSamplingAlgorithm() (BasicSamplingAlgorithm, bool) {
	return &sa, true
}

// SASAuthTypeWorkspaceConnectionProperties ...
type SASAuthTypeWorkspaceConnectionProperties struct {
	Credentials *WorkspaceConnectionSharedAccessSignature `json:"credentials,omitempty"`
	// Category - Possible values include: 'PythonFeed', 'ContainerRegistry', 'Git'
	Category ConnectionCategory `json:"category,omitempty"`
	Target   *string            `json:"target,omitempty"`
	// Value - Value details of the workspace connection.
	Value *string `json:"value,omitempty"`
	// ValueFormat - format for the workspace connection value. Possible values include: 'JSON'
	ValueFormat ValueFormat `json:"valueFormat,omitempty"`
	// AuthType - Possible values include: 'AuthTypeWorkspaceConnectionPropertiesV2', 'AuthTypePAT', 'AuthTypeSAS', 'AuthTypeUsernamePassword', 'AuthTypeNone', 'AuthTypeManagedIdentity'
	AuthType AuthType `json:"authType,omitempty"`
}

// MarshalJSON is the custom marshaler for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	satwcp.AuthType = AuthTypeSAS
	objectMap := make(map[string]interface{})
	if satwcp.Credentials != nil {
		objectMap["credentials"] = satwcp.Credentials
	}
	if satwcp.Category != "" {
		objectMap["category"] = satwcp.Category
	}
	if satwcp.Target != nil {
		objectMap["target"] = satwcp.Target
	}
	if satwcp.Value != nil {
		objectMap["value"] = satwcp.Value
	}
	if satwcp.ValueFormat != "" {
		objectMap["valueFormat"] = satwcp.ValueFormat
	}
	if satwcp.AuthType != "" {
		objectMap["authType"] = satwcp.AuthType
	}
	return json.Marshal(objectMap)
}

// AsPATAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsSASAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool) {
	return &satwcp, true
}

// AsUsernamePasswordAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsNoneAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsManagedIdentityAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool) {
	return nil, false
}

// AsBasicWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for SASAuthTypeWorkspaceConnectionProperties.
func (satwcp SASAuthTypeWorkspaceConnectionProperties) AsBasicWorkspaceConnectionPropertiesV2() (BasicWorkspaceConnectionPropertiesV2, bool) {
	return &satwcp, true
}

// SasDatastoreCredentials SAS datastore credentials configuration.
type SasDatastoreCredentials struct {
	// Secrets - [Required] Storage container secrets.
	Secrets *SasDatastoreSecrets `json:"secrets,omitempty"`
	// CredentialsType - Possible values include: 'CredentialsTypeDatastoreCredentials', 'CredentialsTypeAccountKey1', 'CredentialsTypeCertificate1', 'CredentialsTypeNone1', 'CredentialsTypeSas1', 'CredentialsTypeServicePrincipal1'
	CredentialsType CredentialsTypeBasicDatastoreCredentials `json:"credentialsType,omitempty"`
}

// MarshalJSON is the custom marshaler for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) MarshalJSON() ([]byte, error) {
	sdc.CredentialsType = CredentialsTypeSas1
	objectMap := make(map[string]interface{})
	if sdc.Secrets != nil {
		objectMap["secrets"] = sdc.Secrets
	}
	if sdc.CredentialsType != "" {
		objectMap["credentialsType"] = sdc.CredentialsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool) {
	return nil, false
}

// AsCertificateDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool) {
	return nil, false
}

// AsNoneDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool) {
	return nil, false
}

// AsSasDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool) {
	return &sdc, true
}

// AsServicePrincipalDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool) {
	return nil, false
}

// AsDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsDatastoreCredentials() (*DatastoreCredentials, bool) {
	return nil, false
}

// AsBasicDatastoreCredentials is the BasicDatastoreCredentials implementation for SasDatastoreCredentials.
func (sdc SasDatastoreCredentials) AsBasicDatastoreCredentials() (BasicDatastoreCredentials, bool) {
	return &sdc, true
}

// SasDatastoreSecrets datastore SAS secrets.
type SasDatastoreSecrets struct {
	// SasToken - Storage container SAS token.
	SasToken *string `json:"sasToken,omitempty"`
	// SecretsType - Possible values include: 'SecretsTypeDatastoreSecrets', 'SecretsTypeAccountKey', 'SecretsTypeCertificate', 'SecretsTypeSas', 'SecretsTypeServicePrincipal'
	SecretsType SecretsTypeBasicDatastoreSecrets `json:"secretsType,omitempty"`
}

// MarshalJSON is the custom marshaler for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) MarshalJSON() ([]byte, error) {
	sds.SecretsType = SecretsTypeSas
	objectMap := make(map[string]interface{})
	if sds.SasToken != nil {
		objectMap["sasToken"] = sds.SasToken
	}
	if sds.SecretsType != "" {
		objectMap["secretsType"] = sds.SecretsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreSecrets is the BasicDatastoreSecrets implementation for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) AsAccountKeyDatastoreSecrets() (*AccountKeyDatastoreSecrets, bool) {
	return nil, false
}

// AsCertificateDatastoreSecrets is the BasicDatastoreSecrets implementation for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) AsCertificateDatastoreSecrets() (*CertificateDatastoreSecrets, bool) {
	return nil, false
}

// AsSasDatastoreSecrets is the BasicDatastoreSecrets implementation for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) AsSasDatastoreSecrets() (*SasDatastoreSecrets, bool) {
	return &sds, true
}

// AsServicePrincipalDatastoreSecrets is the BasicDatastoreSecrets implementation for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) AsServicePrincipalDatastoreSecrets() (*ServicePrincipalDatastoreSecrets, bool) {
	return nil, false
}

// AsDatastoreSecrets is the BasicDatastoreSecrets implementation for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) AsDatastoreSecrets() (*DatastoreSecrets, bool) {
	return nil, false
}

// AsBasicDatastoreSecrets is the BasicDatastoreSecrets implementation for SasDatastoreSecrets.
func (sds SasDatastoreSecrets) AsBasicDatastoreSecrets() (BasicDatastoreSecrets, bool) {
	return &sds, true
}

// ScaleSettings scale settings for AML Compute
type ScaleSettings struct {
	// MaxNodeCount - Max number of nodes to use
	MaxNodeCount *int32 `json:"maxNodeCount,omitempty"`
	// MinNodeCount - Min number of nodes to use
	MinNodeCount *int32 `json:"minNodeCount,omitempty"`
	// NodeIdleTimeBeforeScaleDown - Node Idle Time before scaling down amlCompute. This string needs to be in the RFC Format.
	NodeIdleTimeBeforeScaleDown *string `json:"nodeIdleTimeBeforeScaleDown,omitempty"`
}

// ScaleSettingsInformation desired scale settings for the amlCompute.
type ScaleSettingsInformation struct {
	ScaleSettings *ScaleSettings `json:"scaleSettings,omitempty"`
}

// ScheduleBase ...
type ScheduleBase struct {
	ID *string `json:"id,omitempty"`
	// ProvisioningStatus - Possible values include: 'ScheduleProvisioningStateCompleted', 'ScheduleProvisioningStateProvisioning', 'ScheduleProvisioningStateFailed'
	ProvisioningStatus ScheduleProvisioningState `json:"provisioningStatus,omitempty"`
	// Status - Possible values include: 'ScheduleStatusEnabled', 'ScheduleStatusDisabled'
	Status ScheduleStatus `json:"status,omitempty"`
}

// ScriptReference script reference
type ScriptReference struct {
	// ScriptSource - The storage source of the script: inline, workspace.
	ScriptSource *string `json:"scriptSource,omitempty"`
	// ScriptData - The location of scripts in the mounted volume.
	ScriptData *string `json:"scriptData,omitempty"`
	// ScriptArguments - Optional command line arguments passed to the script to run.
	ScriptArguments *string `json:"scriptArguments,omitempty"`
	// Timeout - Optional time period passed to timeout command.
	Timeout *string `json:"timeout,omitempty"`
}

// ScriptsToExecute customized setup scripts
type ScriptsToExecute struct {
	// StartupScript - Script that's run every time the machine starts.
	StartupScript *ScriptReference `json:"startupScript,omitempty"`
	// CreationScript - Script that's run only once during provision of the compute.
	CreationScript *ScriptReference `json:"creationScript,omitempty"`
}

// ServiceManagedResourcesSettings ...
type ServiceManagedResourcesSettings struct {
	// CosmosDb - The settings for the service managed cosmosdb account.
	CosmosDb *CosmosDbSettings `json:"cosmosDb,omitempty"`
}

// ServicePrincipalDatastoreCredentials service Principal datastore credentials configuration.
type ServicePrincipalDatastoreCredentials struct {
	// AuthorityURL - Authority URL used for authentication.
	AuthorityURL *string `json:"authorityUrl,omitempty"`
	// ClientID - [Required] Service principal client ID.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// ResourceURL - Resource the service principal has access to.
	ResourceURL *string `json:"resourceUrl,omitempty"`
	// Secrets - [Required] Service principal secrets.
	Secrets *ServicePrincipalDatastoreSecrets `json:"secrets,omitempty"`
	// TenantID - [Required] ID of the tenant to which the service principal belongs.
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// CredentialsType - Possible values include: 'CredentialsTypeDatastoreCredentials', 'CredentialsTypeAccountKey1', 'CredentialsTypeCertificate1', 'CredentialsTypeNone1', 'CredentialsTypeSas1', 'CredentialsTypeServicePrincipal1'
	CredentialsType CredentialsTypeBasicDatastoreCredentials `json:"credentialsType,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) MarshalJSON() ([]byte, error) {
	spdc.CredentialsType = CredentialsTypeServicePrincipal1
	objectMap := make(map[string]interface{})
	if spdc.AuthorityURL != nil {
		objectMap["authorityUrl"] = spdc.AuthorityURL
	}
	if spdc.ClientID != nil {
		objectMap["clientId"] = spdc.ClientID
	}
	if spdc.ResourceURL != nil {
		objectMap["resourceUrl"] = spdc.ResourceURL
	}
	if spdc.Secrets != nil {
		objectMap["secrets"] = spdc.Secrets
	}
	if spdc.TenantID != nil {
		objectMap["tenantId"] = spdc.TenantID
	}
	if spdc.CredentialsType != "" {
		objectMap["credentialsType"] = spdc.CredentialsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsAccountKeyDatastoreCredentials() (*AccountKeyDatastoreCredentials, bool) {
	return nil, false
}

// AsCertificateDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsCertificateDatastoreCredentials() (*CertificateDatastoreCredentials, bool) {
	return nil, false
}

// AsNoneDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsNoneDatastoreCredentials() (*NoneDatastoreCredentials, bool) {
	return nil, false
}

// AsSasDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsSasDatastoreCredentials() (*SasDatastoreCredentials, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsServicePrincipalDatastoreCredentials() (*ServicePrincipalDatastoreCredentials, bool) {
	return &spdc, true
}

// AsDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsDatastoreCredentials() (*DatastoreCredentials, bool) {
	return nil, false
}

// AsBasicDatastoreCredentials is the BasicDatastoreCredentials implementation for ServicePrincipalDatastoreCredentials.
func (spdc ServicePrincipalDatastoreCredentials) AsBasicDatastoreCredentials() (BasicDatastoreCredentials, bool) {
	return &spdc, true
}

// ServicePrincipalDatastoreSecrets datastore Service Principal secrets.
type ServicePrincipalDatastoreSecrets struct {
	// ClientSecret - Service principal secret.
	ClientSecret *string `json:"clientSecret,omitempty"`
	// SecretsType - Possible values include: 'SecretsTypeDatastoreSecrets', 'SecretsTypeAccountKey', 'SecretsTypeCertificate', 'SecretsTypeSas', 'SecretsTypeServicePrincipal'
	SecretsType SecretsTypeBasicDatastoreSecrets `json:"secretsType,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) MarshalJSON() ([]byte, error) {
	spds.SecretsType = SecretsTypeServicePrincipal
	objectMap := make(map[string]interface{})
	if spds.ClientSecret != nil {
		objectMap["clientSecret"] = spds.ClientSecret
	}
	if spds.SecretsType != "" {
		objectMap["secretsType"] = spds.SecretsType
	}
	return json.Marshal(objectMap)
}

// AsAccountKeyDatastoreSecrets is the BasicDatastoreSecrets implementation for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) AsAccountKeyDatastoreSecrets() (*AccountKeyDatastoreSecrets, bool) {
	return nil, false
}

// AsCertificateDatastoreSecrets is the BasicDatastoreSecrets implementation for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) AsCertificateDatastoreSecrets() (*CertificateDatastoreSecrets, bool) {
	return nil, false
}

// AsSasDatastoreSecrets is the BasicDatastoreSecrets implementation for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) AsSasDatastoreSecrets() (*SasDatastoreSecrets, bool) {
	return nil, false
}

// AsServicePrincipalDatastoreSecrets is the BasicDatastoreSecrets implementation for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) AsServicePrincipalDatastoreSecrets() (*ServicePrincipalDatastoreSecrets, bool) {
	return &spds, true
}

// AsDatastoreSecrets is the BasicDatastoreSecrets implementation for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) AsDatastoreSecrets() (*DatastoreSecrets, bool) {
	return nil, false
}

// AsBasicDatastoreSecrets is the BasicDatastoreSecrets implementation for ServicePrincipalDatastoreSecrets.
func (spds ServicePrincipalDatastoreSecrets) AsBasicDatastoreSecrets() (BasicDatastoreSecrets, bool) {
	return &spds, true
}

// SetupScripts details of customized scripts to execute for setting up the cluster.
type SetupScripts struct {
	// Scripts - Customized setup scripts
	Scripts *ScriptsToExecute `json:"scripts,omitempty"`
}

// SharedPrivateLinkResource ...
type SharedPrivateLinkResource struct {
	// Name - Unique name of the private link.
	Name *string `json:"name,omitempty"`
	// SharedPrivateLinkResourceProperty - Resource properties.
	*SharedPrivateLinkResourceProperty `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SharedPrivateLinkResource.
func (splr SharedPrivateLinkResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if splr.Name != nil {
		objectMap["name"] = splr.Name
	}
	if splr.SharedPrivateLinkResourceProperty != nil {
		objectMap["properties"] = splr.SharedPrivateLinkResourceProperty
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SharedPrivateLinkResource struct.
func (splr *SharedPrivateLinkResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				splr.Name = &name
			}
		case "properties":
			if v != nil {
				var sharedPrivateLinkResourceProperty SharedPrivateLinkResourceProperty
				err = json.Unmarshal(*v, &sharedPrivateLinkResourceProperty)
				if err != nil {
					return err
				}
				splr.SharedPrivateLinkResourceProperty = &sharedPrivateLinkResourceProperty
			}
		}
	}

	return nil
}

// SharedPrivateLinkResourceProperty properties of a shared private link resource.
type SharedPrivateLinkResourceProperty struct {
	// PrivateLinkResourceID - The resource id that private link links to.
	PrivateLinkResourceID *string `json:"privateLinkResourceId,omitempty"`
	// GroupID - The private link resource group id.
	GroupID *string `json:"groupId,omitempty"`
	// RequestMessage - Request message.
	RequestMessage *string `json:"requestMessage,omitempty"`
	// Status - Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service. Possible values include: 'Pending', 'Approved', 'Rejected', 'Disconnected', 'Timeout'
	Status PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// Sku the resource model definition representing SKU
type Sku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// SkuCapacity SKU capacity information
type SkuCapacity struct {
	// Default - Gets or sets the default capacity.
	Default *int32 `json:"default,omitempty"`
	// Maximum - Gets or sets the maximum.
	Maximum *int32 `json:"maximum,omitempty"`
	// Minimum - Gets or sets the minimum.
	Minimum *int32 `json:"minimum,omitempty"`
	// ScaleType - Gets or sets the type of the scale. Possible values include: 'SkuScaleTypeAutomatic', 'SkuScaleTypeManual', 'SkuScaleTypeNone'
	ScaleType SkuScaleType `json:"scaleType,omitempty"`
}

// SkuResource fulfills ARM Contract requirement to list all available SKUS for a resource.
type SkuResource struct {
	// Capacity - Gets or sets the Sku Capacity.
	Capacity *SkuCapacity `json:"capacity,omitempty"`
	// ResourceType - READ-ONLY; The resource type name.
	ResourceType *string `json:"resourceType,omitempty"`
	// Sku - Gets or sets the Sku.
	Sku *SkuSetting `json:"sku,omitempty"`
}

// MarshalJSON is the custom marshaler for SkuResource.
func (sr SkuResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.Capacity != nil {
		objectMap["capacity"] = sr.Capacity
	}
	if sr.Sku != nil {
		objectMap["sku"] = sr.Sku
	}
	return json.Marshal(objectMap)
}

// SkuResourceArmPaginatedResult a paginated list of SkuResource entities.
type SkuResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link to the next page of SkuResource objects. If null, there are no additional pages.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - An array of objects of type SkuResource.
	Value *[]SkuResource `json:"value,omitempty"`
}

// SkuResourceArmPaginatedResultIterator provides access to a complete listing of SkuResource values.
type SkuResourceArmPaginatedResultIterator struct {
	i    int
	page SkuResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SkuResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkuResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SkuResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SkuResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SkuResourceArmPaginatedResultIterator) Response() SkuResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SkuResourceArmPaginatedResultIterator) Value() SkuResource {
	if !iter.page.NotDone() {
		return SkuResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SkuResourceArmPaginatedResultIterator type.
func NewSkuResourceArmPaginatedResultIterator(page SkuResourceArmPaginatedResultPage) SkuResourceArmPaginatedResultIterator {
	return SkuResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (srapr SkuResourceArmPaginatedResult) IsEmpty() bool {
	return srapr.Value == nil || len(*srapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (srapr SkuResourceArmPaginatedResult) hasNextLink() bool {
	return srapr.NextLink != nil && len(*srapr.NextLink) != 0
}

// skuResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (srapr SkuResourceArmPaginatedResult) skuResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !srapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(srapr.NextLink)))
}

// SkuResourceArmPaginatedResultPage contains a page of SkuResource values.
type SkuResourceArmPaginatedResultPage struct {
	fn    func(context.Context, SkuResourceArmPaginatedResult) (SkuResourceArmPaginatedResult, error)
	srapr SkuResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SkuResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkuResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.srapr)
		if err != nil {
			return err
		}
		page.srapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SkuResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SkuResourceArmPaginatedResultPage) NotDone() bool {
	return !page.srapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SkuResourceArmPaginatedResultPage) Response() SkuResourceArmPaginatedResult {
	return page.srapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SkuResourceArmPaginatedResultPage) Values() []SkuResource {
	if page.srapr.IsEmpty() {
		return nil
	}
	return *page.srapr.Value
}

// Creates a new instance of the SkuResourceArmPaginatedResultPage type.
func NewSkuResourceArmPaginatedResultPage(cur SkuResourceArmPaginatedResult, getNextPage func(context.Context, SkuResourceArmPaginatedResult) (SkuResourceArmPaginatedResult, error)) SkuResourceArmPaginatedResultPage {
	return SkuResourceArmPaginatedResultPage{
		fn:    getNextPage,
		srapr: cur,
	}
}

// SkuSetting skuSetting fulfills the need for stripped down SKU info in ARM contract.
type SkuSetting struct {
	// Name - [Required] The name of the SKU. Ex - P3. It is typically a letter+number code.
	Name *string `json:"name,omitempty"`
	// Tier - This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT. Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
}

// SslConfiguration the ssl configuration for scoring
type SslConfiguration struct {
	// Status - Enable or disable ssl for scoring. Possible values include: 'SslConfigStatusDisabled', 'SslConfigStatusEnabled', 'SslConfigStatusAuto'
	Status SslConfigStatus `json:"status,omitempty"`
	// Cert - Cert data
	Cert *string `json:"cert,omitempty"`
	// Key - Key data
	Key *string `json:"key,omitempty"`
	// Cname - CNAME of the cert
	Cname *string `json:"cname,omitempty"`
	// LeafDomainLabel - Leaf domain label of public endpoint
	LeafDomainLabel *string `json:"leafDomainLabel,omitempty"`
	// OverwriteExistingDomain - Indicates whether to overwrite existing domain label.
	OverwriteExistingDomain *bool `json:"overwriteExistingDomain,omitempty"`
}

// SweepJob sweep job definition.
type SweepJob struct {
	// EarlyTermination - Early termination policies enable canceling poor-performing runs before they complete
	EarlyTermination BasicEarlyTerminationPolicy `json:"earlyTermination,omitempty"`
	// Inputs - Mapping of input data bindings used in the job.
	Inputs map[string]BasicJobInput `json:"inputs"`
	// Limits - Sweep Job limit.
	Limits *SweepJobLimits `json:"limits,omitempty"`
	// Objective - [Required] Optimization objective.
	Objective *Objective `json:"objective,omitempty"`
	// Outputs - Mapping of output data bindings used in the job.
	Outputs map[string]BasicJobOutput `json:"outputs"`
	// SamplingAlgorithm - [Required] The hyperparameter sampling algorithm
	SamplingAlgorithm BasicSamplingAlgorithm `json:"samplingAlgorithm,omitempty"`
	// SearchSpace - [Required] A dictionary containing each parameter and its distribution. The dictionary key is the name of the parameter
	SearchSpace interface{} `json:"searchSpace,omitempty"`
	// Trial - [Required] Trial component definition.
	Trial *TrialComponent `json:"trial,omitempty"`
	// ComputeID - ARM resource ID of the compute resource.
	ComputeID *string `json:"computeId,omitempty"`
	// DisplayName - Display name of job.
	DisplayName *string `json:"displayName,omitempty"`
	// ExperimentName - The name of the experiment the job belongs to. If not set, the job is placed in the "Default" experiment.
	ExperimentName *string `json:"experimentName,omitempty"`
	// Identity - Identity configuration. If set, this should be one of AmlToken, ManagedIdentity, UserIdentity or null.
	// Defaults to AmlToken if null.
	Identity BasicIdentityConfiguration `json:"identity,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Services - List of JobEndpoints.
	// For local jobs, a job endpoint will have an endpoint value of FileStreamObject.
	Services map[string]*JobService `json:"services"`
	// Status - READ-ONLY; Status of the job. Possible values include: 'JobStatusNotStarted', 'JobStatusStarting', 'JobStatusProvisioning', 'JobStatusPreparing', 'JobStatusQueued', 'JobStatusRunning', 'JobStatusFinalizing', 'JobStatusCancelRequested', 'JobStatusCompleted', 'JobStatusFailed', 'JobStatusCanceled', 'JobStatusNotResponding', 'JobStatusPaused', 'JobStatusUnknown'
	Status JobStatus `json:"status,omitempty"`
	// JobType - Possible values include: 'JobTypeJobBase', 'JobTypeCommand1', 'JobTypePipeline1', 'JobTypeSweep1'
	JobType JobTypeBasicJobBase `json:"jobType,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SweepJob.
func (sj SweepJob) MarshalJSON() ([]byte, error) {
	sj.JobType = JobTypeSweep1
	objectMap := make(map[string]interface{})
	objectMap["earlyTermination"] = sj.EarlyTermination
	if sj.Inputs != nil {
		objectMap["inputs"] = sj.Inputs
	}
	if sj.Limits != nil {
		objectMap["limits"] = sj.Limits
	}
	if sj.Objective != nil {
		objectMap["objective"] = sj.Objective
	}
	if sj.Outputs != nil {
		objectMap["outputs"] = sj.Outputs
	}
	objectMap["samplingAlgorithm"] = sj.SamplingAlgorithm
	if sj.SearchSpace != nil {
		objectMap["searchSpace"] = sj.SearchSpace
	}
	if sj.Trial != nil {
		objectMap["trial"] = sj.Trial
	}
	if sj.ComputeID != nil {
		objectMap["computeId"] = sj.ComputeID
	}
	if sj.DisplayName != nil {
		objectMap["displayName"] = sj.DisplayName
	}
	if sj.ExperimentName != nil {
		objectMap["experimentName"] = sj.ExperimentName
	}
	objectMap["identity"] = sj.Identity
	if sj.IsArchived != nil {
		objectMap["isArchived"] = sj.IsArchived
	}
	if sj.Services != nil {
		objectMap["services"] = sj.Services
	}
	if sj.JobType != "" {
		objectMap["jobType"] = sj.JobType
	}
	if sj.Description != nil {
		objectMap["description"] = sj.Description
	}
	if sj.Properties != nil {
		objectMap["properties"] = sj.Properties
	}
	if sj.Tags != nil {
		objectMap["tags"] = sj.Tags
	}
	return json.Marshal(objectMap)
}

// AsCommandJob is the BasicJobBase implementation for SweepJob.
func (sj SweepJob) AsCommandJob() (*CommandJob, bool) {
	return nil, false
}

// AsPipelineJob is the BasicJobBase implementation for SweepJob.
func (sj SweepJob) AsPipelineJob() (*PipelineJob, bool) {
	return nil, false
}

// AsSweepJob is the BasicJobBase implementation for SweepJob.
func (sj SweepJob) AsSweepJob() (*SweepJob, bool) {
	return &sj, true
}

// AsJobBase is the BasicJobBase implementation for SweepJob.
func (sj SweepJob) AsJobBase() (*JobBase, bool) {
	return nil, false
}

// AsBasicJobBase is the BasicJobBase implementation for SweepJob.
func (sj SweepJob) AsBasicJobBase() (BasicJobBase, bool) {
	return &sj, true
}

// UnmarshalJSON is the custom unmarshaler for SweepJob struct.
func (sj *SweepJob) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "earlyTermination":
			if v != nil {
				earlyTermination, err := unmarshalBasicEarlyTerminationPolicy(*v)
				if err != nil {
					return err
				}
				sj.EarlyTermination = earlyTermination
			}
		case "inputs":
			if v != nil {
				var inputs map[string]BasicJobInput
				err = json.Unmarshal(*v, &inputs)
				if err != nil {
					return err
				}
				sj.Inputs = inputs
			}
		case "limits":
			if v != nil {
				var limits SweepJobLimits
				err = json.Unmarshal(*v, &limits)
				if err != nil {
					return err
				}
				sj.Limits = &limits
			}
		case "objective":
			if v != nil {
				var objective Objective
				err = json.Unmarshal(*v, &objective)
				if err != nil {
					return err
				}
				sj.Objective = &objective
			}
		case "outputs":
			if v != nil {
				var outputs map[string]BasicJobOutput
				err = json.Unmarshal(*v, &outputs)
				if err != nil {
					return err
				}
				sj.Outputs = outputs
			}
		case "samplingAlgorithm":
			if v != nil {
				samplingAlgorithm, err := unmarshalBasicSamplingAlgorithm(*v)
				if err != nil {
					return err
				}
				sj.SamplingAlgorithm = samplingAlgorithm
			}
		case "searchSpace":
			if v != nil {
				var searchSpace interface{}
				err = json.Unmarshal(*v, &searchSpace)
				if err != nil {
					return err
				}
				sj.SearchSpace = searchSpace
			}
		case "trial":
			if v != nil {
				var trial TrialComponent
				err = json.Unmarshal(*v, &trial)
				if err != nil {
					return err
				}
				sj.Trial = &trial
			}
		case "computeId":
			if v != nil {
				var computeID string
				err = json.Unmarshal(*v, &computeID)
				if err != nil {
					return err
				}
				sj.ComputeID = &computeID
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sj.DisplayName = &displayName
			}
		case "experimentName":
			if v != nil {
				var experimentName string
				err = json.Unmarshal(*v, &experimentName)
				if err != nil {
					return err
				}
				sj.ExperimentName = &experimentName
			}
		case "identity":
			if v != nil {
				identity, err := unmarshalBasicIdentityConfiguration(*v)
				if err != nil {
					return err
				}
				sj.Identity = identity
			}
		case "isArchived":
			if v != nil {
				var isArchived bool
				err = json.Unmarshal(*v, &isArchived)
				if err != nil {
					return err
				}
				sj.IsArchived = &isArchived
			}
		case "services":
			if v != nil {
				var services map[string]*JobService
				err = json.Unmarshal(*v, &services)
				if err != nil {
					return err
				}
				sj.Services = services
			}
		case "status":
			if v != nil {
				var status JobStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				sj.Status = status
			}
		case "jobType":
			if v != nil {
				var jobType JobTypeBasicJobBase
				err = json.Unmarshal(*v, &jobType)
				if err != nil {
					return err
				}
				sj.JobType = jobType
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				sj.Description = &description
			}
		case "properties":
			if v != nil {
				var properties map[string]*string
				err = json.Unmarshal(*v, &properties)
				if err != nil {
					return err
				}
				sj.Properties = properties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sj.Tags = tags
			}
		}
	}

	return nil
}

// SweepJobLimits sweep Job limit class.
type SweepJobLimits struct {
	// MaxConcurrentTrials - Sweep Job max concurrent trials.
	MaxConcurrentTrials *int32 `json:"maxConcurrentTrials,omitempty"`
	// MaxTotalTrials - Sweep Job max total trials.
	MaxTotalTrials *int32 `json:"maxTotalTrials,omitempty"`
	// TrialTimeout - Sweep Job Trial timeout value.
	TrialTimeout *string `json:"trialTimeout,omitempty"`
	// Timeout - The max run duration in ISO 8601 format, after which the job will be cancelled. Only supports duration with precision as low as Seconds.
	Timeout *string `json:"timeout,omitempty"`
	// JobLimitsType - Possible values include: 'JobLimitsTypeJobLimits', 'JobLimitsTypeCommand', 'JobLimitsTypeSweep'
	JobLimitsType JobLimitsTypeBasicJobLimits `json:"jobLimitsType,omitempty"`
}

// MarshalJSON is the custom marshaler for SweepJobLimits.
func (sjl SweepJobLimits) MarshalJSON() ([]byte, error) {
	sjl.JobLimitsType = JobLimitsTypeSweep
	objectMap := make(map[string]interface{})
	if sjl.MaxConcurrentTrials != nil {
		objectMap["maxConcurrentTrials"] = sjl.MaxConcurrentTrials
	}
	if sjl.MaxTotalTrials != nil {
		objectMap["maxTotalTrials"] = sjl.MaxTotalTrials
	}
	if sjl.TrialTimeout != nil {
		objectMap["trialTimeout"] = sjl.TrialTimeout
	}
	if sjl.Timeout != nil {
		objectMap["timeout"] = sjl.Timeout
	}
	if sjl.JobLimitsType != "" {
		objectMap["jobLimitsType"] = sjl.JobLimitsType
	}
	return json.Marshal(objectMap)
}

// AsCommandJobLimits is the BasicJobLimits implementation for SweepJobLimits.
func (sjl SweepJobLimits) AsCommandJobLimits() (*CommandJobLimits, bool) {
	return nil, false
}

// AsSweepJobLimits is the BasicJobLimits implementation for SweepJobLimits.
func (sjl SweepJobLimits) AsSweepJobLimits() (*SweepJobLimits, bool) {
	return &sjl, true
}

// AsJobLimits is the BasicJobLimits implementation for SweepJobLimits.
func (sjl SweepJobLimits) AsJobLimits() (*JobLimits, bool) {
	return nil, false
}

// AsBasicJobLimits is the BasicJobLimits implementation for SweepJobLimits.
func (sjl SweepJobLimits) AsBasicJobLimits() (BasicJobLimits, bool) {
	return &sjl, true
}

// SynapseSpark a SynapseSpark compute.
type SynapseSpark struct {
	Properties *SynapseSparkProperties `json:"properties,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`
	// ComputeType - Possible values include: 'ComputeTypeCompute', 'ComputeTypeDataFactory1', 'ComputeTypeSynapseSpark1'
	ComputeType ComputeTypeBasicCompute `json:"computeType,omitempty"`
}

// MarshalJSON is the custom marshaler for SynapseSpark.
func (ss SynapseSpark) MarshalJSON() ([]byte, error) {
	ss.ComputeType = ComputeTypeSynapseSpark1
	objectMap := make(map[string]interface{})
	if ss.Properties != nil {
		objectMap["properties"] = ss.Properties
	}
	if ss.Description != nil {
		objectMap["description"] = ss.Description
	}
	if ss.ResourceID != nil {
		objectMap["resourceId"] = ss.ResourceID
	}
	if ss.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = ss.DisableLocalAuth
	}
	if ss.ComputeType != "" {
		objectMap["computeType"] = ss.ComputeType
	}
	return json.Marshal(objectMap)
}

// AsDataFactory is the BasicCompute implementation for SynapseSpark.
func (ss SynapseSpark) AsDataFactory() (*DataFactory, bool) {
	return nil, false
}

// AsSynapseSpark is the BasicCompute implementation for SynapseSpark.
func (ss SynapseSpark) AsSynapseSpark() (*SynapseSpark, bool) {
	return &ss, true
}

// AsCompute is the BasicCompute implementation for SynapseSpark.
func (ss SynapseSpark) AsCompute() (*Compute, bool) {
	return nil, false
}

// AsBasicCompute is the BasicCompute implementation for SynapseSpark.
func (ss SynapseSpark) AsBasicCompute() (BasicCompute, bool) {
	return &ss, true
}

// SynapseSparkProperties ...
type SynapseSparkProperties struct {
	// AutoScaleProperties - Auto scale properties.
	AutoScaleProperties *AutoScaleProperties `json:"autoScaleProperties,omitempty"`
	// AutoPauseProperties - Auto pause properties.
	AutoPauseProperties *AutoPauseProperties `json:"autoPauseProperties,omitempty"`
	// SparkVersion - Spark version.
	SparkVersion *string `json:"sparkVersion,omitempty"`
	// NodeCount - The number of compute nodes currently assigned to the compute.
	NodeCount *int32 `json:"nodeCount,omitempty"`
	// NodeSize - Node size.
	NodeSize *string `json:"nodeSize,omitempty"`
	// NodeSizeFamily - Node size family.
	NodeSizeFamily *string `json:"nodeSizeFamily,omitempty"`
	// SubscriptionID - Azure subscription identifier.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// ResourceGroup - Name of the resource group in which workspace is located.
	ResourceGroup *string `json:"resourceGroup,omitempty"`
	// WorkspaceName - Name of Azure Machine Learning workspace.
	WorkspaceName *string `json:"workspaceName,omitempty"`
	// PoolName - Pool name.
	PoolName *string `json:"poolName,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// SystemService a system service running on a compute.
type SystemService struct {
	// SystemServiceType - READ-ONLY; The type of this system service.
	SystemServiceType *string `json:"systemServiceType,omitempty"`
	// PublicIPAddress - READ-ONLY; Public IP address
	PublicIPAddress *string `json:"publicIpAddress,omitempty"`
	// Version - READ-ONLY; The version for this type.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON is the custom marshaler for SystemService.
func (ss SystemService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// TargetUtilizationScaleSettings ...
type TargetUtilizationScaleSettings struct {
	// MaxInstances - The maximum number of instances that the deployment can scale to. The quota will be reserved for max_instances.
	MaxInstances *int32 `json:"maxInstances,omitempty"`
	// MinInstances - The minimum number of instances to always be present.
	MinInstances *int32 `json:"minInstances,omitempty"`
	// PollingInterval - The polling interval in ISO 8691 format. Only supports duration with precision as low as Seconds.
	PollingInterval *string `json:"pollingInterval,omitempty"`
	// TargetUtilizationPercentage - Target CPU usage for the autoscaler.
	TargetUtilizationPercentage *int32 `json:"targetUtilizationPercentage,omitempty"`
	// ScaleType - Possible values include: 'ScaleTypeOnlineScaleSettings', 'ScaleTypeDefault', 'ScaleTypeTargetUtilization'
	ScaleType ScaleTypeBasicOnlineScaleSettings `json:"scaleType,omitempty"`
}

// MarshalJSON is the custom marshaler for TargetUtilizationScaleSettings.
func (tuss TargetUtilizationScaleSettings) MarshalJSON() ([]byte, error) {
	tuss.ScaleType = ScaleTypeTargetUtilization
	objectMap := make(map[string]interface{})
	if tuss.MaxInstances != nil {
		objectMap["maxInstances"] = tuss.MaxInstances
	}
	if tuss.MinInstances != nil {
		objectMap["minInstances"] = tuss.MinInstances
	}
	if tuss.PollingInterval != nil {
		objectMap["pollingInterval"] = tuss.PollingInterval
	}
	if tuss.TargetUtilizationPercentage != nil {
		objectMap["targetUtilizationPercentage"] = tuss.TargetUtilizationPercentage
	}
	if tuss.ScaleType != "" {
		objectMap["scaleType"] = tuss.ScaleType
	}
	return json.Marshal(objectMap)
}

// AsDefaultScaleSettings is the BasicOnlineScaleSettings implementation for TargetUtilizationScaleSettings.
func (tuss TargetUtilizationScaleSettings) AsDefaultScaleSettings() (*DefaultScaleSettings, bool) {
	return nil, false
}

// AsTargetUtilizationScaleSettings is the BasicOnlineScaleSettings implementation for TargetUtilizationScaleSettings.
func (tuss TargetUtilizationScaleSettings) AsTargetUtilizationScaleSettings() (*TargetUtilizationScaleSettings, bool) {
	return &tuss, true
}

// AsOnlineScaleSettings is the BasicOnlineScaleSettings implementation for TargetUtilizationScaleSettings.
func (tuss TargetUtilizationScaleSettings) AsOnlineScaleSettings() (*OnlineScaleSettings, bool) {
	return nil, false
}

// AsBasicOnlineScaleSettings is the BasicOnlineScaleSettings implementation for TargetUtilizationScaleSettings.
func (tuss TargetUtilizationScaleSettings) AsBasicOnlineScaleSettings() (BasicOnlineScaleSettings, bool) {
	return &tuss, true
}

// TensorFlow tensorFlow distribution configuration.
type TensorFlow struct {
	// ParameterServerCount - Number of parameter server tasks.
	ParameterServerCount *int32 `json:"parameterServerCount,omitempty"`
	// WorkerCount - Number of workers. If not specified, will default to the instance count.
	WorkerCount *int32 `json:"workerCount,omitempty"`
	// DistributionType - Possible values include: 'DistributionTypeDistributionConfiguration', 'DistributionTypeMpi1', 'DistributionTypePyTorch1', 'DistributionTypeTensorFlow1'
	DistributionType DistributionTypeBasicDistributionConfiguration `json:"distributionType,omitempty"`
}

// MarshalJSON is the custom marshaler for TensorFlow.
func (tf TensorFlow) MarshalJSON() ([]byte, error) {
	tf.DistributionType = DistributionTypeTensorFlow1
	objectMap := make(map[string]interface{})
	if tf.ParameterServerCount != nil {
		objectMap["parameterServerCount"] = tf.ParameterServerCount
	}
	if tf.WorkerCount != nil {
		objectMap["workerCount"] = tf.WorkerCount
	}
	if tf.DistributionType != "" {
		objectMap["distributionType"] = tf.DistributionType
	}
	return json.Marshal(objectMap)
}

// AsMpi is the BasicDistributionConfiguration implementation for TensorFlow.
func (tf TensorFlow) AsMpi() (*Mpi, bool) {
	return nil, false
}

// AsPyTorch is the BasicDistributionConfiguration implementation for TensorFlow.
func (tf TensorFlow) AsPyTorch() (*PyTorch, bool) {
	return nil, false
}

// AsTensorFlow is the BasicDistributionConfiguration implementation for TensorFlow.
func (tf TensorFlow) AsTensorFlow() (*TensorFlow, bool) {
	return &tf, true
}

// AsDistributionConfiguration is the BasicDistributionConfiguration implementation for TensorFlow.
func (tf TensorFlow) AsDistributionConfiguration() (*DistributionConfiguration, bool) {
	return nil, false
}

// AsBasicDistributionConfiguration is the BasicDistributionConfiguration implementation for TensorFlow.
func (tf TensorFlow) AsBasicDistributionConfiguration() (BasicDistributionConfiguration, bool) {
	return &tf, true
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// TrialComponent trial component definition.
type TrialComponent struct {
	// CodeID - ARM resource ID of the code asset.
	CodeID *string `json:"codeId,omitempty"`
	// Command - [Required] The command to execute on startup of the job. eg. "python train.py"
	Command *string `json:"command,omitempty"`
	// Distribution - Distribution configuration of the job. If set, this should be one of Mpi, Tensorflow, PyTorch, or null.
	Distribution BasicDistributionConfiguration `json:"distribution,omitempty"`
	// EnvironmentID - [Required] The ARM resource ID of the Environment specification for the job.
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentVariables - Environment variables included in the job.
	EnvironmentVariables map[string]*string `json:"environmentVariables"`
	// Resources - Compute Resource configuration for the job.
	Resources *ResourceConfiguration `json:"resources,omitempty"`
}

// MarshalJSON is the custom marshaler for TrialComponent.
func (tc TrialComponent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tc.CodeID != nil {
		objectMap["codeId"] = tc.CodeID
	}
	if tc.Command != nil {
		objectMap["command"] = tc.Command
	}
	objectMap["distribution"] = tc.Distribution
	if tc.EnvironmentID != nil {
		objectMap["environmentId"] = tc.EnvironmentID
	}
	if tc.EnvironmentVariables != nil {
		objectMap["environmentVariables"] = tc.EnvironmentVariables
	}
	if tc.Resources != nil {
		objectMap["resources"] = tc.Resources
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TrialComponent struct.
func (tc *TrialComponent) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "codeId":
			if v != nil {
				var codeID string
				err = json.Unmarshal(*v, &codeID)
				if err != nil {
					return err
				}
				tc.CodeID = &codeID
			}
		case "command":
			if v != nil {
				var command string
				err = json.Unmarshal(*v, &command)
				if err != nil {
					return err
				}
				tc.Command = &command
			}
		case "distribution":
			if v != nil {
				distribution, err := unmarshalBasicDistributionConfiguration(*v)
				if err != nil {
					return err
				}
				tc.Distribution = distribution
			}
		case "environmentId":
			if v != nil {
				var environmentID string
				err = json.Unmarshal(*v, &environmentID)
				if err != nil {
					return err
				}
				tc.EnvironmentID = &environmentID
			}
		case "environmentVariables":
			if v != nil {
				var environmentVariables map[string]*string
				err = json.Unmarshal(*v, &environmentVariables)
				if err != nil {
					return err
				}
				tc.EnvironmentVariables = environmentVariables
			}
		case "resources":
			if v != nil {
				var resources ResourceConfiguration
				err = json.Unmarshal(*v, &resources)
				if err != nil {
					return err
				}
				tc.Resources = &resources
			}
		}
	}

	return nil
}

// TritonModelJobInput ...
type TritonModelJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - [Required] Specifies the type of job. Possible values include: 'JobInputTypeLiteral', 'JobInputTypeURIFile', 'JobInputTypeURIFolder', 'JobInputTypeMltable', 'JobInputTypeCustomModel', 'JobInputTypeMlflowModel', 'JobInputTypeTritonModel'
	JobInputType JobInputType `json:"jobInputType,omitempty"`
}

// TritonModelJobOutput ...
type TritonModelJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - [Required] Specifies the type of job. Possible values include: 'JobOutputTypeURIFile', 'JobOutputTypeURIFolder', 'JobOutputTypeMltable', 'JobOutputTypeCustomModel', 'JobOutputTypeMlflowModel', 'JobOutputTypeTritonModel'
	JobOutputType JobOutputType `json:"jobOutputType,omitempty"`
}

// TruncationSelectionPolicy defines an early termination policy that cancels a given percentage of runs at
// each evaluation interval.
type TruncationSelectionPolicy struct {
	// TruncationPercentage - The percentage of runs to cancel at each evaluation interval.
	TruncationPercentage *int32 `json:"truncationPercentage,omitempty"`
	// DelayEvaluation - Number of intervals by which to delay the first evaluation.
	DelayEvaluation *int32 `json:"delayEvaluation,omitempty"`
	// EvaluationInterval - Interval (number of runs) between policy evaluations.
	EvaluationInterval *int32 `json:"evaluationInterval,omitempty"`
	// PolicyType - Possible values include: 'PolicyTypeEarlyTerminationPolicy', 'PolicyTypeBandit', 'PolicyTypeMedianStopping', 'PolicyTypeTruncationSelection'
	PolicyType PolicyType `json:"policyType,omitempty"`
}

// MarshalJSON is the custom marshaler for TruncationSelectionPolicy.
func (tsp TruncationSelectionPolicy) MarshalJSON() ([]byte, error) {
	tsp.PolicyType = PolicyTypeTruncationSelection
	objectMap := make(map[string]interface{})
	if tsp.TruncationPercentage != nil {
		objectMap["truncationPercentage"] = tsp.TruncationPercentage
	}
	if tsp.DelayEvaluation != nil {
		objectMap["delayEvaluation"] = tsp.DelayEvaluation
	}
	if tsp.EvaluationInterval != nil {
		objectMap["evaluationInterval"] = tsp.EvaluationInterval
	}
	if tsp.PolicyType != "" {
		objectMap["policyType"] = tsp.PolicyType
	}
	return json.Marshal(objectMap)
}

// AsBanditPolicy is the BasicEarlyTerminationPolicy implementation for TruncationSelectionPolicy.
func (tsp TruncationSelectionPolicy) AsBanditPolicy() (*BanditPolicy, bool) {
	return nil, false
}

// AsMedianStoppingPolicy is the BasicEarlyTerminationPolicy implementation for TruncationSelectionPolicy.
func (tsp TruncationSelectionPolicy) AsMedianStoppingPolicy() (*MedianStoppingPolicy, bool) {
	return nil, false
}

// AsTruncationSelectionPolicy is the BasicEarlyTerminationPolicy implementation for TruncationSelectionPolicy.
func (tsp TruncationSelectionPolicy) AsTruncationSelectionPolicy() (*TruncationSelectionPolicy, bool) {
	return &tsp, true
}

// AsEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for TruncationSelectionPolicy.
func (tsp TruncationSelectionPolicy) AsEarlyTerminationPolicy() (*EarlyTerminationPolicy, bool) {
	return nil, false
}

// AsBasicEarlyTerminationPolicy is the BasicEarlyTerminationPolicy implementation for TruncationSelectionPolicy.
func (tsp TruncationSelectionPolicy) AsBasicEarlyTerminationPolicy() (BasicEarlyTerminationPolicy, bool) {
	return &tsp, true
}

// UpdateWorkspaceQuotas the properties for update Quota response.
type UpdateWorkspaceQuotas struct {
	// ID - READ-ONLY; Specifies the resource ID.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Specifies the resource type.
	Type *string `json:"type,omitempty"`
	// Limit - The maximum permitted quota of the resource.
	Limit *int64 `json:"limit,omitempty"`
	// Unit - READ-ONLY; An enum describing the unit of quota measurement. Possible values include: 'Count'
	Unit QuotaUnit `json:"unit,omitempty"`
	// Status - Status of update workspace quota. Possible values include: 'Undefined', 'Success', 'Failure', 'InvalidQuotaBelowClusterMinimum', 'InvalidQuotaExceedsSubscriptionLimit', 'InvalidVMFamilyName', 'OperationNotSupportedForSku', 'OperationNotEnabledForRegion'
	Status Status `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for UpdateWorkspaceQuotas.
func (uwq UpdateWorkspaceQuotas) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if uwq.Limit != nil {
		objectMap["limit"] = uwq.Limit
	}
	if uwq.Status != "" {
		objectMap["status"] = uwq.Status
	}
	return json.Marshal(objectMap)
}

// UpdateWorkspaceQuotasResult the result of update workspace quota.
type UpdateWorkspaceQuotasResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of workspace quota update result.
	Value *[]UpdateWorkspaceQuotas `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URI to fetch the next page of workspace quota update result. Call ListNext() with this to fetch the next page of Workspace Quota update result.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for UpdateWorkspaceQuotasResult.
func (uwqr UpdateWorkspaceQuotasResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// URIFileDataVersion uri-file data version entity
type URIFileDataVersion struct {
	// DataURI - [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220501.Assets.DataVersionBase.DataType
	DataURI *string `json:"dataUri,omitempty"`
	// DataType - Possible values include: 'DataTypeDataVersionBase', 'DataTypeMltable', 'DataTypeURIFile', 'DataTypeURIFolder'
	DataType DataTypeBasicDataVersionBase `json:"dataType,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for URIFileDataVersion.
func (ufdv URIFileDataVersion) MarshalJSON() ([]byte, error) {
	ufdv.DataType = DataTypeURIFile
	objectMap := make(map[string]interface{})
	if ufdv.DataURI != nil {
		objectMap["dataUri"] = ufdv.DataURI
	}
	if ufdv.DataType != "" {
		objectMap["dataType"] = ufdv.DataType
	}
	if ufdv.IsAnonymous != nil {
		objectMap["isAnonymous"] = ufdv.IsAnonymous
	}
	if ufdv.IsArchived != nil {
		objectMap["isArchived"] = ufdv.IsArchived
	}
	if ufdv.Description != nil {
		objectMap["description"] = ufdv.Description
	}
	if ufdv.Properties != nil {
		objectMap["properties"] = ufdv.Properties
	}
	if ufdv.Tags != nil {
		objectMap["tags"] = ufdv.Tags
	}
	return json.Marshal(objectMap)
}

// AsMLTableData is the BasicDataVersionBase implementation for URIFileDataVersion.
func (ufdv URIFileDataVersion) AsMLTableData() (*MLTableData, bool) {
	return nil, false
}

// AsURIFileDataVersion is the BasicDataVersionBase implementation for URIFileDataVersion.
func (ufdv URIFileDataVersion) AsURIFileDataVersion() (*URIFileDataVersion, bool) {
	return &ufdv, true
}

// AsURIFolderDataVersion is the BasicDataVersionBase implementation for URIFileDataVersion.
func (ufdv URIFileDataVersion) AsURIFolderDataVersion() (*URIFolderDataVersion, bool) {
	return nil, false
}

// AsDataVersionBase is the BasicDataVersionBase implementation for URIFileDataVersion.
func (ufdv URIFileDataVersion) AsDataVersionBase() (*DataVersionBase, bool) {
	return nil, false
}

// AsBasicDataVersionBase is the BasicDataVersionBase implementation for URIFileDataVersion.
func (ufdv URIFileDataVersion) AsBasicDataVersionBase() (BasicDataVersionBase, bool) {
	return &ufdv, true
}

// URIFileJobInput ...
type URIFileJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - [Required] Specifies the type of job. Possible values include: 'JobInputTypeLiteral', 'JobInputTypeURIFile', 'JobInputTypeURIFolder', 'JobInputTypeMltable', 'JobInputTypeCustomModel', 'JobInputTypeMlflowModel', 'JobInputTypeTritonModel'
	JobInputType JobInputType `json:"jobInputType,omitempty"`
}

// URIFileJobOutput ...
type URIFileJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - [Required] Specifies the type of job. Possible values include: 'JobOutputTypeURIFile', 'JobOutputTypeURIFolder', 'JobOutputTypeMltable', 'JobOutputTypeCustomModel', 'JobOutputTypeMlflowModel', 'JobOutputTypeTritonModel'
	JobOutputType JobOutputType `json:"jobOutputType,omitempty"`
}

// URIFolderDataVersion uri-folder data version entity
type URIFolderDataVersion struct {
	// DataURI - [Required] Uri of the data. Usage/meaning depends on Microsoft.MachineLearning.ManagementFrontEnd.Contracts.V20220501.Assets.DataVersionBase.DataType
	DataURI *string `json:"dataUri,omitempty"`
	// DataType - Possible values include: 'DataTypeDataVersionBase', 'DataTypeMltable', 'DataTypeURIFile', 'DataTypeURIFolder'
	DataType DataTypeBasicDataVersionBase `json:"dataType,omitempty"`
	// IsAnonymous - If the name version are system generated (anonymous registration).
	IsAnonymous *bool `json:"isAnonymous,omitempty"`
	// IsArchived - Is the asset archived?
	IsArchived *bool `json:"isArchived,omitempty"`
	// Description - The asset description text.
	Description *string `json:"description,omitempty"`
	// Properties - The asset property dictionary.
	Properties map[string]*string `json:"properties"`
	// Tags - Tag dictionary. Tags can be added, removed, and updated.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for URIFolderDataVersion.
func (ufdv URIFolderDataVersion) MarshalJSON() ([]byte, error) {
	ufdv.DataType = DataTypeURIFolder
	objectMap := make(map[string]interface{})
	if ufdv.DataURI != nil {
		objectMap["dataUri"] = ufdv.DataURI
	}
	if ufdv.DataType != "" {
		objectMap["dataType"] = ufdv.DataType
	}
	if ufdv.IsAnonymous != nil {
		objectMap["isAnonymous"] = ufdv.IsAnonymous
	}
	if ufdv.IsArchived != nil {
		objectMap["isArchived"] = ufdv.IsArchived
	}
	if ufdv.Description != nil {
		objectMap["description"] = ufdv.Description
	}
	if ufdv.Properties != nil {
		objectMap["properties"] = ufdv.Properties
	}
	if ufdv.Tags != nil {
		objectMap["tags"] = ufdv.Tags
	}
	return json.Marshal(objectMap)
}

// AsMLTableData is the BasicDataVersionBase implementation for URIFolderDataVersion.
func (ufdv URIFolderDataVersion) AsMLTableData() (*MLTableData, bool) {
	return nil, false
}

// AsURIFileDataVersion is the BasicDataVersionBase implementation for URIFolderDataVersion.
func (ufdv URIFolderDataVersion) AsURIFileDataVersion() (*URIFileDataVersion, bool) {
	return nil, false
}

// AsURIFolderDataVersion is the BasicDataVersionBase implementation for URIFolderDataVersion.
func (ufdv URIFolderDataVersion) AsURIFolderDataVersion() (*URIFolderDataVersion, bool) {
	return &ufdv, true
}

// AsDataVersionBase is the BasicDataVersionBase implementation for URIFolderDataVersion.
func (ufdv URIFolderDataVersion) AsDataVersionBase() (*DataVersionBase, bool) {
	return nil, false
}

// AsBasicDataVersionBase is the BasicDataVersionBase implementation for URIFolderDataVersion.
func (ufdv URIFolderDataVersion) AsBasicDataVersionBase() (BasicDataVersionBase, bool) {
	return &ufdv, true
}

// URIFolderJobInput ...
type URIFolderJobInput struct {
	// Mode - Input Asset Delivery Mode. Possible values include: 'ReadOnlyMount', 'ReadWriteMount', 'Download', 'Direct', 'EvalMount', 'EvalDownload'
	Mode InputDeliveryMode `json:"mode,omitempty"`
	// URI - [Required] Input Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the input.
	Description *string `json:"description,omitempty"`
	// JobInputType - [Required] Specifies the type of job. Possible values include: 'JobInputTypeLiteral', 'JobInputTypeURIFile', 'JobInputTypeURIFolder', 'JobInputTypeMltable', 'JobInputTypeCustomModel', 'JobInputTypeMlflowModel', 'JobInputTypeTritonModel'
	JobInputType JobInputType `json:"jobInputType,omitempty"`
}

// URIFolderJobOutput ...
type URIFolderJobOutput struct {
	// Mode - Output Asset Delivery Mode. Possible values include: 'OutputDeliveryModeReadWriteMount', 'OutputDeliveryModeUpload'
	Mode OutputDeliveryMode `json:"mode,omitempty"`
	// URI - Output Asset URI.
	URI *string `json:"uri,omitempty"`
	// Description - Description for the output.
	Description *string `json:"description,omitempty"`
	// JobOutputType - [Required] Specifies the type of job. Possible values include: 'JobOutputTypeURIFile', 'JobOutputTypeURIFolder', 'JobOutputTypeMltable', 'JobOutputTypeCustomModel', 'JobOutputTypeMlflowModel', 'JobOutputTypeTritonModel'
	JobOutputType JobOutputType `json:"jobOutputType,omitempty"`
}

// Usage describes AML Resource Usage.
type Usage struct {
	// ID - READ-ONLY; Specifies the resource ID.
	ID *string `json:"id,omitempty"`
	// AmlWorkspaceLocation - READ-ONLY; Region of the AML workspace in the id.
	AmlWorkspaceLocation *string `json:"amlWorkspaceLocation,omitempty"`
	// Type - READ-ONLY; Specifies the resource type.
	Type *string `json:"type,omitempty"`
	// Unit - READ-ONLY; An enum describing the unit of usage measurement. Possible values include: 'UsageUnitCount'
	Unit UsageUnit `json:"unit,omitempty"`
	// CurrentValue - READ-ONLY; The current usage of the resource.
	CurrentValue *int64 `json:"currentValue,omitempty"`
	// Limit - READ-ONLY; The maximum permitted usage of the resource.
	Limit *int64 `json:"limit,omitempty"`
	// Name - READ-ONLY; The name of the type of usage.
	Name *UsageName `json:"name,omitempty"`
}

// MarshalJSON is the custom marshaler for Usage.
func (u Usage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UsageName the Usage Names.
type UsageName struct {
	// Value - READ-ONLY; The name of the resource.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - READ-ONLY; The localized name of the resource.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// MarshalJSON is the custom marshaler for UsageName.
func (un UsageName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UserAccountCredentials settings for user account that gets created on each on the nodes of a compute.
type UserAccountCredentials struct {
	// AdminUserName - Name of the administrator user account which can be used to SSH to nodes.
	AdminUserName *string `json:"adminUserName,omitempty"`
	// AdminUserSSHPublicKey - SSH public key of the administrator user account.
	AdminUserSSHPublicKey *string `json:"adminUserSshPublicKey,omitempty"`
	// AdminUserPassword - Password of the administrator user account.
	AdminUserPassword *string `json:"adminUserPassword,omitempty"`
}

// UserAssignedIdentity user assigned identity properties
type UserAssignedIdentity struct {
	// PrincipalID - READ-ONLY; The principal ID of the assigned identity.
	PrincipalID *uuid.UUID `json:"principalId,omitempty"`
	// ClientID - READ-ONLY; The client ID of the assigned identity.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
}

// MarshalJSON is the custom marshaler for UserAssignedIdentity.
func (uai UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UserIdentity user identity configuration.
type UserIdentity struct {
	// IdentityType - Possible values include: 'IdentityTypeIdentityConfiguration', 'IdentityTypeAMLToken', 'IdentityTypeManaged', 'IdentityTypeUserIdentity'
	IdentityType IdentityType `json:"identityType,omitempty"`
}

// MarshalJSON is the custom marshaler for UserIdentity.
func (UI UserIdentity) MarshalJSON() ([]byte, error) {
	UI.IdentityType = IdentityTypeUserIdentity
	objectMap := make(map[string]interface{})
	if UI.IdentityType != "" {
		objectMap["identityType"] = UI.IdentityType
	}
	return json.Marshal(objectMap)
}

// AsAmlToken is the BasicIdentityConfiguration implementation for UserIdentity.
func (UI UserIdentity) AsAmlToken() (*AmlToken, bool) {
	return nil, false
}

// AsManagedIdentity is the BasicIdentityConfiguration implementation for UserIdentity.
func (UI UserIdentity) AsManagedIdentity() (*ManagedIdentity, bool) {
	return nil, false
}

// AsUserIdentity is the BasicIdentityConfiguration implementation for UserIdentity.
func (UI UserIdentity) AsUserIdentity() (*UserIdentity, bool) {
	return &UI, true
}

// AsIdentityConfiguration is the BasicIdentityConfiguration implementation for UserIdentity.
func (UI UserIdentity) AsIdentityConfiguration() (*IdentityConfiguration, bool) {
	return nil, false
}

// AsBasicIdentityConfiguration is the BasicIdentityConfiguration implementation for UserIdentity.
func (UI UserIdentity) AsBasicIdentityConfiguration() (BasicIdentityConfiguration, bool) {
	return &UI, true
}

// UsernamePasswordAuthTypeWorkspaceConnectionProperties ...
type UsernamePasswordAuthTypeWorkspaceConnectionProperties struct {
	Credentials *WorkspaceConnectionUsernamePassword `json:"credentials,omitempty"`
	// Category - Possible values include: 'PythonFeed', 'ContainerRegistry', 'Git'
	Category ConnectionCategory `json:"category,omitempty"`
	Target   *string            `json:"target,omitempty"`
	// Value - Value details of the workspace connection.
	Value *string `json:"value,omitempty"`
	// ValueFormat - format for the workspace connection value. Possible values include: 'JSON'
	ValueFormat ValueFormat `json:"valueFormat,omitempty"`
	// AuthType - Possible values include: 'AuthTypeWorkspaceConnectionPropertiesV2', 'AuthTypePAT', 'AuthTypeSAS', 'AuthTypeUsernamePassword', 'AuthTypeNone', 'AuthTypeManagedIdentity'
	AuthType AuthType `json:"authType,omitempty"`
}

// MarshalJSON is the custom marshaler for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) MarshalJSON() ([]byte, error) {
	upatwcp.AuthType = AuthTypeUsernamePassword
	objectMap := make(map[string]interface{})
	if upatwcp.Credentials != nil {
		objectMap["credentials"] = upatwcp.Credentials
	}
	if upatwcp.Category != "" {
		objectMap["category"] = upatwcp.Category
	}
	if upatwcp.Target != nil {
		objectMap["target"] = upatwcp.Target
	}
	if upatwcp.Value != nil {
		objectMap["value"] = upatwcp.Value
	}
	if upatwcp.ValueFormat != "" {
		objectMap["valueFormat"] = upatwcp.ValueFormat
	}
	if upatwcp.AuthType != "" {
		objectMap["authType"] = upatwcp.AuthType
	}
	return json.Marshal(objectMap)
}

// AsPATAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsSASAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsUsernamePasswordAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool) {
	return &upatwcp, true
}

// AsNoneAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsManagedIdentityAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool) {
	return nil, false
}

// AsBasicWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for UsernamePasswordAuthTypeWorkspaceConnectionProperties.
func (upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties) AsBasicWorkspaceConnectionPropertiesV2() (BasicWorkspaceConnectionPropertiesV2, bool) {
	return &upatwcp, true
}

// VirtualMachine a Machine Learning compute based on Azure Virtual Machines.
type VirtualMachine struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// ComputeLocation - READ-ONLY; Location for the underlying compute
	ComputeLocation *string `json:"computeLocation,omitempty"`
	// ProvisioningState - READ-ONLY; The provision state of the cluster. Valid values are Unknown, Updating, Provisioning, Succeeded, and Failed. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Description - The description of the Machine Learning compute.
	Description *string `json:"description,omitempty"`
	// CreatedOn - READ-ONLY; The time at which the compute was created.
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ModifiedOn - READ-ONLY; The time at which the compute was last modified.
	ModifiedOn *date.Time `json:"modifiedOn,omitempty"`
	// ResourceID - ARM resource id of the underlying compute
	ResourceID *string `json:"resourceId,omitempty"`
	// ProvisioningErrors - READ-ONLY; Errors during provisioning
	ProvisioningErrors *[]ErrorResponse `json:"provisioningErrors,omitempty"`
	// IsAttachedCompute - READ-ONLY; Indicating whether the compute was provisioned by user and brought from outside if true, or machine learning service provisioned it if false.
	IsAttachedCompute *bool `json:"isAttachedCompute,omitempty"`
	// DisableLocalAuth - Opt-out of local authentication and ensure customers can use only MSI and AAD exclusively for authentication.
	DisableLocalAuth *bool                     `json:"disableLocalAuth,omitempty"`
	Properties       *VirtualMachineProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachine.
func (VM VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if VM.ComputeType != "" {
		objectMap["computeType"] = VM.ComputeType
	}
	if VM.Description != nil {
		objectMap["description"] = VM.Description
	}
	if VM.ResourceID != nil {
		objectMap["resourceId"] = VM.ResourceID
	}
	if VM.DisableLocalAuth != nil {
		objectMap["disableLocalAuth"] = VM.DisableLocalAuth
	}
	if VM.Properties != nil {
		objectMap["properties"] = VM.Properties
	}
	return json.Marshal(objectMap)
}

// VirtualMachineImage virtual Machine image for Windows AML Compute
type VirtualMachineImage struct {
	// ID - Virtual Machine image path
	ID *string `json:"id,omitempty"`
}

// VirtualMachineProperties ...
type VirtualMachineProperties struct {
	// VirtualMachineSize - Virtual Machine size
	VirtualMachineSize *string `json:"virtualMachineSize,omitempty"`
	// SSHPort - Port open for ssh connections.
	SSHPort *int32 `json:"sshPort,omitempty"`
	// NotebookServerPort - Notebook server port open for ssh connections.
	NotebookServerPort *int32 `json:"notebookServerPort,omitempty"`
	// Address - Public IP address of the virtual machine.
	Address *string `json:"address,omitempty"`
	// AdministratorAccount - Admin credentials for virtual machine
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`
	// IsNotebookInstanceCompute - Indicates whether this compute will be used for running notebooks.
	IsNotebookInstanceCompute *bool `json:"isNotebookInstanceCompute,omitempty"`
}

// VirtualMachineSchema ...
type VirtualMachineSchema struct {
	Properties *VirtualMachineProperties `json:"properties,omitempty"`
}

// VirtualMachineSecrets secrets related to a Machine Learning compute based on AKS.
type VirtualMachineSecrets struct {
	// ComputeType - The type of compute. Possible values include: 'ComputeTypeAKS', 'ComputeTypeKubernetes', 'ComputeTypeAmlCompute', 'ComputeTypeComputeInstance', 'ComputeTypeDataFactory', 'ComputeTypeVirtualMachine', 'ComputeTypeHDInsight', 'ComputeTypeDatabricks', 'ComputeTypeDataLakeAnalytics', 'ComputeTypeSynapseSpark'
	ComputeType ComputeType `json:"computeType,omitempty"`
	// AdministratorAccount - Admin credentials for virtual machine.
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`
}

// VirtualMachineSecretsSchema ...
type VirtualMachineSecretsSchema struct {
	// AdministratorAccount - Admin credentials for virtual machine.
	AdministratorAccount *VirtualMachineSSHCredentials `json:"administratorAccount,omitempty"`
}

// VirtualMachineSize describes the properties of a VM size.
type VirtualMachineSize struct {
	// Name - READ-ONLY; The name of the virtual machine size.
	Name *string `json:"name,omitempty"`
	// Family - READ-ONLY; The family name of the virtual machine size.
	Family *string `json:"family,omitempty"`
	// VCPUs - READ-ONLY; The number of vCPUs supported by the virtual machine size.
	VCPUs *int32 `json:"vCPUs,omitempty"`
	// Gpus - READ-ONLY; The number of gPUs supported by the virtual machine size.
	Gpus *int32 `json:"gpus,omitempty"`
	// OsVhdSizeMB - READ-ONLY; The OS VHD disk size, in MB, allowed by the virtual machine size.
	OsVhdSizeMB *int32 `json:"osVhdSizeMB,omitempty"`
	// MaxResourceVolumeMB - READ-ONLY; The resource volume size, in MB, allowed by the virtual machine size.
	MaxResourceVolumeMB *int32 `json:"maxResourceVolumeMB,omitempty"`
	// MemoryGB - READ-ONLY; The amount of memory, in GB, supported by the virtual machine size.
	MemoryGB *float64 `json:"memoryGB,omitempty"`
	// LowPriorityCapable - READ-ONLY; Specifies if the virtual machine size supports low priority VMs.
	LowPriorityCapable *bool `json:"lowPriorityCapable,omitempty"`
	// PremiumIO - READ-ONLY; Specifies if the virtual machine size supports premium IO.
	PremiumIO *bool `json:"premiumIO,omitempty"`
	// EstimatedVMPrices - The estimated price information for using a VM.
	EstimatedVMPrices *EstimatedVMPrices `json:"estimatedVMPrices,omitempty"`
	// SupportedComputeTypes - Specifies the compute types supported by the virtual machine size.
	SupportedComputeTypes *[]string `json:"supportedComputeTypes,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineSize.
func (vms VirtualMachineSize) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vms.EstimatedVMPrices != nil {
		objectMap["estimatedVMPrices"] = vms.EstimatedVMPrices
	}
	if vms.SupportedComputeTypes != nil {
		objectMap["supportedComputeTypes"] = vms.SupportedComputeTypes
	}
	return json.Marshal(objectMap)
}

// VirtualMachineSizeListResult the List Virtual Machine size operation response.
type VirtualMachineSizeListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of virtual machine sizes supported by AmlCompute.
	Value *[]VirtualMachineSize `json:"value,omitempty"`
}

// VirtualMachineSSHCredentials admin credentials for virtual machine
type VirtualMachineSSHCredentials struct {
	// Username - Username of admin account
	Username *string `json:"username,omitempty"`
	// Password - Password of admin account
	Password *string `json:"password,omitempty"`
	// PublicKeyData - Public key data
	PublicKeyData *string `json:"publicKeyData,omitempty"`
	// PrivateKeyData - Private key data
	PrivateKeyData *string `json:"privateKeyData,omitempty"`
}

// Workspace an object that represents a machine learning workspace.
type Workspace struct {
	autorest.Response `json:"-"`
	// WorkspaceProperties - The properties of the machine learning workspace.
	*WorkspaceProperties `json:"properties,omitempty"`
	// Identity - The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// Location - Specifies the location of the resource.
	Location *string `json:"location,omitempty"`
	// Tags - Contains resource tags defined as key/value pairs.
	Tags map[string]*string `json:"tags"`
	// Sku - The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Workspace.
func (w Workspace) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.WorkspaceProperties != nil {
		objectMap["properties"] = w.WorkspaceProperties
	}
	if w.Identity != nil {
		objectMap["identity"] = w.Identity
	}
	if w.Location != nil {
		objectMap["location"] = w.Location
	}
	if w.Tags != nil {
		objectMap["tags"] = w.Tags
	}
	if w.Sku != nil {
		objectMap["sku"] = w.Sku
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Workspace struct.
func (w *Workspace) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workspaceProperties WorkspaceProperties
				err = json.Unmarshal(*v, &workspaceProperties)
				if err != nil {
					return err
				}
				w.WorkspaceProperties = &workspaceProperties
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				w.Identity = &identity
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				w.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				w.Tags = tags
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				w.Sku = &sku
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				w.SystemData = &systemData
			}
		}
	}

	return nil
}

// WorkspaceConnectionManagedIdentity ...
type WorkspaceConnectionManagedIdentity struct {
	ResourceID *string `json:"resourceId,omitempty"`
	ClientID   *string `json:"clientId,omitempty"`
}

// WorkspaceConnectionPersonalAccessToken ...
type WorkspaceConnectionPersonalAccessToken struct {
	Pat *string `json:"pat,omitempty"`
}

// BasicWorkspaceConnectionPropertiesV2 ...
type BasicWorkspaceConnectionPropertiesV2 interface {
	AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool)
	AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool)
	AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool)
	AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool)
	AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool)
	AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool)
}

// WorkspaceConnectionPropertiesV2 ...
type WorkspaceConnectionPropertiesV2 struct {
	// Category - Possible values include: 'PythonFeed', 'ContainerRegistry', 'Git'
	Category ConnectionCategory `json:"category,omitempty"`
	Target   *string            `json:"target,omitempty"`
	// Value - Value details of the workspace connection.
	Value *string `json:"value,omitempty"`
	// ValueFormat - format for the workspace connection value. Possible values include: 'JSON'
	ValueFormat ValueFormat `json:"valueFormat,omitempty"`
	// AuthType - Possible values include: 'AuthTypeWorkspaceConnectionPropertiesV2', 'AuthTypePAT', 'AuthTypeSAS', 'AuthTypeUsernamePassword', 'AuthTypeNone', 'AuthTypeManagedIdentity'
	AuthType AuthType `json:"authType,omitempty"`
}

func unmarshalBasicWorkspaceConnectionPropertiesV2(body []byte) (BasicWorkspaceConnectionPropertiesV2, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["authType"] {
	case string(AuthTypePAT):
		var patwcp PATAuthTypeWorkspaceConnectionProperties
		err := json.Unmarshal(body, &patwcp)
		return patwcp, err
	case string(AuthTypeSAS):
		var satwcp SASAuthTypeWorkspaceConnectionProperties
		err := json.Unmarshal(body, &satwcp)
		return satwcp, err
	case string(AuthTypeUsernamePassword):
		var upatwcp UsernamePasswordAuthTypeWorkspaceConnectionProperties
		err := json.Unmarshal(body, &upatwcp)
		return upatwcp, err
	case string(AuthTypeNone):
		var natwcp NoneAuthTypeWorkspaceConnectionProperties
		err := json.Unmarshal(body, &natwcp)
		return natwcp, err
	case string(AuthTypeManagedIdentity):
		var miatwcp ManagedIdentityAuthTypeWorkspaceConnectionProperties
		err := json.Unmarshal(body, &miatwcp)
		return miatwcp, err
	default:
		var wcpv WorkspaceConnectionPropertiesV2
		err := json.Unmarshal(body, &wcpv)
		return wcpv, err
	}
}
func unmarshalBasicWorkspaceConnectionPropertiesV2Array(body []byte) ([]BasicWorkspaceConnectionPropertiesV2, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	wcpvArray := make([]BasicWorkspaceConnectionPropertiesV2, len(rawMessages))

	for index, rawMessage := range rawMessages {
		wcpv, err := unmarshalBasicWorkspaceConnectionPropertiesV2(*rawMessage)
		if err != nil {
			return nil, err
		}
		wcpvArray[index] = wcpv
	}
	return wcpvArray, nil
}

// MarshalJSON is the custom marshaler for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) MarshalJSON() ([]byte, error) {
	wcpv.AuthType = AuthTypeWorkspaceConnectionPropertiesV2
	objectMap := make(map[string]interface{})
	if wcpv.Category != "" {
		objectMap["category"] = wcpv.Category
	}
	if wcpv.Target != nil {
		objectMap["target"] = wcpv.Target
	}
	if wcpv.Value != nil {
		objectMap["value"] = wcpv.Value
	}
	if wcpv.ValueFormat != "" {
		objectMap["valueFormat"] = wcpv.ValueFormat
	}
	if wcpv.AuthType != "" {
		objectMap["authType"] = wcpv.AuthType
	}
	return json.Marshal(objectMap)
}

// AsPATAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsPATAuthTypeWorkspaceConnectionProperties() (*PATAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsSASAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsSASAuthTypeWorkspaceConnectionProperties() (*SASAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsUsernamePasswordAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsUsernamePasswordAuthTypeWorkspaceConnectionProperties() (*UsernamePasswordAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsNoneAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsNoneAuthTypeWorkspaceConnectionProperties() (*NoneAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsManagedIdentityAuthTypeWorkspaceConnectionProperties is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsManagedIdentityAuthTypeWorkspaceConnectionProperties() (*ManagedIdentityAuthTypeWorkspaceConnectionProperties, bool) {
	return nil, false
}

// AsWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsWorkspaceConnectionPropertiesV2() (*WorkspaceConnectionPropertiesV2, bool) {
	return &wcpv, true
}

// AsBasicWorkspaceConnectionPropertiesV2 is the BasicWorkspaceConnectionPropertiesV2 implementation for WorkspaceConnectionPropertiesV2.
func (wcpv WorkspaceConnectionPropertiesV2) AsBasicWorkspaceConnectionPropertiesV2() (BasicWorkspaceConnectionPropertiesV2, bool) {
	return &wcpv, true
}

// WorkspaceConnectionPropertiesV2BasicResource ...
type WorkspaceConnectionPropertiesV2BasicResource struct {
	autorest.Response `json:"-"`
	Properties        BasicWorkspaceConnectionPropertiesV2 `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkspaceConnectionPropertiesV2BasicResource.
func (wcpvbr WorkspaceConnectionPropertiesV2BasicResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = wcpvbr.Properties
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkspaceConnectionPropertiesV2BasicResource struct.
func (wcpvbr *WorkspaceConnectionPropertiesV2BasicResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				properties, err := unmarshalBasicWorkspaceConnectionPropertiesV2(*v)
				if err != nil {
					return err
				}
				wcpvbr.Properties = properties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wcpvbr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wcpvbr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wcpvbr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				wcpvbr.SystemData = &systemData
			}
		}
	}

	return nil
}

// WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult ...
type WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult struct {
	autorest.Response `json:"-"`
	Value             *[]WorkspaceConnectionPropertiesV2BasicResource `json:"value,omitempty"`
	// NextLink - READ-ONLY
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult.
func (wcpvbrapr WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wcpvbrapr.Value != nil {
		objectMap["value"] = wcpvbrapr.Value
	}
	return json.Marshal(objectMap)
}

// WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator provides access to a complete
// listing of WorkspaceConnectionPropertiesV2BasicResource values.
type WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator struct {
	i    int
	page WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator) Response() WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator) Value() WorkspaceConnectionPropertiesV2BasicResource {
	if !iter.page.NotDone() {
		return WorkspaceConnectionPropertiesV2BasicResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator type.
func NewWorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator(page WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage) WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator {
	return WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wcpvbrapr WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult) IsEmpty() bool {
	return wcpvbrapr.Value == nil || len(*wcpvbrapr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wcpvbrapr WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult) hasNextLink() bool {
	return wcpvbrapr.NextLink != nil && len(*wcpvbrapr.NextLink) != 0
}

// workspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wcpvbrapr WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult) workspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wcpvbrapr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wcpvbrapr.NextLink)))
}

// WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage contains a page of
// WorkspaceConnectionPropertiesV2BasicResource values.
type WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage struct {
	fn        func(context.Context, WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult) (WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult, error)
	wcpvbrapr WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wcpvbrapr)
		if err != nil {
			return err
		}
		page.wcpvbrapr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage) NotDone() bool {
	return !page.wcpvbrapr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage) Response() WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult {
	return page.wcpvbrapr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage) Values() []WorkspaceConnectionPropertiesV2BasicResource {
	if page.wcpvbrapr.IsEmpty() {
		return nil
	}
	return *page.wcpvbrapr.Value
}

// Creates a new instance of the WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage type.
func NewWorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage(cur WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult, getNextPage func(context.Context, WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult) (WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult, error)) WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage {
	return WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResultPage{
		fn:        getNextPage,
		wcpvbrapr: cur,
	}
}

// WorkspaceConnectionSharedAccessSignature ...
type WorkspaceConnectionSharedAccessSignature struct {
	Sas *string `json:"sas,omitempty"`
}

// WorkspaceConnectionUsernamePassword ...
type WorkspaceConnectionUsernamePassword struct {
	Username *string `json:"username,omitempty"`
	Password *string `json:"password,omitempty"`
}

// WorkspaceListResult the result of a request to list machine learning workspaces.
type WorkspaceListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of machine learning workspaces. Since this list may be incomplete, the nextLink field should be used to request the next list of machine learning workspaces.
	Value *[]Workspace `json:"value,omitempty"`
	// NextLink - The URI that can be used to request the next list of machine learning workspaces.
	NextLink *string `json:"nextLink,omitempty"`
}

// WorkspaceListResultIterator provides access to a complete listing of Workspace values.
type WorkspaceListResultIterator struct {
	i    int
	page WorkspaceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WorkspaceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WorkspaceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WorkspaceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WorkspaceListResultIterator) Response() WorkspaceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WorkspaceListResultIterator) Value() Workspace {
	if !iter.page.NotDone() {
		return Workspace{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WorkspaceListResultIterator type.
func NewWorkspaceListResultIterator(page WorkspaceListResultPage) WorkspaceListResultIterator {
	return WorkspaceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wlr WorkspaceListResult) IsEmpty() bool {
	return wlr.Value == nil || len(*wlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wlr WorkspaceListResult) hasNextLink() bool {
	return wlr.NextLink != nil && len(*wlr.NextLink) != 0
}

// workspaceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wlr WorkspaceListResult) workspaceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !wlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wlr.NextLink)))
}

// WorkspaceListResultPage contains a page of Workspace values.
type WorkspaceListResultPage struct {
	fn  func(context.Context, WorkspaceListResult) (WorkspaceListResult, error)
	wlr WorkspaceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WorkspaceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkspaceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wlr)
		if err != nil {
			return err
		}
		page.wlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WorkspaceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WorkspaceListResultPage) NotDone() bool {
	return !page.wlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WorkspaceListResultPage) Response() WorkspaceListResult {
	return page.wlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WorkspaceListResultPage) Values() []Workspace {
	if page.wlr.IsEmpty() {
		return nil
	}
	return *page.wlr.Value
}

// Creates a new instance of the WorkspaceListResultPage type.
func NewWorkspaceListResultPage(cur WorkspaceListResult, getNextPage func(context.Context, WorkspaceListResult) (WorkspaceListResult, error)) WorkspaceListResultPage {
	return WorkspaceListResultPage{
		fn:  getNextPage,
		wlr: cur,
	}
}

// WorkspaceProperties the properties of a machine learning workspace.
type WorkspaceProperties struct {
	// WorkspaceID - READ-ONLY; The immutable id associated with this workspace.
	WorkspaceID *string `json:"workspaceId,omitempty"`
	// Description - The description of this workspace.
	Description *string `json:"description,omitempty"`
	// FriendlyName - The friendly name for this workspace. This name in mutable
	FriendlyName *string `json:"friendlyName,omitempty"`
	// KeyVault - ARM id of the key vault associated with this workspace. This cannot be changed once the workspace has been created
	KeyVault *string `json:"keyVault,omitempty"`
	// ApplicationInsights - ARM id of the application insights associated with this workspace.
	ApplicationInsights *string `json:"applicationInsights,omitempty"`
	// ContainerRegistry - ARM id of the container registry associated with this workspace.
	ContainerRegistry *string `json:"containerRegistry,omitempty"`
	// StorageAccount - ARM id of the storage account associated with this workspace. This cannot be changed once the workspace has been created
	StorageAccount *string `json:"storageAccount,omitempty"`
	// DiscoveryURL - Url for the discovery service to identify regional endpoints for machine learning experimentation services
	DiscoveryURL *string `json:"discoveryUrl,omitempty"`
	// ProvisioningState - READ-ONLY; The current deployment state of workspace resource. The provisioningState is to indicate states for resource provisioning. Possible values include: 'ProvisioningStateUnknown', 'ProvisioningStateUpdating', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCanceled'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Encryption - The encryption settings of Azure ML workspace.
	Encryption *EncryptionProperty `json:"encryption,omitempty"`
	// HbiWorkspace - The flag to signal HBI data in the workspace and reduce diagnostic data collected by the service
	HbiWorkspace *bool `json:"hbiWorkspace,omitempty"`
	// ServiceProvisionedResourceGroup - READ-ONLY; The name of the managed resource group created by workspace RP in customer subscription if the workspace is CMK workspace
	ServiceProvisionedResourceGroup *string `json:"serviceProvisionedResourceGroup,omitempty"`
	// PrivateLinkCount - READ-ONLY; Count of private connections in the workspace
	PrivateLinkCount *int32 `json:"privateLinkCount,omitempty"`
	// ImageBuildCompute - The compute name for image build
	ImageBuildCompute *string `json:"imageBuildCompute,omitempty"`
	// AllowPublicAccessWhenBehindVnet - The flag to indicate whether to allow public access when behind VNet.
	AllowPublicAccessWhenBehindVnet *bool `json:"allowPublicAccessWhenBehindVnet,omitempty"`
	// PublicNetworkAccess - Whether requests from Public Network are allowed. Possible values include: 'PublicNetworkAccessEnabled', 'PublicNetworkAccessDisabled'
	PublicNetworkAccess PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
	// PrivateEndpointConnections - READ-ONLY; The list of private endpoint connections in the workspace.
	PrivateEndpointConnections *[]PrivateEndpointConnection `json:"privateEndpointConnections,omitempty"`
	// SharedPrivateLinkResources - The list of shared private link resources in this workspace.
	SharedPrivateLinkResources *[]SharedPrivateLinkResource `json:"sharedPrivateLinkResources,omitempty"`
	// NotebookInfo - READ-ONLY; The notebook info of Azure ML workspace.
	NotebookInfo *NotebookResourceInfo `json:"notebookInfo,omitempty"`
	// ServiceManagedResourcesSettings - The service managed resource settings.
	ServiceManagedResourcesSettings *ServiceManagedResourcesSettings `json:"serviceManagedResourcesSettings,omitempty"`
	// PrimaryUserAssignedIdentity - The user assigned identity resource id that represents the workspace identity.
	PrimaryUserAssignedIdentity *string `json:"primaryUserAssignedIdentity,omitempty"`
	// TenantID - READ-ONLY; The tenant id associated with this workspace.
	TenantID *string `json:"tenantId,omitempty"`
	// StorageHnsEnabled - READ-ONLY; If the storage associated with the workspace has hierarchical namespace(HNS) enabled.
	StorageHnsEnabled *bool `json:"storageHnsEnabled,omitempty"`
	// MlFlowTrackingURI - READ-ONLY; The URI associated with this workspace that machine learning flow must point at to set up tracking.
	MlFlowTrackingURI *string `json:"mlFlowTrackingUri,omitempty"`
	// V1LegacyMode - Enabling v1_legacy_mode may prevent you from using features provided by the v2 API.
	V1LegacyMode *bool `json:"v1LegacyMode,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkspaceProperties.
func (wp WorkspaceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wp.Description != nil {
		objectMap["description"] = wp.Description
	}
	if wp.FriendlyName != nil {
		objectMap["friendlyName"] = wp.FriendlyName
	}
	if wp.KeyVault != nil {
		objectMap["keyVault"] = wp.KeyVault
	}
	if wp.ApplicationInsights != nil {
		objectMap["applicationInsights"] = wp.ApplicationInsights
	}
	if wp.ContainerRegistry != nil {
		objectMap["containerRegistry"] = wp.ContainerRegistry
	}
	if wp.StorageAccount != nil {
		objectMap["storageAccount"] = wp.StorageAccount
	}
	if wp.DiscoveryURL != nil {
		objectMap["discoveryUrl"] = wp.DiscoveryURL
	}
	if wp.Encryption != nil {
		objectMap["encryption"] = wp.Encryption
	}
	if wp.HbiWorkspace != nil {
		objectMap["hbiWorkspace"] = wp.HbiWorkspace
	}
	if wp.ImageBuildCompute != nil {
		objectMap["imageBuildCompute"] = wp.ImageBuildCompute
	}
	if wp.AllowPublicAccessWhenBehindVnet != nil {
		objectMap["allowPublicAccessWhenBehindVnet"] = wp.AllowPublicAccessWhenBehindVnet
	}
	if wp.PublicNetworkAccess != "" {
		objectMap["publicNetworkAccess"] = wp.PublicNetworkAccess
	}
	if wp.SharedPrivateLinkResources != nil {
		objectMap["sharedPrivateLinkResources"] = wp.SharedPrivateLinkResources
	}
	if wp.ServiceManagedResourcesSettings != nil {
		objectMap["serviceManagedResourcesSettings"] = wp.ServiceManagedResourcesSettings
	}
	if wp.PrimaryUserAssignedIdentity != nil {
		objectMap["primaryUserAssignedIdentity"] = wp.PrimaryUserAssignedIdentity
	}
	if wp.V1LegacyMode != nil {
		objectMap["v1LegacyMode"] = wp.V1LegacyMode
	}
	return json.Marshal(objectMap)
}

// WorkspacePropertiesUpdateParameters the parameters for updating the properties of a machine learning
// workspace.
type WorkspacePropertiesUpdateParameters struct {
	// Description - The description of this workspace.
	Description *string `json:"description,omitempty"`
	// FriendlyName - The friendly name for this workspace.
	FriendlyName *string `json:"friendlyName,omitempty"`
	// ImageBuildCompute - The compute name for image build
	ImageBuildCompute *string `json:"imageBuildCompute,omitempty"`
	// ServiceManagedResourcesSettings - The service managed resource settings.
	ServiceManagedResourcesSettings *ServiceManagedResourcesSettings `json:"serviceManagedResourcesSettings,omitempty"`
	// PrimaryUserAssignedIdentity - The user assigned identity resource id that represents the workspace identity.
	PrimaryUserAssignedIdentity *string `json:"primaryUserAssignedIdentity,omitempty"`
	// PublicNetworkAccess - Whether requests from Public Network are allowed. Possible values include: 'PublicNetworkAccessEnabled', 'PublicNetworkAccessDisabled'
	PublicNetworkAccess PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`
	// ApplicationInsights - ARM id of the application insights associated with this workspace.
	ApplicationInsights *string `json:"applicationInsights,omitempty"`
	// ContainerRegistry - ARM id of the container registry associated with this workspace.
	ContainerRegistry *string `json:"containerRegistry,omitempty"`
}

// WorkspacesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WorkspacesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (Workspace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesCreateOrUpdateFuture.Result.
func (future *WorkspacesCreateOrUpdateFuture) result(client WorkspacesClient) (w Workspace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		w.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.WorkspacesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if w.Response.Response, err = future.GetResult(sender); err == nil && w.Response.Response.StatusCode != http.StatusNoContent {
		w, err = client.CreateOrUpdateResponder(w.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesCreateOrUpdateFuture", "Result", w.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspacesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesDeleteFuture.Result.
func (future *WorkspacesDeleteFuture) result(client WorkspacesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.WorkspacesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// WorkspacesDiagnoseFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesDiagnoseFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (DiagnoseResponseResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesDiagnoseFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesDiagnoseFuture.Result.
func (future *WorkspacesDiagnoseFuture) result(client WorkspacesClient) (drr DiagnoseResponseResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesDiagnoseFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		drr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.WorkspacesDiagnoseFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if drr.Response.Response, err = future.GetResult(sender); err == nil && drr.Response.Response.StatusCode != http.StatusNoContent {
		drr, err = client.DiagnoseResponder(drr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesDiagnoseFuture", "Result", drr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspacesPrepareNotebookFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WorkspacesPrepareNotebookFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (NotebookResourceInfo, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesPrepareNotebookFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesPrepareNotebookFuture.Result.
func (future *WorkspacesPrepareNotebookFuture) result(client WorkspacesClient) (nri NotebookResourceInfo, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesPrepareNotebookFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		nri.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.WorkspacesPrepareNotebookFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if nri.Response.Response, err = future.GetResult(sender); err == nil && nri.Response.Response.StatusCode != http.StatusNoContent {
		nri, err = client.PrepareNotebookResponder(nri.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesPrepareNotebookFuture", "Result", nri.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspacesResyncKeysFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesResyncKeysFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesResyncKeysFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesResyncKeysFuture.Result.
func (future *WorkspacesResyncKeysFuture) result(client WorkspacesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesResyncKeysFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.WorkspacesResyncKeysFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// WorkspacesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type WorkspacesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WorkspacesClient) (Workspace, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WorkspacesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WorkspacesUpdateFuture.Result.
func (future *WorkspacesUpdateFuture) result(client WorkspacesClient) (w Workspace, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		w.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("machinelearningservices.WorkspacesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if w.Response.Response, err = future.GetResult(sender); err == nil && w.Response.Response.StatusCode != http.StatusNoContent {
		w, err = client.UpdateResponder(w.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "machinelearningservices.WorkspacesUpdateFuture", "Result", w.Response.Response, "Failure responding to request")
		}
	}
	return
}

// WorkspaceUpdateParameters the parameters for updating a machine learning workspace.
type WorkspaceUpdateParameters struct {
	// Tags - The resource tags for the machine learning workspace.
	Tags map[string]*string `json:"tags"`
	// Sku - The sku of the workspace.
	Sku *Sku `json:"sku,omitempty"`
	// Identity - The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`
	// WorkspacePropertiesUpdateParameters - The properties that the machine learning workspace will be updated with.
	*WorkspacePropertiesUpdateParameters `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for WorkspaceUpdateParameters.
func (wup WorkspaceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wup.Tags != nil {
		objectMap["tags"] = wup.Tags
	}
	if wup.Sku != nil {
		objectMap["sku"] = wup.Sku
	}
	if wup.Identity != nil {
		objectMap["identity"] = wup.Identity
	}
	if wup.WorkspacePropertiesUpdateParameters != nil {
		objectMap["properties"] = wup.WorkspacePropertiesUpdateParameters
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WorkspaceUpdateParameters struct.
func (wup *WorkspaceUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				wup.Tags = tags
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				wup.Sku = &sku
			}
		case "identity":
			if v != nil {
				var identity ManagedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				wup.Identity = &identity
			}
		case "properties":
			if v != nil {
				var workspacePropertiesUpdateParameters WorkspacePropertiesUpdateParameters
				err = json.Unmarshal(*v, &workspacePropertiesUpdateParameters)
				if err != nil {
					return err
				}
				wup.WorkspacePropertiesUpdateParameters = &workspacePropertiesUpdateParameters
			}
		}
	}

	return nil
}
