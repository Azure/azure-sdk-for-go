package authorization

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/authorization/mgmt/2020-10-01-preview/authorization"

// AccessReviewActorIdentity details of the actor identity
type AccessReviewActorIdentity struct {
	// PrincipalID - READ-ONLY; The identity id
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - READ-ONLY; The identity type : user/servicePrincipal. Possible values include: 'User', 'ServicePrincipal'
	PrincipalType AccessReviewActorIdentityType `json:"principalType,omitempty"`
	// PrincipalName - READ-ONLY; The identity display name
	PrincipalName *string `json:"principalName,omitempty"`
	// UserPrincipalName - READ-ONLY; The user principal name(if valid)
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewActorIdentity.
func (arai AccessReviewActorIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AccessReviewDecision access Review.
type AccessReviewDecision struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The access review decision id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The access review decision name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// AccessReviewDecisionProperties - Access Review Decision properties.
	*AccessReviewDecisionProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewDecision.
func (ard AccessReviewDecision) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ard.AccessReviewDecisionProperties != nil {
		objectMap["properties"] = ard.AccessReviewDecisionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewDecision struct.
func (ard *AccessReviewDecision) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ard.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ard.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ard.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var accessReviewDecisionProperties AccessReviewDecisionProperties
				err = json.Unmarshal(*v, &accessReviewDecisionProperties)
				if err != nil {
					return err
				}
				ard.AccessReviewDecisionProperties = &accessReviewDecisionProperties
			}
		}
	}

	return nil
}

// AccessReviewDecisionListResult list of access review decisions.
type AccessReviewDecisionListResult struct {
	autorest.Response `json:"-"`
	// Value - Access Review Decision list.
	Value *[]AccessReviewDecision `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AccessReviewDecisionListResultIterator provides access to a complete listing of AccessReviewDecision
// values.
type AccessReviewDecisionListResultIterator struct {
	i    int
	page AccessReviewDecisionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccessReviewDecisionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccessReviewDecisionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccessReviewDecisionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccessReviewDecisionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccessReviewDecisionListResultIterator) Response() AccessReviewDecisionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccessReviewDecisionListResultIterator) Value() AccessReviewDecision {
	if !iter.page.NotDone() {
		return AccessReviewDecision{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccessReviewDecisionListResultIterator type.
func NewAccessReviewDecisionListResultIterator(page AccessReviewDecisionListResultPage) AccessReviewDecisionListResultIterator {
	return AccessReviewDecisionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ardlr AccessReviewDecisionListResult) IsEmpty() bool {
	return ardlr.Value == nil || len(*ardlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ardlr AccessReviewDecisionListResult) hasNextLink() bool {
	return ardlr.NextLink != nil && len(*ardlr.NextLink) != 0
}

// accessReviewDecisionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ardlr AccessReviewDecisionListResult) accessReviewDecisionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ardlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ardlr.NextLink)))
}

// AccessReviewDecisionListResultPage contains a page of AccessReviewDecision values.
type AccessReviewDecisionListResultPage struct {
	fn    func(context.Context, AccessReviewDecisionListResult) (AccessReviewDecisionListResult, error)
	ardlr AccessReviewDecisionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccessReviewDecisionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccessReviewDecisionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ardlr)
		if err != nil {
			return err
		}
		page.ardlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccessReviewDecisionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccessReviewDecisionListResultPage) NotDone() bool {
	return !page.ardlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccessReviewDecisionListResultPage) Response() AccessReviewDecisionListResult {
	return page.ardlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccessReviewDecisionListResultPage) Values() []AccessReviewDecision {
	if page.ardlr.IsEmpty() {
		return nil
	}
	return *page.ardlr.Value
}

// Creates a new instance of the AccessReviewDecisionListResultPage type.
func NewAccessReviewDecisionListResultPage(cur AccessReviewDecisionListResult, getNextPage func(context.Context, AccessReviewDecisionListResult) (AccessReviewDecisionListResult, error)) AccessReviewDecisionListResultPage {
	return AccessReviewDecisionListResultPage{
		fn:    getNextPage,
		ardlr: cur,
	}
}

// AccessReviewDecisionProperties approval Step.
type AccessReviewDecisionProperties struct {
	// BasicAccessReviewDecisionTarget - READ-ONLY; Target of this decision record. Can be UserDecisionTarget or ServicePrincipalDecisionTarget
	BasicAccessReviewDecisionTarget `json:"target,omitempty"`
	// Recommendation - READ-ONLY; The feature- generated recommendation shown to the reviewer. Possible values include: 'Approve', 'Deny', 'NoInfoAvailable'
	Recommendation AccessRecommendationType `json:"recommendation,omitempty"`
	// Decision - The decision on the approval step. This value is initially set to NotReviewed. Approvers can take action of Approve/Deny. Possible values include: 'AccessReviewResultApprove', 'AccessReviewResultDeny', 'AccessReviewResultNotReviewed', 'AccessReviewResultDontKnow', 'AccessReviewResultNotNotified'
	Decision AccessReviewResult `json:"decision,omitempty"`
	// Justification - Justification provided by approvers for their action
	Justification *string `json:"justification,omitempty"`
	// ReviewedDateTime - READ-ONLY; Date Time when a decision was taken.
	ReviewedDateTime *date.Time `json:"reviewedDateTime,omitempty"`
	// AccessReviewActorIdentity - READ-ONLY; Details of the approver.
	*AccessReviewActorIdentity `json:"reviewedBy,omitempty"`
	// ApplyResult - READ-ONLY; The outcome of applying the decision. Possible values include: 'AccessReviewApplyResultNew', 'AccessReviewApplyResultApplying', 'AccessReviewApplyResultAppliedSuccessfully', 'AccessReviewApplyResultAppliedWithUnknownFailure', 'AccessReviewApplyResultAppliedSuccessfullyButObjectNotFound', 'AccessReviewApplyResultApplyNotSupported'
	ApplyResult AccessReviewApplyResult `json:"applyResult,omitempty"`
	// AppliedDateTime - READ-ONLY; The date and time when the review decision was applied.
	AppliedDateTime *date.Time `json:"appliedDateTime,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewDecisionProperties.
func (ardp AccessReviewDecisionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ardp.Decision != "" {
		objectMap["decision"] = ardp.Decision
	}
	if ardp.Justification != nil {
		objectMap["justification"] = ardp.Justification
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewDecisionProperties struct.
func (ardp *AccessReviewDecisionProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "target":
			if v != nil {
				basicAccessReviewDecisionTarget, err := unmarshalBasicAccessReviewDecisionTarget(*v)
				if err != nil {
					return err
				}
				ardp.BasicAccessReviewDecisionTarget = basicAccessReviewDecisionTarget
			}
		case "recommendation":
			if v != nil {
				var recommendation AccessRecommendationType
				err = json.Unmarshal(*v, &recommendation)
				if err != nil {
					return err
				}
				ardp.Recommendation = recommendation
			}
		case "decision":
			if v != nil {
				var decision AccessReviewResult
				err = json.Unmarshal(*v, &decision)
				if err != nil {
					return err
				}
				ardp.Decision = decision
			}
		case "justification":
			if v != nil {
				var justification string
				err = json.Unmarshal(*v, &justification)
				if err != nil {
					return err
				}
				ardp.Justification = &justification
			}
		case "reviewedDateTime":
			if v != nil {
				var reviewedDateTime date.Time
				err = json.Unmarshal(*v, &reviewedDateTime)
				if err != nil {
					return err
				}
				ardp.ReviewedDateTime = &reviewedDateTime
			}
		case "reviewedBy":
			if v != nil {
				var accessReviewActorIdentity AccessReviewActorIdentity
				err = json.Unmarshal(*v, &accessReviewActorIdentity)
				if err != nil {
					return err
				}
				ardp.AccessReviewActorIdentity = &accessReviewActorIdentity
			}
		case "applyResult":
			if v != nil {
				var applyResult AccessReviewApplyResult
				err = json.Unmarshal(*v, &applyResult)
				if err != nil {
					return err
				}
				ardp.ApplyResult = applyResult
			}
		case "appliedDateTime":
			if v != nil {
				var appliedDateTime date.Time
				err = json.Unmarshal(*v, &appliedDateTime)
				if err != nil {
					return err
				}
				ardp.AppliedDateTime = &appliedDateTime
			}
		case "appliedBy":
			if v != nil {
				var accessReviewActorIdentity1 AccessReviewActorIdentity
				err = json.Unmarshal(*v, &accessReviewActorIdentity1)
				if err != nil {
					return err
				}
				ardp.AccessReviewActorIdentity = &accessReviewActorIdentity1
			}
		}
	}

	return nil
}

// BasicAccessReviewDecisionTarget target of the decision.
type BasicAccessReviewDecisionTarget interface {
	AsUserDecisionTarget() (*UserDecisionTarget, bool)
	AsServicePrincipalDecisionTarget() (*ServicePrincipalDecisionTarget, bool)
	AsAccessReviewDecisionTarget() (*AccessReviewDecisionTarget, bool)
}

// AccessReviewDecisionTarget target of the decision.
type AccessReviewDecisionTarget struct {
	// Type - Possible values include: 'TypeAccessReviewDecisionTarget', 'TypeUser', 'TypeServicePrincipal'
	Type TypeBasicAccessReviewDecisionTarget `json:"type,omitempty"`
}

func unmarshalBasicAccessReviewDecisionTarget(body []byte) (BasicAccessReviewDecisionTarget, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["type"] {
	case string(TypeUser):
		var udt UserDecisionTarget
		err := json.Unmarshal(body, &udt)
		return udt, err
	case string(TypeServicePrincipal):
		var spdt ServicePrincipalDecisionTarget
		err := json.Unmarshal(body, &spdt)
		return spdt, err
	default:
		var ardt AccessReviewDecisionTarget
		err := json.Unmarshal(body, &ardt)
		return ardt, err
	}
}
func unmarshalBasicAccessReviewDecisionTargetArray(body []byte) ([]BasicAccessReviewDecisionTarget, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ardtArray := make([]BasicAccessReviewDecisionTarget, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ardt, err := unmarshalBasicAccessReviewDecisionTarget(*rawMessage)
		if err != nil {
			return nil, err
		}
		ardtArray[index] = ardt
	}
	return ardtArray, nil
}

// MarshalJSON is the custom marshaler for AccessReviewDecisionTarget.
func (ardt AccessReviewDecisionTarget) MarshalJSON() ([]byte, error) {
	ardt.Type = TypeAccessReviewDecisionTarget
	objectMap := make(map[string]interface{})
	if ardt.Type != "" {
		objectMap["type"] = ardt.Type
	}
	return json.Marshal(objectMap)
}

// AsUserDecisionTarget is the BasicAccessReviewDecisionTarget implementation for AccessReviewDecisionTarget.
func (ardt AccessReviewDecisionTarget) AsUserDecisionTarget() (*UserDecisionTarget, bool) {
	return nil, false
}

// AsServicePrincipalDecisionTarget is the BasicAccessReviewDecisionTarget implementation for AccessReviewDecisionTarget.
func (ardt AccessReviewDecisionTarget) AsServicePrincipalDecisionTarget() (*ServicePrincipalDecisionTarget, bool) {
	return nil, false
}

// AsAccessReviewDecisionTarget is the BasicAccessReviewDecisionTarget implementation for AccessReviewDecisionTarget.
func (ardt AccessReviewDecisionTarget) AsAccessReviewDecisionTarget() (*AccessReviewDecisionTarget, bool) {
	return &ardt, true
}

// AsBasicAccessReviewDecisionTarget is the BasicAccessReviewDecisionTarget implementation for AccessReviewDecisionTarget.
func (ardt AccessReviewDecisionTarget) AsBasicAccessReviewDecisionTarget() (BasicAccessReviewDecisionTarget, bool) {
	return &ardt, true
}

// AccessReviewDefaultSettings access Review Default Settings.
type AccessReviewDefaultSettings struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The access review default settings id. This is only going to be default
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The access review default settings name. This is always going to be Access Review Default Settings
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// AccessReviewScheduleSettings - Access Review properties.
	*AccessReviewScheduleSettings `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewDefaultSettings.
func (ards AccessReviewDefaultSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ards.AccessReviewScheduleSettings != nil {
		objectMap["properties"] = ards.AccessReviewScheduleSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewDefaultSettings struct.
func (ards *AccessReviewDefaultSettings) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ards.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ards.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ards.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var accessReviewScheduleSettings AccessReviewScheduleSettings
				err = json.Unmarshal(*v, &accessReviewScheduleSettings)
				if err != nil {
					return err
				}
				ards.AccessReviewScheduleSettings = &accessReviewScheduleSettings
			}
		}
	}

	return nil
}

// AccessReviewInstance access Review Instance.
type AccessReviewInstance struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The access review instance id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The access review instance name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// AccessReviewInstanceProperties - Access Review properties.
	*AccessReviewInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewInstance.
func (ari AccessReviewInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ari.AccessReviewInstanceProperties != nil {
		objectMap["properties"] = ari.AccessReviewInstanceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewInstance struct.
func (ari *AccessReviewInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ari.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ari.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ari.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var accessReviewInstanceProperties AccessReviewInstanceProperties
				err = json.Unmarshal(*v, &accessReviewInstanceProperties)
				if err != nil {
					return err
				}
				ari.AccessReviewInstanceProperties = &accessReviewInstanceProperties
			}
		}
	}

	return nil
}

// AccessReviewInstanceListResult list of Access Review Instances.
type AccessReviewInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - Access Review Instance list.
	Value *[]AccessReviewInstance `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AccessReviewInstanceListResultIterator provides access to a complete listing of AccessReviewInstance
// values.
type AccessReviewInstanceListResultIterator struct {
	i    int
	page AccessReviewInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccessReviewInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccessReviewInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccessReviewInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccessReviewInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccessReviewInstanceListResultIterator) Response() AccessReviewInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccessReviewInstanceListResultIterator) Value() AccessReviewInstance {
	if !iter.page.NotDone() {
		return AccessReviewInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccessReviewInstanceListResultIterator type.
func NewAccessReviewInstanceListResultIterator(page AccessReviewInstanceListResultPage) AccessReviewInstanceListResultIterator {
	return AccessReviewInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (arilr AccessReviewInstanceListResult) IsEmpty() bool {
	return arilr.Value == nil || len(*arilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (arilr AccessReviewInstanceListResult) hasNextLink() bool {
	return arilr.NextLink != nil && len(*arilr.NextLink) != 0
}

// accessReviewInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (arilr AccessReviewInstanceListResult) accessReviewInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !arilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(arilr.NextLink)))
}

// AccessReviewInstanceListResultPage contains a page of AccessReviewInstance values.
type AccessReviewInstanceListResultPage struct {
	fn    func(context.Context, AccessReviewInstanceListResult) (AccessReviewInstanceListResult, error)
	arilr AccessReviewInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccessReviewInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccessReviewInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.arilr)
		if err != nil {
			return err
		}
		page.arilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccessReviewInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccessReviewInstanceListResultPage) NotDone() bool {
	return !page.arilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccessReviewInstanceListResultPage) Response() AccessReviewInstanceListResult {
	return page.arilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccessReviewInstanceListResultPage) Values() []AccessReviewInstance {
	if page.arilr.IsEmpty() {
		return nil
	}
	return *page.arilr.Value
}

// Creates a new instance of the AccessReviewInstanceListResultPage type.
func NewAccessReviewInstanceListResultPage(cur AccessReviewInstanceListResult, getNextPage func(context.Context, AccessReviewInstanceListResult) (AccessReviewInstanceListResult, error)) AccessReviewInstanceListResultPage {
	return AccessReviewInstanceListResultPage{
		fn:    getNextPage,
		arilr: cur,
	}
}

// AccessReviewInstanceProperties access Review Instance properties.
type AccessReviewInstanceProperties struct {
	// Status - READ-ONLY; This read-only field specifies the status of an access review instance. Possible values include: 'NotStarted', 'InProgress', 'Completed', 'Applied', 'Initializing', 'Applying', 'Completing', 'Scheduled', 'AutoReviewing', 'AutoReviewed', 'Starting'
	Status AccessReviewInstanceStatus `json:"status,omitempty"`
	// StartDateTime - The DateTime when the review instance is scheduled to be start.
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// EndDateTime - The DateTime when the review instance is scheduled to end.
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewInstanceProperties.
func (arip AccessReviewInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arip.StartDateTime != nil {
		objectMap["startDateTime"] = arip.StartDateTime
	}
	if arip.EndDateTime != nil {
		objectMap["endDateTime"] = arip.EndDateTime
	}
	return json.Marshal(objectMap)
}

// AccessReviewRecurrencePattern recurrence Pattern of an Access Review Schedule Definition.
type AccessReviewRecurrencePattern struct {
	// Type - The recurrence type : weekly, monthly, etc. Possible values include: 'Weekly', 'AbsoluteMonthly'
	Type AccessReviewRecurrencePatternType `json:"type,omitempty"`
	// Interval - The interval for recurrence. For a quarterly review, the interval is 3 for type : absoluteMonthly.
	Interval *int32 `json:"interval,omitempty"`
}

// AccessReviewRecurrenceRange recurrence Range of an Access Review Schedule Definition.
type AccessReviewRecurrenceRange struct {
	// Type - The recurrence range type. The possible values are: endDate, noEnd, numbered. Possible values include: 'EndDate', 'NoEnd', 'Numbered'
	Type AccessReviewRecurrenceRangeType `json:"type,omitempty"`
	// NumberOfOccurrences - The number of times to repeat the access review. Required and must be positive if type is numbered.
	NumberOfOccurrences *int32 `json:"numberOfOccurrences,omitempty"`
	// StartDate - The DateTime when the review is scheduled to be start. This could be a date in the future. Required on create.
	StartDate *date.Time `json:"startDate,omitempty"`
	// EndDate - The DateTime when the review is scheduled to end. Required if type is endDate
	EndDate *date.Time `json:"endDate,omitempty"`
}

// AccessReviewRecurrenceSettings recurrence Settings of an Access Review Schedule Definition.
type AccessReviewRecurrenceSettings struct {
	// AccessReviewRecurrencePattern - Access Review schedule definition recurrence pattern.
	*AccessReviewRecurrencePattern `json:"pattern,omitempty"`
	// AccessReviewRecurrenceRange - Access Review schedule definition recurrence range.
	*AccessReviewRecurrenceRange `json:"range,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewRecurrenceSettings.
func (arrs AccessReviewRecurrenceSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arrs.AccessReviewRecurrencePattern != nil {
		objectMap["pattern"] = arrs.AccessReviewRecurrencePattern
	}
	if arrs.AccessReviewRecurrenceRange != nil {
		objectMap["range"] = arrs.AccessReviewRecurrenceRange
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewRecurrenceSettings struct.
func (arrs *AccessReviewRecurrenceSettings) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "pattern":
			if v != nil {
				var accessReviewRecurrencePattern AccessReviewRecurrencePattern
				err = json.Unmarshal(*v, &accessReviewRecurrencePattern)
				if err != nil {
					return err
				}
				arrs.AccessReviewRecurrencePattern = &accessReviewRecurrencePattern
			}
		case "range":
			if v != nil {
				var accessReviewRecurrenceRange AccessReviewRecurrenceRange
				err = json.Unmarshal(*v, &accessReviewRecurrenceRange)
				if err != nil {
					return err
				}
				arrs.AccessReviewRecurrenceRange = &accessReviewRecurrenceRange
			}
		}
	}

	return nil
}

// AccessReviewReviewer descriptor for what needs to be reviewed
type AccessReviewReviewer struct {
	// PrincipalID - The id of the reviewer(user/servicePrincipal)
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - READ-ONLY; The identity type : user/servicePrincipal. Possible values include: 'AccessReviewReviewerTypeUser', 'AccessReviewReviewerTypeServicePrincipal'
	PrincipalType AccessReviewReviewerType `json:"principalType,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewReviewer.
func (arr AccessReviewReviewer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arr.PrincipalID != nil {
		objectMap["principalId"] = arr.PrincipalID
	}
	return json.Marshal(objectMap)
}

// AccessReviewScheduleDefinition access Review Schedule Definition.
type AccessReviewScheduleDefinition struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The access review schedule definition id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The access review schedule definition unique id.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
	// AccessReviewScheduleDefinitionProperties - Access Review properties.
	*AccessReviewScheduleDefinitionProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewScheduleDefinition.
func (arsd AccessReviewScheduleDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arsd.AccessReviewScheduleDefinitionProperties != nil {
		objectMap["properties"] = arsd.AccessReviewScheduleDefinitionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewScheduleDefinition struct.
func (arsd *AccessReviewScheduleDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				arsd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				arsd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				arsd.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var accessReviewScheduleDefinitionProperties AccessReviewScheduleDefinitionProperties
				err = json.Unmarshal(*v, &accessReviewScheduleDefinitionProperties)
				if err != nil {
					return err
				}
				arsd.AccessReviewScheduleDefinitionProperties = &accessReviewScheduleDefinitionProperties
			}
		}
	}

	return nil
}

// AccessReviewScheduleDefinitionListResult list of Access Review Schedule Definitions.
type AccessReviewScheduleDefinitionListResult struct {
	autorest.Response `json:"-"`
	// Value - Access Review Schedule Definition list.
	Value *[]AccessReviewScheduleDefinition `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// AccessReviewScheduleDefinitionListResultIterator provides access to a complete listing of
// AccessReviewScheduleDefinition values.
type AccessReviewScheduleDefinitionListResultIterator struct {
	i    int
	page AccessReviewScheduleDefinitionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccessReviewScheduleDefinitionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccessReviewScheduleDefinitionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccessReviewScheduleDefinitionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccessReviewScheduleDefinitionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccessReviewScheduleDefinitionListResultIterator) Response() AccessReviewScheduleDefinitionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccessReviewScheduleDefinitionListResultIterator) Value() AccessReviewScheduleDefinition {
	if !iter.page.NotDone() {
		return AccessReviewScheduleDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccessReviewScheduleDefinitionListResultIterator type.
func NewAccessReviewScheduleDefinitionListResultIterator(page AccessReviewScheduleDefinitionListResultPage) AccessReviewScheduleDefinitionListResultIterator {
	return AccessReviewScheduleDefinitionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (arsdlr AccessReviewScheduleDefinitionListResult) IsEmpty() bool {
	return arsdlr.Value == nil || len(*arsdlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (arsdlr AccessReviewScheduleDefinitionListResult) hasNextLink() bool {
	return arsdlr.NextLink != nil && len(*arsdlr.NextLink) != 0
}

// accessReviewScheduleDefinitionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (arsdlr AccessReviewScheduleDefinitionListResult) accessReviewScheduleDefinitionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !arsdlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(arsdlr.NextLink)))
}

// AccessReviewScheduleDefinitionListResultPage contains a page of AccessReviewScheduleDefinition values.
type AccessReviewScheduleDefinitionListResultPage struct {
	fn     func(context.Context, AccessReviewScheduleDefinitionListResult) (AccessReviewScheduleDefinitionListResult, error)
	arsdlr AccessReviewScheduleDefinitionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccessReviewScheduleDefinitionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccessReviewScheduleDefinitionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.arsdlr)
		if err != nil {
			return err
		}
		page.arsdlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccessReviewScheduleDefinitionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccessReviewScheduleDefinitionListResultPage) NotDone() bool {
	return !page.arsdlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccessReviewScheduleDefinitionListResultPage) Response() AccessReviewScheduleDefinitionListResult {
	return page.arsdlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccessReviewScheduleDefinitionListResultPage) Values() []AccessReviewScheduleDefinition {
	if page.arsdlr.IsEmpty() {
		return nil
	}
	return *page.arsdlr.Value
}

// Creates a new instance of the AccessReviewScheduleDefinitionListResultPage type.
func NewAccessReviewScheduleDefinitionListResultPage(cur AccessReviewScheduleDefinitionListResult, getNextPage func(context.Context, AccessReviewScheduleDefinitionListResult) (AccessReviewScheduleDefinitionListResult, error)) AccessReviewScheduleDefinitionListResultPage {
	return AccessReviewScheduleDefinitionListResultPage{
		fn:     getNextPage,
		arsdlr: cur,
	}
}

// AccessReviewScheduleDefinitionProperties access Review.
type AccessReviewScheduleDefinitionProperties struct {
	// DisplayName - The display name for the schedule definition.
	DisplayName *string `json:"displayName,omitempty"`
	// Status - READ-ONLY; This read-only field specifies the status of an accessReview. Possible values include: 'AccessReviewScheduleDefinitionStatusNotStarted', 'AccessReviewScheduleDefinitionStatusInProgress', 'AccessReviewScheduleDefinitionStatusCompleted', 'AccessReviewScheduleDefinitionStatusApplied', 'AccessReviewScheduleDefinitionStatusInitializing', 'AccessReviewScheduleDefinitionStatusApplying', 'AccessReviewScheduleDefinitionStatusCompleting', 'AccessReviewScheduleDefinitionStatusScheduled', 'AccessReviewScheduleDefinitionStatusAutoReviewing', 'AccessReviewScheduleDefinitionStatusAutoReviewed', 'AccessReviewScheduleDefinitionStatusStarting'
	Status AccessReviewScheduleDefinitionStatus `json:"status,omitempty"`
	// DescriptionForAdmins - The description provided by the access review creator and visible to admins.
	DescriptionForAdmins *string `json:"descriptionForAdmins,omitempty"`
	// DescriptionForReviewers - The description provided by the access review creator to be shown to reviewers.
	DescriptionForReviewers *string `json:"descriptionForReviewers,omitempty"`
	// AccessReviewActorIdentity - READ-ONLY; The user or other identity who created this review.
	*AccessReviewActorIdentity `json:"createdBy,omitempty"`
	// AccessReviewScheduleSettings - Access Review Settings.
	*AccessReviewScheduleSettings `json:"settings,omitempty"`
	// AccessReviewScope - READ-ONLY; This is used to define what to include in scope of the review. The scope definition includes the resourceId and roleDefinitionId.
	*AccessReviewScope `json:"scope,omitempty"`
	// Reviewers - This is the collection of reviewers.
	Reviewers *[]AccessReviewReviewer `json:"reviewers,omitempty"`
	// ReviewersType - READ-ONLY; This field specifies the type of reviewers for a review. Usually for a review, reviewers are explicitly assigned. However, in some cases, the reviewers may not be assigned and instead be chosen dynamically. For example managers review or self review. Possible values include: 'Assigned', 'Self', 'Managers'
	ReviewersType AccessReviewScheduleDefinitionReviewersType `json:"reviewersType,omitempty"`
	// Instances - This is the collection of instances returned when one does an expand on it.
	Instances *[]AccessReviewInstance `json:"instances,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewScheduleDefinitionProperties.
func (arsdp AccessReviewScheduleDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arsdp.DisplayName != nil {
		objectMap["displayName"] = arsdp.DisplayName
	}
	if arsdp.DescriptionForAdmins != nil {
		objectMap["descriptionForAdmins"] = arsdp.DescriptionForAdmins
	}
	if arsdp.DescriptionForReviewers != nil {
		objectMap["descriptionForReviewers"] = arsdp.DescriptionForReviewers
	}
	if arsdp.AccessReviewScheduleSettings != nil {
		objectMap["settings"] = arsdp.AccessReviewScheduleSettings
	}
	if arsdp.Reviewers != nil {
		objectMap["reviewers"] = arsdp.Reviewers
	}
	if arsdp.Instances != nil {
		objectMap["instances"] = arsdp.Instances
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewScheduleDefinitionProperties struct.
func (arsdp *AccessReviewScheduleDefinitionProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				arsdp.DisplayName = &displayName
			}
		case "status":
			if v != nil {
				var status AccessReviewScheduleDefinitionStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				arsdp.Status = status
			}
		case "descriptionForAdmins":
			if v != nil {
				var descriptionForAdmins string
				err = json.Unmarshal(*v, &descriptionForAdmins)
				if err != nil {
					return err
				}
				arsdp.DescriptionForAdmins = &descriptionForAdmins
			}
		case "descriptionForReviewers":
			if v != nil {
				var descriptionForReviewers string
				err = json.Unmarshal(*v, &descriptionForReviewers)
				if err != nil {
					return err
				}
				arsdp.DescriptionForReviewers = &descriptionForReviewers
			}
		case "createdBy":
			if v != nil {
				var accessReviewActorIdentity AccessReviewActorIdentity
				err = json.Unmarshal(*v, &accessReviewActorIdentity)
				if err != nil {
					return err
				}
				arsdp.AccessReviewActorIdentity = &accessReviewActorIdentity
			}
		case "settings":
			if v != nil {
				var accessReviewScheduleSettings AccessReviewScheduleSettings
				err = json.Unmarshal(*v, &accessReviewScheduleSettings)
				if err != nil {
					return err
				}
				arsdp.AccessReviewScheduleSettings = &accessReviewScheduleSettings
			}
		case "scope":
			if v != nil {
				var accessReviewScope AccessReviewScope
				err = json.Unmarshal(*v, &accessReviewScope)
				if err != nil {
					return err
				}
				arsdp.AccessReviewScope = &accessReviewScope
			}
		case "reviewers":
			if v != nil {
				var reviewers []AccessReviewReviewer
				err = json.Unmarshal(*v, &reviewers)
				if err != nil {
					return err
				}
				arsdp.Reviewers = &reviewers
			}
		case "reviewersType":
			if v != nil {
				var reviewersType AccessReviewScheduleDefinitionReviewersType
				err = json.Unmarshal(*v, &reviewersType)
				if err != nil {
					return err
				}
				arsdp.ReviewersType = reviewersType
			}
		case "instances":
			if v != nil {
				var instances []AccessReviewInstance
				err = json.Unmarshal(*v, &instances)
				if err != nil {
					return err
				}
				arsdp.Instances = &instances
			}
		}
	}

	return nil
}

// AccessReviewScheduleSettings settings of an Access Review.
type AccessReviewScheduleSettings struct {
	// MailNotificationsEnabled - Flag to indicate whether sending mails to reviewers and the review creator is enabled.
	MailNotificationsEnabled *bool `json:"mailNotificationsEnabled,omitempty"`
	// ReminderNotificationsEnabled - Flag to indicate whether sending reminder emails to reviewers are enabled.
	ReminderNotificationsEnabled *bool `json:"reminderNotificationsEnabled,omitempty"`
	// DefaultDecisionEnabled - Flag to indicate whether reviewers are required to provide a justification when reviewing access.
	DefaultDecisionEnabled *bool `json:"defaultDecisionEnabled,omitempty"`
	// JustificationRequiredOnApproval - Flag to indicate whether the reviewer is required to pass justification when recording a decision.
	JustificationRequiredOnApproval *bool `json:"justificationRequiredOnApproval,omitempty"`
	// DefaultDecision - This specifies the behavior for the autoReview feature when an access review completes. Possible values include: 'DefaultDecisionTypeApprove', 'DefaultDecisionTypeDeny', 'DefaultDecisionTypeRecommendation'
	DefaultDecision DefaultDecisionType `json:"defaultDecision,omitempty"`
	// AutoApplyDecisionsEnabled - Flag to indicate whether auto-apply capability, to automatically change the target object access resource, is enabled. If not enabled, a user must, after the review completes, apply the access review.
	AutoApplyDecisionsEnabled *bool `json:"autoApplyDecisionsEnabled,omitempty"`
	// RecommendationsEnabled - Flag to indicate whether showing recommendations to reviewers is enabled.
	RecommendationsEnabled *bool `json:"recommendationsEnabled,omitempty"`
	// InstanceDurationInDays - The duration in days for an instance.
	InstanceDurationInDays *int32 `json:"instanceDurationInDays,omitempty"`
	// AccessReviewRecurrenceSettings - Access Review Settings.
	*AccessReviewRecurrenceSettings `json:"recurrence,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewScheduleSettings.
func (arss AccessReviewScheduleSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arss.MailNotificationsEnabled != nil {
		objectMap["mailNotificationsEnabled"] = arss.MailNotificationsEnabled
	}
	if arss.ReminderNotificationsEnabled != nil {
		objectMap["reminderNotificationsEnabled"] = arss.ReminderNotificationsEnabled
	}
	if arss.DefaultDecisionEnabled != nil {
		objectMap["defaultDecisionEnabled"] = arss.DefaultDecisionEnabled
	}
	if arss.JustificationRequiredOnApproval != nil {
		objectMap["justificationRequiredOnApproval"] = arss.JustificationRequiredOnApproval
	}
	if arss.DefaultDecision != "" {
		objectMap["defaultDecision"] = arss.DefaultDecision
	}
	if arss.AutoApplyDecisionsEnabled != nil {
		objectMap["autoApplyDecisionsEnabled"] = arss.AutoApplyDecisionsEnabled
	}
	if arss.RecommendationsEnabled != nil {
		objectMap["recommendationsEnabled"] = arss.RecommendationsEnabled
	}
	if arss.InstanceDurationInDays != nil {
		objectMap["instanceDurationInDays"] = arss.InstanceDurationInDays
	}
	if arss.AccessReviewRecurrenceSettings != nil {
		objectMap["recurrence"] = arss.AccessReviewRecurrenceSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccessReviewScheduleSettings struct.
func (arss *AccessReviewScheduleSettings) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "mailNotificationsEnabled":
			if v != nil {
				var mailNotificationsEnabled bool
				err = json.Unmarshal(*v, &mailNotificationsEnabled)
				if err != nil {
					return err
				}
				arss.MailNotificationsEnabled = &mailNotificationsEnabled
			}
		case "reminderNotificationsEnabled":
			if v != nil {
				var reminderNotificationsEnabled bool
				err = json.Unmarshal(*v, &reminderNotificationsEnabled)
				if err != nil {
					return err
				}
				arss.ReminderNotificationsEnabled = &reminderNotificationsEnabled
			}
		case "defaultDecisionEnabled":
			if v != nil {
				var defaultDecisionEnabled bool
				err = json.Unmarshal(*v, &defaultDecisionEnabled)
				if err != nil {
					return err
				}
				arss.DefaultDecisionEnabled = &defaultDecisionEnabled
			}
		case "justificationRequiredOnApproval":
			if v != nil {
				var justificationRequiredOnApproval bool
				err = json.Unmarshal(*v, &justificationRequiredOnApproval)
				if err != nil {
					return err
				}
				arss.JustificationRequiredOnApproval = &justificationRequiredOnApproval
			}
		case "defaultDecision":
			if v != nil {
				var defaultDecision DefaultDecisionType
				err = json.Unmarshal(*v, &defaultDecision)
				if err != nil {
					return err
				}
				arss.DefaultDecision = defaultDecision
			}
		case "autoApplyDecisionsEnabled":
			if v != nil {
				var autoApplyDecisionsEnabled bool
				err = json.Unmarshal(*v, &autoApplyDecisionsEnabled)
				if err != nil {
					return err
				}
				arss.AutoApplyDecisionsEnabled = &autoApplyDecisionsEnabled
			}
		case "recommendationsEnabled":
			if v != nil {
				var recommendationsEnabled bool
				err = json.Unmarshal(*v, &recommendationsEnabled)
				if err != nil {
					return err
				}
				arss.RecommendationsEnabled = &recommendationsEnabled
			}
		case "instanceDurationInDays":
			if v != nil {
				var instanceDurationInDays int32
				err = json.Unmarshal(*v, &instanceDurationInDays)
				if err != nil {
					return err
				}
				arss.InstanceDurationInDays = &instanceDurationInDays
			}
		case "recurrence":
			if v != nil {
				var accessReviewRecurrenceSettings AccessReviewRecurrenceSettings
				err = json.Unmarshal(*v, &accessReviewRecurrenceSettings)
				if err != nil {
					return err
				}
				arss.AccessReviewRecurrenceSettings = &accessReviewRecurrenceSettings
			}
		}
	}

	return nil
}

// AccessReviewScope descriptor for what needs to be reviewed
type AccessReviewScope struct {
	// ResourceID - READ-ONLY; ResourceId in which this review is getting created
	ResourceID *string `json:"resourceId,omitempty"`
	// RoleDefinitionID - READ-ONLY; This is used to indicate the role being reviewed
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalType - READ-ONLY; The identity type user/servicePrincipal to review. Possible values include: 'AccessReviewScopePrincipalTypeUser', 'AccessReviewScopePrincipalTypeServicePrincipal'
	PrincipalType AccessReviewScopePrincipalType `json:"principalType,omitempty"`
}

// MarshalJSON is the custom marshaler for AccessReviewScope.
func (ars AccessReviewScope) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ApprovalSettings the approval settings.
type ApprovalSettings struct {
	// IsApprovalRequired - Determine whether approval is required or not.
	IsApprovalRequired *bool `json:"isApprovalRequired,omitempty"`
	// IsApprovalRequiredForExtension - Determine whether approval is required for assignment extension.
	IsApprovalRequiredForExtension *bool `json:"isApprovalRequiredForExtension,omitempty"`
	// IsRequestorJustificationRequired - Determine whether requestor justification required.
	IsRequestorJustificationRequired *bool `json:"isRequestorJustificationRequired,omitempty"`
	// ApprovalMode - The type of rule. Possible values include: 'SingleStage', 'Serial', 'Parallel', 'NoApproval'
	ApprovalMode ApprovalMode `json:"approvalMode,omitempty"`
	// ApprovalStages - The approval stages of the request.
	ApprovalStages *[]ApprovalStage `json:"approvalStages,omitempty"`
}

// ApprovalStage the approval stage.
type ApprovalStage struct {
	// ApprovalStageTimeOutInDays - The time in days when approval request would be timed out.
	ApprovalStageTimeOutInDays *int32 `json:"approvalStageTimeOutInDays,omitempty"`
	// IsApproverJustificationRequired - Determine whether approver need to provide justification for his decision.
	IsApproverJustificationRequired *bool `json:"isApproverJustificationRequired,omitempty"`
	// EscalationTimeInMinutes - The time in minutes when the approval request would be escalated if the primary approver does not approves.
	EscalationTimeInMinutes *int32 `json:"escalationTimeInMinutes,omitempty"`
	// PrimaryApprovers - The primary approver of the request.
	PrimaryApprovers *[]UserSet `json:"primaryApprovers,omitempty"`
	// IsEscalationEnabled - The value determine whether escalation feature is enabled.
	IsEscalationEnabled *bool `json:"isEscalationEnabled,omitempty"`
	// EscalationApprovers - The escalation approver of the request.
	EscalationApprovers *[]UserSet `json:"escalationApprovers,omitempty"`
}

// CloudError an error response from the service.
type CloudError struct {
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
}

// DenyAssignment deny Assignment
type DenyAssignment struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The deny assignment ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The deny assignment name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The deny assignment type.
	Type *string `json:"type,omitempty"`
	// DenyAssignmentProperties - Deny assignment properties.
	*DenyAssignmentProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for DenyAssignment.
func (da DenyAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if da.DenyAssignmentProperties != nil {
		objectMap["properties"] = da.DenyAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DenyAssignment struct.
func (da *DenyAssignment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				da.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				da.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				da.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var denyAssignmentProperties DenyAssignmentProperties
				err = json.Unmarshal(*v, &denyAssignmentProperties)
				if err != nil {
					return err
				}
				da.DenyAssignmentProperties = &denyAssignmentProperties
			}
		}
	}

	return nil
}

// DenyAssignmentFilter deny Assignments filter
type DenyAssignmentFilter struct {
	// DenyAssignmentName - Return deny assignment with specified name.
	DenyAssignmentName *string `json:"denyAssignmentName,omitempty"`
	// PrincipalID - Return all deny assignments where the specified principal is listed in the principals list of deny assignments.
	PrincipalID *string `json:"principalId,omitempty"`
	// GdprExportPrincipalID - Return all deny assignments where the specified principal is listed either in the principals list or exclude principals list of deny assignments.
	GdprExportPrincipalID *string `json:"gdprExportPrincipalId,omitempty"`
}

// DenyAssignmentListResult deny assignment list operation result.
type DenyAssignmentListResult struct {
	autorest.Response `json:"-"`
	// Value - Deny assignment list.
	Value *[]DenyAssignment `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// DenyAssignmentListResultIterator provides access to a complete listing of DenyAssignment values.
type DenyAssignmentListResultIterator struct {
	i    int
	page DenyAssignmentListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DenyAssignmentListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DenyAssignmentListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DenyAssignmentListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DenyAssignmentListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DenyAssignmentListResultIterator) Response() DenyAssignmentListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DenyAssignmentListResultIterator) Value() DenyAssignment {
	if !iter.page.NotDone() {
		return DenyAssignment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DenyAssignmentListResultIterator type.
func NewDenyAssignmentListResultIterator(page DenyAssignmentListResultPage) DenyAssignmentListResultIterator {
	return DenyAssignmentListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dalr DenyAssignmentListResult) IsEmpty() bool {
	return dalr.Value == nil || len(*dalr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dalr DenyAssignmentListResult) hasNextLink() bool {
	return dalr.NextLink != nil && len(*dalr.NextLink) != 0
}

// denyAssignmentListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dalr DenyAssignmentListResult) denyAssignmentListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !dalr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dalr.NextLink)))
}

// DenyAssignmentListResultPage contains a page of DenyAssignment values.
type DenyAssignmentListResultPage struct {
	fn   func(context.Context, DenyAssignmentListResult) (DenyAssignmentListResult, error)
	dalr DenyAssignmentListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DenyAssignmentListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DenyAssignmentListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dalr)
		if err != nil {
			return err
		}
		page.dalr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DenyAssignmentListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DenyAssignmentListResultPage) NotDone() bool {
	return !page.dalr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DenyAssignmentListResultPage) Response() DenyAssignmentListResult {
	return page.dalr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DenyAssignmentListResultPage) Values() []DenyAssignment {
	if page.dalr.IsEmpty() {
		return nil
	}
	return *page.dalr.Value
}

// Creates a new instance of the DenyAssignmentListResultPage type.
func NewDenyAssignmentListResultPage(cur DenyAssignmentListResult, getNextPage func(context.Context, DenyAssignmentListResult) (DenyAssignmentListResult, error)) DenyAssignmentListResultPage {
	return DenyAssignmentListResultPage{
		fn:   getNextPage,
		dalr: cur,
	}
}

// DenyAssignmentPermission deny assignment permissions.
type DenyAssignmentPermission struct {
	// Actions - Actions to which the deny assignment does not grant access.
	Actions *[]string `json:"actions,omitempty"`
	// NotActions - Actions to exclude from that the deny assignment does not grant access.
	NotActions *[]string `json:"notActions,omitempty"`
	// DataActions - Data actions to which the deny assignment does not grant access.
	DataActions *[]string `json:"dataActions,omitempty"`
	// NotDataActions - Data actions to exclude from that the deny assignment does not grant access.
	NotDataActions *[]string `json:"notDataActions,omitempty"`
}

// DenyAssignmentProperties deny assignment properties.
type DenyAssignmentProperties struct {
	// DenyAssignmentName - The display name of the deny assignment.
	DenyAssignmentName *string `json:"denyAssignmentName,omitempty"`
	// Description - The description of the deny assignment.
	Description *string `json:"description,omitempty"`
	// Permissions - An array of permissions that are denied by the deny assignment.
	Permissions *[]DenyAssignmentPermission `json:"permissions,omitempty"`
	// Scope - The deny assignment scope.
	Scope *string `json:"scope,omitempty"`
	// DoNotApplyToChildScopes - Determines if the deny assignment applies to child scopes. Default value is false.
	DoNotApplyToChildScopes *bool `json:"doNotApplyToChildScopes,omitempty"`
	// Principals - Array of principals to which the deny assignment applies.
	Principals *[]Principal `json:"principals,omitempty"`
	// ExcludePrincipals - Array of principals to which the deny assignment does not apply.
	ExcludePrincipals *[]Principal `json:"excludePrincipals,omitempty"`
	// IsSystemProtected - Specifies whether this deny assignment was created by Azure and cannot be edited or deleted.
	IsSystemProtected *bool `json:"isSystemProtected,omitempty"`
}

// EligibleChildResource eligible child resource
type EligibleChildResource struct {
	// ID - READ-ONLY; The resource scope Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for EligibleChildResource.
func (ecr EligibleChildResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// EligibleChildResourcesListResult eligible child resources list operation result.
type EligibleChildResourcesListResult struct {
	autorest.Response `json:"-"`
	// Value - Eligible child resource list.
	Value *[]EligibleChildResource `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// EligibleChildResourcesListResultIterator provides access to a complete listing of EligibleChildResource
// values.
type EligibleChildResourcesListResultIterator struct {
	i    int
	page EligibleChildResourcesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EligibleChildResourcesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EligibleChildResourcesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EligibleChildResourcesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EligibleChildResourcesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EligibleChildResourcesListResultIterator) Response() EligibleChildResourcesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EligibleChildResourcesListResultIterator) Value() EligibleChildResource {
	if !iter.page.NotDone() {
		return EligibleChildResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EligibleChildResourcesListResultIterator type.
func NewEligibleChildResourcesListResultIterator(page EligibleChildResourcesListResultPage) EligibleChildResourcesListResultIterator {
	return EligibleChildResourcesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ecrlr EligibleChildResourcesListResult) IsEmpty() bool {
	return ecrlr.Value == nil || len(*ecrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ecrlr EligibleChildResourcesListResult) hasNextLink() bool {
	return ecrlr.NextLink != nil && len(*ecrlr.NextLink) != 0
}

// eligibleChildResourcesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ecrlr EligibleChildResourcesListResult) eligibleChildResourcesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ecrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ecrlr.NextLink)))
}

// EligibleChildResourcesListResultPage contains a page of EligibleChildResource values.
type EligibleChildResourcesListResultPage struct {
	fn    func(context.Context, EligibleChildResourcesListResult) (EligibleChildResourcesListResult, error)
	ecrlr EligibleChildResourcesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EligibleChildResourcesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EligibleChildResourcesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ecrlr)
		if err != nil {
			return err
		}
		page.ecrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EligibleChildResourcesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EligibleChildResourcesListResultPage) NotDone() bool {
	return !page.ecrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EligibleChildResourcesListResultPage) Response() EligibleChildResourcesListResult {
	return page.ecrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EligibleChildResourcesListResultPage) Values() []EligibleChildResource {
	if page.ecrlr.IsEmpty() {
		return nil
	}
	return *page.ecrlr.Value
}

// Creates a new instance of the EligibleChildResourcesListResultPage type.
func NewEligibleChildResourcesListResultPage(cur EligibleChildResourcesListResult, getNextPage func(context.Context, EligibleChildResourcesListResult) (EligibleChildResourcesListResult, error)) EligibleChildResourcesListResultPage {
	return EligibleChildResourcesListResultPage{
		fn:    getNextPage,
		ecrlr: cur,
	}
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDefinition error description and code explaining why an operation failed.
type ErrorDefinition struct {
	// Error - Error of the list gateway status.
	Error *ErrorDefinitionProperties `json:"error,omitempty"`
}

// ErrorDefinitionProperties error description and code explaining why an operation failed.
type ErrorDefinitionProperties struct {
	// Message - READ-ONLY; Description of the error.
	Message *string `json:"message,omitempty"`
	// Code - Error code of list gateway.
	Code *string `json:"code,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDefinitionProperties.
func (edp ErrorDefinitionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if edp.Code != nil {
		objectMap["code"] = edp.Code
	}
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// ExpandedProperties ...
type ExpandedProperties struct {
	// Scope - Details of the resource scope
	Scope *ExpandedPropertiesScope `json:"scope,omitempty"`
	// RoleDefinition - Details of role definition
	RoleDefinition *ExpandedPropertiesRoleDefinition `json:"roleDefinition,omitempty"`
	// Principal - Details of the principal
	Principal *ExpandedPropertiesPrincipal `json:"principal,omitempty"`
}

// ExpandedPropertiesPrincipal details of the principal
type ExpandedPropertiesPrincipal struct {
	// ID - Id of the principal
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the principal
	DisplayName *string `json:"displayName,omitempty"`
	// Email - Email id of the principal
	Email *string `json:"email,omitempty"`
	// Type - Type of the principal
	Type *string `json:"type,omitempty"`
}

// ExpandedPropertiesRoleDefinition details of role definition
type ExpandedPropertiesRoleDefinition struct {
	// ID - Id of the role definition
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the role definition
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Type of the role definition
	Type *string `json:"type,omitempty"`
}

// ExpandedPropertiesScope details of the resource scope
type ExpandedPropertiesScope struct {
	// ID - Scope id of the resource
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the resource
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Type of the resource
	Type *string `json:"type,omitempty"`
}

// Operation the definition of a Microsoft.Authorization operation.
type Operation struct {
	// Name - Name of the operation
	Name *string `json:"name,omitempty"`
	// IsDataAction - Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Display of the operation
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - Origin of the operation
	Origin *string `json:"origin,omitempty"`
}

// OperationDisplay the display information for a Microsoft.Authorization operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; The resource provider name: Microsoft.Authorization.
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; The resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; The operation that users can perform.
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; The description for the operation.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (od OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult the result of a request to list Microsoft.Authorization operations.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - The collection value.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - The URI that can be used to request the next set of paged results.
	NextLink *string `json:"nextLink,omitempty"`
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// Permission role definition permissions.
type Permission struct {
	// Actions - Allowed actions.
	Actions *[]string `json:"actions,omitempty"`
	// NotActions - Denied actions.
	NotActions *[]string `json:"notActions,omitempty"`
	// DataActions - Allowed Data actions.
	DataActions *[]string `json:"dataActions,omitempty"`
	// NotDataActions - Denied Data actions.
	NotDataActions *[]string `json:"notDataActions,omitempty"`
}

// PermissionGetResult permissions information.
type PermissionGetResult struct {
	autorest.Response `json:"-"`
	// Value - An array of permissions.
	Value *[]Permission `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PermissionGetResultIterator provides access to a complete listing of Permission values.
type PermissionGetResultIterator struct {
	i    int
	page PermissionGetResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PermissionGetResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PermissionGetResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PermissionGetResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PermissionGetResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PermissionGetResultIterator) Response() PermissionGetResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PermissionGetResultIterator) Value() Permission {
	if !iter.page.NotDone() {
		return Permission{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PermissionGetResultIterator type.
func NewPermissionGetResultIterator(page PermissionGetResultPage) PermissionGetResultIterator {
	return PermissionGetResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pgr PermissionGetResult) IsEmpty() bool {
	return pgr.Value == nil || len(*pgr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pgr PermissionGetResult) hasNextLink() bool {
	return pgr.NextLink != nil && len(*pgr.NextLink) != 0
}

// permissionGetResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pgr PermissionGetResult) permissionGetResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pgr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pgr.NextLink)))
}

// PermissionGetResultPage contains a page of Permission values.
type PermissionGetResultPage struct {
	fn  func(context.Context, PermissionGetResult) (PermissionGetResult, error)
	pgr PermissionGetResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PermissionGetResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PermissionGetResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pgr)
		if err != nil {
			return err
		}
		page.pgr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PermissionGetResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PermissionGetResultPage) NotDone() bool {
	return !page.pgr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PermissionGetResultPage) Response() PermissionGetResult {
	return page.pgr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PermissionGetResultPage) Values() []Permission {
	if page.pgr.IsEmpty() {
		return nil
	}
	return *page.pgr.Value
}

// Creates a new instance of the PermissionGetResultPage type.
func NewPermissionGetResultPage(cur PermissionGetResult, getNextPage func(context.Context, PermissionGetResult) (PermissionGetResult, error)) PermissionGetResultPage {
	return PermissionGetResultPage{
		fn:  getNextPage,
		pgr: cur,
	}
}

// PolicyAssignmentProperties ...
type PolicyAssignmentProperties struct {
	// Scope - Details of the resource scope
	Scope *PolicyAssignmentPropertiesScope `json:"scope,omitempty"`
	// RoleDefinition - Details of role definition
	RoleDefinition *PolicyAssignmentPropertiesRoleDefinition `json:"roleDefinition,omitempty"`
	// Policy - Details of the policy
	Policy *PolicyAssignmentPropertiesPolicy `json:"policy,omitempty"`
}

// PolicyAssignmentPropertiesPolicy details of the policy
type PolicyAssignmentPropertiesPolicy struct {
	// ID - Id of the policy
	ID             *string    `json:"id,omitempty"`
	LastModifiedBy *Principal `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime - The last modified date time.
	LastModifiedDateTime *date.Time `json:"lastModifiedDateTime,omitempty"`
}

// PolicyAssignmentPropertiesRoleDefinition details of role definition
type PolicyAssignmentPropertiesRoleDefinition struct {
	// ID - Id of the role definition
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the role definition
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Type of the role definition
	Type *string `json:"type,omitempty"`
}

// PolicyAssignmentPropertiesScope details of the resource scope
type PolicyAssignmentPropertiesScope struct {
	// ID - Scope id of the resource
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the resource
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Type of the resource
	Type *string `json:"type,omitempty"`
}

// PolicyProperties ...
type PolicyProperties struct {
	// Scope - READ-ONLY; Details of the resource scope
	Scope *PolicyPropertiesScope `json:"scope,omitempty"`
}

// MarshalJSON is the custom marshaler for PolicyProperties.
func (pp PolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PolicyPropertiesScope details of the resource scope
type PolicyPropertiesScope struct {
	// ID - Scope id of the resource
	ID *string `json:"id,omitempty"`
	// DisplayName - Display name of the resource
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Type of the resource
	Type *string `json:"type,omitempty"`
}

// Principal the name of the entity last modified it
type Principal struct {
	// ID - The id of the principal made changes
	ID *string `json:"id,omitempty"`
	// DisplayName - The name of the principal made changes
	DisplayName *string `json:"displayName,omitempty"`
	// Type - Type of principal such as user , group etc
	Type *string `json:"type,omitempty"`
	// Email - Email of principal
	Email *string `json:"email,omitempty"`
}

// ProviderOperation operation
type ProviderOperation struct {
	// Name - The operation name.
	Name *string `json:"name,omitempty"`
	// DisplayName - The operation display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Description - The operation description.
	Description *string `json:"description,omitempty"`
	// Origin - The operation origin.
	Origin *string `json:"origin,omitempty"`
	// Properties - The operation properties.
	Properties interface{} `json:"properties,omitempty"`
	// IsDataAction - The dataAction flag to specify the operation type.
	IsDataAction *bool `json:"isDataAction,omitempty"`
}

// ProviderOperationsMetadata provider Operations metadata
type ProviderOperationsMetadata struct {
	autorest.Response `json:"-"`
	// ID - The provider id.
	ID *string `json:"id,omitempty"`
	// Name - The provider name.
	Name *string `json:"name,omitempty"`
	// Type - The provider type.
	Type *string `json:"type,omitempty"`
	// DisplayName - The provider display name.
	DisplayName *string `json:"displayName,omitempty"`
	// ResourceTypes - The provider resource types
	ResourceTypes *[]ResourceType `json:"resourceTypes,omitempty"`
	// Operations - The provider operations.
	Operations *[]ProviderOperation `json:"operations,omitempty"`
}

// ProviderOperationsMetadataListResult provider operations metadata list
type ProviderOperationsMetadataListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of providers.
	Value *[]ProviderOperationsMetadata `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// ProviderOperationsMetadataListResultIterator provides access to a complete listing of
// ProviderOperationsMetadata values.
type ProviderOperationsMetadataListResultIterator struct {
	i    int
	page ProviderOperationsMetadataListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProviderOperationsMetadataListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderOperationsMetadataListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProviderOperationsMetadataListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProviderOperationsMetadataListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProviderOperationsMetadataListResultIterator) Response() ProviderOperationsMetadataListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProviderOperationsMetadataListResultIterator) Value() ProviderOperationsMetadata {
	if !iter.page.NotDone() {
		return ProviderOperationsMetadata{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProviderOperationsMetadataListResultIterator type.
func NewProviderOperationsMetadataListResultIterator(page ProviderOperationsMetadataListResultPage) ProviderOperationsMetadataListResultIterator {
	return ProviderOperationsMetadataListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pomlr ProviderOperationsMetadataListResult) IsEmpty() bool {
	return pomlr.Value == nil || len(*pomlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pomlr ProviderOperationsMetadataListResult) hasNextLink() bool {
	return pomlr.NextLink != nil && len(*pomlr.NextLink) != 0
}

// providerOperationsMetadataListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pomlr ProviderOperationsMetadataListResult) providerOperationsMetadataListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pomlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pomlr.NextLink)))
}

// ProviderOperationsMetadataListResultPage contains a page of ProviderOperationsMetadata values.
type ProviderOperationsMetadataListResultPage struct {
	fn    func(context.Context, ProviderOperationsMetadataListResult) (ProviderOperationsMetadataListResult, error)
	pomlr ProviderOperationsMetadataListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProviderOperationsMetadataListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderOperationsMetadataListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pomlr)
		if err != nil {
			return err
		}
		page.pomlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProviderOperationsMetadataListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProviderOperationsMetadataListResultPage) NotDone() bool {
	return !page.pomlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProviderOperationsMetadataListResultPage) Response() ProviderOperationsMetadataListResult {
	return page.pomlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProviderOperationsMetadataListResultPage) Values() []ProviderOperationsMetadata {
	if page.pomlr.IsEmpty() {
		return nil
	}
	return *page.pomlr.Value
}

// Creates a new instance of the ProviderOperationsMetadataListResultPage type.
func NewProviderOperationsMetadataListResultPage(cur ProviderOperationsMetadataListResult, getNextPage func(context.Context, ProviderOperationsMetadataListResult) (ProviderOperationsMetadataListResult, error)) ProviderOperationsMetadataListResultPage {
	return ProviderOperationsMetadataListResultPage{
		fn:    getNextPage,
		pomlr: cur,
	}
}

// ResourceType resource Type
type ResourceType struct {
	// Name - The resource type name.
	Name *string `json:"name,omitempty"`
	// DisplayName - The resource type display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Operations - The resource type operations.
	Operations *[]ProviderOperation `json:"operations,omitempty"`
}

// RoleAssignment role Assignments
type RoleAssignment struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role assignment ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role assignment name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role assignment type.
	Type *string `json:"type,omitempty"`
	// RoleAssignmentProperties - Role assignment properties.
	*RoleAssignmentProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignment.
func (ra RoleAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ra.RoleAssignmentProperties != nil {
		objectMap["properties"] = ra.RoleAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignment struct.
func (ra *RoleAssignment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ra.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ra.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ra.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleAssignmentProperties RoleAssignmentProperties
				err = json.Unmarshal(*v, &roleAssignmentProperties)
				if err != nil {
					return err
				}
				ra.RoleAssignmentProperties = &roleAssignmentProperties
			}
		}
	}

	return nil
}

// RoleAssignmentCreateParameters role assignment create parameters.
type RoleAssignmentCreateParameters struct {
	// RoleAssignmentProperties - Role assignment properties.
	*RoleAssignmentProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentCreateParameters.
func (racp RoleAssignmentCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if racp.RoleAssignmentProperties != nil {
		objectMap["properties"] = racp.RoleAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignmentCreateParameters struct.
func (racp *RoleAssignmentCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var roleAssignmentProperties RoleAssignmentProperties
				err = json.Unmarshal(*v, &roleAssignmentProperties)
				if err != nil {
					return err
				}
				racp.RoleAssignmentProperties = &roleAssignmentProperties
			}
		}
	}

	return nil
}

// RoleAssignmentFilter role Assignments filter
type RoleAssignmentFilter struct {
	// PrincipalID - Returns role assignment of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
}

// RoleAssignmentListResult role assignment list operation result.
type RoleAssignmentListResult struct {
	autorest.Response `json:"-"`
	// Value - Role assignment list.
	Value *[]RoleAssignment `json:"value,omitempty"`
	// NextLink - READ-ONLY; The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentListResult.
func (ralr RoleAssignmentListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ralr.Value != nil {
		objectMap["value"] = ralr.Value
	}
	return json.Marshal(objectMap)
}

// RoleAssignmentListResultIterator provides access to a complete listing of RoleAssignment values.
type RoleAssignmentListResultIterator struct {
	i    int
	page RoleAssignmentListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleAssignmentListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleAssignmentListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleAssignmentListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleAssignmentListResultIterator) Response() RoleAssignmentListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleAssignmentListResultIterator) Value() RoleAssignment {
	if !iter.page.NotDone() {
		return RoleAssignment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleAssignmentListResultIterator type.
func NewRoleAssignmentListResultIterator(page RoleAssignmentListResultPage) RoleAssignmentListResultIterator {
	return RoleAssignmentListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ralr RoleAssignmentListResult) IsEmpty() bool {
	return ralr.Value == nil || len(*ralr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ralr RoleAssignmentListResult) hasNextLink() bool {
	return ralr.NextLink != nil && len(*ralr.NextLink) != 0
}

// roleAssignmentListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ralr RoleAssignmentListResult) roleAssignmentListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ralr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ralr.NextLink)))
}

// RoleAssignmentListResultPage contains a page of RoleAssignment values.
type RoleAssignmentListResultPage struct {
	fn   func(context.Context, RoleAssignmentListResult) (RoleAssignmentListResult, error)
	ralr RoleAssignmentListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleAssignmentListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ralr)
		if err != nil {
			return err
		}
		page.ralr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleAssignmentListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleAssignmentListResultPage) NotDone() bool {
	return !page.ralr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleAssignmentListResultPage) Response() RoleAssignmentListResult {
	return page.ralr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleAssignmentListResultPage) Values() []RoleAssignment {
	if page.ralr.IsEmpty() {
		return nil
	}
	return *page.ralr.Value
}

// Creates a new instance of the RoleAssignmentListResultPage type.
func NewRoleAssignmentListResultPage(cur RoleAssignmentListResult, getNextPage func(context.Context, RoleAssignmentListResult) (RoleAssignmentListResult, error)) RoleAssignmentListResultPage {
	return RoleAssignmentListResultPage{
		fn:   getNextPage,
		ralr: cur,
	}
}

// RoleAssignmentMetricsResult role Assignment Metrics
type RoleAssignmentMetricsResult struct {
	autorest.Response `json:"-"`
	// SubscriptionID - READ-ONLY; The subscription ID.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// RoleAssignmentsLimit - READ-ONLY; The role assignment limit.
	RoleAssignmentsLimit *int64 `json:"roleAssignmentsLimit,omitempty"`
	// RoleAssignmentsCurrentCount - READ-ONLY; The number of current role assignments.
	RoleAssignmentsCurrentCount *int64 `json:"roleAssignmentsCurrentCount,omitempty"`
	// RoleAssignmentsRemainingCount - READ-ONLY; The number of remaining role assignments available.
	RoleAssignmentsRemainingCount *int64 `json:"roleAssignmentsRemainingCount,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentMetricsResult.
func (ramr RoleAssignmentMetricsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RoleAssignmentProperties role assignment properties.
type RoleAssignmentProperties struct {
	// Scope - READ-ONLY; The role assignment scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// Description - Description of role assignment
	Description *string `json:"description,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - READ-ONLY; Time it was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// UpdatedOn - READ-ONLY; Time it was updated
	UpdatedOn *date.Time `json:"updatedOn,omitempty"`
	// CreatedBy - READ-ONLY; Id of the user who created the assignment
	CreatedBy *string `json:"createdBy,omitempty"`
	// UpdatedBy - READ-ONLY; Id of the user who updated the assignment
	UpdatedBy *string `json:"updatedBy,omitempty"`
	// DelegatedManagedIdentityResourceID - Id of the delegated managed identity resource
	DelegatedManagedIdentityResourceID *string `json:"delegatedManagedIdentityResourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentProperties.
func (rap RoleAssignmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rap.RoleDefinitionID != nil {
		objectMap["roleDefinitionId"] = rap.RoleDefinitionID
	}
	if rap.PrincipalID != nil {
		objectMap["principalId"] = rap.PrincipalID
	}
	if rap.PrincipalType != "" {
		objectMap["principalType"] = rap.PrincipalType
	}
	if rap.Description != nil {
		objectMap["description"] = rap.Description
	}
	if rap.Condition != nil {
		objectMap["condition"] = rap.Condition
	}
	if rap.ConditionVersion != nil {
		objectMap["conditionVersion"] = rap.ConditionVersion
	}
	if rap.DelegatedManagedIdentityResourceID != nil {
		objectMap["delegatedManagedIdentityResourceId"] = rap.DelegatedManagedIdentityResourceID
	}
	return json.Marshal(objectMap)
}

// RoleAssignmentSchedule role Assignment schedule
type RoleAssignmentSchedule struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role assignment schedule Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role assignment schedule name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role assignment schedule type.
	Type *string `json:"type,omitempty"`
	// RoleAssignmentScheduleProperties - Role assignment schedule properties.
	*RoleAssignmentScheduleProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentSchedule.
func (ras RoleAssignmentSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ras.RoleAssignmentScheduleProperties != nil {
		objectMap["properties"] = ras.RoleAssignmentScheduleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignmentSchedule struct.
func (ras *RoleAssignmentSchedule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ras.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ras.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ras.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleAssignmentScheduleProperties RoleAssignmentScheduleProperties
				err = json.Unmarshal(*v, &roleAssignmentScheduleProperties)
				if err != nil {
					return err
				}
				ras.RoleAssignmentScheduleProperties = &roleAssignmentScheduleProperties
			}
		}
	}

	return nil
}

// RoleAssignmentScheduleFilter role assignment schedule filter
type RoleAssignmentScheduleFilter struct {
	// PrincipalID - Returns role assignment schedule of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// RoleDefinitionID - Returns role assignment schedule of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// Status - Returns role assignment schedule instances of the specific status.
	Status *string `json:"status,omitempty"`
}

// RoleAssignmentScheduleInstance information about current or upcoming role assignment schedule instance
type RoleAssignmentScheduleInstance struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role assignment schedule instance ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role assignment schedule instance name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role assignment schedule instance type.
	Type *string `json:"type,omitempty"`
	// RoleAssignmentScheduleInstanceProperties - Role assignment schedule instance properties.
	*RoleAssignmentScheduleInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentScheduleInstance.
func (rasi RoleAssignmentScheduleInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rasi.RoleAssignmentScheduleInstanceProperties != nil {
		objectMap["properties"] = rasi.RoleAssignmentScheduleInstanceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignmentScheduleInstance struct.
func (rasi *RoleAssignmentScheduleInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rasi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rasi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rasi.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleAssignmentScheduleInstanceProperties RoleAssignmentScheduleInstanceProperties
				err = json.Unmarshal(*v, &roleAssignmentScheduleInstanceProperties)
				if err != nil {
					return err
				}
				rasi.RoleAssignmentScheduleInstanceProperties = &roleAssignmentScheduleInstanceProperties
			}
		}
	}

	return nil
}

// RoleAssignmentScheduleInstanceFilter role assignment schedule instance filter
type RoleAssignmentScheduleInstanceFilter struct {
	// PrincipalID - Returns role assignment schedule instances of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// RoleDefinitionID - Returns role assignment schedule instances of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// Status - Returns role assignment schedule instances of the specific status.
	Status *string `json:"status,omitempty"`
	// RoleAssignmentScheduleID - Returns role assignment schedule instances belonging to a specific role assignment schedule.
	RoleAssignmentScheduleID *string `json:"roleAssignmentScheduleId,omitempty"`
}

// RoleAssignmentScheduleInstanceListResult role assignment schedule instance list operation result.
type RoleAssignmentScheduleInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - Role assignment schedule instance list.
	Value *[]RoleAssignmentScheduleInstance `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleAssignmentScheduleInstanceListResultIterator provides access to a complete listing of
// RoleAssignmentScheduleInstance values.
type RoleAssignmentScheduleInstanceListResultIterator struct {
	i    int
	page RoleAssignmentScheduleInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleAssignmentScheduleInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentScheduleInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleAssignmentScheduleInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleAssignmentScheduleInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleAssignmentScheduleInstanceListResultIterator) Response() RoleAssignmentScheduleInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleAssignmentScheduleInstanceListResultIterator) Value() RoleAssignmentScheduleInstance {
	if !iter.page.NotDone() {
		return RoleAssignmentScheduleInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleAssignmentScheduleInstanceListResultIterator type.
func NewRoleAssignmentScheduleInstanceListResultIterator(page RoleAssignmentScheduleInstanceListResultPage) RoleAssignmentScheduleInstanceListResultIterator {
	return RoleAssignmentScheduleInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rasilr RoleAssignmentScheduleInstanceListResult) IsEmpty() bool {
	return rasilr.Value == nil || len(*rasilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rasilr RoleAssignmentScheduleInstanceListResult) hasNextLink() bool {
	return rasilr.NextLink != nil && len(*rasilr.NextLink) != 0
}

// roleAssignmentScheduleInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rasilr RoleAssignmentScheduleInstanceListResult) roleAssignmentScheduleInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rasilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rasilr.NextLink)))
}

// RoleAssignmentScheduleInstanceListResultPage contains a page of RoleAssignmentScheduleInstance values.
type RoleAssignmentScheduleInstanceListResultPage struct {
	fn     func(context.Context, RoleAssignmentScheduleInstanceListResult) (RoleAssignmentScheduleInstanceListResult, error)
	rasilr RoleAssignmentScheduleInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleAssignmentScheduleInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentScheduleInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rasilr)
		if err != nil {
			return err
		}
		page.rasilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleAssignmentScheduleInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleAssignmentScheduleInstanceListResultPage) NotDone() bool {
	return !page.rasilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleAssignmentScheduleInstanceListResultPage) Response() RoleAssignmentScheduleInstanceListResult {
	return page.rasilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleAssignmentScheduleInstanceListResultPage) Values() []RoleAssignmentScheduleInstance {
	if page.rasilr.IsEmpty() {
		return nil
	}
	return *page.rasilr.Value
}

// Creates a new instance of the RoleAssignmentScheduleInstanceListResultPage type.
func NewRoleAssignmentScheduleInstanceListResultPage(cur RoleAssignmentScheduleInstanceListResult, getNextPage func(context.Context, RoleAssignmentScheduleInstanceListResult) (RoleAssignmentScheduleInstanceListResult, error)) RoleAssignmentScheduleInstanceListResultPage {
	return RoleAssignmentScheduleInstanceListResultPage{
		fn:     getNextPage,
		rasilr: cur,
	}
}

// RoleAssignmentScheduleInstanceProperties role assignment schedule properties with scope.
type RoleAssignmentScheduleInstanceProperties struct {
	// Scope - The role assignment schedule scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// RoleAssignmentScheduleID - Id of the master role assignment schedule
	RoleAssignmentScheduleID *string `json:"roleAssignmentScheduleId,omitempty"`
	// OriginRoleAssignmentID - Role Assignment Id in external system
	OriginRoleAssignmentID *string `json:"originRoleAssignmentId,omitempty"`
	// Status - The status of the role assignment schedule instance. Possible values include: 'Accepted', 'PendingEvaluation', 'Granted', 'Denied', 'PendingProvisioning', 'Provisioned', 'PendingRevocation', 'Revoked', 'Canceled', 'Failed', 'PendingApprovalProvisioning', 'PendingApproval', 'FailedAsResourceIsLocked', 'PendingAdminDecision', 'AdminApproved', 'AdminDenied', 'TimedOut', 'ProvisioningStarted', 'Invalid', 'PendingScheduleCreation', 'ScheduleCreated', 'PendingExternalProvisioning'
	Status Status `json:"status,omitempty"`
	// StartDateTime - The startDateTime of the role assignment schedule instance
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// EndDateTime - The endDateTime of the role assignment schedule instance
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
	// LinkedRoleEligibilityScheduleID - roleEligibilityScheduleId used to activate
	LinkedRoleEligibilityScheduleID *string `json:"linkedRoleEligibilityScheduleId,omitempty"`
	// LinkedRoleEligibilityScheduleInstanceID - roleEligibilityScheduleInstanceId linked to this roleAssignmentScheduleInstance
	LinkedRoleEligibilityScheduleInstanceID *string `json:"linkedRoleEligibilityScheduleInstanceId,omitempty"`
	// AssignmentType - Assignment type of the role assignment schedule. Possible values include: 'AssignmentTypeActivated', 'AssignmentTypeAssigned'
	AssignmentType AssignmentType `json:"assignmentType,omitempty"`
	// MemberType - Membership type of the role assignment schedule. Possible values include: 'Inherited', 'Direct', 'Group'
	MemberType MemberType `json:"memberType,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - DateTime when role assignment schedule was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ExpandedProperties - Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`
}

// RoleAssignmentScheduleListResult role assignment schedule list operation result.
type RoleAssignmentScheduleListResult struct {
	autorest.Response `json:"-"`
	// Value - Role assignment schedule list.
	Value *[]RoleAssignmentSchedule `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleAssignmentScheduleListResultIterator provides access to a complete listing of RoleAssignmentSchedule
// values.
type RoleAssignmentScheduleListResultIterator struct {
	i    int
	page RoleAssignmentScheduleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleAssignmentScheduleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentScheduleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleAssignmentScheduleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleAssignmentScheduleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleAssignmentScheduleListResultIterator) Response() RoleAssignmentScheduleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleAssignmentScheduleListResultIterator) Value() RoleAssignmentSchedule {
	if !iter.page.NotDone() {
		return RoleAssignmentSchedule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleAssignmentScheduleListResultIterator type.
func NewRoleAssignmentScheduleListResultIterator(page RoleAssignmentScheduleListResultPage) RoleAssignmentScheduleListResultIterator {
	return RoleAssignmentScheduleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (raslr RoleAssignmentScheduleListResult) IsEmpty() bool {
	return raslr.Value == nil || len(*raslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (raslr RoleAssignmentScheduleListResult) hasNextLink() bool {
	return raslr.NextLink != nil && len(*raslr.NextLink) != 0
}

// roleAssignmentScheduleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (raslr RoleAssignmentScheduleListResult) roleAssignmentScheduleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !raslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(raslr.NextLink)))
}

// RoleAssignmentScheduleListResultPage contains a page of RoleAssignmentSchedule values.
type RoleAssignmentScheduleListResultPage struct {
	fn    func(context.Context, RoleAssignmentScheduleListResult) (RoleAssignmentScheduleListResult, error)
	raslr RoleAssignmentScheduleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleAssignmentScheduleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentScheduleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.raslr)
		if err != nil {
			return err
		}
		page.raslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleAssignmentScheduleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleAssignmentScheduleListResultPage) NotDone() bool {
	return !page.raslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleAssignmentScheduleListResultPage) Response() RoleAssignmentScheduleListResult {
	return page.raslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleAssignmentScheduleListResultPage) Values() []RoleAssignmentSchedule {
	if page.raslr.IsEmpty() {
		return nil
	}
	return *page.raslr.Value
}

// Creates a new instance of the RoleAssignmentScheduleListResultPage type.
func NewRoleAssignmentScheduleListResultPage(cur RoleAssignmentScheduleListResult, getNextPage func(context.Context, RoleAssignmentScheduleListResult) (RoleAssignmentScheduleListResult, error)) RoleAssignmentScheduleListResultPage {
	return RoleAssignmentScheduleListResultPage{
		fn:    getNextPage,
		raslr: cur,
	}
}

// RoleAssignmentScheduleProperties role assignment schedule properties with scope.
type RoleAssignmentScheduleProperties struct {
	// Scope - The role assignment schedule scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// RoleAssignmentScheduleRequestID - The id of roleAssignmentScheduleRequest used to create this roleAssignmentSchedule
	RoleAssignmentScheduleRequestID *string `json:"roleAssignmentScheduleRequestId,omitempty"`
	// LinkedRoleEligibilityScheduleID - The id of roleEligibilitySchedule used to activated this roleAssignmentSchedule
	LinkedRoleEligibilityScheduleID *string `json:"linkedRoleEligibilityScheduleId,omitempty"`
	// AssignmentType - Assignment type of the role assignment schedule. Possible values include: 'AssignmentTypeActivated', 'AssignmentTypeAssigned'
	AssignmentType AssignmentType `json:"assignmentType,omitempty"`
	// MemberType - Membership type of the role assignment schedule. Possible values include: 'Inherited', 'Direct', 'Group'
	MemberType MemberType `json:"memberType,omitempty"`
	// Status - The status of the role assignment schedule. Possible values include: 'Accepted', 'PendingEvaluation', 'Granted', 'Denied', 'PendingProvisioning', 'Provisioned', 'PendingRevocation', 'Revoked', 'Canceled', 'Failed', 'PendingApprovalProvisioning', 'PendingApproval', 'FailedAsResourceIsLocked', 'PendingAdminDecision', 'AdminApproved', 'AdminDenied', 'TimedOut', 'ProvisioningStarted', 'Invalid', 'PendingScheduleCreation', 'ScheduleCreated', 'PendingExternalProvisioning'
	Status Status `json:"status,omitempty"`
	// StartDateTime - Start DateTime when role assignment schedule
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// EndDateTime - End DateTime when role assignment schedule
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - DateTime when role assignment schedule was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// UpdatedOn - DateTime when role assignment schedule was modified
	UpdatedOn *date.Time `json:"updatedOn,omitempty"`
	// ExpandedProperties - Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`
}

// RoleAssignmentScheduleRequest role Assignment schedule request
type RoleAssignmentScheduleRequest struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role assignment schedule request ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role assignment schedule request name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role assignment schedule request type.
	Type *string `json:"type,omitempty"`
	// RoleAssignmentScheduleRequestProperties - Role assignment schedule request properties.
	*RoleAssignmentScheduleRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentScheduleRequest.
func (rasr RoleAssignmentScheduleRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rasr.RoleAssignmentScheduleRequestProperties != nil {
		objectMap["properties"] = rasr.RoleAssignmentScheduleRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleAssignmentScheduleRequest struct.
func (rasr *RoleAssignmentScheduleRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rasr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rasr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rasr.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleAssignmentScheduleRequestProperties RoleAssignmentScheduleRequestProperties
				err = json.Unmarshal(*v, &roleAssignmentScheduleRequestProperties)
				if err != nil {
					return err
				}
				rasr.RoleAssignmentScheduleRequestProperties = &roleAssignmentScheduleRequestProperties
			}
		}
	}

	return nil
}

// RoleAssignmentScheduleRequestFilter role assignment schedule request filter
type RoleAssignmentScheduleRequestFilter struct {
	// PrincipalID - Returns role assignment requests of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// RoleDefinitionID - Returns role assignment requests of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// RequestorID - Returns role assignment requests created by specific principal.
	RequestorID *string `json:"requestorId,omitempty"`
	// Status - Returns role assignment requests of specific status.
	Status *string `json:"status,omitempty"`
}

// RoleAssignmentScheduleRequestListResult role assignment schedule request list operation result.
type RoleAssignmentScheduleRequestListResult struct {
	autorest.Response `json:"-"`
	// Value - Role assignment schedule request list.
	Value *[]RoleAssignmentScheduleRequest `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleAssignmentScheduleRequestListResultIterator provides access to a complete listing of
// RoleAssignmentScheduleRequest values.
type RoleAssignmentScheduleRequestListResultIterator struct {
	i    int
	page RoleAssignmentScheduleRequestListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleAssignmentScheduleRequestListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentScheduleRequestListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleAssignmentScheduleRequestListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleAssignmentScheduleRequestListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleAssignmentScheduleRequestListResultIterator) Response() RoleAssignmentScheduleRequestListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleAssignmentScheduleRequestListResultIterator) Value() RoleAssignmentScheduleRequest {
	if !iter.page.NotDone() {
		return RoleAssignmentScheduleRequest{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleAssignmentScheduleRequestListResultIterator type.
func NewRoleAssignmentScheduleRequestListResultIterator(page RoleAssignmentScheduleRequestListResultPage) RoleAssignmentScheduleRequestListResultIterator {
	return RoleAssignmentScheduleRequestListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rasrlr RoleAssignmentScheduleRequestListResult) IsEmpty() bool {
	return rasrlr.Value == nil || len(*rasrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rasrlr RoleAssignmentScheduleRequestListResult) hasNextLink() bool {
	return rasrlr.NextLink != nil && len(*rasrlr.NextLink) != 0
}

// roleAssignmentScheduleRequestListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rasrlr RoleAssignmentScheduleRequestListResult) roleAssignmentScheduleRequestListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rasrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rasrlr.NextLink)))
}

// RoleAssignmentScheduleRequestListResultPage contains a page of RoleAssignmentScheduleRequest values.
type RoleAssignmentScheduleRequestListResultPage struct {
	fn     func(context.Context, RoleAssignmentScheduleRequestListResult) (RoleAssignmentScheduleRequestListResult, error)
	rasrlr RoleAssignmentScheduleRequestListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleAssignmentScheduleRequestListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleAssignmentScheduleRequestListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rasrlr)
		if err != nil {
			return err
		}
		page.rasrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleAssignmentScheduleRequestListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleAssignmentScheduleRequestListResultPage) NotDone() bool {
	return !page.rasrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleAssignmentScheduleRequestListResultPage) Response() RoleAssignmentScheduleRequestListResult {
	return page.rasrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleAssignmentScheduleRequestListResultPage) Values() []RoleAssignmentScheduleRequest {
	if page.rasrlr.IsEmpty() {
		return nil
	}
	return *page.rasrlr.Value
}

// Creates a new instance of the RoleAssignmentScheduleRequestListResultPage type.
func NewRoleAssignmentScheduleRequestListResultPage(cur RoleAssignmentScheduleRequestListResult, getNextPage func(context.Context, RoleAssignmentScheduleRequestListResult) (RoleAssignmentScheduleRequestListResult, error)) RoleAssignmentScheduleRequestListResultPage {
	return RoleAssignmentScheduleRequestListResultPage{
		fn:     getNextPage,
		rasrlr: cur,
	}
}

// RoleAssignmentScheduleRequestProperties role assignment schedule request properties with scope.
type RoleAssignmentScheduleRequestProperties struct {
	// Scope - READ-ONLY; The role assignment schedule request scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - READ-ONLY; The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// RequestType - The type of the role assignment schedule request. Eg: SelfActivate, AdminAssign etc. Possible values include: 'AdminAssign', 'AdminRemove', 'AdminUpdate', 'AdminExtend', 'AdminRenew', 'SelfActivate', 'SelfDeactivate', 'SelfExtend', 'SelfRenew'
	RequestType RequestType `json:"requestType,omitempty"`
	// Status - READ-ONLY; The status of the role assignment schedule request. Possible values include: 'Accepted', 'PendingEvaluation', 'Granted', 'Denied', 'PendingProvisioning', 'Provisioned', 'PendingRevocation', 'Revoked', 'Canceled', 'Failed', 'PendingApprovalProvisioning', 'PendingApproval', 'FailedAsResourceIsLocked', 'PendingAdminDecision', 'AdminApproved', 'AdminDenied', 'TimedOut', 'ProvisioningStarted', 'Invalid', 'PendingScheduleCreation', 'ScheduleCreated', 'PendingExternalProvisioning'
	Status Status `json:"status,omitempty"`
	// ApprovalID - READ-ONLY; The approvalId of the role assignment schedule request.
	ApprovalID *string `json:"approvalId,omitempty"`
	// TargetRoleAssignmentScheduleID - The resultant role assignment schedule id or the role assignment schedule id being updated
	TargetRoleAssignmentScheduleID *string `json:"targetRoleAssignmentScheduleId,omitempty"`
	// TargetRoleAssignmentScheduleInstanceID - The role assignment schedule instance id being updated
	TargetRoleAssignmentScheduleInstanceID *string `json:"targetRoleAssignmentScheduleInstanceId,omitempty"`
	// ScheduleInfo - Schedule info of the role assignment schedule
	ScheduleInfo *RoleAssignmentScheduleRequestPropertiesScheduleInfo `json:"scheduleInfo,omitempty"`
	// LinkedRoleEligibilityScheduleID - The linked role eligibility schedule id - to activate an eligibility.
	LinkedRoleEligibilityScheduleID *string `json:"linkedRoleEligibilityScheduleId,omitempty"`
	// Justification - Justification for the role assignment
	Justification *string `json:"justification,omitempty"`
	// TicketInfo - Ticket Info of the role assignment
	TicketInfo *RoleAssignmentScheduleRequestPropertiesTicketInfo `json:"ticketInfo,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - READ-ONLY; DateTime when role assignment schedule request was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// RequestorID - READ-ONLY; Id of the user who created this request
	RequestorID *string `json:"requestorId,omitempty"`
	// ExpandedProperties - READ-ONLY; Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleAssignmentScheduleRequestProperties.
func (rasrp RoleAssignmentScheduleRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rasrp.RoleDefinitionID != nil {
		objectMap["roleDefinitionId"] = rasrp.RoleDefinitionID
	}
	if rasrp.PrincipalID != nil {
		objectMap["principalId"] = rasrp.PrincipalID
	}
	if rasrp.RequestType != "" {
		objectMap["requestType"] = rasrp.RequestType
	}
	if rasrp.TargetRoleAssignmentScheduleID != nil {
		objectMap["targetRoleAssignmentScheduleId"] = rasrp.TargetRoleAssignmentScheduleID
	}
	if rasrp.TargetRoleAssignmentScheduleInstanceID != nil {
		objectMap["targetRoleAssignmentScheduleInstanceId"] = rasrp.TargetRoleAssignmentScheduleInstanceID
	}
	if rasrp.ScheduleInfo != nil {
		objectMap["scheduleInfo"] = rasrp.ScheduleInfo
	}
	if rasrp.LinkedRoleEligibilityScheduleID != nil {
		objectMap["linkedRoleEligibilityScheduleId"] = rasrp.LinkedRoleEligibilityScheduleID
	}
	if rasrp.Justification != nil {
		objectMap["justification"] = rasrp.Justification
	}
	if rasrp.TicketInfo != nil {
		objectMap["ticketInfo"] = rasrp.TicketInfo
	}
	if rasrp.Condition != nil {
		objectMap["condition"] = rasrp.Condition
	}
	if rasrp.ConditionVersion != nil {
		objectMap["conditionVersion"] = rasrp.ConditionVersion
	}
	return json.Marshal(objectMap)
}

// RoleAssignmentScheduleRequestPropertiesScheduleInfo schedule info of the role assignment schedule
type RoleAssignmentScheduleRequestPropertiesScheduleInfo struct {
	// StartDateTime - Start DateTime of the role assignment schedule.
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// Expiration - Expiration of the role assignment schedule
	Expiration *RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration `json:"expiration,omitempty"`
}

// RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration expiration of the role assignment schedule
type RoleAssignmentScheduleRequestPropertiesScheduleInfoExpiration struct {
	// Type - Type of the role assignment schedule expiration. Possible values include: 'AfterDuration', 'AfterDateTime', 'NoExpiration'
	Type Type `json:"type,omitempty"`
	// EndDateTime - End DateTime of the role assignment schedule.
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
	// Duration - Duration of the role assignment schedule in TimeSpan.
	Duration *string `json:"duration,omitempty"`
}

// RoleAssignmentScheduleRequestPropertiesTicketInfo ticket Info of the role assignment
type RoleAssignmentScheduleRequestPropertiesTicketInfo struct {
	// TicketNumber - Ticket number for the role assignment
	TicketNumber *string `json:"ticketNumber,omitempty"`
	// TicketSystem - Ticket system name for the role assignment
	TicketSystem *string `json:"ticketSystem,omitempty"`
}

// RoleDefinition role definition.
type RoleDefinition struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role definition ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role definition name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role definition type.
	Type *string `json:"type,omitempty"`
	// RoleDefinitionProperties - Role definition properties.
	*RoleDefinitionProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleDefinition.
func (rd RoleDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rd.RoleDefinitionProperties != nil {
		objectMap["properties"] = rd.RoleDefinitionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleDefinition struct.
func (rd *RoleDefinition) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rd.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rd.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleDefinitionProperties RoleDefinitionProperties
				err = json.Unmarshal(*v, &roleDefinitionProperties)
				if err != nil {
					return err
				}
				rd.RoleDefinitionProperties = &roleDefinitionProperties
			}
		}
	}

	return nil
}

// RoleDefinitionFilter role Definitions filter
type RoleDefinitionFilter struct {
	// RoleName - Returns role definition with the specific name.
	RoleName *string `json:"roleName,omitempty"`
	// Type - Returns role definition with the specific type.
	Type *string `json:"type,omitempty"`
}

// RoleDefinitionListResult role definition list operation result.
type RoleDefinitionListResult struct {
	autorest.Response `json:"-"`
	// Value - Role definition list.
	Value *[]RoleDefinition `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleDefinitionListResultIterator provides access to a complete listing of RoleDefinition values.
type RoleDefinitionListResultIterator struct {
	i    int
	page RoleDefinitionListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleDefinitionListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleDefinitionListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleDefinitionListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleDefinitionListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleDefinitionListResultIterator) Response() RoleDefinitionListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleDefinitionListResultIterator) Value() RoleDefinition {
	if !iter.page.NotDone() {
		return RoleDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleDefinitionListResultIterator type.
func NewRoleDefinitionListResultIterator(page RoleDefinitionListResultPage) RoleDefinitionListResultIterator {
	return RoleDefinitionListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rdlr RoleDefinitionListResult) IsEmpty() bool {
	return rdlr.Value == nil || len(*rdlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rdlr RoleDefinitionListResult) hasNextLink() bool {
	return rdlr.NextLink != nil && len(*rdlr.NextLink) != 0
}

// roleDefinitionListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rdlr RoleDefinitionListResult) roleDefinitionListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rdlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rdlr.NextLink)))
}

// RoleDefinitionListResultPage contains a page of RoleDefinition values.
type RoleDefinitionListResultPage struct {
	fn   func(context.Context, RoleDefinitionListResult) (RoleDefinitionListResult, error)
	rdlr RoleDefinitionListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleDefinitionListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleDefinitionListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rdlr)
		if err != nil {
			return err
		}
		page.rdlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleDefinitionListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleDefinitionListResultPage) NotDone() bool {
	return !page.rdlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleDefinitionListResultPage) Response() RoleDefinitionListResult {
	return page.rdlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleDefinitionListResultPage) Values() []RoleDefinition {
	if page.rdlr.IsEmpty() {
		return nil
	}
	return *page.rdlr.Value
}

// Creates a new instance of the RoleDefinitionListResultPage type.
func NewRoleDefinitionListResultPage(cur RoleDefinitionListResult, getNextPage func(context.Context, RoleDefinitionListResult) (RoleDefinitionListResult, error)) RoleDefinitionListResultPage {
	return RoleDefinitionListResultPage{
		fn:   getNextPage,
		rdlr: cur,
	}
}

// RoleDefinitionProperties role definition properties.
type RoleDefinitionProperties struct {
	// RoleName - The role name.
	RoleName *string `json:"roleName,omitempty"`
	// Description - The role definition description.
	Description *string `json:"description,omitempty"`
	// RoleType - The role type.
	RoleType *string `json:"type,omitempty"`
	// Permissions - Role definition permissions.
	Permissions *[]Permission `json:"permissions,omitempty"`
	// AssignableScopes - Role definition assignable scopes.
	AssignableScopes *[]string `json:"assignableScopes,omitempty"`
}

// RoleEligibilitySchedule role eligibility schedule
type RoleEligibilitySchedule struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role eligibility schedule Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role eligibility schedule name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role eligibility schedule type.
	Type *string `json:"type,omitempty"`
	// RoleEligibilityScheduleProperties - role eligibility schedule properties.
	*RoleEligibilityScheduleProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleEligibilitySchedule.
func (res RoleEligibilitySchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if res.RoleEligibilityScheduleProperties != nil {
		objectMap["properties"] = res.RoleEligibilityScheduleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleEligibilitySchedule struct.
func (res *RoleEligibilitySchedule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				res.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				res.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				res.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleEligibilityScheduleProperties RoleEligibilityScheduleProperties
				err = json.Unmarshal(*v, &roleEligibilityScheduleProperties)
				if err != nil {
					return err
				}
				res.RoleEligibilityScheduleProperties = &roleEligibilityScheduleProperties
			}
		}
	}

	return nil
}

// RoleEligibilityScheduleFilter role eligibility schedule filter
type RoleEligibilityScheduleFilter struct {
	// PrincipalID - Returns role eligibility schedule of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// RoleDefinitionID - Returns role eligibility schedule of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// Status - Returns role eligibility schedule of the specific status.
	Status *string `json:"status,omitempty"`
}

// RoleEligibilityScheduleInstance information about current or upcoming role eligibility schedule instance
type RoleEligibilityScheduleInstance struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role eligibility schedule instance ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role eligibility schedule instance name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role eligibility schedule instance type.
	Type *string `json:"type,omitempty"`
	// RoleEligibilityScheduleInstanceProperties - Role eligibility schedule instance properties.
	*RoleEligibilityScheduleInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleEligibilityScheduleInstance.
func (resi RoleEligibilityScheduleInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if resi.RoleEligibilityScheduleInstanceProperties != nil {
		objectMap["properties"] = resi.RoleEligibilityScheduleInstanceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleEligibilityScheduleInstance struct.
func (resi *RoleEligibilityScheduleInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				resi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				resi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				resi.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleEligibilityScheduleInstanceProperties RoleEligibilityScheduleInstanceProperties
				err = json.Unmarshal(*v, &roleEligibilityScheduleInstanceProperties)
				if err != nil {
					return err
				}
				resi.RoleEligibilityScheduleInstanceProperties = &roleEligibilityScheduleInstanceProperties
			}
		}
	}

	return nil
}

// RoleEligibilityScheduleInstanceFilter role eligibility schedule instance filter
type RoleEligibilityScheduleInstanceFilter struct {
	// PrincipalID - Returns role eligibility schedule instances of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// RoleDefinitionID - Returns role eligibility schedule instances of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// Status - Returns role eligibility schedule instances of the specific status.
	Status *string `json:"status,omitempty"`
	// RoleEligibilityScheduleID - Returns role eligibility schedule instances belonging to a specific role eligibility schedule.
	RoleEligibilityScheduleID *string `json:"roleEligibilityScheduleId,omitempty"`
}

// RoleEligibilityScheduleInstanceListResult role eligibility schedule instance list operation result.
type RoleEligibilityScheduleInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - Role eligibility schedule instance list.
	Value *[]RoleEligibilityScheduleInstance `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleEligibilityScheduleInstanceListResultIterator provides access to a complete listing of
// RoleEligibilityScheduleInstance values.
type RoleEligibilityScheduleInstanceListResultIterator struct {
	i    int
	page RoleEligibilityScheduleInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleEligibilityScheduleInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleEligibilityScheduleInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleEligibilityScheduleInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleEligibilityScheduleInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleEligibilityScheduleInstanceListResultIterator) Response() RoleEligibilityScheduleInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleEligibilityScheduleInstanceListResultIterator) Value() RoleEligibilityScheduleInstance {
	if !iter.page.NotDone() {
		return RoleEligibilityScheduleInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleEligibilityScheduleInstanceListResultIterator type.
func NewRoleEligibilityScheduleInstanceListResultIterator(page RoleEligibilityScheduleInstanceListResultPage) RoleEligibilityScheduleInstanceListResultIterator {
	return RoleEligibilityScheduleInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (resilr RoleEligibilityScheduleInstanceListResult) IsEmpty() bool {
	return resilr.Value == nil || len(*resilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (resilr RoleEligibilityScheduleInstanceListResult) hasNextLink() bool {
	return resilr.NextLink != nil && len(*resilr.NextLink) != 0
}

// roleEligibilityScheduleInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (resilr RoleEligibilityScheduleInstanceListResult) roleEligibilityScheduleInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !resilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(resilr.NextLink)))
}

// RoleEligibilityScheduleInstanceListResultPage contains a page of RoleEligibilityScheduleInstance values.
type RoleEligibilityScheduleInstanceListResultPage struct {
	fn     func(context.Context, RoleEligibilityScheduleInstanceListResult) (RoleEligibilityScheduleInstanceListResult, error)
	resilr RoleEligibilityScheduleInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleEligibilityScheduleInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleEligibilityScheduleInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.resilr)
		if err != nil {
			return err
		}
		page.resilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleEligibilityScheduleInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleEligibilityScheduleInstanceListResultPage) NotDone() bool {
	return !page.resilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleEligibilityScheduleInstanceListResultPage) Response() RoleEligibilityScheduleInstanceListResult {
	return page.resilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleEligibilityScheduleInstanceListResultPage) Values() []RoleEligibilityScheduleInstance {
	if page.resilr.IsEmpty() {
		return nil
	}
	return *page.resilr.Value
}

// Creates a new instance of the RoleEligibilityScheduleInstanceListResultPage type.
func NewRoleEligibilityScheduleInstanceListResultPage(cur RoleEligibilityScheduleInstanceListResult, getNextPage func(context.Context, RoleEligibilityScheduleInstanceListResult) (RoleEligibilityScheduleInstanceListResult, error)) RoleEligibilityScheduleInstanceListResultPage {
	return RoleEligibilityScheduleInstanceListResultPage{
		fn:     getNextPage,
		resilr: cur,
	}
}

// RoleEligibilityScheduleInstanceProperties role eligibility schedule properties with scope.
type RoleEligibilityScheduleInstanceProperties struct {
	// Scope - The role eligibility schedule scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// RoleEligibilityScheduleID - Id of the master role eligibility schedule
	RoleEligibilityScheduleID *string `json:"roleEligibilityScheduleId,omitempty"`
	// Status - The status of the role eligibility schedule instance. Possible values include: 'Accepted', 'PendingEvaluation', 'Granted', 'Denied', 'PendingProvisioning', 'Provisioned', 'PendingRevocation', 'Revoked', 'Canceled', 'Failed', 'PendingApprovalProvisioning', 'PendingApproval', 'FailedAsResourceIsLocked', 'PendingAdminDecision', 'AdminApproved', 'AdminDenied', 'TimedOut', 'ProvisioningStarted', 'Invalid', 'PendingScheduleCreation', 'ScheduleCreated', 'PendingExternalProvisioning'
	Status Status `json:"status,omitempty"`
	// StartDateTime - The startDateTime of the role eligibility schedule instance
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// EndDateTime - The endDateTime of the role eligibility schedule instance
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
	// MemberType - Membership type of the role eligibility schedule. Possible values include: 'Inherited', 'Direct', 'Group'
	MemberType MemberType `json:"memberType,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - DateTime when role eligibility schedule was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// ExpandedProperties - Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`
}

// RoleEligibilityScheduleListResult role eligibility schedule list operation result.
type RoleEligibilityScheduleListResult struct {
	autorest.Response `json:"-"`
	// Value - role eligibility schedule list.
	Value *[]RoleEligibilitySchedule `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleEligibilityScheduleListResultIterator provides access to a complete listing of
// RoleEligibilitySchedule values.
type RoleEligibilityScheduleListResultIterator struct {
	i    int
	page RoleEligibilityScheduleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleEligibilityScheduleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleEligibilityScheduleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleEligibilityScheduleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleEligibilityScheduleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleEligibilityScheduleListResultIterator) Response() RoleEligibilityScheduleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleEligibilityScheduleListResultIterator) Value() RoleEligibilitySchedule {
	if !iter.page.NotDone() {
		return RoleEligibilitySchedule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleEligibilityScheduleListResultIterator type.
func NewRoleEligibilityScheduleListResultIterator(page RoleEligibilityScheduleListResultPage) RoleEligibilityScheduleListResultIterator {
	return RoleEligibilityScheduleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (reslr RoleEligibilityScheduleListResult) IsEmpty() bool {
	return reslr.Value == nil || len(*reslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (reslr RoleEligibilityScheduleListResult) hasNextLink() bool {
	return reslr.NextLink != nil && len(*reslr.NextLink) != 0
}

// roleEligibilityScheduleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (reslr RoleEligibilityScheduleListResult) roleEligibilityScheduleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !reslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(reslr.NextLink)))
}

// RoleEligibilityScheduleListResultPage contains a page of RoleEligibilitySchedule values.
type RoleEligibilityScheduleListResultPage struct {
	fn    func(context.Context, RoleEligibilityScheduleListResult) (RoleEligibilityScheduleListResult, error)
	reslr RoleEligibilityScheduleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleEligibilityScheduleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleEligibilityScheduleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.reslr)
		if err != nil {
			return err
		}
		page.reslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleEligibilityScheduleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleEligibilityScheduleListResultPage) NotDone() bool {
	return !page.reslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleEligibilityScheduleListResultPage) Response() RoleEligibilityScheduleListResult {
	return page.reslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleEligibilityScheduleListResultPage) Values() []RoleEligibilitySchedule {
	if page.reslr.IsEmpty() {
		return nil
	}
	return *page.reslr.Value
}

// Creates a new instance of the RoleEligibilityScheduleListResultPage type.
func NewRoleEligibilityScheduleListResultPage(cur RoleEligibilityScheduleListResult, getNextPage func(context.Context, RoleEligibilityScheduleListResult) (RoleEligibilityScheduleListResult, error)) RoleEligibilityScheduleListResultPage {
	return RoleEligibilityScheduleListResultPage{
		fn:    getNextPage,
		reslr: cur,
	}
}

// RoleEligibilityScheduleProperties role eligibility schedule properties with scope.
type RoleEligibilityScheduleProperties struct {
	// Scope - The role eligibility schedule scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// RoleEligibilityScheduleRequestID - The id of roleEligibilityScheduleRequest used to create this roleAssignmentSchedule
	RoleEligibilityScheduleRequestID *string `json:"roleEligibilityScheduleRequestId,omitempty"`
	// MemberType - Membership type of the role eligibility schedule. Possible values include: 'Inherited', 'Direct', 'Group'
	MemberType MemberType `json:"memberType,omitempty"`
	// Status - The status of the role eligibility schedule. Possible values include: 'Accepted', 'PendingEvaluation', 'Granted', 'Denied', 'PendingProvisioning', 'Provisioned', 'PendingRevocation', 'Revoked', 'Canceled', 'Failed', 'PendingApprovalProvisioning', 'PendingApproval', 'FailedAsResourceIsLocked', 'PendingAdminDecision', 'AdminApproved', 'AdminDenied', 'TimedOut', 'ProvisioningStarted', 'Invalid', 'PendingScheduleCreation', 'ScheduleCreated', 'PendingExternalProvisioning'
	Status Status `json:"status,omitempty"`
	// StartDateTime - Start DateTime when role eligibility schedule
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// EndDateTime - End DateTime when role eligibility schedule
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - DateTime when role eligibility schedule was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// UpdatedOn - DateTime when role eligibility schedule was modified
	UpdatedOn *date.Time `json:"updatedOn,omitempty"`
	// ExpandedProperties - Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`
}

// RoleEligibilityScheduleRequest role Eligibility schedule request
type RoleEligibilityScheduleRequest struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role eligibility schedule request ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role eligibility schedule request name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role eligibility schedule request type.
	Type *string `json:"type,omitempty"`
	// RoleEligibilityScheduleRequestProperties - Role eligibility schedule request properties.
	*RoleEligibilityScheduleRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleEligibilityScheduleRequest.
func (resr RoleEligibilityScheduleRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if resr.RoleEligibilityScheduleRequestProperties != nil {
		objectMap["properties"] = resr.RoleEligibilityScheduleRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleEligibilityScheduleRequest struct.
func (resr *RoleEligibilityScheduleRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				resr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				resr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				resr.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleEligibilityScheduleRequestProperties RoleEligibilityScheduleRequestProperties
				err = json.Unmarshal(*v, &roleEligibilityScheduleRequestProperties)
				if err != nil {
					return err
				}
				resr.RoleEligibilityScheduleRequestProperties = &roleEligibilityScheduleRequestProperties
			}
		}
	}

	return nil
}

// RoleEligibilityScheduleRequestFilter role eligibility schedule request filter
type RoleEligibilityScheduleRequestFilter struct {
	// PrincipalID - Returns role eligibility requests of the specific principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// RoleDefinitionID - Returns role eligibility requests of the specific role definition.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// RequestorID - Returns role eligibility requests created by specific principal.
	RequestorID *string `json:"requestorId,omitempty"`
	// Status - Returns role eligibility requests of specific status.
	Status *string `json:"status,omitempty"`
}

// RoleEligibilityScheduleRequestListResult role eligibility schedule request list operation result.
type RoleEligibilityScheduleRequestListResult struct {
	autorest.Response `json:"-"`
	// Value - Role eligibility schedule request list.
	Value *[]RoleEligibilityScheduleRequest `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleEligibilityScheduleRequestListResultIterator provides access to a complete listing of
// RoleEligibilityScheduleRequest values.
type RoleEligibilityScheduleRequestListResultIterator struct {
	i    int
	page RoleEligibilityScheduleRequestListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleEligibilityScheduleRequestListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleEligibilityScheduleRequestListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleEligibilityScheduleRequestListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleEligibilityScheduleRequestListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleEligibilityScheduleRequestListResultIterator) Response() RoleEligibilityScheduleRequestListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleEligibilityScheduleRequestListResultIterator) Value() RoleEligibilityScheduleRequest {
	if !iter.page.NotDone() {
		return RoleEligibilityScheduleRequest{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleEligibilityScheduleRequestListResultIterator type.
func NewRoleEligibilityScheduleRequestListResultIterator(page RoleEligibilityScheduleRequestListResultPage) RoleEligibilityScheduleRequestListResultIterator {
	return RoleEligibilityScheduleRequestListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (resrlr RoleEligibilityScheduleRequestListResult) IsEmpty() bool {
	return resrlr.Value == nil || len(*resrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (resrlr RoleEligibilityScheduleRequestListResult) hasNextLink() bool {
	return resrlr.NextLink != nil && len(*resrlr.NextLink) != 0
}

// roleEligibilityScheduleRequestListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (resrlr RoleEligibilityScheduleRequestListResult) roleEligibilityScheduleRequestListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !resrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(resrlr.NextLink)))
}

// RoleEligibilityScheduleRequestListResultPage contains a page of RoleEligibilityScheduleRequest values.
type RoleEligibilityScheduleRequestListResultPage struct {
	fn     func(context.Context, RoleEligibilityScheduleRequestListResult) (RoleEligibilityScheduleRequestListResult, error)
	resrlr RoleEligibilityScheduleRequestListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleEligibilityScheduleRequestListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleEligibilityScheduleRequestListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.resrlr)
		if err != nil {
			return err
		}
		page.resrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleEligibilityScheduleRequestListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleEligibilityScheduleRequestListResultPage) NotDone() bool {
	return !page.resrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleEligibilityScheduleRequestListResultPage) Response() RoleEligibilityScheduleRequestListResult {
	return page.resrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleEligibilityScheduleRequestListResultPage) Values() []RoleEligibilityScheduleRequest {
	if page.resrlr.IsEmpty() {
		return nil
	}
	return *page.resrlr.Value
}

// Creates a new instance of the RoleEligibilityScheduleRequestListResultPage type.
func NewRoleEligibilityScheduleRequestListResultPage(cur RoleEligibilityScheduleRequestListResult, getNextPage func(context.Context, RoleEligibilityScheduleRequestListResult) (RoleEligibilityScheduleRequestListResult, error)) RoleEligibilityScheduleRequestListResultPage {
	return RoleEligibilityScheduleRequestListResultPage{
		fn:     getNextPage,
		resrlr: cur,
	}
}

// RoleEligibilityScheduleRequestProperties role eligibility schedule request properties with scope.
type RoleEligibilityScheduleRequestProperties struct {
	// Scope - READ-ONLY; The role eligibility schedule request scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition ID.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PrincipalID - The principal ID.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalType - READ-ONLY; The principal type of the assigned principal ID. Possible values include: 'PrincipalTypeUser', 'PrincipalTypeGroup', 'PrincipalTypeServicePrincipal', 'PrincipalTypeForeignGroup', 'PrincipalTypeDevice'
	PrincipalType PrincipalType `json:"principalType,omitempty"`
	// RequestType - The type of the role assignment schedule request. Eg: SelfActivate, AdminAssign etc. Possible values include: 'AdminAssign', 'AdminRemove', 'AdminUpdate', 'AdminExtend', 'AdminRenew', 'SelfActivate', 'SelfDeactivate', 'SelfExtend', 'SelfRenew'
	RequestType RequestType `json:"requestType,omitempty"`
	// Status - READ-ONLY; The status of the role eligibility schedule request. Possible values include: 'Accepted', 'PendingEvaluation', 'Granted', 'Denied', 'PendingProvisioning', 'Provisioned', 'PendingRevocation', 'Revoked', 'Canceled', 'Failed', 'PendingApprovalProvisioning', 'PendingApproval', 'FailedAsResourceIsLocked', 'PendingAdminDecision', 'AdminApproved', 'AdminDenied', 'TimedOut', 'ProvisioningStarted', 'Invalid', 'PendingScheduleCreation', 'ScheduleCreated', 'PendingExternalProvisioning'
	Status Status `json:"status,omitempty"`
	// ApprovalID - READ-ONLY; The approvalId of the role eligibility schedule request.
	ApprovalID *string `json:"approvalId,omitempty"`
	// ScheduleInfo - Schedule info of the role eligibility schedule
	ScheduleInfo *RoleEligibilityScheduleRequestPropertiesScheduleInfo `json:"scheduleInfo,omitempty"`
	// TargetRoleEligibilityScheduleID - The resultant role eligibility schedule id or the role eligibility schedule id being updated
	TargetRoleEligibilityScheduleID *string `json:"targetRoleEligibilityScheduleId,omitempty"`
	// TargetRoleEligibilityScheduleInstanceID - The role eligibility schedule instance id being updated
	TargetRoleEligibilityScheduleInstanceID *string `json:"targetRoleEligibilityScheduleInstanceId,omitempty"`
	// Justification - Justification for the role eligibility
	Justification *string `json:"justification,omitempty"`
	// TicketInfo - Ticket Info of the role eligibility
	TicketInfo *RoleEligibilityScheduleRequestPropertiesTicketInfo `json:"ticketInfo,omitempty"`
	// Condition - The conditions on the role assignment. This limits the resources it can be assigned to. e.g.: @Resource[Microsoft.Storage/storageAccounts/blobServices/containers:ContainerName] StringEqualsIgnoreCase 'foo_storage_container'
	Condition *string `json:"condition,omitempty"`
	// ConditionVersion - Version of the condition. Currently accepted value is '2.0'
	ConditionVersion *string `json:"conditionVersion,omitempty"`
	// CreatedOn - READ-ONLY; DateTime when role eligibility schedule request was created
	CreatedOn *date.Time `json:"createdOn,omitempty"`
	// RequestorID - READ-ONLY; Id of the user who created this request
	RequestorID *string `json:"requestorId,omitempty"`
	// ExpandedProperties - READ-ONLY; Additional properties of principal, scope and role definition
	ExpandedProperties *ExpandedProperties `json:"expandedProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleEligibilityScheduleRequestProperties.
func (resrp RoleEligibilityScheduleRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if resrp.RoleDefinitionID != nil {
		objectMap["roleDefinitionId"] = resrp.RoleDefinitionID
	}
	if resrp.PrincipalID != nil {
		objectMap["principalId"] = resrp.PrincipalID
	}
	if resrp.RequestType != "" {
		objectMap["requestType"] = resrp.RequestType
	}
	if resrp.ScheduleInfo != nil {
		objectMap["scheduleInfo"] = resrp.ScheduleInfo
	}
	if resrp.TargetRoleEligibilityScheduleID != nil {
		objectMap["targetRoleEligibilityScheduleId"] = resrp.TargetRoleEligibilityScheduleID
	}
	if resrp.TargetRoleEligibilityScheduleInstanceID != nil {
		objectMap["targetRoleEligibilityScheduleInstanceId"] = resrp.TargetRoleEligibilityScheduleInstanceID
	}
	if resrp.Justification != nil {
		objectMap["justification"] = resrp.Justification
	}
	if resrp.TicketInfo != nil {
		objectMap["ticketInfo"] = resrp.TicketInfo
	}
	if resrp.Condition != nil {
		objectMap["condition"] = resrp.Condition
	}
	if resrp.ConditionVersion != nil {
		objectMap["conditionVersion"] = resrp.ConditionVersion
	}
	return json.Marshal(objectMap)
}

// RoleEligibilityScheduleRequestPropertiesScheduleInfo schedule info of the role eligibility schedule
type RoleEligibilityScheduleRequestPropertiesScheduleInfo struct {
	// StartDateTime - Start DateTime of the role eligibility schedule.
	StartDateTime *date.Time `json:"startDateTime,omitempty"`
	// Expiration - Expiration of the role eligibility schedule
	Expiration *RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration `json:"expiration,omitempty"`
}

// RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration expiration of the role eligibility
// schedule
type RoleEligibilityScheduleRequestPropertiesScheduleInfoExpiration struct {
	// Type - Type of the role eligibility schedule expiration. Possible values include: 'AfterDuration', 'AfterDateTime', 'NoExpiration'
	Type Type `json:"type,omitempty"`
	// EndDateTime - End DateTime of the role eligibility schedule.
	EndDateTime *date.Time `json:"endDateTime,omitempty"`
	// Duration - Duration of the role eligibility schedule in TimeSpan.
	Duration *string `json:"duration,omitempty"`
}

// RoleEligibilityScheduleRequestPropertiesTicketInfo ticket Info of the role eligibility
type RoleEligibilityScheduleRequestPropertiesTicketInfo struct {
	// TicketNumber - Ticket number for the role eligibility
	TicketNumber *string `json:"ticketNumber,omitempty"`
	// TicketSystem - Ticket system name for the role eligibility
	TicketSystem *string `json:"ticketSystem,omitempty"`
}

// RoleManagementPolicy role management policy
type RoleManagementPolicy struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role management policy Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role management policy name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role management policy type.
	Type *string `json:"type,omitempty"`
	// RoleManagementPolicyProperties - Role management policy properties.
	*RoleManagementPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicy.
func (rmp RoleManagementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmp.RoleManagementPolicyProperties != nil {
		objectMap["properties"] = rmp.RoleManagementPolicyProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleManagementPolicy struct.
func (rmp *RoleManagementPolicy) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rmp.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rmp.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rmp.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleManagementPolicyProperties RoleManagementPolicyProperties
				err = json.Unmarshal(*v, &roleManagementPolicyProperties)
				if err != nil {
					return err
				}
				rmp.RoleManagementPolicyProperties = &roleManagementPolicyProperties
			}
		}
	}

	return nil
}

// RoleManagementPolicyApprovalRule the role management policy rule.
type RoleManagementPolicyApprovalRule struct {
	// Setting - The approval setting
	Setting *ApprovalSettings `json:"setting,omitempty"`
	// ID - The id of the rule.
	ID *string `json:"id,omitempty"`
	// Target - The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
	// RuleType - Possible values include: 'RuleTypeRoleManagementPolicyRule', 'RuleTypeRoleManagementPolicyApprovalRule', 'RuleTypeRoleManagementPolicyAuthenticationContextRule', 'RuleTypeRoleManagementPolicyEnablementRule', 'RuleTypeRoleManagementPolicyExpirationRule', 'RuleTypeRoleManagementPolicyNotificationRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) MarshalJSON() ([]byte, error) {
	rmpar.RuleType = RuleTypeRoleManagementPolicyApprovalRule
	objectMap := make(map[string]interface{})
	if rmpar.Setting != nil {
		objectMap["setting"] = rmpar.Setting
	}
	if rmpar.ID != nil {
		objectMap["id"] = rmpar.ID
	}
	if rmpar.Target != nil {
		objectMap["target"] = rmpar.Target
	}
	if rmpar.RuleType != "" {
		objectMap["ruleType"] = rmpar.RuleType
	}
	return json.Marshal(objectMap)
}

// AsRoleManagementPolicyApprovalRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool) {
	return &rmpar, true
}

// AsRoleManagementPolicyAuthenticationContextRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyEnablementRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyExpirationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyNotificationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool) {
	return nil, false
}

// AsBasicRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyApprovalRule.
func (rmpar RoleManagementPolicyApprovalRule) AsBasicRoleManagementPolicyRule() (BasicRoleManagementPolicyRule, bool) {
	return &rmpar, true
}

// RoleManagementPolicyAssignment role management policy
type RoleManagementPolicyAssignment struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The role management policy Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The role management policy name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The role management policy type.
	Type *string `json:"type,omitempty"`
	// RoleManagementPolicyAssignmentProperties - Role management policy properties.
	*RoleManagementPolicyAssignmentProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyAssignment.
func (rmpa RoleManagementPolicyAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmpa.RoleManagementPolicyAssignmentProperties != nil {
		objectMap["properties"] = rmpa.RoleManagementPolicyAssignmentProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleManagementPolicyAssignment struct.
func (rmpa *RoleManagementPolicyAssignment) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rmpa.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rmpa.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rmpa.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var roleManagementPolicyAssignmentProperties RoleManagementPolicyAssignmentProperties
				err = json.Unmarshal(*v, &roleManagementPolicyAssignmentProperties)
				if err != nil {
					return err
				}
				rmpa.RoleManagementPolicyAssignmentProperties = &roleManagementPolicyAssignmentProperties
			}
		}
	}

	return nil
}

// RoleManagementPolicyAssignmentListResult role management policy assignment list operation result.
type RoleManagementPolicyAssignmentListResult struct {
	autorest.Response `json:"-"`
	// Value - Role management policy assignment list.
	Value *[]RoleManagementPolicyAssignment `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleManagementPolicyAssignmentListResultIterator provides access to a complete listing of
// RoleManagementPolicyAssignment values.
type RoleManagementPolicyAssignmentListResultIterator struct {
	i    int
	page RoleManagementPolicyAssignmentListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleManagementPolicyAssignmentListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleManagementPolicyAssignmentListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleManagementPolicyAssignmentListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleManagementPolicyAssignmentListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleManagementPolicyAssignmentListResultIterator) Response() RoleManagementPolicyAssignmentListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleManagementPolicyAssignmentListResultIterator) Value() RoleManagementPolicyAssignment {
	if !iter.page.NotDone() {
		return RoleManagementPolicyAssignment{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleManagementPolicyAssignmentListResultIterator type.
func NewRoleManagementPolicyAssignmentListResultIterator(page RoleManagementPolicyAssignmentListResultPage) RoleManagementPolicyAssignmentListResultIterator {
	return RoleManagementPolicyAssignmentListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rmpalr RoleManagementPolicyAssignmentListResult) IsEmpty() bool {
	return rmpalr.Value == nil || len(*rmpalr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rmpalr RoleManagementPolicyAssignmentListResult) hasNextLink() bool {
	return rmpalr.NextLink != nil && len(*rmpalr.NextLink) != 0
}

// roleManagementPolicyAssignmentListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rmpalr RoleManagementPolicyAssignmentListResult) roleManagementPolicyAssignmentListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rmpalr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rmpalr.NextLink)))
}

// RoleManagementPolicyAssignmentListResultPage contains a page of RoleManagementPolicyAssignment values.
type RoleManagementPolicyAssignmentListResultPage struct {
	fn     func(context.Context, RoleManagementPolicyAssignmentListResult) (RoleManagementPolicyAssignmentListResult, error)
	rmpalr RoleManagementPolicyAssignmentListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleManagementPolicyAssignmentListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleManagementPolicyAssignmentListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rmpalr)
		if err != nil {
			return err
		}
		page.rmpalr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleManagementPolicyAssignmentListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleManagementPolicyAssignmentListResultPage) NotDone() bool {
	return !page.rmpalr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleManagementPolicyAssignmentListResultPage) Response() RoleManagementPolicyAssignmentListResult {
	return page.rmpalr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleManagementPolicyAssignmentListResultPage) Values() []RoleManagementPolicyAssignment {
	if page.rmpalr.IsEmpty() {
		return nil
	}
	return *page.rmpalr.Value
}

// Creates a new instance of the RoleManagementPolicyAssignmentListResultPage type.
func NewRoleManagementPolicyAssignmentListResultPage(cur RoleManagementPolicyAssignmentListResult, getNextPage func(context.Context, RoleManagementPolicyAssignmentListResult) (RoleManagementPolicyAssignmentListResult, error)) RoleManagementPolicyAssignmentListResultPage {
	return RoleManagementPolicyAssignmentListResultPage{
		fn:     getNextPage,
		rmpalr: cur,
	}
}

// RoleManagementPolicyAssignmentProperties role management policy assignment properties with scope.
type RoleManagementPolicyAssignmentProperties struct {
	// Scope - The role management policy scope.
	Scope *string `json:"scope,omitempty"`
	// RoleDefinitionID - The role definition of management policy assignment.
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
	// PolicyID - The policy id role management policy assignment.
	PolicyID *string `json:"policyId,omitempty"`
	// PolicyAssignmentProperties - READ-ONLY; Additional properties of scope, role definition and policy
	PolicyAssignmentProperties *PolicyAssignmentProperties `json:"policyAssignmentProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyAssignmentProperties.
func (rmpap RoleManagementPolicyAssignmentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmpap.Scope != nil {
		objectMap["scope"] = rmpap.Scope
	}
	if rmpap.RoleDefinitionID != nil {
		objectMap["roleDefinitionId"] = rmpap.RoleDefinitionID
	}
	if rmpap.PolicyID != nil {
		objectMap["policyId"] = rmpap.PolicyID
	}
	return json.Marshal(objectMap)
}

// RoleManagementPolicyAuthenticationContextRule the role management policy rule.
type RoleManagementPolicyAuthenticationContextRule struct {
	// IsEnabled - The value indicating if rule is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// ClaimValue - The claim value.
	ClaimValue *string `json:"claimValue,omitempty"`
	// ID - The id of the rule.
	ID *string `json:"id,omitempty"`
	// Target - The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
	// RuleType - Possible values include: 'RuleTypeRoleManagementPolicyRule', 'RuleTypeRoleManagementPolicyApprovalRule', 'RuleTypeRoleManagementPolicyAuthenticationContextRule', 'RuleTypeRoleManagementPolicyEnablementRule', 'RuleTypeRoleManagementPolicyExpirationRule', 'RuleTypeRoleManagementPolicyNotificationRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) MarshalJSON() ([]byte, error) {
	rmpacr.RuleType = RuleTypeRoleManagementPolicyAuthenticationContextRule
	objectMap := make(map[string]interface{})
	if rmpacr.IsEnabled != nil {
		objectMap["isEnabled"] = rmpacr.IsEnabled
	}
	if rmpacr.ClaimValue != nil {
		objectMap["claimValue"] = rmpacr.ClaimValue
	}
	if rmpacr.ID != nil {
		objectMap["id"] = rmpacr.ID
	}
	if rmpacr.Target != nil {
		objectMap["target"] = rmpacr.Target
	}
	if rmpacr.RuleType != "" {
		objectMap["ruleType"] = rmpacr.RuleType
	}
	return json.Marshal(objectMap)
}

// AsRoleManagementPolicyApprovalRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyAuthenticationContextRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool) {
	return &rmpacr, true
}

// AsRoleManagementPolicyEnablementRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyExpirationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyNotificationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool) {
	return nil, false
}

// AsBasicRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyAuthenticationContextRule.
func (rmpacr RoleManagementPolicyAuthenticationContextRule) AsBasicRoleManagementPolicyRule() (BasicRoleManagementPolicyRule, bool) {
	return &rmpacr, true
}

// RoleManagementPolicyEnablementRule the role management policy rule.
type RoleManagementPolicyEnablementRule struct {
	// EnabledRules - The list of enabled rules.
	EnabledRules *[]EnablementRules `json:"enabledRules,omitempty"`
	// ID - The id of the rule.
	ID *string `json:"id,omitempty"`
	// Target - The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
	// RuleType - Possible values include: 'RuleTypeRoleManagementPolicyRule', 'RuleTypeRoleManagementPolicyApprovalRule', 'RuleTypeRoleManagementPolicyAuthenticationContextRule', 'RuleTypeRoleManagementPolicyEnablementRule', 'RuleTypeRoleManagementPolicyExpirationRule', 'RuleTypeRoleManagementPolicyNotificationRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) MarshalJSON() ([]byte, error) {
	rmper.RuleType = RuleTypeRoleManagementPolicyEnablementRule
	objectMap := make(map[string]interface{})
	if rmper.EnabledRules != nil {
		objectMap["enabledRules"] = rmper.EnabledRules
	}
	if rmper.ID != nil {
		objectMap["id"] = rmper.ID
	}
	if rmper.Target != nil {
		objectMap["target"] = rmper.Target
	}
	if rmper.RuleType != "" {
		objectMap["ruleType"] = rmper.RuleType
	}
	return json.Marshal(objectMap)
}

// AsRoleManagementPolicyApprovalRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyAuthenticationContextRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyEnablementRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool) {
	return &rmper, true
}

// AsRoleManagementPolicyExpirationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyNotificationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool) {
	return nil, false
}

// AsBasicRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyEnablementRule.
func (rmper RoleManagementPolicyEnablementRule) AsBasicRoleManagementPolicyRule() (BasicRoleManagementPolicyRule, bool) {
	return &rmper, true
}

// RoleManagementPolicyExpirationRule the role management policy rule.
type RoleManagementPolicyExpirationRule struct {
	// IsExpirationRequired - The value indicating whether expiration is required.
	IsExpirationRequired *bool `json:"isExpirationRequired,omitempty"`
	// MaximumDuration - The maximum duration of expiration in timespan.
	MaximumDuration *string `json:"maximumDuration,omitempty"`
	// ID - The id of the rule.
	ID *string `json:"id,omitempty"`
	// Target - The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
	// RuleType - Possible values include: 'RuleTypeRoleManagementPolicyRule', 'RuleTypeRoleManagementPolicyApprovalRule', 'RuleTypeRoleManagementPolicyAuthenticationContextRule', 'RuleTypeRoleManagementPolicyEnablementRule', 'RuleTypeRoleManagementPolicyExpirationRule', 'RuleTypeRoleManagementPolicyNotificationRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) MarshalJSON() ([]byte, error) {
	rmper.RuleType = RuleTypeRoleManagementPolicyExpirationRule
	objectMap := make(map[string]interface{})
	if rmper.IsExpirationRequired != nil {
		objectMap["isExpirationRequired"] = rmper.IsExpirationRequired
	}
	if rmper.MaximumDuration != nil {
		objectMap["maximumDuration"] = rmper.MaximumDuration
	}
	if rmper.ID != nil {
		objectMap["id"] = rmper.ID
	}
	if rmper.Target != nil {
		objectMap["target"] = rmper.Target
	}
	if rmper.RuleType != "" {
		objectMap["ruleType"] = rmper.RuleType
	}
	return json.Marshal(objectMap)
}

// AsRoleManagementPolicyApprovalRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyAuthenticationContextRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyEnablementRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyExpirationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool) {
	return &rmper, true
}

// AsRoleManagementPolicyNotificationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool) {
	return nil, false
}

// AsBasicRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyExpirationRule.
func (rmper RoleManagementPolicyExpirationRule) AsBasicRoleManagementPolicyRule() (BasicRoleManagementPolicyRule, bool) {
	return &rmper, true
}

// RoleManagementPolicyListResult role management policy list operation result.
type RoleManagementPolicyListResult struct {
	autorest.Response `json:"-"`
	// Value - Role management policy list.
	Value *[]RoleManagementPolicy `json:"value,omitempty"`
	// NextLink - The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// RoleManagementPolicyListResultIterator provides access to a complete listing of RoleManagementPolicy
// values.
type RoleManagementPolicyListResultIterator struct {
	i    int
	page RoleManagementPolicyListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *RoleManagementPolicyListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleManagementPolicyListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *RoleManagementPolicyListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter RoleManagementPolicyListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter RoleManagementPolicyListResultIterator) Response() RoleManagementPolicyListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter RoleManagementPolicyListResultIterator) Value() RoleManagementPolicy {
	if !iter.page.NotDone() {
		return RoleManagementPolicy{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the RoleManagementPolicyListResultIterator type.
func NewRoleManagementPolicyListResultIterator(page RoleManagementPolicyListResultPage) RoleManagementPolicyListResultIterator {
	return RoleManagementPolicyListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rmplr RoleManagementPolicyListResult) IsEmpty() bool {
	return rmplr.Value == nil || len(*rmplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rmplr RoleManagementPolicyListResult) hasNextLink() bool {
	return rmplr.NextLink != nil && len(*rmplr.NextLink) != 0
}

// roleManagementPolicyListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rmplr RoleManagementPolicyListResult) roleManagementPolicyListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !rmplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rmplr.NextLink)))
}

// RoleManagementPolicyListResultPage contains a page of RoleManagementPolicy values.
type RoleManagementPolicyListResultPage struct {
	fn    func(context.Context, RoleManagementPolicyListResult) (RoleManagementPolicyListResult, error)
	rmplr RoleManagementPolicyListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *RoleManagementPolicyListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/RoleManagementPolicyListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rmplr)
		if err != nil {
			return err
		}
		page.rmplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *RoleManagementPolicyListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page RoleManagementPolicyListResultPage) NotDone() bool {
	return !page.rmplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page RoleManagementPolicyListResultPage) Response() RoleManagementPolicyListResult {
	return page.rmplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page RoleManagementPolicyListResultPage) Values() []RoleManagementPolicy {
	if page.rmplr.IsEmpty() {
		return nil
	}
	return *page.rmplr.Value
}

// Creates a new instance of the RoleManagementPolicyListResultPage type.
func NewRoleManagementPolicyListResultPage(cur RoleManagementPolicyListResult, getNextPage func(context.Context, RoleManagementPolicyListResult) (RoleManagementPolicyListResult, error)) RoleManagementPolicyListResultPage {
	return RoleManagementPolicyListResultPage{
		fn:    getNextPage,
		rmplr: cur,
	}
}

// RoleManagementPolicyNotificationRule the role management policy rule.
type RoleManagementPolicyNotificationRule struct {
	// NotificationType - The type of notification. Possible values include: 'Email'
	NotificationType NotificationDeliveryMechanism `json:"notificationType,omitempty"`
	// NotificationLevel - The notification level. Possible values include: 'None', 'Critical', 'All'
	NotificationLevel NotificationLevel `json:"notificationLevel,omitempty"`
	// RecipientType - The recipient type. Possible values include: 'Requestor', 'Approver', 'Admin'
	RecipientType RecipientType `json:"recipientType,omitempty"`
	// NotificationRecipients - The list notification recipients.
	NotificationRecipients *[]string `json:"notificationRecipients,omitempty"`
	// IsDefaultRecipientsEnabled - Its value determine if the notification need to be sent to the recipient type specified in policy rule.
	IsDefaultRecipientsEnabled *bool `json:"isDefaultRecipientsEnabled,omitempty"`
	// ID - The id of the rule.
	ID *string `json:"id,omitempty"`
	// Target - The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
	// RuleType - Possible values include: 'RuleTypeRoleManagementPolicyRule', 'RuleTypeRoleManagementPolicyApprovalRule', 'RuleTypeRoleManagementPolicyAuthenticationContextRule', 'RuleTypeRoleManagementPolicyEnablementRule', 'RuleTypeRoleManagementPolicyExpirationRule', 'RuleTypeRoleManagementPolicyNotificationRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) MarshalJSON() ([]byte, error) {
	rmpnr.RuleType = RuleTypeRoleManagementPolicyNotificationRule
	objectMap := make(map[string]interface{})
	if rmpnr.NotificationType != "" {
		objectMap["notificationType"] = rmpnr.NotificationType
	}
	if rmpnr.NotificationLevel != "" {
		objectMap["notificationLevel"] = rmpnr.NotificationLevel
	}
	if rmpnr.RecipientType != "" {
		objectMap["recipientType"] = rmpnr.RecipientType
	}
	if rmpnr.NotificationRecipients != nil {
		objectMap["notificationRecipients"] = rmpnr.NotificationRecipients
	}
	if rmpnr.IsDefaultRecipientsEnabled != nil {
		objectMap["isDefaultRecipientsEnabled"] = rmpnr.IsDefaultRecipientsEnabled
	}
	if rmpnr.ID != nil {
		objectMap["id"] = rmpnr.ID
	}
	if rmpnr.Target != nil {
		objectMap["target"] = rmpnr.Target
	}
	if rmpnr.RuleType != "" {
		objectMap["ruleType"] = rmpnr.RuleType
	}
	return json.Marshal(objectMap)
}

// AsRoleManagementPolicyApprovalRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyAuthenticationContextRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyEnablementRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyExpirationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyNotificationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool) {
	return &rmpnr, true
}

// AsRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool) {
	return nil, false
}

// AsBasicRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyNotificationRule.
func (rmpnr RoleManagementPolicyNotificationRule) AsBasicRoleManagementPolicyRule() (BasicRoleManagementPolicyRule, bool) {
	return &rmpnr, true
}

// RoleManagementPolicyProperties role management policy properties with scope.
type RoleManagementPolicyProperties struct {
	// Scope - The role management policy scope.
	Scope *string `json:"scope,omitempty"`
	// DisplayName - The role management policy display name.
	DisplayName *string `json:"displayName,omitempty"`
	// Description - The role management policy description.
	Description *string `json:"description,omitempty"`
	// IsOrganizationDefault - The role management policy is default policy.
	IsOrganizationDefault *bool      `json:"isOrganizationDefault,omitempty"`
	LastModifiedBy        *Principal `json:"lastModifiedBy,omitempty"`
	// LastModifiedDateTime - READ-ONLY; The last modified date time.
	LastModifiedDateTime *date.Time `json:"lastModifiedDateTime,omitempty"`
	// Rules - The rule applied to the policy.
	Rules *[]BasicRoleManagementPolicyRule `json:"rules,omitempty"`
	// EffectiveRules - READ-ONLY; The readonly computed rule applied to the policy.
	EffectiveRules *[]BasicRoleManagementPolicyRule `json:"effectiveRules,omitempty"`
	// PolicyProperties - READ-ONLY; Additional properties of scope
	PolicyProperties *PolicyProperties `json:"policyProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyProperties.
func (rmpp RoleManagementPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmpp.Scope != nil {
		objectMap["scope"] = rmpp.Scope
	}
	if rmpp.DisplayName != nil {
		objectMap["displayName"] = rmpp.DisplayName
	}
	if rmpp.Description != nil {
		objectMap["description"] = rmpp.Description
	}
	if rmpp.IsOrganizationDefault != nil {
		objectMap["isOrganizationDefault"] = rmpp.IsOrganizationDefault
	}
	if rmpp.LastModifiedBy != nil {
		objectMap["lastModifiedBy"] = rmpp.LastModifiedBy
	}
	if rmpp.Rules != nil {
		objectMap["rules"] = rmpp.Rules
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RoleManagementPolicyProperties struct.
func (rmpp *RoleManagementPolicyProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "scope":
			if v != nil {
				var scope string
				err = json.Unmarshal(*v, &scope)
				if err != nil {
					return err
				}
				rmpp.Scope = &scope
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				rmpp.DisplayName = &displayName
			}
		case "description":
			if v != nil {
				var description string
				err = json.Unmarshal(*v, &description)
				if err != nil {
					return err
				}
				rmpp.Description = &description
			}
		case "isOrganizationDefault":
			if v != nil {
				var isOrganizationDefault bool
				err = json.Unmarshal(*v, &isOrganizationDefault)
				if err != nil {
					return err
				}
				rmpp.IsOrganizationDefault = &isOrganizationDefault
			}
		case "lastModifiedBy":
			if v != nil {
				var lastModifiedBy Principal
				err = json.Unmarshal(*v, &lastModifiedBy)
				if err != nil {
					return err
				}
				rmpp.LastModifiedBy = &lastModifiedBy
			}
		case "lastModifiedDateTime":
			if v != nil {
				var lastModifiedDateTime date.Time
				err = json.Unmarshal(*v, &lastModifiedDateTime)
				if err != nil {
					return err
				}
				rmpp.LastModifiedDateTime = &lastModifiedDateTime
			}
		case "rules":
			if v != nil {
				rules, err := unmarshalBasicRoleManagementPolicyRuleArray(*v)
				if err != nil {
					return err
				}
				rmpp.Rules = &rules
			}
		case "effectiveRules":
			if v != nil {
				effectiveRules, err := unmarshalBasicRoleManagementPolicyRuleArray(*v)
				if err != nil {
					return err
				}
				rmpp.EffectiveRules = &effectiveRules
			}
		case "policyProperties":
			if v != nil {
				var policyProperties PolicyProperties
				err = json.Unmarshal(*v, &policyProperties)
				if err != nil {
					return err
				}
				rmpp.PolicyProperties = &policyProperties
			}
		}
	}

	return nil
}

// BasicRoleManagementPolicyRule the role management policy rule.
type BasicRoleManagementPolicyRule interface {
	AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool)
	AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool)
	AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool)
	AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool)
	AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool)
	AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool)
}

// RoleManagementPolicyRule the role management policy rule.
type RoleManagementPolicyRule struct {
	// ID - The id of the rule.
	ID *string `json:"id,omitempty"`
	// Target - The target of the current rule.
	Target *RoleManagementPolicyRuleTarget `json:"target,omitempty"`
	// RuleType - Possible values include: 'RuleTypeRoleManagementPolicyRule', 'RuleTypeRoleManagementPolicyApprovalRule', 'RuleTypeRoleManagementPolicyAuthenticationContextRule', 'RuleTypeRoleManagementPolicyEnablementRule', 'RuleTypeRoleManagementPolicyExpirationRule', 'RuleTypeRoleManagementPolicyNotificationRule'
	RuleType RuleType `json:"ruleType,omitempty"`
}

func unmarshalBasicRoleManagementPolicyRule(body []byte) (BasicRoleManagementPolicyRule, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["ruleType"] {
	case string(RuleTypeRoleManagementPolicyApprovalRule):
		var rmpar RoleManagementPolicyApprovalRule
		err := json.Unmarshal(body, &rmpar)
		return rmpar, err
	case string(RuleTypeRoleManagementPolicyAuthenticationContextRule):
		var rmpacr RoleManagementPolicyAuthenticationContextRule
		err := json.Unmarshal(body, &rmpacr)
		return rmpacr, err
	case string(RuleTypeRoleManagementPolicyEnablementRule):
		var rmper RoleManagementPolicyEnablementRule
		err := json.Unmarshal(body, &rmper)
		return rmper, err
	case string(RuleTypeRoleManagementPolicyExpirationRule):
		var rmper RoleManagementPolicyExpirationRule
		err := json.Unmarshal(body, &rmper)
		return rmper, err
	case string(RuleTypeRoleManagementPolicyNotificationRule):
		var rmpnr RoleManagementPolicyNotificationRule
		err := json.Unmarshal(body, &rmpnr)
		return rmpnr, err
	default:
		var rmpr RoleManagementPolicyRule
		err := json.Unmarshal(body, &rmpr)
		return rmpr, err
	}
}
func unmarshalBasicRoleManagementPolicyRuleArray(body []byte) ([]BasicRoleManagementPolicyRule, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	rmprArray := make([]BasicRoleManagementPolicyRule, len(rawMessages))

	for index, rawMessage := range rawMessages {
		rmpr, err := unmarshalBasicRoleManagementPolicyRule(*rawMessage)
		if err != nil {
			return nil, err
		}
		rmprArray[index] = rmpr
	}
	return rmprArray, nil
}

// MarshalJSON is the custom marshaler for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) MarshalJSON() ([]byte, error) {
	rmpr.RuleType = RuleTypeRoleManagementPolicyRule
	objectMap := make(map[string]interface{})
	if rmpr.ID != nil {
		objectMap["id"] = rmpr.ID
	}
	if rmpr.Target != nil {
		objectMap["target"] = rmpr.Target
	}
	if rmpr.RuleType != "" {
		objectMap["ruleType"] = rmpr.RuleType
	}
	return json.Marshal(objectMap)
}

// AsRoleManagementPolicyApprovalRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsRoleManagementPolicyApprovalRule() (*RoleManagementPolicyApprovalRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyAuthenticationContextRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsRoleManagementPolicyAuthenticationContextRule() (*RoleManagementPolicyAuthenticationContextRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyEnablementRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsRoleManagementPolicyEnablementRule() (*RoleManagementPolicyEnablementRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyExpirationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsRoleManagementPolicyExpirationRule() (*RoleManagementPolicyExpirationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyNotificationRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsRoleManagementPolicyNotificationRule() (*RoleManagementPolicyNotificationRule, bool) {
	return nil, false
}

// AsRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsRoleManagementPolicyRule() (*RoleManagementPolicyRule, bool) {
	return &rmpr, true
}

// AsBasicRoleManagementPolicyRule is the BasicRoleManagementPolicyRule implementation for RoleManagementPolicyRule.
func (rmpr RoleManagementPolicyRule) AsBasicRoleManagementPolicyRule() (BasicRoleManagementPolicyRule, bool) {
	return &rmpr, true
}

// RoleManagementPolicyRuleTarget the role management policy rule target.
type RoleManagementPolicyRuleTarget struct {
	// Caller - The caller of the setting.
	Caller *string `json:"caller,omitempty"`
	// Operations - The type of operation.
	Operations *[]string `json:"operations,omitempty"`
	// Level - The assignment level to which it is applied.
	Level *string `json:"level,omitempty"`
	// TargetObjects - The list of target objects.
	TargetObjects *[]string `json:"targetObjects,omitempty"`
	// InheritableSettings - The list of inheritable settings.
	InheritableSettings *[]string `json:"inheritableSettings,omitempty"`
	// EnforcedSettings - The list of enforced settings.
	EnforcedSettings *[]string `json:"enforcedSettings,omitempty"`
}

// ServicePrincipalDecisionTarget service Principal Decision Target
type ServicePrincipalDecisionTarget struct {
	// PrincipalID - READ-ONLY; The id of service principal whose access is reviewed.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalName - READ-ONLY; The display name of the service principal whose access was reviewed.
	PrincipalName *string `json:"principalName,omitempty"`
	// AppID - READ-ONLY; The appId for the service principal entity being reviewed
	AppID *string `json:"appId,omitempty"`
	// Type - Possible values include: 'TypeAccessReviewDecisionTarget', 'TypeUser', 'TypeServicePrincipal'
	Type TypeBasicAccessReviewDecisionTarget `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServicePrincipalDecisionTarget.
func (spdt ServicePrincipalDecisionTarget) MarshalJSON() ([]byte, error) {
	spdt.Type = TypeServicePrincipal
	objectMap := make(map[string]interface{})
	if spdt.Type != "" {
		objectMap["type"] = spdt.Type
	}
	return json.Marshal(objectMap)
}

// AsUserDecisionTarget is the BasicAccessReviewDecisionTarget implementation for ServicePrincipalDecisionTarget.
func (spdt ServicePrincipalDecisionTarget) AsUserDecisionTarget() (*UserDecisionTarget, bool) {
	return nil, false
}

// AsServicePrincipalDecisionTarget is the BasicAccessReviewDecisionTarget implementation for ServicePrincipalDecisionTarget.
func (spdt ServicePrincipalDecisionTarget) AsServicePrincipalDecisionTarget() (*ServicePrincipalDecisionTarget, bool) {
	return &spdt, true
}

// AsAccessReviewDecisionTarget is the BasicAccessReviewDecisionTarget implementation for ServicePrincipalDecisionTarget.
func (spdt ServicePrincipalDecisionTarget) AsAccessReviewDecisionTarget() (*AccessReviewDecisionTarget, bool) {
	return nil, false
}

// AsBasicAccessReviewDecisionTarget is the BasicAccessReviewDecisionTarget implementation for ServicePrincipalDecisionTarget.
func (spdt ServicePrincipalDecisionTarget) AsBasicAccessReviewDecisionTarget() (BasicAccessReviewDecisionTarget, bool) {
	return &spdt, true
}

// UserDecisionTarget user Decision Target
type UserDecisionTarget struct {
	// PrincipalID - READ-ONLY; The id of user whose access was reviewed.
	PrincipalID *string `json:"principalId,omitempty"`
	// PrincipalName - READ-ONLY; The display name of the user whose access was reviewed.
	PrincipalName *string `json:"principalName,omitempty"`
	// UserPrincipalName - READ-ONLY; The user principal name of the user whose access was reviewed.
	UserPrincipalName *string `json:"userPrincipalName,omitempty"`
	// Type - Possible values include: 'TypeAccessReviewDecisionTarget', 'TypeUser', 'TypeServicePrincipal'
	Type TypeBasicAccessReviewDecisionTarget `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for UserDecisionTarget.
func (udt UserDecisionTarget) MarshalJSON() ([]byte, error) {
	udt.Type = TypeUser
	objectMap := make(map[string]interface{})
	if udt.Type != "" {
		objectMap["type"] = udt.Type
	}
	return json.Marshal(objectMap)
}

// AsUserDecisionTarget is the BasicAccessReviewDecisionTarget implementation for UserDecisionTarget.
func (udt UserDecisionTarget) AsUserDecisionTarget() (*UserDecisionTarget, bool) {
	return &udt, true
}

// AsServicePrincipalDecisionTarget is the BasicAccessReviewDecisionTarget implementation for UserDecisionTarget.
func (udt UserDecisionTarget) AsServicePrincipalDecisionTarget() (*ServicePrincipalDecisionTarget, bool) {
	return nil, false
}

// AsAccessReviewDecisionTarget is the BasicAccessReviewDecisionTarget implementation for UserDecisionTarget.
func (udt UserDecisionTarget) AsAccessReviewDecisionTarget() (*AccessReviewDecisionTarget, bool) {
	return nil, false
}

// AsBasicAccessReviewDecisionTarget is the BasicAccessReviewDecisionTarget implementation for UserDecisionTarget.
func (udt UserDecisionTarget) AsBasicAccessReviewDecisionTarget() (BasicAccessReviewDecisionTarget, bool) {
	return &udt, true
}

// UserSet the detail of a user.
type UserSet struct {
	// UserType - The type of user. Possible values include: 'UserTypeUser', 'UserTypeGroup'
	UserType UserType `json:"userType,omitempty"`
	// IsBackup - The value indicating whether the user is a backup fallback approver
	IsBackup *bool `json:"isBackup,omitempty"`
	// ID - The object id of the user.
	ID *string `json:"id,omitempty"`
	// Description - The description of the user.
	Description *string `json:"description,omitempty"`
}

// ValidationResponse validation response
type ValidationResponse struct {
	autorest.Response `json:"-"`
	// IsValid - READ-ONLY; Whether or not validation succeeded
	IsValid *bool `json:"isValid,omitempty"`
	// ErrorInfo - Failed validation result details
	ErrorInfo *ValidationResponseErrorInfo `json:"errorInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ValidationResponse.
func (vr ValidationResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vr.ErrorInfo != nil {
		objectMap["errorInfo"] = vr.ErrorInfo
	}
	return json.Marshal(objectMap)
}

// ValidationResponseErrorInfo failed validation result details
type ValidationResponseErrorInfo struct {
	// Code - READ-ONLY; Error code indicating why validation failed
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Message indicating why validation failed
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for ValidationResponseErrorInfo.
func (vrei ValidationResponseErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}
