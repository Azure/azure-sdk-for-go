package avs

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// WorkloadNetworksClient is the azure VMware Solution API
type WorkloadNetworksClient struct {
	BaseClient
}

// NewWorkloadNetworksClient creates an instance of the WorkloadNetworksClient client.
func NewWorkloadNetworksClient(subscriptionID string) WorkloadNetworksClient {
	return NewWorkloadNetworksClientWithBaseURI(DefaultBaseURI, subscriptionID)
}

// NewWorkloadNetworksClientWithBaseURI creates an instance of the WorkloadNetworksClient client using a custom
// endpoint.  Use this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure
// stack).
func NewWorkloadNetworksClientWithBaseURI(baseURI string, subscriptionID string) WorkloadNetworksClient {
	return WorkloadNetworksClient{NewWithBaseURI(baseURI, subscriptionID)}
}

// CreateDhcp sends the create dhcp request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// dhcpID - NSX DHCP identifier. Generally the same as the DHCP display name
// workloadNetworkDhcp - NSX DHCP
func (client WorkloadNetworksClient) CreateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp) (result WorkloadNetworksCreateDhcpFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.CreateDhcp")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "CreateDhcp", err.Error())
	}

	req, err := client.CreateDhcpPreparer(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreateDhcp", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateDhcpSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreateDhcp", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateDhcpPreparer prepares the CreateDhcp request.
func (client WorkloadNetworksClient) CreateDhcpPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"dhcpId":            autorest.Encode("path", dhcpID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}", pathParameters),
		autorest.WithJSON(workloadNetworkDhcp),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateDhcpSender sends the CreateDhcp request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) CreateDhcpSender(req *http.Request) (future WorkloadNetworksCreateDhcpFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateDhcpResponder handles the response to the CreateDhcp request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) CreateDhcpResponder(resp *http.Response) (result WorkloadNetworkDhcp, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreatePortMirroring sends the create port mirroring request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// portMirroringID - NSX Port Mirroring identifier. Generally the same as the Port Mirroring display name
// workloadNetworkPortMirroring - NSX port mirroring
func (client WorkloadNetworksClient) CreatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring) (result WorkloadNetworksCreatePortMirroringFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.CreatePortMirroring")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "CreatePortMirroring", err.Error())
	}

	req, err := client.CreatePortMirroringPreparer(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreatePortMirroring", nil, "Failure preparing request")
		return
	}

	result, err = client.CreatePortMirroringSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreatePortMirroring", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreatePortMirroringPreparer prepares the CreatePortMirroring request.
func (client WorkloadNetworksClient) CreatePortMirroringPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"portMirroringId":   autorest.Encode("path", portMirroringID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}", pathParameters),
		autorest.WithJSON(workloadNetworkPortMirroring),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreatePortMirroringSender sends the CreatePortMirroring request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) CreatePortMirroringSender(req *http.Request) (future WorkloadNetworksCreatePortMirroringFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreatePortMirroringResponder handles the response to the CreatePortMirroring request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) CreatePortMirroringResponder(resp *http.Response) (result WorkloadNetworkPortMirroring, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateSegments sends the create segments request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// segmentID - NSX Segment identifier. Generally the same as the Segment's display name
// workloadNetworkSegment - NSX Segment
func (client WorkloadNetworksClient) CreateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment) (result WorkloadNetworksCreateSegmentsFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.CreateSegments")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "CreateSegments", err.Error())
	}

	req, err := client.CreateSegmentsPreparer(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreateSegments", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateSegmentsSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreateSegments", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateSegmentsPreparer prepares the CreateSegments request.
func (client WorkloadNetworksClient) CreateSegmentsPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"segmentId":         autorest.Encode("path", segmentID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}", pathParameters),
		autorest.WithJSON(workloadNetworkSegment),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateSegmentsSender sends the CreateSegments request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) CreateSegmentsSender(req *http.Request) (future WorkloadNetworksCreateSegmentsFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateSegmentsResponder handles the response to the CreateSegments request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) CreateSegmentsResponder(resp *http.Response) (result WorkloadNetworkSegment, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateVMGroup sends the create vm group request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// VMGroupID - NSX VM Group identifier. Generally the same as the VM Group's display name
// workloadNetworkVMGroup - NSX VM Group
func (client WorkloadNetworksClient) CreateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, VMGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup) (result WorkloadNetworksCreateVMGroupFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.CreateVMGroup")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "CreateVMGroup", err.Error())
	}

	req, err := client.CreateVMGroupPreparer(ctx, resourceGroupName, privateCloudName, VMGroupID, workloadNetworkVMGroup)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreateVMGroup", nil, "Failure preparing request")
		return
	}

	result, err = client.CreateVMGroupSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "CreateVMGroup", result.Response(), "Failure sending request")
		return
	}

	return
}

// CreateVMGroupPreparer prepares the CreateVMGroup request.
func (client WorkloadNetworksClient) CreateVMGroupPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, VMGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vmGroupId":         autorest.Encode("path", VMGroupID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}", pathParameters),
		autorest.WithJSON(workloadNetworkVMGroup),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateVMGroupSender sends the CreateVMGroup request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) CreateVMGroupSender(req *http.Request) (future WorkloadNetworksCreateVMGroupFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// CreateVMGroupResponder handles the response to the CreateVMGroup request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) CreateVMGroupResponder(resp *http.Response) (result WorkloadNetworkVMGroup, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteDhcp sends the delete dhcp request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// dhcpID - NSX DHCP identifier. Generally the same as the DHCP display name
func (client WorkloadNetworksClient) DeleteDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string) (result WorkloadNetworksDeleteDhcpFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.DeleteDhcp")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "DeleteDhcp", err.Error())
	}

	req, err := client.DeleteDhcpPreparer(ctx, resourceGroupName, privateCloudName, dhcpID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeleteDhcp", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteDhcpSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeleteDhcp", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteDhcpPreparer prepares the DeleteDhcp request.
func (client WorkloadNetworksClient) DeleteDhcpPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"dhcpId":            autorest.Encode("path", dhcpID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDhcpSender sends the DeleteDhcp request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) DeleteDhcpSender(req *http.Request) (future WorkloadNetworksDeleteDhcpFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteDhcpResponder handles the response to the DeleteDhcp request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) DeleteDhcpResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeletePortMirroring sends the delete port mirroring request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// portMirroringID - NSX Port Mirroring identifier. Generally the same as the Port Mirroring display name
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) DeletePortMirroring(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string) (result WorkloadNetworksDeletePortMirroringFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.DeletePortMirroring")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "DeletePortMirroring", err.Error())
	}

	req, err := client.DeletePortMirroringPreparer(ctx, resourceGroupName, portMirroringID, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeletePortMirroring", nil, "Failure preparing request")
		return
	}

	result, err = client.DeletePortMirroringSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeletePortMirroring", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeletePortMirroringPreparer prepares the DeletePortMirroring request.
func (client WorkloadNetworksClient) DeletePortMirroringPreparer(ctx context.Context, resourceGroupName string, portMirroringID string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"portMirroringId":   autorest.Encode("path", portMirroringID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeletePortMirroringSender sends the DeletePortMirroring request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) DeletePortMirroringSender(req *http.Request) (future WorkloadNetworksDeletePortMirroringFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeletePortMirroringResponder handles the response to the DeletePortMirroring request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) DeletePortMirroringResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteSegment sends the delete segment request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// segmentID - NSX Segment identifier. Generally the same as the Segment's display name
func (client WorkloadNetworksClient) DeleteSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string) (result WorkloadNetworksDeleteSegmentFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.DeleteSegment")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "DeleteSegment", err.Error())
	}

	req, err := client.DeleteSegmentPreparer(ctx, resourceGroupName, privateCloudName, segmentID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeleteSegment", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteSegmentSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeleteSegment", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteSegmentPreparer prepares the DeleteSegment request.
func (client WorkloadNetworksClient) DeleteSegmentPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"segmentId":         autorest.Encode("path", segmentID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteSegmentSender sends the DeleteSegment request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) DeleteSegmentSender(req *http.Request) (future WorkloadNetworksDeleteSegmentFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteSegmentResponder handles the response to the DeleteSegment request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) DeleteSegmentResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// DeleteVMGroup sends the delete vm group request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// VMGroupID - NSX VM Group identifier. Generally the same as the VM Group's display name
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) DeleteVMGroup(ctx context.Context, resourceGroupName string, VMGroupID string, privateCloudName string) (result WorkloadNetworksDeleteVMGroupFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.DeleteVMGroup")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "DeleteVMGroup", err.Error())
	}

	req, err := client.DeleteVMGroupPreparer(ctx, resourceGroupName, VMGroupID, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeleteVMGroup", nil, "Failure preparing request")
		return
	}

	result, err = client.DeleteVMGroupSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "DeleteVMGroup", result.Response(), "Failure sending request")
		return
	}

	return
}

// DeleteVMGroupPreparer prepares the DeleteVMGroup request.
func (client WorkloadNetworksClient) DeleteVMGroupPreparer(ctx context.Context, resourceGroupName string, VMGroupID string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vmGroupId":         autorest.Encode("path", VMGroupID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteVMGroupSender sends the DeleteVMGroup request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) DeleteVMGroupSender(req *http.Request) (future WorkloadNetworksDeleteVMGroupFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// DeleteVMGroupResponder handles the response to the DeleteVMGroup request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) DeleteVMGroupResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent),
		autorest.ByClosing())
	result.Response = resp
	return
}

// GetDhcp sends the get dhcp request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// dhcpID - NSX DHCP identifier. Generally the same as the DHCP display name
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) GetDhcp(ctx context.Context, resourceGroupName string, dhcpID string, privateCloudName string) (result WorkloadNetworkDhcp, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.GetDhcp")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "GetDhcp", err.Error())
	}

	req, err := client.GetDhcpPreparer(ctx, resourceGroupName, dhcpID, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetDhcp", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDhcpSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetDhcp", resp, "Failure sending request")
		return
	}

	result, err = client.GetDhcpResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetDhcp", resp, "Failure responding to request")
	}

	return
}

// GetDhcpPreparer prepares the GetDhcp request.
func (client WorkloadNetworksClient) GetDhcpPreparer(ctx context.Context, resourceGroupName string, dhcpID string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"dhcpId":            autorest.Encode("path", dhcpID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDhcpSender sends the GetDhcp request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) GetDhcpSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetDhcpResponder handles the response to the GetDhcp request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) GetDhcpResponder(resp *http.Response) (result WorkloadNetworkDhcp, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetGateway sends the get gateway request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// gatewayID - NSX Gateway identifier. Generally the same as the Gateway's display name
func (client WorkloadNetworksClient) GetGateway(ctx context.Context, resourceGroupName string, privateCloudName string, gatewayID string) (result WorkloadNetworkGateway, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.GetGateway")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "GetGateway", err.Error())
	}

	req, err := client.GetGatewayPreparer(ctx, resourceGroupName, privateCloudName, gatewayID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetGateway", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetGatewaySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetGateway", resp, "Failure sending request")
		return
	}

	result, err = client.GetGatewayResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetGateway", resp, "Failure responding to request")
	}

	return
}

// GetGatewayPreparer prepares the GetGateway request.
func (client WorkloadNetworksClient) GetGatewayPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, gatewayID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"gatewayId":         autorest.Encode("path", gatewayID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetGatewaySender sends the GetGateway request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) GetGatewaySender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetGatewayResponder handles the response to the GetGateway request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) GetGatewayResponder(resp *http.Response) (result WorkloadNetworkGateway, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetPortMirroring sends the get port mirroring request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// portMirroringID - NSX Port Mirroring identifier. Generally the same as the Port Mirroring display name
func (client WorkloadNetworksClient) GetPortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string) (result WorkloadNetworkPortMirroring, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.GetPortMirroring")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "GetPortMirroring", err.Error())
	}

	req, err := client.GetPortMirroringPreparer(ctx, resourceGroupName, privateCloudName, portMirroringID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetPortMirroring", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetPortMirroringSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetPortMirroring", resp, "Failure sending request")
		return
	}

	result, err = client.GetPortMirroringResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetPortMirroring", resp, "Failure responding to request")
	}

	return
}

// GetPortMirroringPreparer prepares the GetPortMirroring request.
func (client WorkloadNetworksClient) GetPortMirroringPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"portMirroringId":   autorest.Encode("path", portMirroringID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetPortMirroringSender sends the GetPortMirroring request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) GetPortMirroringSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetPortMirroringResponder handles the response to the GetPortMirroring request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) GetPortMirroringResponder(resp *http.Response) (result WorkloadNetworkPortMirroring, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSegment sends the get segment request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// segmentID - NSX Segment identifier. Generally the same as the Segment's display name
func (client WorkloadNetworksClient) GetSegment(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string) (result WorkloadNetworkSegment, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.GetSegment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "GetSegment", err.Error())
	}

	req, err := client.GetSegmentPreparer(ctx, resourceGroupName, privateCloudName, segmentID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetSegment", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSegmentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetSegment", resp, "Failure sending request")
		return
	}

	result, err = client.GetSegmentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetSegment", resp, "Failure responding to request")
	}

	return
}

// GetSegmentPreparer prepares the GetSegment request.
func (client WorkloadNetworksClient) GetSegmentPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"segmentId":         autorest.Encode("path", segmentID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSegmentSender sends the GetSegment request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) GetSegmentSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetSegmentResponder handles the response to the GetSegment request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) GetSegmentResponder(resp *http.Response) (result WorkloadNetworkSegment, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVirtualMachine sends the get virtual machine request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// virtualMachineID - NSX Virtual Machine identifier.
func (client WorkloadNetworksClient) GetVirtualMachine(ctx context.Context, resourceGroupName string, privateCloudName string, virtualMachineID string) (result WorkloadNetworkVirtualMachine, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.GetVirtualMachine")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "GetVirtualMachine", err.Error())
	}

	req, err := client.GetVirtualMachinePreparer(ctx, resourceGroupName, privateCloudName, virtualMachineID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetVirtualMachine", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVirtualMachineSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetVirtualMachine", resp, "Failure sending request")
		return
	}

	result, err = client.GetVirtualMachineResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetVirtualMachine", resp, "Failure responding to request")
	}

	return
}

// GetVirtualMachinePreparer prepares the GetVirtualMachine request.
func (client WorkloadNetworksClient) GetVirtualMachinePreparer(ctx context.Context, resourceGroupName string, privateCloudName string, virtualMachineID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"virtualMachineId":  autorest.Encode("path", virtualMachineID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVirtualMachineSender sends the GetVirtualMachine request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) GetVirtualMachineSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetVirtualMachineResponder handles the response to the GetVirtualMachine request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) GetVirtualMachineResponder(resp *http.Response) (result WorkloadNetworkVirtualMachine, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVMGroup sends the get vm group request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// VMGroupID - NSX VM Group identifier. Generally the same as the VM Group's display name
func (client WorkloadNetworksClient) GetVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, VMGroupID string) (result WorkloadNetworkVMGroup, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.GetVMGroup")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "GetVMGroup", err.Error())
	}

	req, err := client.GetVMGroupPreparer(ctx, resourceGroupName, privateCloudName, VMGroupID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetVMGroup", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVMGroupSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetVMGroup", resp, "Failure sending request")
		return
	}

	result, err = client.GetVMGroupResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "GetVMGroup", resp, "Failure responding to request")
	}

	return
}

// GetVMGroupPreparer prepares the GetVMGroup request.
func (client WorkloadNetworksClient) GetVMGroupPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, VMGroupID string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vmGroupId":         autorest.Encode("path", VMGroupID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVMGroupSender sends the GetVMGroup request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) GetVMGroupSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// GetVMGroupResponder handles the response to the GetVMGroup request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) GetVMGroupResponder(resp *http.Response) (result WorkloadNetworkVMGroup, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListDhcp sends the list dhcp request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) ListDhcp(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkDhcpListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListDhcp")
		defer func() {
			sc := -1
			if result.wndl.Response.Response != nil {
				sc = result.wndl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "ListDhcp", err.Error())
	}

	result.fn = client.listDhcpNextResults
	req, err := client.ListDhcpPreparer(ctx, resourceGroupName, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListDhcp", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListDhcpSender(req)
	if err != nil {
		result.wndl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListDhcp", resp, "Failure sending request")
		return
	}

	result.wndl, err = client.ListDhcpResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListDhcp", resp, "Failure responding to request")
	}
	if result.wndl.hasNextLink() && result.wndl.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListDhcpPreparer prepares the ListDhcp request.
func (client WorkloadNetworksClient) ListDhcpPreparer(ctx context.Context, resourceGroupName string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListDhcpSender sends the ListDhcp request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) ListDhcpSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListDhcpResponder handles the response to the ListDhcp request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) ListDhcpResponder(resp *http.Response) (result WorkloadNetworkDhcpList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listDhcpNextResults retrieves the next set of results, if any.
func (client WorkloadNetworksClient) listDhcpNextResults(ctx context.Context, lastResults WorkloadNetworkDhcpList) (result WorkloadNetworkDhcpList, err error) {
	req, err := lastResults.workloadNetworkDhcpListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listDhcpNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListDhcpSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listDhcpNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListDhcpResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listDhcpNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListDhcpComplete enumerates all values, automatically crossing page boundaries as required.
func (client WorkloadNetworksClient) ListDhcpComplete(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkDhcpListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListDhcp")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListDhcp(ctx, resourceGroupName, privateCloudName)
	return
}

// ListGateways sends the list gateways request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) ListGateways(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkGatewayListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListGateways")
		defer func() {
			sc := -1
			if result.wngl.Response.Response != nil {
				sc = result.wngl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "ListGateways", err.Error())
	}

	result.fn = client.listGatewaysNextResults
	req, err := client.ListGatewaysPreparer(ctx, resourceGroupName, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListGateways", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListGatewaysSender(req)
	if err != nil {
		result.wngl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListGateways", resp, "Failure sending request")
		return
	}

	result.wngl, err = client.ListGatewaysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListGateways", resp, "Failure responding to request")
	}
	if result.wngl.hasNextLink() && result.wngl.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListGatewaysPreparer prepares the ListGateways request.
func (client WorkloadNetworksClient) ListGatewaysPreparer(ctx context.Context, resourceGroupName string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListGatewaysSender sends the ListGateways request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) ListGatewaysSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListGatewaysResponder handles the response to the ListGateways request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) ListGatewaysResponder(resp *http.Response) (result WorkloadNetworkGatewayList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listGatewaysNextResults retrieves the next set of results, if any.
func (client WorkloadNetworksClient) listGatewaysNextResults(ctx context.Context, lastResults WorkloadNetworkGatewayList) (result WorkloadNetworkGatewayList, err error) {
	req, err := lastResults.workloadNetworkGatewayListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listGatewaysNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListGatewaysSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listGatewaysNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListGatewaysResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listGatewaysNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListGatewaysComplete enumerates all values, automatically crossing page boundaries as required.
func (client WorkloadNetworksClient) ListGatewaysComplete(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkGatewayListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListGateways")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListGateways(ctx, resourceGroupName, privateCloudName)
	return
}

// ListPortMirroring sends the list port mirroring request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) ListPortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkPortMirroringListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListPortMirroring")
		defer func() {
			sc := -1
			if result.wnpml.Response.Response != nil {
				sc = result.wnpml.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "ListPortMirroring", err.Error())
	}

	result.fn = client.listPortMirroringNextResults
	req, err := client.ListPortMirroringPreparer(ctx, resourceGroupName, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListPortMirroring", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListPortMirroringSender(req)
	if err != nil {
		result.wnpml.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListPortMirroring", resp, "Failure sending request")
		return
	}

	result.wnpml, err = client.ListPortMirroringResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListPortMirroring", resp, "Failure responding to request")
	}
	if result.wnpml.hasNextLink() && result.wnpml.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListPortMirroringPreparer prepares the ListPortMirroring request.
func (client WorkloadNetworksClient) ListPortMirroringPreparer(ctx context.Context, resourceGroupName string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListPortMirroringSender sends the ListPortMirroring request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) ListPortMirroringSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListPortMirroringResponder handles the response to the ListPortMirroring request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) ListPortMirroringResponder(resp *http.Response) (result WorkloadNetworkPortMirroringList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listPortMirroringNextResults retrieves the next set of results, if any.
func (client WorkloadNetworksClient) listPortMirroringNextResults(ctx context.Context, lastResults WorkloadNetworkPortMirroringList) (result WorkloadNetworkPortMirroringList, err error) {
	req, err := lastResults.workloadNetworkPortMirroringListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listPortMirroringNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListPortMirroringSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listPortMirroringNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListPortMirroringResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listPortMirroringNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListPortMirroringComplete enumerates all values, automatically crossing page boundaries as required.
func (client WorkloadNetworksClient) ListPortMirroringComplete(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkPortMirroringListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListPortMirroring")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListPortMirroring(ctx, resourceGroupName, privateCloudName)
	return
}

// ListSegments sends the list segments request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) ListSegments(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkSegmentsListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListSegments")
		defer func() {
			sc := -1
			if result.wnsl.Response.Response != nil {
				sc = result.wnsl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "ListSegments", err.Error())
	}

	result.fn = client.listSegmentsNextResults
	req, err := client.ListSegmentsPreparer(ctx, resourceGroupName, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListSegments", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListSegmentsSender(req)
	if err != nil {
		result.wnsl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListSegments", resp, "Failure sending request")
		return
	}

	result.wnsl, err = client.ListSegmentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListSegments", resp, "Failure responding to request")
	}
	if result.wnsl.hasNextLink() && result.wnsl.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListSegmentsPreparer prepares the ListSegments request.
func (client WorkloadNetworksClient) ListSegmentsPreparer(ctx context.Context, resourceGroupName string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListSegmentsSender sends the ListSegments request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) ListSegmentsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListSegmentsResponder handles the response to the ListSegments request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) ListSegmentsResponder(resp *http.Response) (result WorkloadNetworkSegmentsList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listSegmentsNextResults retrieves the next set of results, if any.
func (client WorkloadNetworksClient) listSegmentsNextResults(ctx context.Context, lastResults WorkloadNetworkSegmentsList) (result WorkloadNetworkSegmentsList, err error) {
	req, err := lastResults.workloadNetworkSegmentsListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listSegmentsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListSegmentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listSegmentsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListSegmentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listSegmentsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListSegmentsComplete enumerates all values, automatically crossing page boundaries as required.
func (client WorkloadNetworksClient) ListSegmentsComplete(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkSegmentsListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListSegments")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListSegments(ctx, resourceGroupName, privateCloudName)
	return
}

// ListVirtualMachines sends the list virtual machines request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) ListVirtualMachines(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkVirtualMachinesListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListVirtualMachines")
		defer func() {
			sc := -1
			if result.wnvml.Response.Response != nil {
				sc = result.wnvml.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "ListVirtualMachines", err.Error())
	}

	result.fn = client.listVirtualMachinesNextResults
	req, err := client.ListVirtualMachinesPreparer(ctx, resourceGroupName, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListVirtualMachines", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListVirtualMachinesSender(req)
	if err != nil {
		result.wnvml.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListVirtualMachines", resp, "Failure sending request")
		return
	}

	result.wnvml, err = client.ListVirtualMachinesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListVirtualMachines", resp, "Failure responding to request")
	}
	if result.wnvml.hasNextLink() && result.wnvml.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListVirtualMachinesPreparer prepares the ListVirtualMachines request.
func (client WorkloadNetworksClient) ListVirtualMachinesPreparer(ctx context.Context, resourceGroupName string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListVirtualMachinesSender sends the ListVirtualMachines request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) ListVirtualMachinesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListVirtualMachinesResponder handles the response to the ListVirtualMachines request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) ListVirtualMachinesResponder(resp *http.Response) (result WorkloadNetworkVirtualMachinesList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listVirtualMachinesNextResults retrieves the next set of results, if any.
func (client WorkloadNetworksClient) listVirtualMachinesNextResults(ctx context.Context, lastResults WorkloadNetworkVirtualMachinesList) (result WorkloadNetworkVirtualMachinesList, err error) {
	req, err := lastResults.workloadNetworkVirtualMachinesListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listVirtualMachinesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListVirtualMachinesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listVirtualMachinesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListVirtualMachinesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listVirtualMachinesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListVirtualMachinesComplete enumerates all values, automatically crossing page boundaries as required.
func (client WorkloadNetworksClient) ListVirtualMachinesComplete(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkVirtualMachinesListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListVirtualMachines")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListVirtualMachines(ctx, resourceGroupName, privateCloudName)
	return
}

// ListVMGroups sends the list vm groups request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
func (client WorkloadNetworksClient) ListVMGroups(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkVMGroupsListPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListVMGroups")
		defer func() {
			sc := -1
			if result.wnvgl.Response.Response != nil {
				sc = result.wnvgl.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "ListVMGroups", err.Error())
	}

	result.fn = client.listVMGroupsNextResults
	req, err := client.ListVMGroupsPreparer(ctx, resourceGroupName, privateCloudName)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListVMGroups", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListVMGroupsSender(req)
	if err != nil {
		result.wnvgl.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListVMGroups", resp, "Failure sending request")
		return
	}

	result.wnvgl, err = client.ListVMGroupsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "ListVMGroups", resp, "Failure responding to request")
	}
	if result.wnvgl.hasNextLink() && result.wnvgl.IsEmpty() {
		err = result.NextWithContext(ctx)
	}

	return
}

// ListVMGroupsPreparer prepares the ListVMGroups request.
func (client WorkloadNetworksClient) ListVMGroupsPreparer(ctx context.Context, resourceGroupName string, privateCloudName string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListVMGroupsSender sends the ListVMGroups request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) ListVMGroupsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListVMGroupsResponder handles the response to the ListVMGroups request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) ListVMGroupsResponder(resp *http.Response) (result WorkloadNetworkVMGroupsList, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listVMGroupsNextResults retrieves the next set of results, if any.
func (client WorkloadNetworksClient) listVMGroupsNextResults(ctx context.Context, lastResults WorkloadNetworkVMGroupsList) (result WorkloadNetworkVMGroupsList, err error) {
	req, err := lastResults.workloadNetworkVMGroupsListPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listVMGroupsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListVMGroupsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listVMGroupsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListVMGroupsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "listVMGroupsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListVMGroupsComplete enumerates all values, automatically crossing page boundaries as required.
func (client WorkloadNetworksClient) ListVMGroupsComplete(ctx context.Context, resourceGroupName string, privateCloudName string) (result WorkloadNetworkVMGroupsListIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.ListVMGroups")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListVMGroups(ctx, resourceGroupName, privateCloudName)
	return
}

// UpdateDhcp sends the update dhcp request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// dhcpID - NSX DHCP identifier. Generally the same as the DHCP display name
// workloadNetworkDhcp - NSX DHCP
func (client WorkloadNetworksClient) UpdateDhcp(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp) (result WorkloadNetworksUpdateDhcpFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.UpdateDhcp")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "UpdateDhcp", err.Error())
	}

	req, err := client.UpdateDhcpPreparer(ctx, resourceGroupName, privateCloudName, dhcpID, workloadNetworkDhcp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdateDhcp", nil, "Failure preparing request")
		return
	}

	result, err = client.UpdateDhcpSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdateDhcp", result.Response(), "Failure sending request")
		return
	}

	return
}

// UpdateDhcpPreparer prepares the UpdateDhcp request.
func (client WorkloadNetworksClient) UpdateDhcpPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, dhcpID string, workloadNetworkDhcp WorkloadNetworkDhcp) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"dhcpId":            autorest.Encode("path", dhcpID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}", pathParameters),
		autorest.WithJSON(workloadNetworkDhcp),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDhcpSender sends the UpdateDhcp request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) UpdateDhcpSender(req *http.Request) (future WorkloadNetworksUpdateDhcpFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// UpdateDhcpResponder handles the response to the UpdateDhcp request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) UpdateDhcpResponder(resp *http.Response) (result WorkloadNetworkDhcp, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdatePortMirroring sends the update port mirroring request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// portMirroringID - NSX Port Mirroring identifier. Generally the same as the Port Mirroring display name
// workloadNetworkPortMirroring - NSX port mirroring
func (client WorkloadNetworksClient) UpdatePortMirroring(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring) (result WorkloadNetworksUpdatePortMirroringFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.UpdatePortMirroring")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "UpdatePortMirroring", err.Error())
	}

	req, err := client.UpdatePortMirroringPreparer(ctx, resourceGroupName, privateCloudName, portMirroringID, workloadNetworkPortMirroring)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdatePortMirroring", nil, "Failure preparing request")
		return
	}

	result, err = client.UpdatePortMirroringSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdatePortMirroring", result.Response(), "Failure sending request")
		return
	}

	return
}

// UpdatePortMirroringPreparer prepares the UpdatePortMirroring request.
func (client WorkloadNetworksClient) UpdatePortMirroringPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, portMirroringID string, workloadNetworkPortMirroring WorkloadNetworkPortMirroring) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"portMirroringId":   autorest.Encode("path", portMirroringID),
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}", pathParameters),
		autorest.WithJSON(workloadNetworkPortMirroring),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdatePortMirroringSender sends the UpdatePortMirroring request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) UpdatePortMirroringSender(req *http.Request) (future WorkloadNetworksUpdatePortMirroringFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// UpdatePortMirroringResponder handles the response to the UpdatePortMirroring request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) UpdatePortMirroringResponder(resp *http.Response) (result WorkloadNetworkPortMirroring, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateSegments sends the update segments request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// segmentID - NSX Segment identifier. Generally the same as the Segment's display name
// workloadNetworkSegment - NSX Segment
func (client WorkloadNetworksClient) UpdateSegments(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment) (result WorkloadNetworksUpdateSegmentsFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.UpdateSegments")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "UpdateSegments", err.Error())
	}

	req, err := client.UpdateSegmentsPreparer(ctx, resourceGroupName, privateCloudName, segmentID, workloadNetworkSegment)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdateSegments", nil, "Failure preparing request")
		return
	}

	result, err = client.UpdateSegmentsSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdateSegments", result.Response(), "Failure sending request")
		return
	}

	return
}

// UpdateSegmentsPreparer prepares the UpdateSegments request.
func (client WorkloadNetworksClient) UpdateSegmentsPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, segmentID string, workloadNetworkSegment WorkloadNetworkSegment) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"segmentId":         autorest.Encode("path", segmentID),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}", pathParameters),
		autorest.WithJSON(workloadNetworkSegment),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateSegmentsSender sends the UpdateSegments request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) UpdateSegmentsSender(req *http.Request) (future WorkloadNetworksUpdateSegmentsFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// UpdateSegmentsResponder handles the response to the UpdateSegments request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) UpdateSegmentsResponder(resp *http.Response) (result WorkloadNetworkSegment, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVMGroup sends the update vm group request.
// Parameters:
// resourceGroupName - the name of the resource group. The name is case insensitive.
// privateCloudName - name of the private cloud
// VMGroupID - NSX VM Group identifier. Generally the same as the VM Group's display name
// workloadNetworkVMGroup - NSX VM Group
func (client WorkloadNetworksClient) UpdateVMGroup(ctx context.Context, resourceGroupName string, privateCloudName string, VMGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup) (result WorkloadNetworksUpdateVMGroupFuture, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WorkloadNetworksClient.UpdateVMGroup")
		defer func() {
			sc := -1
			if result.Response() != nil {
				sc = result.Response().StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: resourceGroupName,
			Constraints: []validation.Constraint{{Target: "resourceGroupName", Name: validation.MaxLength, Rule: 90, Chain: nil},
				{Target: "resourceGroupName", Name: validation.MinLength, Rule: 1, Chain: nil},
				{Target: "resourceGroupName", Name: validation.Pattern, Rule: `^[-\w\._\(\)]+$`, Chain: nil}}}}); err != nil {
		return result, validation.NewError("avs.WorkloadNetworksClient", "UpdateVMGroup", err.Error())
	}

	req, err := client.UpdateVMGroupPreparer(ctx, resourceGroupName, privateCloudName, VMGroupID, workloadNetworkVMGroup)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdateVMGroup", nil, "Failure preparing request")
		return
	}

	result, err = client.UpdateVMGroupSender(req)
	if err != nil {
		err = autorest.NewErrorWithError(err, "avs.WorkloadNetworksClient", "UpdateVMGroup", result.Response(), "Failure sending request")
		return
	}

	return
}

// UpdateVMGroupPreparer prepares the UpdateVMGroup request.
func (client WorkloadNetworksClient) UpdateVMGroupPreparer(ctx context.Context, resourceGroupName string, privateCloudName string, VMGroupID string, workloadNetworkVMGroup WorkloadNetworkVMGroup) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"privateCloudName":  autorest.Encode("path", privateCloudName),
		"resourceGroupName": autorest.Encode("path", resourceGroupName),
		"subscriptionId":    autorest.Encode("path", client.SubscriptionID),
		"vmGroupId":         autorest.Encode("path", VMGroupID),
	}

	const APIVersion = "2020-07-17-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}", pathParameters),
		autorest.WithJSON(workloadNetworkVMGroup),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVMGroupSender sends the UpdateVMGroup request. The method will close the
// http.Response Body if it receives an error.
func (client WorkloadNetworksClient) UpdateVMGroupSender(req *http.Request) (future WorkloadNetworksUpdateVMGroupFuture, err error) {
	var resp *http.Response
	resp, err = client.Send(req, azure.DoRetryWithRegistration(client.Client))
	if err != nil {
		return
	}
	future.Future, err = azure.NewFutureFromResponse(resp)
	return
}

// UpdateVMGroupResponder handles the response to the UpdateVMGroup request. The method always
// closes the http.Response Body.
func (client WorkloadNetworksClient) UpdateVMGroupResponder(resp *http.Response) (result WorkloadNetworkVMGroup, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
