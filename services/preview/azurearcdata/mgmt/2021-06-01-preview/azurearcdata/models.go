package azurearcdata

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/azurearcdata/mgmt/2021-06-01-preview/azurearcdata"

// BasicLoginInformation username and password for basic login authentication.
type BasicLoginInformation struct {
	// Username - Login username.
	Username *string `json:"username,omitempty"`
	// Password - Login password.
	Password *string `json:"password,omitempty"`
}

// CommonSku the resource model definition representing SKU for ARM resources
type CommonSku struct {
	// Name - The name of the SKU.  It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Dev - Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose.
	Dev *bool `json:"dev,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// DataControllerProperties the data controller properties.
type DataControllerProperties struct {
	OnPremiseProperty *OnPremiseProperty `json:"onPremiseProperty,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw          interface{}      `json:"k8sRaw,omitempty"`
	UploadWatermark *UploadWatermark `json:"uploadWatermark,omitempty"`
	// LastUploadedDate - Last uploaded date from Kubernetes cluster. Defaults to current date time
	LastUploadedDate            *date.Time                   `json:"lastUploadedDate,omitempty"`
	BasicLoginInformation       *BasicLoginInformation       `json:"basicLoginInformation,omitempty"`
	LogAnalyticsWorkspaceConfig *LogAnalyticsWorkspaceConfig `json:"logAnalyticsWorkspaceConfig,omitempty"`
	UploadServicePrincipal      *UploadServicePrincipal      `json:"uploadServicePrincipal,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for DataControllerProperties.
func (dcp DataControllerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcp.OnPremiseProperty != nil {
		objectMap["onPremiseProperty"] = dcp.OnPremiseProperty
	}
	if dcp.K8sRaw != nil {
		objectMap["k8sRaw"] = dcp.K8sRaw
	}
	if dcp.UploadWatermark != nil {
		objectMap["uploadWatermark"] = dcp.UploadWatermark
	}
	if dcp.LastUploadedDate != nil {
		objectMap["lastUploadedDate"] = dcp.LastUploadedDate
	}
	if dcp.BasicLoginInformation != nil {
		objectMap["basicLoginInformation"] = dcp.BasicLoginInformation
	}
	if dcp.LogAnalyticsWorkspaceConfig != nil {
		objectMap["logAnalyticsWorkspaceConfig"] = dcp.LogAnalyticsWorkspaceConfig
	}
	if dcp.UploadServicePrincipal != nil {
		objectMap["uploadServicePrincipal"] = dcp.UploadServicePrincipal
	}
	return json.Marshal(objectMap)
}

// DataControllerResource data controller resource
type DataControllerResource struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Properties - The data controller's properties
	Properties *DataControllerProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataControllerResource.
func (dcr DataControllerResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcr.ExtendedLocation != nil {
		objectMap["extendedLocation"] = dcr.ExtendedLocation
	}
	if dcr.Properties != nil {
		objectMap["properties"] = dcr.Properties
	}
	if dcr.Tags != nil {
		objectMap["tags"] = dcr.Tags
	}
	if dcr.Location != nil {
		objectMap["location"] = dcr.Location
	}
	return json.Marshal(objectMap)
}

// DataControllersPutDataControllerFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DataControllersPutDataControllerFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DataControllersClient) (DataControllerResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DataControllersPutDataControllerFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DataControllersPutDataControllerFuture.Result.
func (future *DataControllersPutDataControllerFuture) result(client DataControllersClient) (dcr DataControllerResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.DataControllersPutDataControllerFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		dcr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.DataControllersPutDataControllerFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if dcr.Response.Response, err = future.GetResult(sender); err == nil && dcr.Response.Response.StatusCode != http.StatusNoContent {
		dcr, err = client.PutDataControllerResponder(dcr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.DataControllersPutDataControllerFuture", "Result", dcr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DataControllerUpdate used for updating a data controller resource.
type DataControllerUpdate struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for DataControllerUpdate.
func (dcu DataControllerUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dcu.Tags != nil {
		objectMap["tags"] = dcu.Tags
	}
	return json.Marshal(objectMap)
}

// ErrorResponse an error response from the Azure Data on Azure Arc service.
type ErrorResponse struct {
	// Error - null
	Error *ErrorResponseBody `json:"error,omitempty"`
}

// ErrorResponseBody an error response from the Batch service.
type ErrorResponseBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]ErrorResponseBody `json:"details,omitempty"`
}

// ExtendedLocation the complex type of the extended location.
type ExtendedLocation struct {
	// Name - The name of the extended location.
	Name *string `json:"name,omitempty"`
	// Type - The type of the extended location. Possible values include: 'CustomLocation'
	Type ExtendedLocationTypes `json:"type,omitempty"`
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// LogAnalyticsWorkspaceConfig log analytics workspace id and primary key
type LogAnalyticsWorkspaceConfig struct {
	// WorkspaceID - Azure Log Analytics workspace ID
	WorkspaceID *uuid.UUID `json:"workspaceId,omitempty"`
	// PrimaryKey - Primary key of the workspace
	PrimaryKey *string `json:"primaryKey,omitempty"`
}

// ODataError information about an error.
type ODataError struct {
	// Code - A language-independent error name.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Target - The target of the error (for example, the name of the property in error).
	Target *string `json:"target,omitempty"`
	// Details - The error details.
	Details *[]ODataError `json:"details,omitempty"`
}

// OnPremiseProperty properties from the Kubernetes data controller
type OnPremiseProperty struct {
	// ID - A globally unique ID identifying the associated Kubernetes cluster
	ID *uuid.UUID `json:"id,omitempty"`
	// PublicSigningKey - Certificate that contains the Kubernetes cluster public key used to verify signing
	PublicSigningKey *string `json:"publicSigningKey,omitempty"`
	// SigningCertificateThumbprint - Unique thumbprint returned to customer to verify the certificate being uploaded
	SigningCertificateThumbprint *string `json:"signingCertificateThumbprint,omitempty"`
}

// Operation azure Data Services on Azure Arc operation definition.
type Operation struct {
	// Name - The name of the operation being performed on this particular object.
	Name *string `json:"name,omitempty"`
	// Display - The localized display information for this particular operation / action.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation. Possible values include: 'OperationOriginUser', 'OperationOriginSystem'
	Origin OperationOrigin `json:"origin,omitempty"`
	// IsDataAction - Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Properties - READ-ONLY; Additional descriptions for the operation.
	Properties map[string]interface{} `json:"properties"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Name != nil {
		objectMap["name"] = o.Name
	}
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	if o.IsDataAction != nil {
		objectMap["isDataAction"] = o.IsDataAction
	}
	return json.Marshal(objectMap)
}

// OperationDisplay display metadata associated with the operation.
type OperationDisplay struct {
	// Provider - The localized friendly form of the resource provider name.
	Provider *string `json:"provider,omitempty"`
	// Resource - The localized friendly form of the resource type related to this action/operation.
	Resource *string `json:"resource,omitempty"`
	// Operation - The localized friendly name for the operation.
	Operation *string `json:"operation,omitempty"`
	// Description - The localized friendly description for the operation.
	Description *string `json:"description,omitempty"`
}

// OperationListResult result of the request to list Azure Data Services on Azure Arc operations.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// PageOfDataControllerResource ...
type PageOfDataControllerResource struct {
	autorest.Response `json:"-"`
	Value             *[]DataControllerResource `json:"value,omitempty"`
	// NextLink - Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// PageOfDataControllerResourceIterator provides access to a complete listing of DataControllerResource
// values.
type PageOfDataControllerResourceIterator struct {
	i    int
	page PageOfDataControllerResourcePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PageOfDataControllerResourceIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PageOfDataControllerResourceIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PageOfDataControllerResourceIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PageOfDataControllerResourceIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PageOfDataControllerResourceIterator) Response() PageOfDataControllerResource {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PageOfDataControllerResourceIterator) Value() DataControllerResource {
	if !iter.page.NotDone() {
		return DataControllerResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PageOfDataControllerResourceIterator type.
func NewPageOfDataControllerResourceIterator(page PageOfDataControllerResourcePage) PageOfDataControllerResourceIterator {
	return PageOfDataControllerResourceIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (podcr PageOfDataControllerResource) IsEmpty() bool {
	return podcr.Value == nil || len(*podcr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (podcr PageOfDataControllerResource) hasNextLink() bool {
	return podcr.NextLink != nil && len(*podcr.NextLink) != 0
}

// pageOfDataControllerResourcePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (podcr PageOfDataControllerResource) pageOfDataControllerResourcePreparer(ctx context.Context) (*http.Request, error) {
	if !podcr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(podcr.NextLink)))
}

// PageOfDataControllerResourcePage contains a page of DataControllerResource values.
type PageOfDataControllerResourcePage struct {
	fn    func(context.Context, PageOfDataControllerResource) (PageOfDataControllerResource, error)
	podcr PageOfDataControllerResource
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PageOfDataControllerResourcePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PageOfDataControllerResourcePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.podcr)
		if err != nil {
			return err
		}
		page.podcr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PageOfDataControllerResourcePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PageOfDataControllerResourcePage) NotDone() bool {
	return !page.podcr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PageOfDataControllerResourcePage) Response() PageOfDataControllerResource {
	return page.podcr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PageOfDataControllerResourcePage) Values() []DataControllerResource {
	if page.podcr.IsEmpty() {
		return nil
	}
	return *page.podcr.Value
}

// Creates a new instance of the PageOfDataControllerResourcePage type.
func NewPageOfDataControllerResourcePage(cur PageOfDataControllerResource, getNextPage func(context.Context, PageOfDataControllerResource) (PageOfDataControllerResource, error)) PageOfDataControllerResourcePage {
	return PageOfDataControllerResourcePage{
		fn:    getNextPage,
		podcr: cur,
	}
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// PostgresInstance a Postgres Instance.
type PostgresInstance struct {
	autorest.Response `json:"-"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Properties - null
	Properties *PostgresInstanceProperties `json:"properties,omitempty"`
	// Sku - Resource sku.
	Sku *PostgresInstanceSku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PostgresInstance.
func (pi PostgresInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pi.ExtendedLocation != nil {
		objectMap["extendedLocation"] = pi.ExtendedLocation
	}
	if pi.Properties != nil {
		objectMap["properties"] = pi.Properties
	}
	if pi.Sku != nil {
		objectMap["sku"] = pi.Sku
	}
	if pi.Tags != nil {
		objectMap["tags"] = pi.Tags
	}
	if pi.Location != nil {
		objectMap["location"] = pi.Location
	}
	return json.Marshal(objectMap)
}

// PostgresInstanceListResult a list of PostgresInstance.
type PostgresInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]PostgresInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PostgresInstanceListResult.
func (pilr PostgresInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PostgresInstanceListResultIterator provides access to a complete listing of PostgresInstance values.
type PostgresInstanceListResultIterator struct {
	i    int
	page PostgresInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PostgresInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PostgresInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PostgresInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PostgresInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PostgresInstanceListResultIterator) Response() PostgresInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PostgresInstanceListResultIterator) Value() PostgresInstance {
	if !iter.page.NotDone() {
		return PostgresInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PostgresInstanceListResultIterator type.
func NewPostgresInstanceListResultIterator(page PostgresInstanceListResultPage) PostgresInstanceListResultIterator {
	return PostgresInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pilr PostgresInstanceListResult) IsEmpty() bool {
	return pilr.Value == nil || len(*pilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pilr PostgresInstanceListResult) hasNextLink() bool {
	return pilr.NextLink != nil && len(*pilr.NextLink) != 0
}

// postgresInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pilr PostgresInstanceListResult) postgresInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pilr.NextLink)))
}

// PostgresInstanceListResultPage contains a page of PostgresInstance values.
type PostgresInstanceListResultPage struct {
	fn   func(context.Context, PostgresInstanceListResult) (PostgresInstanceListResult, error)
	pilr PostgresInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PostgresInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PostgresInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pilr)
		if err != nil {
			return err
		}
		page.pilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PostgresInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PostgresInstanceListResultPage) NotDone() bool {
	return !page.pilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PostgresInstanceListResultPage) Response() PostgresInstanceListResult {
	return page.pilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PostgresInstanceListResultPage) Values() []PostgresInstance {
	if page.pilr.IsEmpty() {
		return nil
	}
	return *page.pilr.Value
}

// Creates a new instance of the PostgresInstanceListResultPage type.
func NewPostgresInstanceListResultPage(cur PostgresInstanceListResult, getNextPage func(context.Context, PostgresInstanceListResult) (PostgresInstanceListResult, error)) PostgresInstanceListResultPage {
	return PostgresInstanceListResultPage{
		fn:   getNextPage,
		pilr: cur,
	}
}

// PostgresInstanceProperties postgres Instance properties.
type PostgresInstanceProperties struct {
	// DataControllerID - The data controller id
	DataControllerID *string `json:"dataControllerId,omitempty"`
	// Admin - The instance admin
	Admin *string `json:"admin,omitempty"`
	// BasicLoginInformation - Username and password for basic authentication.
	BasicLoginInformation *BasicLoginInformation `json:"basicLoginInformation,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw interface{} `json:"k8sRaw,omitempty"`
	// LastUploadedDate - Last uploaded date from Kubernetes cluster. Defaults to current date time
	LastUploadedDate *date.Time `json:"lastUploadedDate,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for PostgresInstanceProperties.
func (pip PostgresInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pip.DataControllerID != nil {
		objectMap["dataControllerId"] = pip.DataControllerID
	}
	if pip.Admin != nil {
		objectMap["admin"] = pip.Admin
	}
	if pip.BasicLoginInformation != nil {
		objectMap["basicLoginInformation"] = pip.BasicLoginInformation
	}
	if pip.K8sRaw != nil {
		objectMap["k8sRaw"] = pip.K8sRaw
	}
	if pip.LastUploadedDate != nil {
		objectMap["lastUploadedDate"] = pip.LastUploadedDate
	}
	return json.Marshal(objectMap)
}

// PostgresInstancesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PostgresInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PostgresInstancesClient) (PostgresInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PostgresInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PostgresInstancesCreateFuture.Result.
func (future *PostgresInstancesCreateFuture) result(client PostgresInstancesClient) (pi PostgresInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.PostgresInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.PostgresInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pi.Response.Response, err = future.GetResult(sender); err == nil && pi.Response.Response.StatusCode != http.StatusNoContent {
		pi, err = client.CreateResponder(pi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.PostgresInstancesCreateFuture", "Result", pi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PostgresInstanceSku the resource model definition representing SKU for Azure Database for PostgresSQL -
// Azure Arc
type PostgresInstanceSku struct {
	// Tier - This field is required to be implemented by the Resource Provider if the service has more than one tier. Possible values include: 'Hyperscale'
	Tier PostgresInstanceSkuTier `json:"tier,omitempty"`
	// Name - The name of the SKU.  It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Dev - Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose.
	Dev *bool `json:"dev,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// PostgresInstanceUpdate an update to a Postgres Instance.
type PostgresInstanceUpdate struct {
	// Tags - Resource tags.
	Tags       map[string]*string          `json:"tags"`
	Properties *PostgresInstanceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PostgresInstanceUpdate.
func (piu PostgresInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if piu.Tags != nil {
		objectMap["tags"] = piu.Tags
	}
	if piu.Properties != nil {
		objectMap["properties"] = piu.Properties
	}
	return json.Marshal(objectMap)
}

// ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
// required location and tags
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource ...
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceSku ...
type ResourceSku struct {
	Capacity *int32  `json:"capacity,omitempty"`
	Family   *string `json:"family,omitempty"`
	Name     *string `json:"name,omitempty"`
	Size     *string `json:"size,omitempty"`
	Tier     *string `json:"tier,omitempty"`
}

// SQLManagedInstance a SqlManagedInstance.
type SQLManagedInstance struct {
	autorest.Response `json:"-"`
	// Properties - null
	Properties *SQLManagedInstanceProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Sku - Resource sku.
	Sku *SQLManagedInstanceSku `json:"sku,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstance.
func (smi SQLManagedInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smi.Properties != nil {
		objectMap["properties"] = smi.Properties
	}
	if smi.ExtendedLocation != nil {
		objectMap["extendedLocation"] = smi.ExtendedLocation
	}
	if smi.Sku != nil {
		objectMap["sku"] = smi.Sku
	}
	if smi.Tags != nil {
		objectMap["tags"] = smi.Tags
	}
	if smi.Location != nil {
		objectMap["location"] = smi.Location
	}
	return json.Marshal(objectMap)
}

// SQLManagedInstanceListResult a list of SqlManagedInstance.
type SQLManagedInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]SQLManagedInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceListResult.
func (smilr SQLManagedInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SQLManagedInstanceListResultIterator provides access to a complete listing of SQLManagedInstance values.
type SQLManagedInstanceListResultIterator struct {
	i    int
	page SQLManagedInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SQLManagedInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLManagedInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SQLManagedInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SQLManagedInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SQLManagedInstanceListResultIterator) Response() SQLManagedInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SQLManagedInstanceListResultIterator) Value() SQLManagedInstance {
	if !iter.page.NotDone() {
		return SQLManagedInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SQLManagedInstanceListResultIterator type.
func NewSQLManagedInstanceListResultIterator(page SQLManagedInstanceListResultPage) SQLManagedInstanceListResultIterator {
	return SQLManagedInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (smilr SQLManagedInstanceListResult) IsEmpty() bool {
	return smilr.Value == nil || len(*smilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (smilr SQLManagedInstanceListResult) hasNextLink() bool {
	return smilr.NextLink != nil && len(*smilr.NextLink) != 0
}

// sQLManagedInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (smilr SQLManagedInstanceListResult) sQLManagedInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !smilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(smilr.NextLink)))
}

// SQLManagedInstanceListResultPage contains a page of SQLManagedInstance values.
type SQLManagedInstanceListResultPage struct {
	fn    func(context.Context, SQLManagedInstanceListResult) (SQLManagedInstanceListResult, error)
	smilr SQLManagedInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SQLManagedInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLManagedInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.smilr)
		if err != nil {
			return err
		}
		page.smilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SQLManagedInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SQLManagedInstanceListResultPage) NotDone() bool {
	return !page.smilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SQLManagedInstanceListResultPage) Response() SQLManagedInstanceListResult {
	return page.smilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SQLManagedInstanceListResultPage) Values() []SQLManagedInstance {
	if page.smilr.IsEmpty() {
		return nil
	}
	return *page.smilr.Value
}

// Creates a new instance of the SQLManagedInstanceListResultPage type.
func NewSQLManagedInstanceListResultPage(cur SQLManagedInstanceListResult, getNextPage func(context.Context, SQLManagedInstanceListResult) (SQLManagedInstanceListResult, error)) SQLManagedInstanceListResultPage {
	return SQLManagedInstanceListResultPage{
		fn:    getNextPage,
		smilr: cur,
	}
}

// SQLManagedInstanceProperties properties of sqlManagedInstance.
type SQLManagedInstanceProperties struct {
	// DataControllerID - null
	DataControllerID *string `json:"dataControllerId,omitempty"`
	// Admin - The instance admin user
	Admin *string `json:"admin,omitempty"`
	// StartTime - The instance start time
	StartTime *string `json:"startTime,omitempty"`
	// EndTime - The instance end time
	EndTime *string `json:"endTime,omitempty"`
	// K8sRaw - The raw kubernetes information
	K8sRaw interface{} `json:"k8sRaw,omitempty"`
	// BasicLoginInformation - Username and password for basic authentication.
	BasicLoginInformation *BasicLoginInformation `json:"basicLoginInformation,omitempty"`
	// LastUploadedDate - Last uploaded date from Kubernetes cluster. Defaults to current date time
	LastUploadedDate *date.Time `json:"lastUploadedDate,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceProperties.
func (smip SQLManagedInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smip.DataControllerID != nil {
		objectMap["dataControllerId"] = smip.DataControllerID
	}
	if smip.Admin != nil {
		objectMap["admin"] = smip.Admin
	}
	if smip.StartTime != nil {
		objectMap["startTime"] = smip.StartTime
	}
	if smip.EndTime != nil {
		objectMap["endTime"] = smip.EndTime
	}
	if smip.K8sRaw != nil {
		objectMap["k8sRaw"] = smip.K8sRaw
	}
	if smip.BasicLoginInformation != nil {
		objectMap["basicLoginInformation"] = smip.BasicLoginInformation
	}
	if smip.LastUploadedDate != nil {
		objectMap["lastUploadedDate"] = smip.LastUploadedDate
	}
	return json.Marshal(objectMap)
}

// SQLManagedInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SQLManagedInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SQLManagedInstancesClient) (SQLManagedInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SQLManagedInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SQLManagedInstancesCreateFuture.Result.
func (future *SQLManagedInstancesCreateFuture) result(client SQLManagedInstancesClient) (smi SQLManagedInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.SQLManagedInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		smi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.SQLManagedInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if smi.Response.Response, err = future.GetResult(sender); err == nil && smi.Response.Response.StatusCode != http.StatusNoContent {
		smi, err = client.CreateResponder(smi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.SQLManagedInstancesCreateFuture", "Result", smi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SQLManagedInstanceSku the resource model definition representing SKU for Azure Managed Instance - Azure
// Arc
type SQLManagedInstanceSku struct {
	// Tier - This field is required to be implemented by the Resource Provider if the service has more than one tier. Possible values include: 'GeneralPurpose', 'BusinessCritical'
	Tier SQLManagedInstanceSkuTier `json:"tier,omitempty"`
	// Name - The name of the SKU.  It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Dev - Whether dev/test is enabled. When the dev field is set to true, the resource is used for dev/test purpose.
	Dev *bool `json:"dev,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// SQLManagedInstanceUpdate an update to a SQL Managed Instance.
type SQLManagedInstanceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SQLManagedInstanceUpdate.
func (smiu SQLManagedInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if smiu.Tags != nil {
		objectMap["tags"] = smiu.Tags
	}
	return json.Marshal(objectMap)
}

// SQLServerInstance a SqlServerInstance.
type SQLServerInstance struct {
	autorest.Response `json:"-"`
	// Properties - null
	Properties *SQLServerInstanceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstance.
func (ssi SQLServerInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssi.Properties != nil {
		objectMap["properties"] = ssi.Properties
	}
	if ssi.Tags != nil {
		objectMap["tags"] = ssi.Tags
	}
	if ssi.Location != nil {
		objectMap["location"] = ssi.Location
	}
	return json.Marshal(objectMap)
}

// SQLServerInstanceListResult a list of SqlServerInstance.
type SQLServerInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; Array of results.
	Value *[]SQLServerInstance `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceListResult.
func (ssilr SQLServerInstanceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SQLServerInstanceListResultIterator provides access to a complete listing of SQLServerInstance values.
type SQLServerInstanceListResultIterator struct {
	i    int
	page SQLServerInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SQLServerInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLServerInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SQLServerInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SQLServerInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SQLServerInstanceListResultIterator) Response() SQLServerInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SQLServerInstanceListResultIterator) Value() SQLServerInstance {
	if !iter.page.NotDone() {
		return SQLServerInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SQLServerInstanceListResultIterator type.
func NewSQLServerInstanceListResultIterator(page SQLServerInstanceListResultPage) SQLServerInstanceListResultIterator {
	return SQLServerInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssilr SQLServerInstanceListResult) IsEmpty() bool {
	return ssilr.Value == nil || len(*ssilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssilr SQLServerInstanceListResult) hasNextLink() bool {
	return ssilr.NextLink != nil && len(*ssilr.NextLink) != 0
}

// sQLServerInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssilr SQLServerInstanceListResult) sQLServerInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ssilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssilr.NextLink)))
}

// SQLServerInstanceListResultPage contains a page of SQLServerInstance values.
type SQLServerInstanceListResultPage struct {
	fn    func(context.Context, SQLServerInstanceListResult) (SQLServerInstanceListResult, error)
	ssilr SQLServerInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SQLServerInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SQLServerInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssilr)
		if err != nil {
			return err
		}
		page.ssilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SQLServerInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SQLServerInstanceListResultPage) NotDone() bool {
	return !page.ssilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SQLServerInstanceListResultPage) Response() SQLServerInstanceListResult {
	return page.ssilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SQLServerInstanceListResultPage) Values() []SQLServerInstance {
	if page.ssilr.IsEmpty() {
		return nil
	}
	return *page.ssilr.Value
}

// Creates a new instance of the SQLServerInstanceListResultPage type.
func NewSQLServerInstanceListResultPage(cur SQLServerInstanceListResult, getNextPage func(context.Context, SQLServerInstanceListResult) (SQLServerInstanceListResult, error)) SQLServerInstanceListResultPage {
	return SQLServerInstanceListResultPage{
		fn:    getNextPage,
		ssilr: cur,
	}
}

// SQLServerInstanceProperties properties of SqlServerInstance.
type SQLServerInstanceProperties struct {
	// Version - SQL Server version.
	Version *string `json:"version,omitempty"`
	// Edition - SQL Server edition.
	Edition *string `json:"edition,omitempty"`
	// ContainerResourceID - ARM Resource id of the container resource (Azure Arc for Servers).
	ContainerResourceID *string `json:"containerResourceId,omitempty"`
	// CreateTime - READ-ONLY; The time when the resource was created.
	CreateTime *string `json:"createTime,omitempty"`
	// VCore - The number of logical processors used by the SQL Server instance.
	VCore *string `json:"vCore,omitempty"`
	// Status - The cloud connectivity status.
	Status *string `json:"status,omitempty"`
	// PatchLevel - SQL Server update level.
	PatchLevel *string `json:"patchLevel,omitempty"`
	// Collation - SQL Server collation.
	Collation *string `json:"collation,omitempty"`
	// CurrentVersion - SQL Server current version.
	CurrentVersion *string `json:"currentVersion,omitempty"`
	// InstanceName - SQL Server instance name.
	InstanceName *string `json:"instanceName,omitempty"`
	// TCPDynamicPorts - Dynamic TCP ports used by SQL Server.
	TCPDynamicPorts *string `json:"tcpDynamicPorts,omitempty"`
	// TCPStaticPorts - Static TCP ports used by SQL Server.
	TCPStaticPorts *string `json:"tcpStaticPorts,omitempty"`
	// ProductID - SQL Server product ID.
	ProductID *string `json:"productId,omitempty"`
	// LicenseType - SQL Server license type.
	LicenseType *string `json:"licenseType,omitempty"`
	// ProvisioningState - READ-ONLY
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceProperties.
func (ssip SQLServerInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssip.Version != nil {
		objectMap["version"] = ssip.Version
	}
	if ssip.Edition != nil {
		objectMap["edition"] = ssip.Edition
	}
	if ssip.ContainerResourceID != nil {
		objectMap["containerResourceId"] = ssip.ContainerResourceID
	}
	if ssip.VCore != nil {
		objectMap["vCore"] = ssip.VCore
	}
	if ssip.Status != nil {
		objectMap["status"] = ssip.Status
	}
	if ssip.PatchLevel != nil {
		objectMap["patchLevel"] = ssip.PatchLevel
	}
	if ssip.Collation != nil {
		objectMap["collation"] = ssip.Collation
	}
	if ssip.CurrentVersion != nil {
		objectMap["currentVersion"] = ssip.CurrentVersion
	}
	if ssip.InstanceName != nil {
		objectMap["instanceName"] = ssip.InstanceName
	}
	if ssip.TCPDynamicPorts != nil {
		objectMap["tcpDynamicPorts"] = ssip.TCPDynamicPorts
	}
	if ssip.TCPStaticPorts != nil {
		objectMap["tcpStaticPorts"] = ssip.TCPStaticPorts
	}
	if ssip.ProductID != nil {
		objectMap["productId"] = ssip.ProductID
	}
	if ssip.LicenseType != nil {
		objectMap["licenseType"] = ssip.LicenseType
	}
	return json.Marshal(objectMap)
}

// SQLServerInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SQLServerInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SQLServerInstancesClient) (SQLServerInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SQLServerInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SQLServerInstancesCreateFuture.Result.
func (future *SQLServerInstancesCreateFuture) result(client SQLServerInstancesClient) (ssi SQLServerInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurearcdata.SQLServerInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurearcdata.SQLServerInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssi.Response.Response, err = future.GetResult(sender); err == nil && ssi.Response.Response.StatusCode != http.StatusNoContent {
		ssi, err = client.CreateResponder(ssi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurearcdata.SQLServerInstancesCreateFuture", "Result", ssi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SQLServerInstanceUpdate an update to a SQL Server Instance.
type SQLServerInstanceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for SQLServerInstanceUpdate.
func (ssiu SQLServerInstanceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssiu.Tags != nil {
		objectMap["tags"] = ssiu.Tags
	}
	return json.Marshal(objectMap)
}

// SystemData read only system data
type SystemData struct {
	// CreatedBy - An identifier for the identity that created the resource
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType IdentityType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC)
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - An identifier for the identity that last modified the resource
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType IdentityType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for a ARM tracked top level resource
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// UploadServicePrincipal service principal for uploading billing, metrics and logs.
type UploadServicePrincipal struct {
	// ClientID - Client ID of the service principal for uploading data.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
	// TenantID - Tenant ID of the service principal.
	TenantID *uuid.UUID `json:"tenantId,omitempty"`
	// Authority - Authority for the service principal. Example: https://login.microsoftonline.com/
	Authority *string `json:"authority,omitempty"`
	// ClientSecret - Secret of the service principal
	ClientSecret *string `json:"clientSecret,omitempty"`
}

// UploadWatermark properties on upload watermark.  Mostly timestamp for each upload data type
type UploadWatermark struct {
	// Metrics - Last uploaded date for metrics from kubernetes cluster. Defaults to current date time
	Metrics *date.Time `json:"metrics,omitempty"`
	// Logs - Last uploaded date for logs from kubernetes cluster. Defaults to current date time
	Logs *date.Time `json:"logs,omitempty"`
	// Usages - Last uploaded date for usages from kubernetes cluster. Defaults to current date time
	Usages *date.Time `json:"usages,omitempty"`
}
