package billing

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// ReservationsClient is the billing client provides access to billing resources for Azure subscriptions.
type ReservationsClient struct {
	BaseClient
}

// NewReservationsClient creates an instance of the ReservationsClient client.
func NewReservationsClient(subscriptionID string) ReservationsClient {
	return NewReservationsClientWithBaseURI(DefaultBaseURI, subscriptionID)
}

// NewReservationsClientWithBaseURI creates an instance of the ReservationsClient client using a custom endpoint.  Use
// this when interacting with an Azure cloud that uses a non-standard base URI (sovereign clouds, Azure stack).
func NewReservationsClientWithBaseURI(baseURI string, subscriptionID string) ReservationsClient {
	return ReservationsClient{NewWithBaseURI(baseURI, subscriptionID)}
}

// ListByBillingAccount lists the reservations for a billing account and the roll up counts of reservations group by
// provisioning states.
// Parameters:
// billingAccountName - the ID that uniquely identifies a billing account.
// filter - may be used to filter by reservation properties. The filter supports 'eq', 'or', and 'and'. It does
// not currently support 'ne', 'gt', 'le', 'ge', or 'not'.
// orderby - may be used to sort order by reservation properties.
// refreshSummary - to indicate whether to refresh the roll up counts of the reservations group by provisioning
// states
// selectedState - the selected provisioning state
func (client ReservationsClient) ListByBillingAccount(ctx context.Context, billingAccountName string, filter string, orderby string, refreshSummary string, selectedState string) (result ReservationsListResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ReservationsClient.ListByBillingAccount")
		defer func() {
			sc := -1
			if result.rlr.Response.Response != nil {
				sc = result.rlr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listByBillingAccountNextResults
	req, err := client.ListByBillingAccountPreparer(ctx, billingAccountName, filter, orderby, refreshSummary, selectedState)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "ListByBillingAccount", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListByBillingAccountSender(req)
	if err != nil {
		result.rlr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "ListByBillingAccount", resp, "Failure sending request")
		return
	}

	result.rlr, err = client.ListByBillingAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "ListByBillingAccount", resp, "Failure responding to request")
		return
	}
	if result.rlr.hasNextLink() && result.rlr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListByBillingAccountPreparer prepares the ListByBillingAccount request.
func (client ReservationsClient) ListByBillingAccountPreparer(ctx context.Context, billingAccountName string, filter string, orderby string, refreshSummary string, selectedState string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"billingAccountName": autorest.Encode("path", billingAccountName),
	}

	const APIVersion = "2020-05-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if len(refreshSummary) > 0 {
		queryParameters["refreshSummary"] = autorest.Encode("query", refreshSummary)
	}
	if len(selectedState) > 0 {
		queryParameters["selectedState"] = autorest.Encode("query", selectedState)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/reservations", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListByBillingAccountSender sends the ListByBillingAccount request. The method will close the
// http.Response Body if it receives an error.
func (client ReservationsClient) ListByBillingAccountSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListByBillingAccountResponder handles the response to the ListByBillingAccount request. The method always
// closes the http.Response Body.
func (client ReservationsClient) ListByBillingAccountResponder(resp *http.Response) (result ReservationsListResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listByBillingAccountNextResults retrieves the next set of results, if any.
func (client ReservationsClient) listByBillingAccountNextResults(ctx context.Context, lastResults ReservationsListResult) (result ReservationsListResult, err error) {
	req, err := lastResults.reservationsListResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "billing.ReservationsClient", "listByBillingAccountNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListByBillingAccountSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "billing.ReservationsClient", "listByBillingAccountNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListByBillingAccountResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "listByBillingAccountNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListByBillingAccountComplete enumerates all values, automatically crossing page boundaries as required.
func (client ReservationsClient) ListByBillingAccountComplete(ctx context.Context, billingAccountName string, filter string, orderby string, refreshSummary string, selectedState string) (result ReservationsListResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ReservationsClient.ListByBillingAccount")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListByBillingAccount(ctx, billingAccountName, filter, orderby, refreshSummary, selectedState)
	return
}

// ListByBillingProfile lists the reservations for a billing profile and the roll up counts of reservations group by
// provisioning state.
// Parameters:
// billingAccountName - the ID that uniquely identifies a billing account.
// billingProfileName - the ID that uniquely identifies a billing profile.
// filter - may be used to filter by reservation properties. The filter supports 'eq', 'or', and 'and'. It does
// not currently support 'ne', 'gt', 'le', 'ge', or 'not'.
// orderby - may be used to sort order by reservation properties.
// refreshSummary - to indicate whether to refresh the roll up counts of the reservations group by provisioning
// state
// selectedState - the selected provisioning state
func (client ReservationsClient) ListByBillingProfile(ctx context.Context, billingAccountName string, billingProfileName string, filter string, orderby string, refreshSummary string, selectedState string) (result ReservationsListResultPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ReservationsClient.ListByBillingProfile")
		defer func() {
			sc := -1
			if result.rlr.Response.Response != nil {
				sc = result.rlr.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.fn = client.listByBillingProfileNextResults
	req, err := client.ListByBillingProfilePreparer(ctx, billingAccountName, billingProfileName, filter, orderby, refreshSummary, selectedState)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "ListByBillingProfile", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListByBillingProfileSender(req)
	if err != nil {
		result.rlr.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "ListByBillingProfile", resp, "Failure sending request")
		return
	}

	result.rlr, err = client.ListByBillingProfileResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "ListByBillingProfile", resp, "Failure responding to request")
		return
	}
	if result.rlr.hasNextLink() && result.rlr.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListByBillingProfilePreparer prepares the ListByBillingProfile request.
func (client ReservationsClient) ListByBillingProfilePreparer(ctx context.Context, billingAccountName string, billingProfileName string, filter string, orderby string, refreshSummary string, selectedState string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"billingAccountName": autorest.Encode("path", billingAccountName),
		"billingProfileName": autorest.Encode("path", billingProfileName),
	}

	const APIVersion = "2020-05-01"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(filter) > 0 {
		queryParameters["$filter"] = autorest.Encode("query", filter)
	}
	if len(orderby) > 0 {
		queryParameters["$orderby"] = autorest.Encode("query", orderby)
	}
	if len(refreshSummary) > 0 {
		queryParameters["refreshSummary"] = autorest.Encode("query", refreshSummary)
	}
	if len(selectedState) > 0 {
		queryParameters["selectedState"] = autorest.Encode("query", selectedState)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/providers/Microsoft.Billing/billingAccounts/{billingAccountName}/billingProfiles/{billingProfileName}/reservations", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListByBillingProfileSender sends the ListByBillingProfile request. The method will close the
// http.Response Body if it receives an error.
func (client ReservationsClient) ListByBillingProfileSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// ListByBillingProfileResponder handles the response to the ListByBillingProfile request. The method always
// closes the http.Response Body.
func (client ReservationsClient) ListByBillingProfileResponder(resp *http.Response) (result ReservationsListResult, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listByBillingProfileNextResults retrieves the next set of results, if any.
func (client ReservationsClient) listByBillingProfileNextResults(ctx context.Context, lastResults ReservationsListResult) (result ReservationsListResult, err error) {
	req, err := lastResults.reservationsListResultPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "billing.ReservationsClient", "listByBillingProfileNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListByBillingProfileSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "billing.ReservationsClient", "listByBillingProfileNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListByBillingProfileResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.ReservationsClient", "listByBillingProfileNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListByBillingProfileComplete enumerates all values, automatically crossing page boundaries as required.
func (client ReservationsClient) ListByBillingProfileComplete(ctx context.Context, billingAccountName string, billingProfileName string, filter string, orderby string, refreshSummary string, selectedState string) (result ReservationsListResultIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ReservationsClient.ListByBillingProfile")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListByBillingProfile(ctx, billingAccountName, billingProfileName, filter, orderby, refreshSummary, selectedState)
	return
}
