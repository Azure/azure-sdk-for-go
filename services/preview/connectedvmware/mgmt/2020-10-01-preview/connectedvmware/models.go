package connectedvmware

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/connectedvmware/mgmt/2020-10-01-preview/connectedvmware"

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Cluster define the cluster.
type Cluster struct {
	autorest.Response `json:"-"`
	// ClusterProperties - Resource properties.
	*ClusterProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.ClusterProperties != nil {
		objectMap["properties"] = c.ClusterProperties
	}
	if c.Location != nil {
		objectMap["location"] = c.Location
	}
	if c.ExtendedLocation != nil {
		objectMap["extendedLocation"] = c.ExtendedLocation
	}
	if c.SystemData != nil {
		objectMap["systemData"] = c.SystemData
	}
	if c.Tags != nil {
		objectMap["tags"] = c.Tags
	}
	if c.Kind != nil {
		objectMap["kind"] = c.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Cluster struct.
func (c *Cluster) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var clusterProperties ClusterProperties
				err = json.Unmarshal(*v, &clusterProperties)
				if err != nil {
					return err
				}
				c.ClusterProperties = &clusterProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				c.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				c.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				c.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				c.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				c.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				c.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				c.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				c.Kind = &kind
			}
		}
	}

	return nil
}

// ClusterInventoryItem the cluster inventory item.
type ClusterInventoryItem struct {
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for ClusterInventoryItem.
func (cii ClusterInventoryItem) MarshalJSON() ([]byte, error) {
	cii.InventoryType = InventoryTypeCluster1
	objectMap := make(map[string]interface{})
	if cii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = cii.ManagedResourceID
	}
	if cii.MoRefID != nil {
		objectMap["moRefId"] = cii.MoRefID
	}
	if cii.MoName != nil {
		objectMap["moName"] = cii.MoName
	}
	if cii.InventoryType != "" {
		objectMap["inventoryType"] = cii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return &cii, true
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for ClusterInventoryItem.
func (cii ClusterInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &cii, true
}

// ClusterProperties defines the resource properties.
type ClusterProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this cluster resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the cluster.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the cluster.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the cluster.
	MoName *string `json:"moName,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// DatastoreIds - READ-ONLY; Gets or sets the datastore ARM ids.
	DatastoreIds *[]string `json:"datastoreIds,omitempty"`
	// NetworkIds - READ-ONLY; Gets or sets the network ARM ids.
	NetworkIds *[]string `json:"networkIds,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ClusterProperties.
func (cp ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.VCenterID != nil {
		objectMap["vCenterId"] = cp.VCenterID
	}
	if cp.MoRefID != nil {
		objectMap["moRefId"] = cp.MoRefID
	}
	if cp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = cp.InventoryItemID
	}
	return json.Marshal(objectMap)
}

// ClustersCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ClustersCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ClustersClient) (Cluster, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ClustersCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ClustersCreateFuture.Result.
func (future *ClustersCreateFuture) result(client ClustersClient) (c Cluster, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.ClustersCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		c.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.ClustersCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if c.Response.Response, err = future.GetResult(sender); err == nil && c.Response.Response.StatusCode != http.StatusNoContent {
		c, err = client.CreateResponder(c.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.ClustersCreateFuture", "Result", c.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ClustersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ClustersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ClustersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ClustersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ClustersDeleteFuture.Result.
func (future *ClustersDeleteFuture) result(client ClustersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.ClustersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.ClustersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ClustersList list of Clusters.
type ClustersList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of Clusters.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of Clusters
	Value *[]Cluster `json:"value,omitempty"`
}

// ClustersListIterator provides access to a complete listing of Cluster values.
type ClustersListIterator struct {
	i    int
	page ClustersListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ClustersListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ClustersListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ClustersListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ClustersListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ClustersListIterator) Response() ClustersList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ClustersListIterator) Value() Cluster {
	if !iter.page.NotDone() {
		return Cluster{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ClustersListIterator type.
func NewClustersListIterator(page ClustersListPage) ClustersListIterator {
	return ClustersListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (cl ClustersList) IsEmpty() bool {
	return cl.Value == nil || len(*cl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (cl ClustersList) hasNextLink() bool {
	return cl.NextLink != nil && len(*cl.NextLink) != 0
}

// clustersListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (cl ClustersList) clustersListPreparer(ctx context.Context) (*http.Request, error) {
	if !cl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(cl.NextLink)))
}

// ClustersListPage contains a page of Cluster values.
type ClustersListPage struct {
	fn func(context.Context, ClustersList) (ClustersList, error)
	cl ClustersList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ClustersListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ClustersListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.cl)
		if err != nil {
			return err
		}
		page.cl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ClustersListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ClustersListPage) NotDone() bool {
	return !page.cl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ClustersListPage) Response() ClustersList {
	return page.cl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ClustersListPage) Values() []Cluster {
	if page.cl.IsEmpty() {
		return nil
	}
	return *page.cl.Value
}

// Creates a new instance of the ClustersListPage type.
func NewClustersListPage(cur ClustersList, getNextPage func(context.Context, ClustersList) (ClustersList, error)) ClustersListPage {
	return ClustersListPage{
		fn: getNextPage,
		cl: cur,
	}
}

// Condition condition defines an extension to status.
type Condition struct {
	// Status - READ-ONLY; Status of the condition.
	Status *string `json:"status,omitempty"`
	// Reason - READ-ONLY; The reason for the condition's status.
	Reason *string `json:"reason,omitempty"`
	// Message - READ-ONLY; A human readable message indicating details about the status.
	Message *string `json:"message,omitempty"`
	// Severity - READ-ONLY; Severity with which to treat failures of this type of condition.
	Severity *string `json:"severity,omitempty"`
}

// MarshalJSON is the custom marshaler for Condition.
func (c Condition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Datastore define the datastore.
type Datastore struct {
	autorest.Response `json:"-"`
	// DatastoreProperties - Resource properties.
	*DatastoreProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for Datastore.
func (d Datastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.DatastoreProperties != nil {
		objectMap["properties"] = d.DatastoreProperties
	}
	if d.Location != nil {
		objectMap["location"] = d.Location
	}
	if d.ExtendedLocation != nil {
		objectMap["extendedLocation"] = d.ExtendedLocation
	}
	if d.SystemData != nil {
		objectMap["systemData"] = d.SystemData
	}
	if d.Tags != nil {
		objectMap["tags"] = d.Tags
	}
	if d.Kind != nil {
		objectMap["kind"] = d.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Datastore struct.
func (d *Datastore) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var datastoreProperties DatastoreProperties
				err = json.Unmarshal(*v, &datastoreProperties)
				if err != nil {
					return err
				}
				d.DatastoreProperties = &datastoreProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				d.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				d.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				d.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				d.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				d.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				d.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				d.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				d.Kind = &kind
			}
		}
	}

	return nil
}

// DatastoreInventoryItem the datastore inventory item.
type DatastoreInventoryItem struct {
	// CapacityGB - Gets or sets Maximum capacity of this datastore, in GBs.
	CapacityGB *int64 `json:"capacityGB,omitempty"`
	// FreeSpaceGB - Gets or sets Available space of this datastore, in GBs.
	FreeSpaceGB *int64 `json:"freeSpaceGB,omitempty"`
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) MarshalJSON() ([]byte, error) {
	dii.InventoryType = InventoryTypeDatastore1
	objectMap := make(map[string]interface{})
	if dii.CapacityGB != nil {
		objectMap["capacityGB"] = dii.CapacityGB
	}
	if dii.FreeSpaceGB != nil {
		objectMap["freeSpaceGB"] = dii.FreeSpaceGB
	}
	if dii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = dii.ManagedResourceID
	}
	if dii.MoRefID != nil {
		objectMap["moRefId"] = dii.MoRefID
	}
	if dii.MoName != nil {
		objectMap["moName"] = dii.MoName
	}
	if dii.InventoryType != "" {
		objectMap["inventoryType"] = dii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return &dii, true
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for DatastoreInventoryItem.
func (dii DatastoreInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &dii, true
}

// DatastoreProperties defines the resource properties.
type DatastoreProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this datastore resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the datastore.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the datastore.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the datastore.
	MoName *string `json:"moName,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the resource. Possible values include: 'Succeeded', 'Failed', 'Canceled', 'Provisioning', 'Updating', 'Deleting', 'Accepted', 'Created'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for DatastoreProperties.
func (dp DatastoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dp.VCenterID != nil {
		objectMap["vCenterId"] = dp.VCenterID
	}
	if dp.MoRefID != nil {
		objectMap["moRefId"] = dp.MoRefID
	}
	if dp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = dp.InventoryItemID
	}
	return json.Marshal(objectMap)
}

// DatastoresCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DatastoresCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DatastoresClient) (Datastore, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DatastoresCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DatastoresCreateFuture.Result.
func (future *DatastoresCreateFuture) result(client DatastoresClient) (d Datastore, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.DatastoresCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		d.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.DatastoresCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if d.Response.Response, err = future.GetResult(sender); err == nil && d.Response.Response.StatusCode != http.StatusNoContent {
		d, err = client.CreateResponder(d.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.DatastoresCreateFuture", "Result", d.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DatastoresDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type DatastoresDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DatastoresClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DatastoresDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DatastoresDeleteFuture.Result.
func (future *DatastoresDeleteFuture) result(client DatastoresClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.DatastoresDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.DatastoresDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DatastoresList list of Datastores.
type DatastoresList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of Datastores.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of Datastores
	Value *[]Datastore `json:"value,omitempty"`
}

// DatastoresListIterator provides access to a complete listing of Datastore values.
type DatastoresListIterator struct {
	i    int
	page DatastoresListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DatastoresListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DatastoresListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DatastoresListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DatastoresListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DatastoresListIterator) Response() DatastoresList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DatastoresListIterator) Value() Datastore {
	if !iter.page.NotDone() {
		return Datastore{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DatastoresListIterator type.
func NewDatastoresListIterator(page DatastoresListPage) DatastoresListIterator {
	return DatastoresListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (dl DatastoresList) IsEmpty() bool {
	return dl.Value == nil || len(*dl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (dl DatastoresList) hasNextLink() bool {
	return dl.NextLink != nil && len(*dl.NextLink) != 0
}

// datastoresListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (dl DatastoresList) datastoresListPreparer(ctx context.Context) (*http.Request, error) {
	if !dl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(dl.NextLink)))
}

// DatastoresListPage contains a page of Datastore values.
type DatastoresListPage struct {
	fn func(context.Context, DatastoresList) (DatastoresList, error)
	dl DatastoresList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DatastoresListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DatastoresListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.dl)
		if err != nil {
			return err
		}
		page.dl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DatastoresListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DatastoresListPage) NotDone() bool {
	return !page.dl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DatastoresListPage) Response() DatastoresList {
	return page.dl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DatastoresListPage) Values() []Datastore {
	if page.dl.IsEmpty() {
		return nil
	}
	return *page.dl.Value
}

// Creates a new instance of the DatastoresListPage type.
func NewDatastoresListPage(cur DatastoresList, getNextPage func(context.Context, DatastoresList) (DatastoresList, error)) DatastoresListPage {
	return DatastoresListPage{
		fn: getNextPage,
		dl: cur,
	}
}

// ErrorDefinition error definition.
type ErrorDefinition struct {
	// Code - READ-ONLY; Service specific error code which serves as the substatus for the HTTP error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Description of the error.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; Internal error details.
	Details *[]ErrorDefinition `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDefinition.
func (ed ErrorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail ...
type ErrorDetail struct {
	// Code - The error's code.
	Code *string `json:"code,omitempty"`
	// Message - A human readable error message.
	Message *string `json:"message,omitempty"`
	// Target - Indicates which property in the request is responsible for the error.
	Target *string `json:"target,omitempty"`
	// Details - Additional error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
}

// ErrorResponse error response.
type ErrorResponse struct {
	// Error - The error details.
	Error *ErrorDefinition `json:"error,omitempty"`
}

// ExtendedLocation the extended location.
type ExtendedLocation struct {
	// Type - The extended location type.
	Type *string `json:"type,omitempty"`
	// Name - The extended location name.
	Name *string `json:"name,omitempty"`
}

// GuestAgent defines the GuestAgent.
type GuestAgent struct {
	autorest.Response `json:"-"`
	// GuestAgentProperties - Resource properties.
	*GuestAgentProperties `json:"properties,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for GuestAgent.
func (ga GuestAgent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ga.GuestAgentProperties != nil {
		objectMap["properties"] = ga.GuestAgentProperties
	}
	if ga.SystemData != nil {
		objectMap["systemData"] = ga.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for GuestAgent struct.
func (ga *GuestAgent) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var guestAgentProperties GuestAgentProperties
				err = json.Unmarshal(*v, &guestAgentProperties)
				if err != nil {
					return err
				}
				ga.GuestAgentProperties = &guestAgentProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ga.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ga.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ga.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ga.Type = &typeVar
			}
		}
	}

	return nil
}

// GuestAgentList list of GuestAgent.
type GuestAgentList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of GuestAgent.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of GuestAgent
	Value *[]GuestAgent `json:"value,omitempty"`
}

// GuestAgentListIterator provides access to a complete listing of GuestAgent values.
type GuestAgentListIterator struct {
	i    int
	page GuestAgentListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *GuestAgentListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GuestAgentListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *GuestAgentListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter GuestAgentListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter GuestAgentListIterator) Response() GuestAgentList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter GuestAgentListIterator) Value() GuestAgent {
	if !iter.page.NotDone() {
		return GuestAgent{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the GuestAgentListIterator type.
func NewGuestAgentListIterator(page GuestAgentListPage) GuestAgentListIterator {
	return GuestAgentListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (gal GuestAgentList) IsEmpty() bool {
	return gal.Value == nil || len(*gal.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (gal GuestAgentList) hasNextLink() bool {
	return gal.NextLink != nil && len(*gal.NextLink) != 0
}

// guestAgentListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (gal GuestAgentList) guestAgentListPreparer(ctx context.Context) (*http.Request, error) {
	if !gal.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(gal.NextLink)))
}

// GuestAgentListPage contains a page of GuestAgent values.
type GuestAgentListPage struct {
	fn  func(context.Context, GuestAgentList) (GuestAgentList, error)
	gal GuestAgentList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *GuestAgentListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GuestAgentListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.gal)
		if err != nil {
			return err
		}
		page.gal = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *GuestAgentListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page GuestAgentListPage) NotDone() bool {
	return !page.gal.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page GuestAgentListPage) Response() GuestAgentList {
	return page.gal
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page GuestAgentListPage) Values() []GuestAgent {
	if page.gal.IsEmpty() {
		return nil
	}
	return *page.gal.Value
}

// Creates a new instance of the GuestAgentListPage type.
func NewGuestAgentListPage(cur GuestAgentList, getNextPage func(context.Context, GuestAgentList) (GuestAgentList, error)) GuestAgentListPage {
	return GuestAgentListPage{
		fn:  getNextPage,
		gal: cur,
	}
}

// GuestAgentProfile defines the resource properties.
type GuestAgentProfile struct {
	// VMUUID - READ-ONLY; Specifies the VM's unique SMBIOS ID.
	VMUUID *string `json:"vmUuid,omitempty"`
	// Status - READ-ONLY; The status of the hybrid machine agent. Possible values include: 'StatusTypesConnected', 'StatusTypesDisconnected', 'StatusTypesError'
	Status StatusTypes `json:"status,omitempty"`
	// LastStatusChange - READ-ONLY; The time of the last status change.
	LastStatusChange *date.Time `json:"lastStatusChange,omitempty"`
	// AgentVersion - READ-ONLY; The hybrid machine agent full version.
	AgentVersion *string `json:"agentVersion,omitempty"`
	// ErrorDetails - READ-ONLY; Details about the error state.
	ErrorDetails *[]ErrorDetail `json:"errorDetails,omitempty"`
}

// MarshalJSON is the custom marshaler for GuestAgentProfile.
func (gap GuestAgentProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// GuestAgentProperties defines the resource properties.
type GuestAgentProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// Credentials - Username / Password Credentials to provision guest agent.
	Credentials *GuestCredential `json:"credentials,omitempty"`
	// HTTPProxyConfig - HTTP Proxy configuration for the VM.
	HTTPProxyConfig *HTTPProxyConfiguration `json:"httpProxyConfig,omitempty"`
	// ProvisioningAction - Gets or sets the guest agent provisioning action. Possible values include: 'Install', 'Uninstall', 'Repair'
	ProvisioningAction ProvisioningAction `json:"provisioningAction,omitempty"`
	// Status - READ-ONLY; Gets or sets the guest agent status.
	Status *string `json:"status,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for GuestAgentProperties.
func (gap GuestAgentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gap.Credentials != nil {
		objectMap["credentials"] = gap.Credentials
	}
	if gap.HTTPProxyConfig != nil {
		objectMap["httpProxyConfig"] = gap.HTTPProxyConfig
	}
	if gap.ProvisioningAction != "" {
		objectMap["provisioningAction"] = gap.ProvisioningAction
	}
	return json.Marshal(objectMap)
}

// GuestAgentsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type GuestAgentsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(GuestAgentsClient) (GuestAgent, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GuestAgentsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GuestAgentsCreateFuture.Result.
func (future *GuestAgentsCreateFuture) result(client GuestAgentsClient) (ga GuestAgent, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.GuestAgentsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ga.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.GuestAgentsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ga.Response.Response, err = future.GetResult(sender); err == nil && ga.Response.Response.StatusCode != http.StatusNoContent {
		ga, err = client.CreateResponder(ga.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.GuestAgentsCreateFuture", "Result", ga.Response.Response, "Failure responding to request")
		}
	}
	return
}

// GuestAgentsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type GuestAgentsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(GuestAgentsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GuestAgentsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GuestAgentsDeleteFuture.Result.
func (future *GuestAgentsDeleteFuture) result(client GuestAgentsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.GuestAgentsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.GuestAgentsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// GuestCredential username / Password Credentials to connect to guest.
type GuestCredential struct {
	// Username - Gets or sets username to connect with the guest.
	Username *string `json:"username,omitempty"`
	// Password - Gets or sets the password to connect with the guest.
	Password *string `json:"password,omitempty"`
}

// HardwareProfile defines the resource properties.
type HardwareProfile struct {
	// MemorySizeMB - Gets or sets memory size in MBs for the vm.
	MemorySizeMB *int32 `json:"memorySizeMB,omitempty"`
	// NumCPUs - Gets or sets the number of vCPUs for the vm.
	NumCPUs *int32 `json:"numCPUs,omitempty"`
	// NumCoresPerSocket - Gets or sets the number of cores per socket for the vm. Defaults to 1 if unspecified.
	NumCoresPerSocket *int32 `json:"numCoresPerSocket,omitempty"`
	// CPUHotAddEnabled - READ-ONLY; Gets or sets a value indicating whether virtual processors can be added while this virtual machine is running.
	CPUHotAddEnabled *bool `json:"cpuHotAddEnabled,omitempty"`
	// CPUHotRemoveEnabled - READ-ONLY; Gets or sets a value indicating whether virtual processors can be removed while this virtual machine is running.
	CPUHotRemoveEnabled *bool `json:"cpuHotRemoveEnabled,omitempty"`
	// MemoryHotAddEnabled - READ-ONLY; Gets or sets a value indicating whether memory can be added while this virtual machine is running.
	MemoryHotAddEnabled *bool `json:"memoryHotAddEnabled,omitempty"`
}

// MarshalJSON is the custom marshaler for HardwareProfile.
func (hp HardwareProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hp.MemorySizeMB != nil {
		objectMap["memorySizeMB"] = hp.MemorySizeMB
	}
	if hp.NumCPUs != nil {
		objectMap["numCPUs"] = hp.NumCPUs
	}
	if hp.NumCoresPerSocket != nil {
		objectMap["numCoresPerSocket"] = hp.NumCoresPerSocket
	}
	return json.Marshal(objectMap)
}

// Host define the host.
type Host struct {
	autorest.Response `json:"-"`
	// HostProperties - Resource properties.
	*HostProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for Host.
func (h Host) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if h.HostProperties != nil {
		objectMap["properties"] = h.HostProperties
	}
	if h.Location != nil {
		objectMap["location"] = h.Location
	}
	if h.ExtendedLocation != nil {
		objectMap["extendedLocation"] = h.ExtendedLocation
	}
	if h.SystemData != nil {
		objectMap["systemData"] = h.SystemData
	}
	if h.Tags != nil {
		objectMap["tags"] = h.Tags
	}
	if h.Kind != nil {
		objectMap["kind"] = h.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Host struct.
func (h *Host) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hostProperties HostProperties
				err = json.Unmarshal(*v, &hostProperties)
				if err != nil {
					return err
				}
				h.HostProperties = &hostProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				h.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				h.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				h.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				h.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				h.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				h.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				h.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				h.Kind = &kind
			}
		}
	}

	return nil
}

// HostInventoryItem the host inventory item.
type HostInventoryItem struct {
	// Parent - Parent host inventory resource details.
	Parent *InventoryItemDetails `json:"parent,omitempty"`
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for HostInventoryItem.
func (hii HostInventoryItem) MarshalJSON() ([]byte, error) {
	hii.InventoryType = InventoryTypeHost1
	objectMap := make(map[string]interface{})
	if hii.Parent != nil {
		objectMap["parent"] = hii.Parent
	}
	if hii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = hii.ManagedResourceID
	}
	if hii.MoRefID != nil {
		objectMap["moRefId"] = hii.MoRefID
	}
	if hii.MoName != nil {
		objectMap["moName"] = hii.MoName
	}
	if hii.InventoryType != "" {
		objectMap["inventoryType"] = hii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return &hii, true
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for HostInventoryItem.
func (hii HostInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &hii, true
}

// HostProperties defines the resource properties.
type HostProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this host resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the host.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the host.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the host.
	MoName *string `json:"moName,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for HostProperties.
func (hp HostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if hp.VCenterID != nil {
		objectMap["vCenterId"] = hp.VCenterID
	}
	if hp.MoRefID != nil {
		objectMap["moRefId"] = hp.MoRefID
	}
	if hp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = hp.InventoryItemID
	}
	return json.Marshal(objectMap)
}

// HostsCreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type HostsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(HostsClient) (Host, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *HostsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for HostsCreateFuture.Result.
func (future *HostsCreateFuture) result(client HostsClient) (h Host, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.HostsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		h.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.HostsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if h.Response.Response, err = future.GetResult(sender); err == nil && h.Response.Response.StatusCode != http.StatusNoContent {
		h, err = client.CreateResponder(h.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.HostsCreateFuture", "Result", h.Response.Response, "Failure responding to request")
		}
	}
	return
}

// HostsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type HostsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(HostsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *HostsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for HostsDeleteFuture.Result.
func (future *HostsDeleteFuture) result(client HostsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.HostsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.HostsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// HostsList list of Hosts.
type HostsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of Hosts.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of Hosts
	Value *[]Host `json:"value,omitempty"`
}

// HostsListIterator provides access to a complete listing of Host values.
type HostsListIterator struct {
	i    int
	page HostsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *HostsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HostsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *HostsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter HostsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter HostsListIterator) Response() HostsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter HostsListIterator) Value() Host {
	if !iter.page.NotDone() {
		return Host{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the HostsListIterator type.
func NewHostsListIterator(page HostsListPage) HostsListIterator {
	return HostsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (hl HostsList) IsEmpty() bool {
	return hl.Value == nil || len(*hl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (hl HostsList) hasNextLink() bool {
	return hl.NextLink != nil && len(*hl.NextLink) != 0
}

// hostsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (hl HostsList) hostsListPreparer(ctx context.Context) (*http.Request, error) {
	if !hl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(hl.NextLink)))
}

// HostsListPage contains a page of Host values.
type HostsListPage struct {
	fn func(context.Context, HostsList) (HostsList, error)
	hl HostsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *HostsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HostsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.hl)
		if err != nil {
			return err
		}
		page.hl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *HostsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page HostsListPage) NotDone() bool {
	return !page.hl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page HostsListPage) Response() HostsList {
	return page.hl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page HostsListPage) Values() []Host {
	if page.hl.IsEmpty() {
		return nil
	}
	return *page.hl.Value
}

// Creates a new instance of the HostsListPage type.
func NewHostsListPage(cur HostsList, getNextPage func(context.Context, HostsList) (HostsList, error)) HostsListPage {
	return HostsListPage{
		fn: getNextPage,
		hl: cur,
	}
}

// HTTPProxyConfiguration HTTP Proxy configuration for the VM.
type HTTPProxyConfiguration struct {
	// HTTPSProxy - Gets or sets httpsProxy url.
	HTTPSProxy *string `json:"httpsProxy,omitempty"`
}

// HybridIdentityMetadata defines the HybridIdentityMetadata.
type HybridIdentityMetadata struct {
	autorest.Response `json:"-"`
	// HybridIdentityMetadataProperties - Resource properties.
	*HybridIdentityMetadataProperties `json:"properties,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridIdentityMetadata.
func (him HybridIdentityMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if him.HybridIdentityMetadataProperties != nil {
		objectMap["properties"] = him.HybridIdentityMetadataProperties
	}
	if him.SystemData != nil {
		objectMap["systemData"] = him.SystemData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for HybridIdentityMetadata struct.
func (him *HybridIdentityMetadata) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var hybridIdentityMetadataProperties HybridIdentityMetadataProperties
				err = json.Unmarshal(*v, &hybridIdentityMetadataProperties)
				if err != nil {
					return err
				}
				him.HybridIdentityMetadataProperties = &hybridIdentityMetadataProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				him.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				him.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				him.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				him.Type = &typeVar
			}
		}
	}

	return nil
}

// HybridIdentityMetadataList list of HybridIdentityMetadata.
type HybridIdentityMetadataList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of HybridIdentityMetadata.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of HybridIdentityMetadata
	Value *[]HybridIdentityMetadata `json:"value,omitempty"`
}

// HybridIdentityMetadataListIterator provides access to a complete listing of HybridIdentityMetadata
// values.
type HybridIdentityMetadataListIterator struct {
	i    int
	page HybridIdentityMetadataListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *HybridIdentityMetadataListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HybridIdentityMetadataListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *HybridIdentityMetadataListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter HybridIdentityMetadataListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter HybridIdentityMetadataListIterator) Response() HybridIdentityMetadataList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter HybridIdentityMetadataListIterator) Value() HybridIdentityMetadata {
	if !iter.page.NotDone() {
		return HybridIdentityMetadata{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the HybridIdentityMetadataListIterator type.
func NewHybridIdentityMetadataListIterator(page HybridIdentityMetadataListPage) HybridIdentityMetadataListIterator {
	return HybridIdentityMetadataListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (himl HybridIdentityMetadataList) IsEmpty() bool {
	return himl.Value == nil || len(*himl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (himl HybridIdentityMetadataList) hasNextLink() bool {
	return himl.NextLink != nil && len(*himl.NextLink) != 0
}

// hybridIdentityMetadataListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (himl HybridIdentityMetadataList) hybridIdentityMetadataListPreparer(ctx context.Context) (*http.Request, error) {
	if !himl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(himl.NextLink)))
}

// HybridIdentityMetadataListPage contains a page of HybridIdentityMetadata values.
type HybridIdentityMetadataListPage struct {
	fn   func(context.Context, HybridIdentityMetadataList) (HybridIdentityMetadataList, error)
	himl HybridIdentityMetadataList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *HybridIdentityMetadataListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/HybridIdentityMetadataListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.himl)
		if err != nil {
			return err
		}
		page.himl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *HybridIdentityMetadataListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page HybridIdentityMetadataListPage) NotDone() bool {
	return !page.himl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page HybridIdentityMetadataListPage) Response() HybridIdentityMetadataList {
	return page.himl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page HybridIdentityMetadataListPage) Values() []HybridIdentityMetadata {
	if page.himl.IsEmpty() {
		return nil
	}
	return *page.himl.Value
}

// Creates a new instance of the HybridIdentityMetadataListPage type.
func NewHybridIdentityMetadataListPage(cur HybridIdentityMetadataList, getNextPage func(context.Context, HybridIdentityMetadataList) (HybridIdentityMetadataList, error)) HybridIdentityMetadataListPage {
	return HybridIdentityMetadataListPage{
		fn:   getNextPage,
		himl: cur,
	}
}

// HybridIdentityMetadataProperties defines the resource properties.
type HybridIdentityMetadataProperties struct {
	// VMID - Gets or sets the Vm Id.
	VMID *string `json:"vmId,omitempty"`
	// PublicKey - Gets or sets the Public Key.
	PublicKey *string `json:"publicKey,omitempty"`
	// Identity - READ-ONLY; The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for HybridIdentityMetadataProperties.
func (himp HybridIdentityMetadataProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if himp.VMID != nil {
		objectMap["vmId"] = himp.VMID
	}
	if himp.PublicKey != nil {
		objectMap["publicKey"] = himp.PublicKey
	}
	return json.Marshal(objectMap)
}

// Identity managed service identity.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal id of managed service identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant of managed service identity.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The type of managed service identity. Possible values include: 'None', 'SystemAssigned'
	Type IdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// InventoryItem defines the inventory item.
type InventoryItem struct {
	autorest.Response `json:"-"`
	// BasicInventoryItemProperties - Resource properties.
	BasicInventoryItemProperties `json:"properties,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for InventoryItem.
func (ii InventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["properties"] = ii.BasicInventoryItemProperties
	if ii.SystemData != nil {
		objectMap["systemData"] = ii.SystemData
	}
	if ii.Kind != nil {
		objectMap["kind"] = ii.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InventoryItem struct.
func (ii *InventoryItem) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				basicInventoryItemProperties, err := unmarshalBasicInventoryItemProperties(*v)
				if err != nil {
					return err
				}
				ii.BasicInventoryItemProperties = basicInventoryItemProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ii.SystemData = &systemData
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				ii.Kind = &kind
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ii.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ii.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ii.Type = &typeVar
			}
		}
	}

	return nil
}

// InventoryItemDetails defines the resource properties.
type InventoryItemDetails struct {
	// InventoryItemID - Gets or sets the inventory Item ID for the resource.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the resource.
	MoName *string `json:"moName,omitempty"`
}

// BasicInventoryItemProperties defines the resource properties.
type BasicInventoryItemProperties interface {
	AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool)
	AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool)
	AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool)
	AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool)
	AsClusterInventoryItem() (*ClusterInventoryItem, bool)
	AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool)
	AsHostInventoryItem() (*HostInventoryItem, bool)
	AsInventoryItemProperties() (*InventoryItemProperties, bool)
}

// InventoryItemProperties defines the resource properties.
type InventoryItemProperties struct {
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

func unmarshalBasicInventoryItemProperties(body []byte) (BasicInventoryItemProperties, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["inventoryType"] {
	case string(InventoryTypeResourcePool1):
		var rpii ResourcePoolInventoryItem
		err := json.Unmarshal(body, &rpii)
		return rpii, err
	case string(InventoryTypeVirtualMachine1):
		var vmii VirtualMachineInventoryItem
		err := json.Unmarshal(body, &vmii)
		return vmii, err
	case string(InventoryTypeVirtualMachineTemplate1):
		var vmtii VirtualMachineTemplateInventoryItem
		err := json.Unmarshal(body, &vmtii)
		return vmtii, err
	case string(InventoryTypeVirtualNetwork1):
		var vnii VirtualNetworkInventoryItem
		err := json.Unmarshal(body, &vnii)
		return vnii, err
	case string(InventoryTypeCluster1):
		var cii ClusterInventoryItem
		err := json.Unmarshal(body, &cii)
		return cii, err
	case string(InventoryTypeDatastore1):
		var dii DatastoreInventoryItem
		err := json.Unmarshal(body, &dii)
		return dii, err
	case string(InventoryTypeHost1):
		var hii HostInventoryItem
		err := json.Unmarshal(body, &hii)
		return hii, err
	default:
		var iip InventoryItemProperties
		err := json.Unmarshal(body, &iip)
		return iip, err
	}
}
func unmarshalBasicInventoryItemPropertiesArray(body []byte) ([]BasicInventoryItemProperties, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	iipArray := make([]BasicInventoryItemProperties, len(rawMessages))

	for index, rawMessage := range rawMessages {
		iip, err := unmarshalBasicInventoryItemProperties(*rawMessage)
		if err != nil {
			return nil, err
		}
		iipArray[index] = iip
	}
	return iipArray, nil
}

// MarshalJSON is the custom marshaler for InventoryItemProperties.
func (iip InventoryItemProperties) MarshalJSON() ([]byte, error) {
	iip.InventoryType = InventoryTypeInventoryItemProperties
	objectMap := make(map[string]interface{})
	if iip.ManagedResourceID != nil {
		objectMap["managedResourceId"] = iip.ManagedResourceID
	}
	if iip.MoRefID != nil {
		objectMap["moRefId"] = iip.MoRefID
	}
	if iip.MoName != nil {
		objectMap["moName"] = iip.MoName
	}
	if iip.InventoryType != "" {
		objectMap["inventoryType"] = iip.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return &iip, true
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for InventoryItemProperties.
func (iip InventoryItemProperties) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &iip, true
}

// InventoryItemsList list of InventoryItems.
type InventoryItemsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of InventoryItems.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of InventoryItems
	Value *[]InventoryItem `json:"value,omitempty"`
}

// InventoryItemsListIterator provides access to a complete listing of InventoryItem values.
type InventoryItemsListIterator struct {
	i    int
	page InventoryItemsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *InventoryItemsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InventoryItemsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *InventoryItemsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter InventoryItemsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter InventoryItemsListIterator) Response() InventoryItemsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter InventoryItemsListIterator) Value() InventoryItem {
	if !iter.page.NotDone() {
		return InventoryItem{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the InventoryItemsListIterator type.
func NewInventoryItemsListIterator(page InventoryItemsListPage) InventoryItemsListIterator {
	return InventoryItemsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (iil InventoryItemsList) IsEmpty() bool {
	return iil.Value == nil || len(*iil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (iil InventoryItemsList) hasNextLink() bool {
	return iil.NextLink != nil && len(*iil.NextLink) != 0
}

// inventoryItemsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (iil InventoryItemsList) inventoryItemsListPreparer(ctx context.Context) (*http.Request, error) {
	if !iil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(iil.NextLink)))
}

// InventoryItemsListPage contains a page of InventoryItem values.
type InventoryItemsListPage struct {
	fn  func(context.Context, InventoryItemsList) (InventoryItemsList, error)
	iil InventoryItemsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *InventoryItemsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/InventoryItemsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.iil)
		if err != nil {
			return err
		}
		page.iil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *InventoryItemsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page InventoryItemsListPage) NotDone() bool {
	return !page.iil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page InventoryItemsListPage) Response() InventoryItemsList {
	return page.iil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page InventoryItemsListPage) Values() []InventoryItem {
	if page.iil.IsEmpty() {
		return nil
	}
	return *page.iil.Value
}

// Creates a new instance of the InventoryItemsListPage type.
func NewInventoryItemsListPage(cur InventoryItemsList, getNextPage func(context.Context, InventoryItemsList) (InventoryItemsList, error)) InventoryItemsListPage {
	return InventoryItemsListPage{
		fn:  getNextPage,
		iil: cur,
	}
}

// MachineExtension describes a Machine Extension.
type MachineExtension struct {
	autorest.Response `json:"-"`
	// MachineExtensionProperties - Describes Machine Extension Properties.
	*MachineExtensionProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MachineExtension.
func (me MachineExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if me.MachineExtensionProperties != nil {
		objectMap["properties"] = me.MachineExtensionProperties
	}
	if me.Location != nil {
		objectMap["location"] = me.Location
	}
	if me.SystemData != nil {
		objectMap["systemData"] = me.SystemData
	}
	if me.Tags != nil {
		objectMap["tags"] = me.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MachineExtension struct.
func (me *MachineExtension) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var machineExtensionProperties MachineExtensionProperties
				err = json.Unmarshal(*v, &machineExtensionProperties)
				if err != nil {
					return err
				}
				me.MachineExtensionProperties = &machineExtensionProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				me.Location = &location
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				me.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				me.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				me.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				me.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				me.Type = &typeVar
			}
		}
	}

	return nil
}

// MachineExtensionInstanceView describes the Machine Extension Instance View.
type MachineExtensionInstanceView struct {
	// Name - READ-ONLY; The machine extension name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`
	// TypeHandlerVersion - READ-ONLY; Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
	// Status - Instance view status.
	Status *MachineExtensionInstanceViewStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for MachineExtensionInstanceView.
func (meiv MachineExtensionInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if meiv.Status != nil {
		objectMap["status"] = meiv.Status
	}
	return json.Marshal(objectMap)
}

// MachineExtensionInstanceViewStatus instance view status.
type MachineExtensionInstanceViewStatus struct {
	// Code - READ-ONLY; The status code.
	Code *string `json:"code,omitempty"`
	// Level - READ-ONLY; The level code. Possible values include: 'Info', 'Warning', 'Error'
	Level StatusLevelTypes `json:"level,omitempty"`
	// DisplayStatus - READ-ONLY; The short localizable label for the status.
	DisplayStatus *string `json:"displayStatus,omitempty"`
	// Message - READ-ONLY; The detailed status message, including for alerts and error messages.
	Message *string `json:"message,omitempty"`
	// Time - READ-ONLY; The time of the status.
	Time *date.Time `json:"time,omitempty"`
}

// MarshalJSON is the custom marshaler for MachineExtensionInstanceViewStatus.
func (meiv MachineExtensionInstanceViewStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// MachineExtensionProperties describes the properties of a Machine Extension.
type MachineExtensionProperties struct {
	// ForceUpdateTag - How the extension handler should be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`
	// Publisher - The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`
	// Type - Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`
	// TypeHandlerVersion - Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
	// AutoUpgradeMinorVersion - Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`
	// Settings - Json formatted public settings for the extension.
	Settings interface{} `json:"settings,omitempty"`
	// ProtectedSettings - The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `json:"protectedSettings,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InstanceView - The machine extension instance view.
	InstanceView *MachineExtensionPropertiesInstanceView `json:"instanceView,omitempty"`
}

// MarshalJSON is the custom marshaler for MachineExtensionProperties.
func (mep MachineExtensionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mep.ForceUpdateTag != nil {
		objectMap["forceUpdateTag"] = mep.ForceUpdateTag
	}
	if mep.Publisher != nil {
		objectMap["publisher"] = mep.Publisher
	}
	if mep.Type != nil {
		objectMap["type"] = mep.Type
	}
	if mep.TypeHandlerVersion != nil {
		objectMap["typeHandlerVersion"] = mep.TypeHandlerVersion
	}
	if mep.AutoUpgradeMinorVersion != nil {
		objectMap["autoUpgradeMinorVersion"] = mep.AutoUpgradeMinorVersion
	}
	if mep.Settings != nil {
		objectMap["settings"] = mep.Settings
	}
	if mep.ProtectedSettings != nil {
		objectMap["protectedSettings"] = mep.ProtectedSettings
	}
	if mep.InstanceView != nil {
		objectMap["instanceView"] = mep.InstanceView
	}
	return json.Marshal(objectMap)
}

// MachineExtensionPropertiesInstanceView the machine extension instance view.
type MachineExtensionPropertiesInstanceView struct {
	// Name - READ-ONLY; The machine extension name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`
	// TypeHandlerVersion - READ-ONLY; Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
	// Status - Instance view status.
	Status *MachineExtensionInstanceViewStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for MachineExtensionPropertiesInstanceView.
func (mepV MachineExtensionPropertiesInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mepV.Status != nil {
		objectMap["status"] = mepV.Status
	}
	return json.Marshal(objectMap)
}

// MachineExtensionsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type MachineExtensionsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MachineExtensionsClient) (MachineExtension, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MachineExtensionsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MachineExtensionsCreateOrUpdateFuture.Result.
func (future *MachineExtensionsCreateOrUpdateFuture) result(client MachineExtensionsClient) (me MachineExtension, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.MachineExtensionsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		me.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.MachineExtensionsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if me.Response.Response, err = future.GetResult(sender); err == nil && me.Response.Response.StatusCode != http.StatusNoContent {
		me, err = client.CreateOrUpdateResponder(me.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.MachineExtensionsCreateOrUpdateFuture", "Result", me.Response.Response, "Failure responding to request")
		}
	}
	return
}

// MachineExtensionsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type MachineExtensionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MachineExtensionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MachineExtensionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MachineExtensionsDeleteFuture.Result.
func (future *MachineExtensionsDeleteFuture) result(client MachineExtensionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.MachineExtensionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.MachineExtensionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// MachineExtensionsListResult describes the Machine Extensions List Result.
type MachineExtensionsListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of extensions
	Value *[]MachineExtension `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of machine extensions. Call ListNext() with this to fetch the next page of extensions.
	NextLink *string `json:"nextLink,omitempty"`
}

// MachineExtensionsListResultIterator provides access to a complete listing of MachineExtension values.
type MachineExtensionsListResultIterator struct {
	i    int
	page MachineExtensionsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *MachineExtensionsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MachineExtensionsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *MachineExtensionsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter MachineExtensionsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter MachineExtensionsListResultIterator) Response() MachineExtensionsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter MachineExtensionsListResultIterator) Value() MachineExtension {
	if !iter.page.NotDone() {
		return MachineExtension{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the MachineExtensionsListResultIterator type.
func NewMachineExtensionsListResultIterator(page MachineExtensionsListResultPage) MachineExtensionsListResultIterator {
	return MachineExtensionsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (melr MachineExtensionsListResult) IsEmpty() bool {
	return melr.Value == nil || len(*melr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (melr MachineExtensionsListResult) hasNextLink() bool {
	return melr.NextLink != nil && len(*melr.NextLink) != 0
}

// machineExtensionsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (melr MachineExtensionsListResult) machineExtensionsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !melr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(melr.NextLink)))
}

// MachineExtensionsListResultPage contains a page of MachineExtension values.
type MachineExtensionsListResultPage struct {
	fn   func(context.Context, MachineExtensionsListResult) (MachineExtensionsListResult, error)
	melr MachineExtensionsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *MachineExtensionsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MachineExtensionsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.melr)
		if err != nil {
			return err
		}
		page.melr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *MachineExtensionsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page MachineExtensionsListResultPage) NotDone() bool {
	return !page.melr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page MachineExtensionsListResultPage) Response() MachineExtensionsListResult {
	return page.melr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page MachineExtensionsListResultPage) Values() []MachineExtension {
	if page.melr.IsEmpty() {
		return nil
	}
	return *page.melr.Value
}

// Creates a new instance of the MachineExtensionsListResultPage type.
func NewMachineExtensionsListResultPage(cur MachineExtensionsListResult, getNextPage func(context.Context, MachineExtensionsListResult) (MachineExtensionsListResult, error)) MachineExtensionsListResultPage {
	return MachineExtensionsListResultPage{
		fn:   getNextPage,
		melr: cur,
	}
}

// MachineExtensionsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type MachineExtensionsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MachineExtensionsClient) (MachineExtension, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MachineExtensionsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MachineExtensionsUpdateFuture.Result.
func (future *MachineExtensionsUpdateFuture) result(client MachineExtensionsClient) (me MachineExtension, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.MachineExtensionsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		me.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.MachineExtensionsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if me.Response.Response, err = future.GetResult(sender); err == nil && me.Response.Response.StatusCode != http.StatusNoContent {
		me, err = client.UpdateResponder(me.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.MachineExtensionsUpdateFuture", "Result", me.Response.Response, "Failure responding to request")
		}
	}
	return
}

// MachineExtensionUpdate describes a Machine Extension Update.
type MachineExtensionUpdate struct {
	// MachineExtensionUpdateProperties - Describes Machine Extension Update Properties.
	*MachineExtensionUpdateProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for MachineExtensionUpdate.
func (meu MachineExtensionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if meu.MachineExtensionUpdateProperties != nil {
		objectMap["properties"] = meu.MachineExtensionUpdateProperties
	}
	if meu.Tags != nil {
		objectMap["tags"] = meu.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MachineExtensionUpdate struct.
func (meu *MachineExtensionUpdate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var machineExtensionUpdateProperties MachineExtensionUpdateProperties
				err = json.Unmarshal(*v, &machineExtensionUpdateProperties)
				if err != nil {
					return err
				}
				meu.MachineExtensionUpdateProperties = &machineExtensionUpdateProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				meu.Tags = tags
			}
		}
	}

	return nil
}

// MachineExtensionUpdateProperties describes the properties of a Machine Extension.
type MachineExtensionUpdateProperties struct {
	// ForceUpdateTag - How the extension handler should be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`
	// Publisher - The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`
	// Type - Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`
	// TypeHandlerVersion - Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
	// AutoUpgradeMinorVersion - Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`
	// Settings - Json formatted public settings for the extension.
	Settings interface{} `json:"settings,omitempty"`
	// ProtectedSettings - The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings interface{} `json:"protectedSettings,omitempty"`
}

// NetworkInterface network Interface model
type NetworkInterface struct {
	// Name - Gets or sets the name of the network interface.
	Name *string `json:"name,omitempty"`
	// Label - READ-ONLY; Gets or sets the label of the virtual network in vCenter that the nic is connected to.
	Label *string `json:"label,omitempty"`
	// IPAddresses - READ-ONLY; Gets or sets the nic ip addresses.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
	// MacAddress - READ-ONLY; Gets or sets the NIC MAC address.
	MacAddress *string `json:"macAddress,omitempty"`
	// NetworkID - Gets or sets the ARM Id of the network resource to connect the virtual machine.
	NetworkID *string `json:"networkId,omitempty"`
	// NicType - NIC type. Possible values include: 'Vmxnet3', 'Vmxnet2', 'Vmxnet', 'E1000', 'E1000e', 'Pcnet32'
	NicType NICType `json:"nicType,omitempty"`
	// PowerOnBoot - Gets or sets the power on boot. Possible values include: 'Enabled', 'Disabled'
	PowerOnBoot PowerOnBootOption `json:"powerOnBoot,omitempty"`
	// NetworkMoRefID - READ-ONLY; Gets or sets the vCenter MoRef (Managed Object Reference) ID of the virtual network
	// that the nic is connected to.
	NetworkMoRefID *string `json:"networkMoRefId,omitempty"`
	// NetworkMoName - READ-ONLY; Gets or sets the name of the virtual network in vCenter that the nic is connected to.
	NetworkMoName *string `json:"networkMoName,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
	// IPSettings - Gets or sets the ipsettings.
	IPSettings *NicIPSettings `json:"ipSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for NetworkInterface.
func (ni NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ni.Name != nil {
		objectMap["name"] = ni.Name
	}
	if ni.NetworkID != nil {
		objectMap["networkId"] = ni.NetworkID
	}
	if ni.NicType != "" {
		objectMap["nicType"] = ni.NicType
	}
	if ni.PowerOnBoot != "" {
		objectMap["powerOnBoot"] = ni.PowerOnBoot
	}
	if ni.DeviceKey != nil {
		objectMap["deviceKey"] = ni.DeviceKey
	}
	if ni.IPSettings != nil {
		objectMap["ipSettings"] = ni.IPSettings
	}
	return json.Marshal(objectMap)
}

// NetworkInterfaceUpdate defines the network interface update.
type NetworkInterfaceUpdate struct {
	// Name - Gets or sets the name of the network interface.
	Name *string `json:"name,omitempty"`
	// NetworkID - Gets or sets the ARM Id of the network resource to connect the virtual machine.
	NetworkID *string `json:"networkId,omitempty"`
	// NicType - NIC type. Possible values include: 'Vmxnet3', 'Vmxnet2', 'Vmxnet', 'E1000', 'E1000e', 'Pcnet32'
	NicType NICType `json:"nicType,omitempty"`
	// PowerOnBoot - Gets or sets the power on boot. Possible values include: 'Enabled', 'Disabled'
	PowerOnBoot PowerOnBootOption `json:"powerOnBoot,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
}

// NetworkProfile defines the resource properties.
type NetworkProfile struct {
	// NetworkInterfaces - Gets or sets the list of network interfaces associated with the virtual machine.
	NetworkInterfaces *[]NetworkInterface `json:"networkInterfaces,omitempty"`
}

// NetworkProfileUpdate defines the update resource properties.
type NetworkProfileUpdate struct {
	// NetworkInterfaces - Gets or sets the list of network interfaces associated with the virtual machine.
	NetworkInterfaces *[]NetworkInterfaceUpdate `json:"networkInterfaces,omitempty"`
}

// NicIPAddressSettings IP address information for a virtual network adapter reported by the fabric.
type NicIPAddressSettings struct {
	// AllocationMethod - READ-ONLY; Gets the ip address allocation method.
	AllocationMethod *string `json:"allocationMethod,omitempty"`
	// IPAddress - READ-ONLY; Gets the ip address for the nic.
	IPAddress *string `json:"ipAddress,omitempty"`
	// SubnetMask - READ-ONLY; Gets the mask.
	SubnetMask *string `json:"subnetMask,omitempty"`
}

// MarshalJSON is the custom marshaler for NicIPAddressSettings.
func (nias NicIPAddressSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// NicIPSettings defines the network interface ip settings.
type NicIPSettings struct {
	// AllocationMethod - Gets or sets the nic allocation method. Possible values include: 'Unset', 'Dynamic', 'Static', 'Linklayer', 'Random', 'Other'
	AllocationMethod IPAddressAllocationMethod `json:"allocationMethod,omitempty"`
	// DNSServers - Gets or sets the dns servers.
	DNSServers *[]string `json:"dnsServers,omitempty"`
	// Gateway - Gets or sets the gateway.
	Gateway *[]string `json:"gateway,omitempty"`
	// IPAddress - Gets or sets the ip address for the nic.
	IPAddress *string `json:"ipAddress,omitempty"`
	// SubnetMask - Gets or sets the mask.
	SubnetMask *string `json:"subnetMask,omitempty"`
	// PrimaryWinsServer - READ-ONLY; Gets or sets the primary server.
	PrimaryWinsServer *string `json:"primaryWinsServer,omitempty"`
	// SecondaryWinsServer - READ-ONLY; Gets or sets the secondary server.
	SecondaryWinsServer *string `json:"secondaryWinsServer,omitempty"`
	// IPAddressInfo - READ-ONLY; Gets or sets the IP address information being reported for this NIC. This contains the same IPv4 information above plus IPV6 information.
	IPAddressInfo *[]NicIPAddressSettings `json:"ipAddressInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for NicIPSettings.
func (nis NicIPSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if nis.AllocationMethod != "" {
		objectMap["allocationMethod"] = nis.AllocationMethod
	}
	if nis.DNSServers != nil {
		objectMap["dnsServers"] = nis.DNSServers
	}
	if nis.Gateway != nil {
		objectMap["gateway"] = nis.Gateway
	}
	if nis.IPAddress != nil {
		objectMap["ipAddress"] = nis.IPAddress
	}
	if nis.SubnetMask != nil {
		objectMap["subnetMask"] = nis.SubnetMask
	}
	return json.Marshal(objectMap)
}

// Operation operation provided by provider
type Operation struct {
	// Name - Name of the operation
	Name *string `json:"name,omitempty"`
	// IsDataAction - Indicates whether the operation is data action or not.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Properties of the operation
	Display *OperationDisplay `json:"display,omitempty"`
}

// OperationDisplay properties of the operation
type OperationDisplay struct {
	// Provider - Provider name
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource name
	Resource *string `json:"resource,omitempty"`
	// Operation - Operation name
	Operation *string `json:"operation,omitempty"`
	// Description - Description of the operation
	Description *string `json:"description,omitempty"`
}

// OperationsList lists the operations available.
type OperationsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of operations.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of operations
	Value *[]Operation `json:"value,omitempty"`
}

// OperationsListIterator provides access to a complete listing of Operation values.
type OperationsListIterator struct {
	i    int
	page OperationsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationsListIterator) Response() OperationsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationsListIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationsListIterator type.
func NewOperationsListIterator(page OperationsListPage) OperationsListIterator {
	return OperationsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationsList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OperationsList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// operationsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationsList) operationsListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationsListPage contains a page of Operation values.
type OperationsListPage struct {
	fn func(context.Context, OperationsList) (OperationsList, error)
	ol OperationsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationsListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationsListPage) Response() OperationsList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationsListPage) Values() []Operation {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationsListPage type.
func NewOperationsListPage(cur OperationsList, getNextPage func(context.Context, OperationsList) (OperationsList, error)) OperationsListPage {
	return OperationsListPage{
		fn: getNextPage,
		ol: cur,
	}
}

// OsProfile defines the resource properties.
type OsProfile struct {
	// ComputerName - Gets or sets computer name.
	ComputerName *string `json:"computerName,omitempty"`
	// AdminUsername - Gets or sets administrator username.
	AdminUsername *string `json:"adminUsername,omitempty"`
	// AdminPassword - Gets or sets administrator password.
	AdminPassword *string `json:"adminPassword,omitempty"`
	// OsType - Gets or sets the type of the os. Possible values include: 'OsTypeWindows', 'OsTypeLinux', 'OsTypeOther'
	OsType OsType `json:"osType,omitempty"`
	// OsName - READ-ONLY; Gets or sets os name.
	OsName *string `json:"osName,omitempty"`
	// ToolsRunningStatus - READ-ONLY; Gets or sets the current running status of VMware Tools running in the guest operating system.
	ToolsRunningStatus *string `json:"toolsRunningStatus,omitempty"`
	// ToolsVersionStatus - READ-ONLY; Gets or sets the current version status of VMware Tools installed in the guest operating system.
	ToolsVersionStatus *string `json:"toolsVersionStatus,omitempty"`
	// ToolsVersion - READ-ONLY; Gets or sets the current version of VMware Tools.
	ToolsVersion *string `json:"toolsVersion,omitempty"`
}

// MarshalJSON is the custom marshaler for OsProfile.
func (op OsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if op.ComputerName != nil {
		objectMap["computerName"] = op.ComputerName
	}
	if op.AdminUsername != nil {
		objectMap["adminUsername"] = op.AdminUsername
	}
	if op.AdminPassword != nil {
		objectMap["adminPassword"] = op.AdminPassword
	}
	if op.OsType != "" {
		objectMap["osType"] = op.OsType
	}
	return json.Marshal(objectMap)
}

// PlacementProfile defines the resource properties.
type PlacementProfile struct {
	// ResourcePoolID - Gets or sets the ARM Id of the resourcePool resource on which this virtual machine will deploy.
	ResourcePoolID *string `json:"resourcePoolId,omitempty"`
	// ClusterID - Gets or sets the ARM Id of the cluster resource on which this virtual machine will deploy.
	ClusterID *string `json:"clusterId,omitempty"`
	// HostID - Gets or sets the ARM Id of the host resource on which this virtual machine will deploy.
	HostID *string `json:"hostId,omitempty"`
	// DatastoreID - Gets or sets the ARM Id of the datastore resource on which the data for the virtual machine will be kept.
	DatastoreID *string `json:"datastoreId,omitempty"`
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourcePatch object containing updates for patch operations.
type ResourcePatch struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ResourcePatch.
func (rp ResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rp.Tags != nil {
		objectMap["tags"] = rp.Tags
	}
	return json.Marshal(objectMap)
}

// ResourcePool define the resourcePool.
type ResourcePool struct {
	autorest.Response `json:"-"`
	// ResourcePoolProperties - Resource properties.
	*ResourcePoolProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourcePool.
func (rp ResourcePool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rp.ResourcePoolProperties != nil {
		objectMap["properties"] = rp.ResourcePoolProperties
	}
	if rp.Location != nil {
		objectMap["location"] = rp.Location
	}
	if rp.ExtendedLocation != nil {
		objectMap["extendedLocation"] = rp.ExtendedLocation
	}
	if rp.SystemData != nil {
		objectMap["systemData"] = rp.SystemData
	}
	if rp.Tags != nil {
		objectMap["tags"] = rp.Tags
	}
	if rp.Kind != nil {
		objectMap["kind"] = rp.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourcePool struct.
func (rp *ResourcePool) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var resourcePoolProperties ResourcePoolProperties
				err = json.Unmarshal(*v, &resourcePoolProperties)
				if err != nil {
					return err
				}
				rp.ResourcePoolProperties = &resourcePoolProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rp.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				rp.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				rp.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rp.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rp.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rp.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rp.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				rp.Kind = &kind
			}
		}
	}

	return nil
}

// ResourcePoolInventoryItem the resource pool inventory item.
type ResourcePoolInventoryItem struct {
	// Parent - Parent resourcePool inventory resource details.
	Parent *InventoryItemDetails `json:"parent,omitempty"`
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) MarshalJSON() ([]byte, error) {
	rpii.InventoryType = InventoryTypeResourcePool1
	objectMap := make(map[string]interface{})
	if rpii.Parent != nil {
		objectMap["parent"] = rpii.Parent
	}
	if rpii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = rpii.ManagedResourceID
	}
	if rpii.MoRefID != nil {
		objectMap["moRefId"] = rpii.MoRefID
	}
	if rpii.MoName != nil {
		objectMap["moName"] = rpii.MoName
	}
	if rpii.InventoryType != "" {
		objectMap["inventoryType"] = rpii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return &rpii, true
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for ResourcePoolInventoryItem.
func (rpii ResourcePoolInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &rpii, true
}

// ResourcePoolProperties defines the resource properties.
type ResourcePoolProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this resource pool resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the resource pool.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the resource pool.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the resource pool.
	MoName *string `json:"moName,omitempty"`
	// CPUSharesLevel - READ-ONLY; Gets or sets CPUSharesLevel which specifies the CPU allocation level for this pool.
	// This property is used in relative allocation between resource consumers.
	CPUSharesLevel *string `json:"cpuSharesLevel,omitempty"`
	// CPUReservationMHz - READ-ONLY; Gets or sets CPUReservationMHz which specifies the CPU size in MHz that is guaranteed
	// to be available.
	CPUReservationMHz *int64 `json:"cpuReservationMHz,omitempty"`
	// CPULimitMHz - READ-ONLY; Gets or sets CPULimitMHz which specifies a CPU usage limit in MHz.
	// Utilization will not exceed this limit even if there are available resources.
	CPULimitMHz *int64 `json:"cpuLimitMHz,omitempty"`
	// MemSharesLevel - READ-ONLY; Gets or sets CPUSharesLevel which specifies the memory allocation level for this pool.
	// This property is used in relative allocation between resource consumers.
	MemSharesLevel *string `json:"memSharesLevel,omitempty"`
	// MemReservationMB - READ-ONLY; Gets or sets MemReservationMB which specifies the guaranteed available memory in
	// megabytes.
	MemReservationMB *int64 `json:"memReservationMB,omitempty"`
	// MemLimitMB - READ-ONLY; Gets or sets MemLimitMB specifies a memory usage limit in megabytes.
	// Utilization will not exceed the specified limit even if there are available resources.
	MemLimitMB *int64 `json:"memLimitMB,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourcePoolProperties.
func (rpp ResourcePoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rpp.VCenterID != nil {
		objectMap["vCenterId"] = rpp.VCenterID
	}
	if rpp.MoRefID != nil {
		objectMap["moRefId"] = rpp.MoRefID
	}
	if rpp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = rpp.InventoryItemID
	}
	return json.Marshal(objectMap)
}

// ResourcePoolsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ResourcePoolsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ResourcePoolsClient) (ResourcePool, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ResourcePoolsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ResourcePoolsCreateFuture.Result.
func (future *ResourcePoolsCreateFuture) result(client ResourcePoolsClient) (rp ResourcePool, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.ResourcePoolsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.ResourcePoolsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rp.Response.Response, err = future.GetResult(sender); err == nil && rp.Response.Response.StatusCode != http.StatusNoContent {
		rp, err = client.CreateResponder(rp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.ResourcePoolsCreateFuture", "Result", rp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ResourcePoolsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ResourcePoolsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ResourcePoolsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ResourcePoolsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ResourcePoolsDeleteFuture.Result.
func (future *ResourcePoolsDeleteFuture) result(client ResourcePoolsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.ResourcePoolsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.ResourcePoolsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ResourcePoolsList list of ResourcePools.
type ResourcePoolsList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of ResourcePools.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of ResourcePools
	Value *[]ResourcePool `json:"value,omitempty"`
}

// ResourcePoolsListIterator provides access to a complete listing of ResourcePool values.
type ResourcePoolsListIterator struct {
	i    int
	page ResourcePoolsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourcePoolsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourcePoolsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourcePoolsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourcePoolsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourcePoolsListIterator) Response() ResourcePoolsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourcePoolsListIterator) Value() ResourcePool {
	if !iter.page.NotDone() {
		return ResourcePool{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourcePoolsListIterator type.
func NewResourcePoolsListIterator(page ResourcePoolsListPage) ResourcePoolsListIterator {
	return ResourcePoolsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rpl ResourcePoolsList) IsEmpty() bool {
	return rpl.Value == nil || len(*rpl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rpl ResourcePoolsList) hasNextLink() bool {
	return rpl.NextLink != nil && len(*rpl.NextLink) != 0
}

// resourcePoolsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rpl ResourcePoolsList) resourcePoolsListPreparer(ctx context.Context) (*http.Request, error) {
	if !rpl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rpl.NextLink)))
}

// ResourcePoolsListPage contains a page of ResourcePool values.
type ResourcePoolsListPage struct {
	fn  func(context.Context, ResourcePoolsList) (ResourcePoolsList, error)
	rpl ResourcePoolsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourcePoolsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourcePoolsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rpl)
		if err != nil {
			return err
		}
		page.rpl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourcePoolsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourcePoolsListPage) NotDone() bool {
	return !page.rpl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourcePoolsListPage) Response() ResourcePoolsList {
	return page.rpl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourcePoolsListPage) Values() []ResourcePool {
	if page.rpl.IsEmpty() {
		return nil
	}
	return *page.rpl.Value
}

// Creates a new instance of the ResourcePoolsListPage type.
func NewResourcePoolsListPage(cur ResourcePoolsList, getNextPage func(context.Context, ResourcePoolsList) (ResourcePoolsList, error)) ResourcePoolsListPage {
	return ResourcePoolsListPage{
		fn:  getNextPage,
		rpl: cur,
	}
}

// ResourceStatus the resource status information.
type ResourceStatus struct {
	// Type - READ-ONLY; The type of the condition.
	Type *string `json:"type,omitempty"`
	// Status - READ-ONLY; Status of the condition.
	Status *string `json:"status,omitempty"`
	// Reason - READ-ONLY; The reason for the condition's status.
	Reason *string `json:"reason,omitempty"`
	// Message - READ-ONLY; A human readable message indicating details about the status.
	Message *string `json:"message,omitempty"`
	// Severity - READ-ONLY; Severity with which to treat failures of this type of condition.
	Severity *string `json:"severity,omitempty"`
	// LastUpdatedAt - READ-ONLY; The last update time for this condition.
	LastUpdatedAt *date.Time `json:"lastUpdatedAt,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceStatus.
func (rs ResourceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// StopVirtualMachineOptions defines the stop action properties.
type StopVirtualMachineOptions struct {
	// SkipShutdown - Gets or sets a value indicating whether to request non-graceful VM shutdown. True value for this flag indicates non-graceful shutdown whereas false indicates otherwise. Defaults to false.
	SkipShutdown *bool `json:"skipShutdown,omitempty"`
}

// StorageProfile defines the resource properties.
type StorageProfile struct {
	// Disks - Gets or sets the list of virtual disks associated with the virtual machine.
	Disks *[]VirtualDisk `json:"disks,omitempty"`
	// ScsiControllers - READ-ONLY; Gets or sets the list of virtual SCSI controllers associated with the virtual machine.
	ScsiControllers *[]VirtualSCSIController `json:"scsiControllers,omitempty"`
}

// MarshalJSON is the custom marshaler for StorageProfile.
func (sp StorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.Disks != nil {
		objectMap["disks"] = sp.Disks
	}
	return json.Marshal(objectMap)
}

// StorageProfileUpdate defines the resource update properties.
type StorageProfileUpdate struct {
	// Disks - Gets or sets the list of virtual disks associated with the virtual machine.
	Disks *[]VirtualDiskUpdate `json:"disks,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// VCenter defines the vCenter.
type VCenter struct {
	autorest.Response `json:"-"`
	// VCenterProperties - Resource properties.
	*VCenterProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for VCenter.
func (vc VCenter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vc.VCenterProperties != nil {
		objectMap["properties"] = vc.VCenterProperties
	}
	if vc.Location != nil {
		objectMap["location"] = vc.Location
	}
	if vc.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vc.ExtendedLocation
	}
	if vc.SystemData != nil {
		objectMap["systemData"] = vc.SystemData
	}
	if vc.Tags != nil {
		objectMap["tags"] = vc.Tags
	}
	if vc.Kind != nil {
		objectMap["kind"] = vc.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VCenter struct.
func (vc *VCenter) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var vCenterProperties VCenterProperties
				err = json.Unmarshal(*v, &vCenterProperties)
				if err != nil {
					return err
				}
				vc.VCenterProperties = &vCenterProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vc.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vc.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vc.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vc.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vc.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vc.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vc.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vc.Kind = &kind
			}
		}
	}

	return nil
}

// VCenterProperties defines the resource properties.
type VCenterProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// Fqdn - Gets or sets the FQDN/IPAddress of the vCenter.
	Fqdn *string `json:"fqdn,omitempty"`
	// Port - Gets or sets the port of the vCenter.
	Port *int32 `json:"port,omitempty"`
	// Version - READ-ONLY; Gets or sets the version of the vCenter.
	Version *string `json:"version,omitempty"`
	// InstanceUUID - READ-ONLY; Gets or sets the instance UUID of the vCenter.
	InstanceUUID *string `json:"instanceUuid,omitempty"`
	// ConnectionStatus - READ-ONLY; Gets or sets the connection status to the vCenter.
	ConnectionStatus *string `json:"connectionStatus,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// Credentials - Username / Password Credentials to connect to vcenter.
	Credentials *VICredential `json:"credentials,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VCenterProperties.
func (vcp VCenterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vcp.Fqdn != nil {
		objectMap["fqdn"] = vcp.Fqdn
	}
	if vcp.Port != nil {
		objectMap["port"] = vcp.Port
	}
	if vcp.Credentials != nil {
		objectMap["credentials"] = vcp.Credentials
	}
	return json.Marshal(objectMap)
}

// VCentersCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VCentersCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VCentersClient) (VCenter, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VCentersCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VCentersCreateFuture.Result.
func (future *VCentersCreateFuture) result(client VCentersClient) (vc VCenter, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VCentersCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VCentersCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vc.Response.Response, err = future.GetResult(sender); err == nil && vc.Response.Response.StatusCode != http.StatusNoContent {
		vc, err = client.CreateResponder(vc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.VCentersCreateFuture", "Result", vc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VCentersDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VCentersDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VCentersClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VCentersDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VCentersDeleteFuture.Result.
func (future *VCentersDeleteFuture) result(client VCentersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VCentersDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VCentersDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VCentersList list of VCenters.
type VCentersList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VCenters.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VCenters
	Value *[]VCenter `json:"value,omitempty"`
}

// VCentersListIterator provides access to a complete listing of VCenter values.
type VCentersListIterator struct {
	i    int
	page VCentersListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VCentersListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VCentersListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VCentersListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VCentersListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VCentersListIterator) Response() VCentersList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VCentersListIterator) Value() VCenter {
	if !iter.page.NotDone() {
		return VCenter{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VCentersListIterator type.
func NewVCentersListIterator(page VCentersListPage) VCentersListIterator {
	return VCentersListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vcl VCentersList) IsEmpty() bool {
	return vcl.Value == nil || len(*vcl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vcl VCentersList) hasNextLink() bool {
	return vcl.NextLink != nil && len(*vcl.NextLink) != 0
}

// vCentersListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vcl VCentersList) vCentersListPreparer(ctx context.Context) (*http.Request, error) {
	if !vcl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vcl.NextLink)))
}

// VCentersListPage contains a page of VCenter values.
type VCentersListPage struct {
	fn  func(context.Context, VCentersList) (VCentersList, error)
	vcl VCentersList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VCentersListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VCentersListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vcl)
		if err != nil {
			return err
		}
		page.vcl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VCentersListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VCentersListPage) NotDone() bool {
	return !page.vcl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VCentersListPage) Response() VCentersList {
	return page.vcl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VCentersListPage) Values() []VCenter {
	if page.vcl.IsEmpty() {
		return nil
	}
	return *page.vcl.Value
}

// Creates a new instance of the VCentersListPage type.
func NewVCentersListPage(cur VCentersList, getNextPage func(context.Context, VCentersList) (VCentersList, error)) VCentersListPage {
	return VCentersListPage{
		fn:  getNextPage,
		vcl: cur,
	}
}

// VICredential username / Password Credentials to connect to vcenter.
type VICredential struct {
	// Username - Gets or sets username to connect with the vCenter.
	Username *string `json:"username,omitempty"`
	// Password - Gets or sets the password to connect with the vCenter.
	Password *string `json:"password,omitempty"`
}

// VirtualDisk virtual disk model
type VirtualDisk struct {
	// Name - Gets or sets the name of the virtual disk.
	Name *string `json:"name,omitempty"`
	// Label - READ-ONLY; Gets or sets the label of the virtual disk in vCenter.
	Label *string `json:"label,omitempty"`
	// DiskObjectID - READ-ONLY; Gets or sets the disk object id.
	DiskObjectID *string `json:"diskObjectId,omitempty"`
	// DiskSizeGB - Gets or sets the disk total size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
	// DiskMode - Gets or sets the disk mode. Possible values include: 'Persistent', 'IndependentPersistent', 'IndependentNonpersistent'
	DiskMode DiskMode `json:"diskMode,omitempty"`
	// ControllerKey - Gets or sets the controller id.
	ControllerKey *int32 `json:"controllerKey,omitempty"`
	// UnitNumber - Gets or sets the unit number of the disk on the controller.
	UnitNumber *int32 `json:"unitNumber,omitempty"`
	// DeviceName - Gets or sets the device name.
	DeviceName *string `json:"deviceName,omitempty"`
	// DiskType - Gets or sets the disk backing type. Possible values include: 'Flat', 'Pmem', 'Rawphysical', 'Rawvirtual', 'Sparse', 'Sesparse', 'Unknown'
	DiskType DiskType `json:"diskType,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualDisk.
func (vd VirtualDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vd.Name != nil {
		objectMap["name"] = vd.Name
	}
	if vd.DiskSizeGB != nil {
		objectMap["diskSizeGB"] = vd.DiskSizeGB
	}
	if vd.DeviceKey != nil {
		objectMap["deviceKey"] = vd.DeviceKey
	}
	if vd.DiskMode != "" {
		objectMap["diskMode"] = vd.DiskMode
	}
	if vd.ControllerKey != nil {
		objectMap["controllerKey"] = vd.ControllerKey
	}
	if vd.UnitNumber != nil {
		objectMap["unitNumber"] = vd.UnitNumber
	}
	if vd.DeviceName != nil {
		objectMap["deviceName"] = vd.DeviceName
	}
	if vd.DiskType != "" {
		objectMap["diskType"] = vd.DiskType
	}
	return json.Marshal(objectMap)
}

// VirtualDiskUpdate defines the virtual disk update.
type VirtualDiskUpdate struct {
	// Name - Gets or sets the name of the virtual disk.
	Name *string `json:"name,omitempty"`
	// DiskSizeGB - Gets or sets the disk total size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`
	// DeviceKey - Gets or sets the device key value.
	DeviceKey *int32 `json:"deviceKey,omitempty"`
	// DiskMode - Gets or sets the disk mode. Possible values include: 'Persistent', 'IndependentPersistent', 'IndependentNonpersistent'
	DiskMode DiskMode `json:"diskMode,omitempty"`
	// ControllerKey - Gets or sets the controller id.
	ControllerKey *int32 `json:"controllerKey,omitempty"`
	// UnitNumber - Gets or sets the unit number of the disk on the controller.
	UnitNumber *int32 `json:"unitNumber,omitempty"`
	// DeviceName - Gets or sets the device name.
	DeviceName *string `json:"deviceName,omitempty"`
	// DiskType - Gets or sets the disk backing type. Possible values include: 'Flat', 'Pmem', 'Rawphysical', 'Rawvirtual', 'Sparse', 'Sesparse', 'Unknown'
	DiskType DiskType `json:"diskType,omitempty"`
}

// VirtualMachine define the virtualMachine.
type VirtualMachine struct {
	autorest.Response `json:"-"`
	// VirtualMachineProperties - Resource properties.
	*VirtualMachineProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
	// Identity - The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachine.
func (VM VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if VM.VirtualMachineProperties != nil {
		objectMap["properties"] = VM.VirtualMachineProperties
	}
	if VM.Location != nil {
		objectMap["location"] = VM.Location
	}
	if VM.ExtendedLocation != nil {
		objectMap["extendedLocation"] = VM.ExtendedLocation
	}
	if VM.SystemData != nil {
		objectMap["systemData"] = VM.SystemData
	}
	if VM.Tags != nil {
		objectMap["tags"] = VM.Tags
	}
	if VM.Kind != nil {
		objectMap["kind"] = VM.Kind
	}
	if VM.Identity != nil {
		objectMap["identity"] = VM.Identity
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualMachine struct.
func (VM *VirtualMachine) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualMachineProperties VirtualMachineProperties
				err = json.Unmarshal(*v, &virtualMachineProperties)
				if err != nil {
					return err
				}
				VM.VirtualMachineProperties = &virtualMachineProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				VM.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				VM.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				VM.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				VM.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				VM.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				VM.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				VM.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				VM.Kind = &kind
			}
		case "identity":
			if v != nil {
				var identity Identity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				VM.Identity = &identity
			}
		}
	}

	return nil
}

// VirtualMachineInventoryItem the VM inventory item.
type VirtualMachineInventoryItem struct {
	// OsType - Gets or sets the type of the os. Possible values include: 'OsTypeWindows', 'OsTypeLinux', 'OsTypeOther'
	OsType OsType `json:"osType,omitempty"`
	// OsName - Gets or sets os name.
	OsName *string `json:"osName,omitempty"`
	// IPAddresses - Gets or sets the nic ip addresses.
	IPAddresses *[]string `json:"ipAddresses,omitempty"`
	// FolderPath - Gets or sets the folder path of the vm.
	FolderPath *string `json:"folderPath,omitempty"`
	// Host - Host inventory resource details.
	Host *InventoryItemDetails `json:"host,omitempty"`
	// ResourcePool - ResourcePool inventory resource details.
	ResourcePool *InventoryItemDetails `json:"resourcePool,omitempty"`
	// InstanceUUID - Gets or sets the instance uuid of the vm.
	InstanceUUID *string `json:"instanceUuid,omitempty"`
	// SmbiosUUID - Gets or sets the SMBIOS UUID of the vm.
	SmbiosUUID *string `json:"smbiosUuid,omitempty"`
	// PowerState - READ-ONLY; Gets the power state of the virtual machine.
	PowerState *string `json:"powerState,omitempty"`
	// ToolsRunningStatus - READ-ONLY; Gets or sets the current running status of VMware Tools running in the guest operating system.
	ToolsRunningStatus *string `json:"toolsRunningStatus,omitempty"`
	// ToolsVersionStatus - READ-ONLY; Gets or sets the current version status of VMware Tools installed in the guest operating system.
	ToolsVersionStatus *string `json:"toolsVersionStatus,omitempty"`
	// ToolsVersion - READ-ONLY; Gets or sets the current version of VMware Tools.
	ToolsVersion *string `json:"toolsVersion,omitempty"`
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) MarshalJSON() ([]byte, error) {
	vmii.InventoryType = InventoryTypeVirtualMachine1
	objectMap := make(map[string]interface{})
	if vmii.OsType != "" {
		objectMap["osType"] = vmii.OsType
	}
	if vmii.OsName != nil {
		objectMap["osName"] = vmii.OsName
	}
	if vmii.IPAddresses != nil {
		objectMap["ipAddresses"] = vmii.IPAddresses
	}
	if vmii.FolderPath != nil {
		objectMap["folderPath"] = vmii.FolderPath
	}
	if vmii.Host != nil {
		objectMap["host"] = vmii.Host
	}
	if vmii.ResourcePool != nil {
		objectMap["resourcePool"] = vmii.ResourcePool
	}
	if vmii.InstanceUUID != nil {
		objectMap["instanceUuid"] = vmii.InstanceUUID
	}
	if vmii.SmbiosUUID != nil {
		objectMap["smbiosUuid"] = vmii.SmbiosUUID
	}
	if vmii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = vmii.ManagedResourceID
	}
	if vmii.MoRefID != nil {
		objectMap["moRefId"] = vmii.MoRefID
	}
	if vmii.MoName != nil {
		objectMap["moName"] = vmii.MoName
	}
	if vmii.InventoryType != "" {
		objectMap["inventoryType"] = vmii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return &vmii, true
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for VirtualMachineInventoryItem.
func (vmii VirtualMachineInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &vmii, true
}

// VirtualMachineProperties defines the resource properties.
type VirtualMachineProperties struct {
	// ResourcePoolID - Gets or sets the ARM Id of the resourcePool resource on which this virtual machine will
	// deploy.
	ResourcePoolID *string `json:"resourcePoolId,omitempty"`
	// TemplateID - Gets or sets the ARM Id of the template resource to deploy the virtual machine.
	TemplateID *string `json:"templateId,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this resource pool resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// PlacementProfile - Placement properties.
	PlacementProfile *PlacementProfile `json:"placementProfile,omitempty"`
	// OsProfile - OS properties.
	OsProfile *OsProfile `json:"osProfile,omitempty"`
	// HardwareProfile - Hardware properties.
	HardwareProfile *HardwareProfile `json:"hardwareProfile,omitempty"`
	// NetworkProfile - Network properties.
	NetworkProfile *NetworkProfile `json:"networkProfile,omitempty"`
	// StorageProfile - Storage properties.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`
	// GuestAgentProfile - Guest agent status properties.
	GuestAgentProfile *GuestAgentProfile `json:"guestAgentProfile,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the virtual machine.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the virtual machine.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the virtual machine.
	MoName *string `json:"moName,omitempty"`
	// FolderPath - READ-ONLY; Gets or sets the folder path of the vm.
	FolderPath *string `json:"folderPath,omitempty"`
	// InstanceUUID - READ-ONLY; Gets or sets the instance uuid of the vm.
	InstanceUUID *string `json:"instanceUuid,omitempty"`
	// SmbiosUUID - Gets or sets the SMBIOS UUID of the vm.
	SmbiosUUID *string `json:"smbiosUuid,omitempty"`
	// FirmwareType - Firmware type. Possible values include: 'Bios', 'Efi'
	FirmwareType FirmwareType `json:"firmwareType,omitempty"`
	// PowerState - READ-ONLY; Gets the power state of the virtual machine.
	PowerState *string `json:"powerState,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// VMID - READ-ONLY; Gets or sets a unique identifier for the vm resource.
	VMID *string `json:"vmId,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineProperties.
func (vmp VirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmp.ResourcePoolID != nil {
		objectMap["resourcePoolId"] = vmp.ResourcePoolID
	}
	if vmp.TemplateID != nil {
		objectMap["templateId"] = vmp.TemplateID
	}
	if vmp.VCenterID != nil {
		objectMap["vCenterId"] = vmp.VCenterID
	}
	if vmp.PlacementProfile != nil {
		objectMap["placementProfile"] = vmp.PlacementProfile
	}
	if vmp.OsProfile != nil {
		objectMap["osProfile"] = vmp.OsProfile
	}
	if vmp.HardwareProfile != nil {
		objectMap["hardwareProfile"] = vmp.HardwareProfile
	}
	if vmp.NetworkProfile != nil {
		objectMap["networkProfile"] = vmp.NetworkProfile
	}
	if vmp.StorageProfile != nil {
		objectMap["storageProfile"] = vmp.StorageProfile
	}
	if vmp.GuestAgentProfile != nil {
		objectMap["guestAgentProfile"] = vmp.GuestAgentProfile
	}
	if vmp.MoRefID != nil {
		objectMap["moRefId"] = vmp.MoRefID
	}
	if vmp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = vmp.InventoryItemID
	}
	if vmp.SmbiosUUID != nil {
		objectMap["smbiosUuid"] = vmp.SmbiosUUID
	}
	if vmp.FirmwareType != "" {
		objectMap["firmwareType"] = vmp.FirmwareType
	}
	return json.Marshal(objectMap)
}

// VirtualMachinesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachinesClient) (VirtualMachine, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachinesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachinesCreateFuture.Result.
func (future *VirtualMachinesCreateFuture) result(client VirtualMachinesClient) (VM VirtualMachine, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		VM.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachinesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if VM.Response.Response, err = future.GetResult(sender); err == nil && VM.Response.Response.StatusCode != http.StatusNoContent {
		VM, err = client.CreateResponder(VM.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesCreateFuture", "Result", VM.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualMachinesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachinesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachinesDeleteFuture.Result.
func (future *VirtualMachinesDeleteFuture) result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachinesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesList list of VirtualMachines.
type VirtualMachinesList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VirtualMachines.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VirtualMachines
	Value *[]VirtualMachine `json:"value,omitempty"`
}

// VirtualMachinesListIterator provides access to a complete listing of VirtualMachine values.
type VirtualMachinesListIterator struct {
	i    int
	page VirtualMachinesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualMachinesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualMachinesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualMachinesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualMachinesListIterator) Response() VirtualMachinesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualMachinesListIterator) Value() VirtualMachine {
	if !iter.page.NotDone() {
		return VirtualMachine{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualMachinesListIterator type.
func NewVirtualMachinesListIterator(page VirtualMachinesListPage) VirtualMachinesListIterator {
	return VirtualMachinesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vml VirtualMachinesList) IsEmpty() bool {
	return vml.Value == nil || len(*vml.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vml VirtualMachinesList) hasNextLink() bool {
	return vml.NextLink != nil && len(*vml.NextLink) != 0
}

// virtualMachinesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vml VirtualMachinesList) virtualMachinesListPreparer(ctx context.Context) (*http.Request, error) {
	if !vml.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vml.NextLink)))
}

// VirtualMachinesListPage contains a page of VirtualMachine values.
type VirtualMachinesListPage struct {
	fn  func(context.Context, VirtualMachinesList) (VirtualMachinesList, error)
	vml VirtualMachinesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualMachinesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachinesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vml)
		if err != nil {
			return err
		}
		page.vml = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualMachinesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualMachinesListPage) NotDone() bool {
	return !page.vml.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualMachinesListPage) Response() VirtualMachinesList {
	return page.vml
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualMachinesListPage) Values() []VirtualMachine {
	if page.vml.IsEmpty() {
		return nil
	}
	return *page.vml.Value
}

// Creates a new instance of the VirtualMachinesListPage type.
func NewVirtualMachinesListPage(cur VirtualMachinesList, getNextPage func(context.Context, VirtualMachinesList) (VirtualMachinesList, error)) VirtualMachinesListPage {
	return VirtualMachinesListPage{
		fn:  getNextPage,
		vml: cur,
	}
}

// VirtualMachinesRestartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesRestartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachinesRestartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachinesRestartFuture.Result.
func (future *VirtualMachinesRestartFuture) result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesRestartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachinesRestartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachinesStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachinesStartFuture.Result.
func (future *VirtualMachinesStartFuture) result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachinesStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachinesStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachinesStopFuture.Result.
func (future *VirtualMachinesStopFuture) result(client VirtualMachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachinesStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachinesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualMachinesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachinesClient) (VirtualMachine, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachinesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachinesUpdateFuture.Result.
func (future *VirtualMachinesUpdateFuture) result(client VirtualMachinesClient) (VM VirtualMachine, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		VM.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachinesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if VM.Response.Response, err = future.GetResult(sender); err == nil && VM.Response.Response.StatusCode != http.StatusNoContent {
		VM, err = client.UpdateResponder(VM.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachinesUpdateFuture", "Result", VM.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualMachineTemplate define the virtualMachineTemplate.
type VirtualMachineTemplate struct {
	autorest.Response `json:"-"`
	// VirtualMachineTemplateProperties - Resource properties.
	*VirtualMachineTemplateProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineTemplate.
func (vmt VirtualMachineTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmt.VirtualMachineTemplateProperties != nil {
		objectMap["properties"] = vmt.VirtualMachineTemplateProperties
	}
	if vmt.Location != nil {
		objectMap["location"] = vmt.Location
	}
	if vmt.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vmt.ExtendedLocation
	}
	if vmt.SystemData != nil {
		objectMap["systemData"] = vmt.SystemData
	}
	if vmt.Tags != nil {
		objectMap["tags"] = vmt.Tags
	}
	if vmt.Kind != nil {
		objectMap["kind"] = vmt.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualMachineTemplate struct.
func (vmt *VirtualMachineTemplate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualMachineTemplateProperties VirtualMachineTemplateProperties
				err = json.Unmarshal(*v, &virtualMachineTemplateProperties)
				if err != nil {
					return err
				}
				vmt.VirtualMachineTemplateProperties = &virtualMachineTemplateProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vmt.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vmt.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vmt.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vmt.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vmt.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vmt.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vmt.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vmt.Kind = &kind
			}
		}
	}

	return nil
}

// VirtualMachineTemplateInventoryItem the VM Template inventory item.
type VirtualMachineTemplateInventoryItem struct {
	// MemorySizeMB - Gets or sets memory size in MBs for the template.
	MemorySizeMB *int32 `json:"memorySizeMB,omitempty"`
	// NumCPUs - Gets or sets the number of vCPUs for the template.
	NumCPUs *int32 `json:"numCPUs,omitempty"`
	// NumCoresPerSocket - Gets or sets the number of cores per socket for the template.
	// Defaults to 1 if unspecified.
	NumCoresPerSocket *int32 `json:"numCoresPerSocket,omitempty"`
	// OsType - Gets or sets the type of the os. Possible values include: 'OsTypeWindows', 'OsTypeLinux', 'OsTypeOther'
	OsType OsType `json:"osType,omitempty"`
	// OsName - Gets or sets os name.
	OsName *string `json:"osName,omitempty"`
	// FolderPath - Gets or sets the folder path of the template.
	FolderPath *string `json:"folderPath,omitempty"`
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) MarshalJSON() ([]byte, error) {
	vmtii.InventoryType = InventoryTypeVirtualMachineTemplate1
	objectMap := make(map[string]interface{})
	if vmtii.MemorySizeMB != nil {
		objectMap["memorySizeMB"] = vmtii.MemorySizeMB
	}
	if vmtii.NumCPUs != nil {
		objectMap["numCPUs"] = vmtii.NumCPUs
	}
	if vmtii.NumCoresPerSocket != nil {
		objectMap["numCoresPerSocket"] = vmtii.NumCoresPerSocket
	}
	if vmtii.OsType != "" {
		objectMap["osType"] = vmtii.OsType
	}
	if vmtii.OsName != nil {
		objectMap["osName"] = vmtii.OsName
	}
	if vmtii.FolderPath != nil {
		objectMap["folderPath"] = vmtii.FolderPath
	}
	if vmtii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = vmtii.ManagedResourceID
	}
	if vmtii.MoRefID != nil {
		objectMap["moRefId"] = vmtii.MoRefID
	}
	if vmtii.MoName != nil {
		objectMap["moName"] = vmtii.MoName
	}
	if vmtii.InventoryType != "" {
		objectMap["inventoryType"] = vmtii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return &vmtii, true
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return nil, false
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for VirtualMachineTemplateInventoryItem.
func (vmtii VirtualMachineTemplateInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &vmtii, true
}

// VirtualMachineTemplateProperties defines the resource properties.
type VirtualMachineTemplateProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this template resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the virtual machine
	// template.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the virtual machine template.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the virtual machine template.
	MoName *string `json:"moName,omitempty"`
	// MemorySizeMB - READ-ONLY; Gets or sets memory size in MBs for the template.
	MemorySizeMB *int32 `json:"memorySizeMB,omitempty"`
	// NumCPUs - READ-ONLY; Gets or sets the number of vCPUs for the template.
	NumCPUs *int32 `json:"numCPUs,omitempty"`
	// NumCoresPerSocket - READ-ONLY; Gets or sets the number of cores per socket for the template.
	// Defaults to 1 if unspecified.
	NumCoresPerSocket *int32 `json:"numCoresPerSocket,omitempty"`
	// OsType - READ-ONLY; Gets or sets the type of the os. Possible values include: 'OsTypeWindows', 'OsTypeLinux', 'OsTypeOther'
	OsType OsType `json:"osType,omitempty"`
	// OsName - READ-ONLY; Gets or sets os name.
	OsName *string `json:"osName,omitempty"`
	// FolderPath - READ-ONLY; Gets or sets the folder path of the template.
	FolderPath *string `json:"folderPath,omitempty"`
	// NetworkInterfaces - READ-ONLY; Gets or sets the network interfaces of the template.
	NetworkInterfaces *[]NetworkInterface `json:"networkInterfaces,omitempty"`
	// Disks - READ-ONLY; Gets or sets the disks the template.
	Disks *[]VirtualDisk `json:"disks,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// ToolsVersionStatus - READ-ONLY; Gets or sets the current version status of VMware Tools installed in the guest operating system.
	ToolsVersionStatus *string `json:"toolsVersionStatus,omitempty"`
	// ToolsVersion - READ-ONLY; Gets or sets the current version of VMware Tools.
	ToolsVersion *string `json:"toolsVersion,omitempty"`
	// FirmwareType - READ-ONLY; Firmware type. Possible values include: 'Bios', 'Efi'
	FirmwareType FirmwareType `json:"firmwareType,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineTemplateProperties.
func (vmtp VirtualMachineTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmtp.VCenterID != nil {
		objectMap["vCenterId"] = vmtp.VCenterID
	}
	if vmtp.MoRefID != nil {
		objectMap["moRefId"] = vmtp.MoRefID
	}
	if vmtp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = vmtp.InventoryItemID
	}
	return json.Marshal(objectMap)
}

// VirtualMachineTemplatesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualMachineTemplatesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachineTemplatesClient) (VirtualMachineTemplate, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachineTemplatesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachineTemplatesCreateFuture.Result.
func (future *VirtualMachineTemplatesCreateFuture) result(client VirtualMachineTemplatesClient) (vmt VirtualMachineTemplate, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachineTemplatesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vmt.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachineTemplatesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vmt.Response.Response, err = future.GetResult(sender); err == nil && vmt.Response.Response.StatusCode != http.StatusNoContent {
		vmt, err = client.CreateResponder(vmt.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachineTemplatesCreateFuture", "Result", vmt.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualMachineTemplatesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualMachineTemplatesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualMachineTemplatesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualMachineTemplatesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualMachineTemplatesDeleteFuture.Result.
func (future *VirtualMachineTemplatesDeleteFuture) result(client VirtualMachineTemplatesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualMachineTemplatesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualMachineTemplatesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachineTemplatesList list of VirtualMachineTemplates.
type VirtualMachineTemplatesList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VirtualMachineTemplates.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VirtualMachineTemplates
	Value *[]VirtualMachineTemplate `json:"value,omitempty"`
}

// VirtualMachineTemplatesListIterator provides access to a complete listing of VirtualMachineTemplate
// values.
type VirtualMachineTemplatesListIterator struct {
	i    int
	page VirtualMachineTemplatesListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualMachineTemplatesListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachineTemplatesListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualMachineTemplatesListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualMachineTemplatesListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualMachineTemplatesListIterator) Response() VirtualMachineTemplatesList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualMachineTemplatesListIterator) Value() VirtualMachineTemplate {
	if !iter.page.NotDone() {
		return VirtualMachineTemplate{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualMachineTemplatesListIterator type.
func NewVirtualMachineTemplatesListIterator(page VirtualMachineTemplatesListPage) VirtualMachineTemplatesListIterator {
	return VirtualMachineTemplatesListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vmtl VirtualMachineTemplatesList) IsEmpty() bool {
	return vmtl.Value == nil || len(*vmtl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vmtl VirtualMachineTemplatesList) hasNextLink() bool {
	return vmtl.NextLink != nil && len(*vmtl.NextLink) != 0
}

// virtualMachineTemplatesListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vmtl VirtualMachineTemplatesList) virtualMachineTemplatesListPreparer(ctx context.Context) (*http.Request, error) {
	if !vmtl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vmtl.NextLink)))
}

// VirtualMachineTemplatesListPage contains a page of VirtualMachineTemplate values.
type VirtualMachineTemplatesListPage struct {
	fn   func(context.Context, VirtualMachineTemplatesList) (VirtualMachineTemplatesList, error)
	vmtl VirtualMachineTemplatesList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualMachineTemplatesListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualMachineTemplatesListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vmtl)
		if err != nil {
			return err
		}
		page.vmtl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualMachineTemplatesListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualMachineTemplatesListPage) NotDone() bool {
	return !page.vmtl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualMachineTemplatesListPage) Response() VirtualMachineTemplatesList {
	return page.vmtl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualMachineTemplatesListPage) Values() []VirtualMachineTemplate {
	if page.vmtl.IsEmpty() {
		return nil
	}
	return *page.vmtl.Value
}

// Creates a new instance of the VirtualMachineTemplatesListPage type.
func NewVirtualMachineTemplatesListPage(cur VirtualMachineTemplatesList, getNextPage func(context.Context, VirtualMachineTemplatesList) (VirtualMachineTemplatesList, error)) VirtualMachineTemplatesListPage {
	return VirtualMachineTemplatesListPage{
		fn:   getNextPage,
		vmtl: cur,
	}
}

// VirtualMachineUpdate defines the virtualMachineUpdate.
type VirtualMachineUpdate struct {
	// VirtualMachineUpdateProperties - Resource properties.
	*VirtualMachineUpdateProperties `json:"properties,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Identity - The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualMachineUpdate.
func (vmu VirtualMachineUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmu.VirtualMachineUpdateProperties != nil {
		objectMap["properties"] = vmu.VirtualMachineUpdateProperties
	}
	if vmu.Tags != nil {
		objectMap["tags"] = vmu.Tags
	}
	if vmu.Identity != nil {
		objectMap["identity"] = vmu.Identity
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualMachineUpdate struct.
func (vmu *VirtualMachineUpdate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualMachineUpdateProperties VirtualMachineUpdateProperties
				err = json.Unmarshal(*v, &virtualMachineUpdateProperties)
				if err != nil {
					return err
				}
				vmu.VirtualMachineUpdateProperties = &virtualMachineUpdateProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vmu.Tags = tags
			}
		case "identity":
			if v != nil {
				var identity Identity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				vmu.Identity = &identity
			}
		}
	}

	return nil
}

// VirtualMachineUpdateProperties defines the resource properties.
type VirtualMachineUpdateProperties struct {
	HardwareProfile *HardwareProfile      `json:"hardwareProfile,omitempty"`
	StorageProfile  *StorageProfileUpdate `json:"storageProfile,omitempty"`
	NetworkProfile  *NetworkProfileUpdate `json:"networkProfile,omitempty"`
}

// VirtualNetwork define the virtualNetwork.
type VirtualNetwork struct {
	autorest.Response `json:"-"`
	// VirtualNetworkProperties - Resource properties.
	*VirtualNetworkProperties `json:"properties,omitempty"`
	// Location - Gets or sets the location.
	Location *string `json:"location,omitempty"`
	// ExtendedLocation - Gets or sets the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// SystemData - The system data.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
	// Name - READ-ONLY; Gets or sets the name.
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; Gets or sets the Id.
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Gets or sets the type of the resource.
	Type *string `json:"type,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetwork.
func (vn VirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vn.VirtualNetworkProperties != nil {
		objectMap["properties"] = vn.VirtualNetworkProperties
	}
	if vn.Location != nil {
		objectMap["location"] = vn.Location
	}
	if vn.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vn.ExtendedLocation
	}
	if vn.SystemData != nil {
		objectMap["systemData"] = vn.SystemData
	}
	if vn.Tags != nil {
		objectMap["tags"] = vn.Tags
	}
	if vn.Kind != nil {
		objectMap["kind"] = vn.Kind
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualNetwork struct.
func (vn *VirtualNetwork) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualNetworkProperties VirtualNetworkProperties
				err = json.Unmarshal(*v, &virtualNetworkProperties)
				if err != nil {
					return err
				}
				vn.VirtualNetworkProperties = &virtualNetworkProperties
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vn.Location = &location
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vn.ExtendedLocation = &extendedLocation
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vn.SystemData = &systemData
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vn.Tags = tags
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vn.Name = &name
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vn.ID = &ID
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vn.Type = &typeVar
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				vn.Kind = &kind
			}
		}
	}

	return nil
}

// VirtualNetworkInventoryItem the Virtual network inventory item.
type VirtualNetworkInventoryItem struct {
	// ManagedResourceID - Gets or sets the tracked resource id corresponding to the inventory resource.
	ManagedResourceID *string `json:"managedResourceId,omitempty"`
	// MoRefID - Gets or sets the MoRef (Managed Object Reference) ID for the inventory item.
	MoRefID *string `json:"moRefId,omitempty"`
	// MoName - Gets or sets the vCenter Managed Object name for the inventory item.
	MoName *string `json:"moName,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// InventoryType - Possible values include: 'InventoryTypeInventoryItemProperties', 'InventoryTypeResourcePool1', 'InventoryTypeVirtualMachine1', 'InventoryTypeVirtualMachineTemplate1', 'InventoryTypeVirtualNetwork1', 'InventoryTypeCluster1', 'InventoryTypeDatastore1', 'InventoryTypeHost1'
	InventoryType InventoryTypeBasicInventoryItemProperties `json:"inventoryType,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) MarshalJSON() ([]byte, error) {
	vnii.InventoryType = InventoryTypeVirtualNetwork1
	objectMap := make(map[string]interface{})
	if vnii.ManagedResourceID != nil {
		objectMap["managedResourceId"] = vnii.ManagedResourceID
	}
	if vnii.MoRefID != nil {
		objectMap["moRefId"] = vnii.MoRefID
	}
	if vnii.MoName != nil {
		objectMap["moName"] = vnii.MoName
	}
	if vnii.InventoryType != "" {
		objectMap["inventoryType"] = vnii.InventoryType
	}
	return json.Marshal(objectMap)
}

// AsResourcePoolInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsResourcePoolInventoryItem() (*ResourcePoolInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsVirtualMachineInventoryItem() (*VirtualMachineInventoryItem, bool) {
	return nil, false
}

// AsVirtualMachineTemplateInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsVirtualMachineTemplateInventoryItem() (*VirtualMachineTemplateInventoryItem, bool) {
	return nil, false
}

// AsVirtualNetworkInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsVirtualNetworkInventoryItem() (*VirtualNetworkInventoryItem, bool) {
	return &vnii, true
}

// AsClusterInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsClusterInventoryItem() (*ClusterInventoryItem, bool) {
	return nil, false
}

// AsDatastoreInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsDatastoreInventoryItem() (*DatastoreInventoryItem, bool) {
	return nil, false
}

// AsHostInventoryItem is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsHostInventoryItem() (*HostInventoryItem, bool) {
	return nil, false
}

// AsInventoryItemProperties is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsInventoryItemProperties() (*InventoryItemProperties, bool) {
	return nil, false
}

// AsBasicInventoryItemProperties is the BasicInventoryItemProperties implementation for VirtualNetworkInventoryItem.
func (vnii VirtualNetworkInventoryItem) AsBasicInventoryItemProperties() (BasicInventoryItemProperties, bool) {
	return &vnii, true
}

// VirtualNetworkProperties defines the resource properties.
type VirtualNetworkProperties struct {
	// UUID - READ-ONLY; Gets or sets a unique identifier for this resource.
	UUID *string `json:"uuid,omitempty"`
	// VCenterID - Gets or sets the ARM Id of the vCenter resource in which this template resides.
	VCenterID *string `json:"vCenterId,omitempty"`
	// MoRefID - Gets or sets the vCenter MoRef (Managed Object Reference) ID for the virtual network.
	MoRefID *string `json:"moRefId,omitempty"`
	// InventoryItemID - Gets or sets the inventory Item ID for the virtual network.
	InventoryItemID *string `json:"inventoryItemId,omitempty"`
	// MoName - READ-ONLY; Gets or sets the vCenter Managed Object name for the virtual network.
	MoName *string `json:"moName,omitempty"`
	// CustomResourceName - READ-ONLY; Gets the name of the corresponding resource in Kubernetes.
	CustomResourceName *string `json:"customResourceName,omitempty"`
	// Statuses - READ-ONLY; The resource status information.
	Statuses *[]ResourceStatus `json:"statuses,omitempty"`
	// ProvisioningState - READ-ONLY; Gets or sets the provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualNetworkProperties.
func (vnp VirtualNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnp.VCenterID != nil {
		objectMap["vCenterId"] = vnp.VCenterID
	}
	if vnp.MoRefID != nil {
		objectMap["moRefId"] = vnp.MoRefID
	}
	if vnp.InventoryItemID != nil {
		objectMap["inventoryItemId"] = vnp.InventoryItemID
	}
	return json.Marshal(objectMap)
}

// VirtualNetworksCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualNetworksCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworksClient) (VirtualNetwork, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworksCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworksCreateFuture.Result.
func (future *VirtualNetworksCreateFuture) result(client VirtualNetworksClient) (vn VirtualNetwork, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualNetworksCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vn.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualNetworksCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vn.Response.Response, err = future.GetResult(sender); err == nil && vn.Response.Response.StatusCode != http.StatusNoContent {
		vn, err = client.CreateResponder(vn.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "connectedvmware.VirtualNetworksCreateFuture", "Result", vn.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualNetworksDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualNetworksDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualNetworksClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualNetworksDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualNetworksDeleteFuture.Result.
func (future *VirtualNetworksDeleteFuture) result(client VirtualNetworksClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "connectedvmware.VirtualNetworksDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("connectedvmware.VirtualNetworksDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualNetworksList list of VirtualNetworks.
type VirtualNetworksList struct {
	autorest.Response `json:"-"`
	// NextLink - Url to follow for getting next page of VirtualNetworks.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - Array of VirtualNetworks
	Value *[]VirtualNetwork `json:"value,omitempty"`
}

// VirtualNetworksListIterator provides access to a complete listing of VirtualNetwork values.
type VirtualNetworksListIterator struct {
	i    int
	page VirtualNetworksListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualNetworksListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworksListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualNetworksListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualNetworksListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualNetworksListIterator) Response() VirtualNetworksList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualNetworksListIterator) Value() VirtualNetwork {
	if !iter.page.NotDone() {
		return VirtualNetwork{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualNetworksListIterator type.
func NewVirtualNetworksListIterator(page VirtualNetworksListPage) VirtualNetworksListIterator {
	return VirtualNetworksListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vnl VirtualNetworksList) IsEmpty() bool {
	return vnl.Value == nil || len(*vnl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vnl VirtualNetworksList) hasNextLink() bool {
	return vnl.NextLink != nil && len(*vnl.NextLink) != 0
}

// virtualNetworksListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vnl VirtualNetworksList) virtualNetworksListPreparer(ctx context.Context) (*http.Request, error) {
	if !vnl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vnl.NextLink)))
}

// VirtualNetworksListPage contains a page of VirtualNetwork values.
type VirtualNetworksListPage struct {
	fn  func(context.Context, VirtualNetworksList) (VirtualNetworksList, error)
	vnl VirtualNetworksList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualNetworksListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualNetworksListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vnl)
		if err != nil {
			return err
		}
		page.vnl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualNetworksListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualNetworksListPage) NotDone() bool {
	return !page.vnl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualNetworksListPage) Response() VirtualNetworksList {
	return page.vnl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualNetworksListPage) Values() []VirtualNetwork {
	if page.vnl.IsEmpty() {
		return nil
	}
	return *page.vnl.Value
}

// Creates a new instance of the VirtualNetworksListPage type.
func NewVirtualNetworksListPage(cur VirtualNetworksList, getNextPage func(context.Context, VirtualNetworksList) (VirtualNetworksList, error)) VirtualNetworksListPage {
	return VirtualNetworksListPage{
		fn:  getNextPage,
		vnl: cur,
	}
}

// VirtualSCSIController this data object type contains the properties of a SCSI controller device attached
// to a virtual machine that is reported by the controller.
type VirtualSCSIController struct {
	// Type - Gets or sets the controller type. Possible values include: 'Lsilogic', 'Buslogic', 'Pvscsi', 'Lsilogicsas'
	Type SCSIControllerType `json:"type,omitempty"`
	// ControllerKey - Gets or sets the key of the controller.
	ControllerKey *int32 `json:"controllerKey,omitempty"`
	// BusNumber - Gets or sets the bus number of the controller.
	BusNumber *int32 `json:"busNumber,omitempty"`
	// ScsiCtlrUnitNumber - Gets or sets the SCSI controller unit number.
	ScsiCtlrUnitNumber *int32 `json:"scsiCtlrUnitNumber,omitempty"`
	// Sharing - Gets or sets the sharing mode. Possible values include: 'NoSharing', 'PhysicalSharing', 'VirtualSharing'
	Sharing VirtualSCSISharing `json:"sharing,omitempty"`
}
