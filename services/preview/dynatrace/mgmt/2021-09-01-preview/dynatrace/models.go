package dynatrace

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/dynatrace/mgmt/2021-09-01-preview/dynatrace"

// AccountInfo dynatrace Account Information
type AccountInfo struct {
	// AccountID - Account Id of the account this environment is linked to
	AccountID *string `json:"accountId,omitempty"`
	// RegionID - Region in which the account is created
	RegionID *string `json:"regionId,omitempty"`
}

// AccountInfoSecure dynatrace account API Key
type AccountInfoSecure struct {
	autorest.Response `json:"-"`
	// AccountID - READ-ONLY; Account Id of the account this environment is linked to
	AccountID *string `json:"accountId,omitempty"`
	// APIKey - READ-ONLY; API Key of the user account
	APIKey *string `json:"apiKey,omitempty"`
	// RegionID - READ-ONLY; Region in which the account is created
	RegionID *string `json:"regionId,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountInfoSecure.
func (ais AccountInfoSecure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// AppServiceInfo details of App Services having Dynatrace OneAgent installed
type AppServiceInfo struct {
	// ResourceID - App service resource ID
	ResourceID *string `json:"resourceId,omitempty"`
	// Version - Version of the Dynatrace agent installed on the App Service.
	Version *string `json:"version,omitempty"`
	// MonitoringType - The monitoring mode of OneAgent. Possible values include: 'CLOUDINFRASTRUCTURE', 'FULLSTACK'
	MonitoringType MonitoringType `json:"monitoringType,omitempty"`
	// AutoUpdateSetting - Update settings of OneAgent. Possible values include: 'ENABLED', 'DISABLED'
	AutoUpdateSetting AutoUpdateSetting `json:"autoUpdateSetting,omitempty"`
	// UpdateStatus - The current update status of OneAgent. Possible values include: 'UpdateStatusINCOMPATIBLE', 'UpdateStatusOUTDATED', 'UpdateStatusSCHEDULED', 'UpdateStatusSUPPRESSED', 'UpdateStatusUNKNOWN', 'UpdateStatusUP2DATE', 'UpdateStatusUPDATEINPROGRESS', 'UpdateStatusUPDATEPENDING', 'UpdateStatusUPDATEPROBLEM'
	UpdateStatus UpdateStatus `json:"updateStatus,omitempty"`
	// AvailabilityState - The availability state of OneAgent. Possible values include: 'CRASHED', 'LOST', 'MONITORED', 'PREMONITORED', 'SHUTDOWN', 'UNEXPECTEDSHUTDOWN', 'UNKNOWN', 'UNMONITORED'
	AvailabilityState AvailabilityState `json:"availabilityState,omitempty"`
	// LogModule - Tells whether log modules are enabled or not. Possible values include: 'LogModuleENABLED', 'LogModuleDISABLED'
	LogModule LogModule `json:"logModule,omitempty"`
	// HostGroup - The name of the host group
	HostGroup *string `json:"hostGroup,omitempty"`
	// HostName - The name of the host
	HostName *string `json:"hostName,omitempty"`
}

// AppServiceListResponse response of a list App Services Operation.
type AppServiceListResponse struct {
	autorest.Response `json:"-"`
	// Value - The items on this page
	Value *[]AppServiceInfo `json:"value,omitempty"`
	// NextLink - The link to the next page of items
	NextLink *string `json:"nextLink,omitempty"`
}

// AppServiceListResponseIterator provides access to a complete listing of AppServiceInfo values.
type AppServiceListResponseIterator struct {
	i    int
	page AppServiceListResponsePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppServiceListResponseIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceListResponseIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppServiceListResponseIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppServiceListResponseIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppServiceListResponseIterator) Response() AppServiceListResponse {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppServiceListResponseIterator) Value() AppServiceInfo {
	if !iter.page.NotDone() {
		return AppServiceInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppServiceListResponseIterator type.
func NewAppServiceListResponseIterator(page AppServiceListResponsePage) AppServiceListResponseIterator {
	return AppServiceListResponseIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aslr AppServiceListResponse) IsEmpty() bool {
	return aslr.Value == nil || len(*aslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aslr AppServiceListResponse) hasNextLink() bool {
	return aslr.NextLink != nil && len(*aslr.NextLink) != 0
}

// appServiceListResponsePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aslr AppServiceListResponse) appServiceListResponsePreparer(ctx context.Context) (*http.Request, error) {
	if !aslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aslr.NextLink)))
}

// AppServiceListResponsePage contains a page of AppServiceInfo values.
type AppServiceListResponsePage struct {
	fn   func(context.Context, AppServiceListResponse) (AppServiceListResponse, error)
	aslr AppServiceListResponse
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppServiceListResponsePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppServiceListResponsePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aslr)
		if err != nil {
			return err
		}
		page.aslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppServiceListResponsePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppServiceListResponsePage) NotDone() bool {
	return !page.aslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppServiceListResponsePage) Response() AppServiceListResponse {
	return page.aslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppServiceListResponsePage) Values() []AppServiceInfo {
	if page.aslr.IsEmpty() {
		return nil
	}
	return *page.aslr.Value
}

// Creates a new instance of the AppServiceListResponsePage type.
func NewAppServiceListResponsePage(cur AppServiceListResponse, getNextPage func(context.Context, AppServiceListResponse) (AppServiceListResponse, error)) AppServiceListResponsePage {
	return AppServiceListResponsePage{
		fn:   getNextPage,
		aslr: cur,
	}
}

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// EnvironmentInfo dynatrace Environment Information
type EnvironmentInfo struct {
	// EnvironmentID - Id of the environment created
	EnvironmentID *string `json:"environmentId,omitempty"`
	// IngestionKey - Ingestion key of the environment
	IngestionKey *string `json:"ingestionKey,omitempty"`
	// LogsIngestionEndpoint - Ingestion endpoint used for sending logs
	LogsIngestionEndpoint *string `json:"logsIngestionEndpoint,omitempty"`
	// LandingURL - Landing URL for Dynatrace environment
	LandingURL *string `json:"landingURL,omitempty"`
}

// EnvironmentProperties properties of the Dynatrace environment.
type EnvironmentProperties struct {
	// UserID - User id
	UserID *string `json:"userId,omitempty"`
	// AccountInfo - Dynatrace Account Information
	AccountInfo *AccountInfo `json:"accountInfo,omitempty"`
	// EnvironmentInfo - Dynatrace Environment Information
	EnvironmentInfo *EnvironmentInfo `json:"environmentInfo,omitempty"`
	// SingleSignOnProperties - The details of a Dynatrace single sign-on.
	SingleSignOnProperties *SingleSignOnProperties `json:"singleSignOnProperties,omitempty"`
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// FilteringTag the definition of a filtering tag. Filtering tags are used for capturing resources and
// include/exclude them from being monitored.
type FilteringTag struct {
	// Name - The name (also known as the key) of the tag.
	Name *string `json:"name,omitempty"`
	// Value - The value of the tag.
	Value *string `json:"value,omitempty"`
	// Action - Valid actions for a filtering tag. Exclusion takes priority over inclusion. Possible values include: 'Include', 'Exclude'
	Action TagAction `json:"action,omitempty"`
}

// IdentityProperties the properties of the managed service identities assigned to this resource.
type IdentityProperties struct {
	// TenantID - READ-ONLY; The Active Directory tenant id of the principal.
	TenantID *string `json:"tenantId,omitempty"`
	// PrincipalID - READ-ONLY; The active directory identifier of this principal.
	PrincipalID *string `json:"principalId,omitempty"`
	// Type - The type of managed identity assigned to this resource. Possible values include: 'SystemAssigned', 'UserAssigned', 'SystemAndUserAssigned'
	Type ManagedIdentityType `json:"type,omitempty"`
	// UserAssignedIdentities - The identities assigned to this resource by the user.
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for IdentityProperties.
func (IP IdentityProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if IP.Type != "" {
		objectMap["type"] = IP.Type
	}
	if IP.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = IP.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// LinkableEnvironmentListResponse response for getting all the linkable environments
type LinkableEnvironmentListResponse struct {
	autorest.Response `json:"-"`
	// Value - List of environments for which user is an admin
	Value *[]LinkableEnvironmentResponse `json:"value,omitempty"`
	// NextLink - Link to the next set of results, if any.
	NextLink *string `json:"nextLink,omitempty"`
}

// LinkableEnvironmentListResponseIterator provides access to a complete listing of
// LinkableEnvironmentResponse values.
type LinkableEnvironmentListResponseIterator struct {
	i    int
	page LinkableEnvironmentListResponsePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *LinkableEnvironmentListResponseIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LinkableEnvironmentListResponseIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *LinkableEnvironmentListResponseIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter LinkableEnvironmentListResponseIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter LinkableEnvironmentListResponseIterator) Response() LinkableEnvironmentListResponse {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter LinkableEnvironmentListResponseIterator) Value() LinkableEnvironmentResponse {
	if !iter.page.NotDone() {
		return LinkableEnvironmentResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the LinkableEnvironmentListResponseIterator type.
func NewLinkableEnvironmentListResponseIterator(page LinkableEnvironmentListResponsePage) LinkableEnvironmentListResponseIterator {
	return LinkableEnvironmentListResponseIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lelr LinkableEnvironmentListResponse) IsEmpty() bool {
	return lelr.Value == nil || len(*lelr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lelr LinkableEnvironmentListResponse) hasNextLink() bool {
	return lelr.NextLink != nil && len(*lelr.NextLink) != 0
}

// linkableEnvironmentListResponsePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lelr LinkableEnvironmentListResponse) linkableEnvironmentListResponsePreparer(ctx context.Context) (*http.Request, error) {
	if !lelr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lelr.NextLink)))
}

// LinkableEnvironmentListResponsePage contains a page of LinkableEnvironmentResponse values.
type LinkableEnvironmentListResponsePage struct {
	fn   func(context.Context, LinkableEnvironmentListResponse) (LinkableEnvironmentListResponse, error)
	lelr LinkableEnvironmentListResponse
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *LinkableEnvironmentListResponsePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/LinkableEnvironmentListResponsePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lelr)
		if err != nil {
			return err
		}
		page.lelr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *LinkableEnvironmentListResponsePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page LinkableEnvironmentListResponsePage) NotDone() bool {
	return !page.lelr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page LinkableEnvironmentListResponsePage) Response() LinkableEnvironmentListResponse {
	return page.lelr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page LinkableEnvironmentListResponsePage) Values() []LinkableEnvironmentResponse {
	if page.lelr.IsEmpty() {
		return nil
	}
	return *page.lelr.Value
}

// Creates a new instance of the LinkableEnvironmentListResponsePage type.
func NewLinkableEnvironmentListResponsePage(cur LinkableEnvironmentListResponse, getNextPage func(context.Context, LinkableEnvironmentListResponse) (LinkableEnvironmentListResponse, error)) LinkableEnvironmentListResponsePage {
	return LinkableEnvironmentListResponsePage{
		fn:   getNextPage,
		lelr: cur,
	}
}

// LinkableEnvironmentRequest request for getting all the linkable environments for a user
type LinkableEnvironmentRequest struct {
	// TenantID - Tenant Id of the user in which they want to link the environment
	TenantID *string `json:"tenantId,omitempty"`
	// UserPrincipal - user principal id of the user
	UserPrincipal *string `json:"userPrincipal,omitempty"`
	// Region - Azure region in which we want to link the environment
	Region *string `json:"region,omitempty"`
}

// LinkableEnvironmentResponse response for getting all the linkable environments
type LinkableEnvironmentResponse struct {
	// EnvironmentID - environment id for which user is an admin
	EnvironmentID *string `json:"environmentId,omitempty"`
	// EnvironmentName - Name of the environment
	EnvironmentName *string `json:"environmentName,omitempty"`
	// PlanData - Billing plan information.
	PlanData *PlanData `json:"planData,omitempty"`
}

// LogRules set of rules for sending logs for the Monitor resource.
type LogRules struct {
	// SendAadLogs - Flag specifying if AAD logs should be sent for the Monitor resource. Possible values include: 'SendAadLogsStatusEnabled', 'SendAadLogsStatusDisabled'
	SendAadLogs SendAadLogsStatus `json:"sendAadLogs,omitempty"`
	// SendSubscriptionLogs - Flag specifying if subscription logs should be sent for the Monitor resource. Possible values include: 'SendSubscriptionLogsStatusEnabled', 'SendSubscriptionLogsStatusDisabled'
	SendSubscriptionLogs SendSubscriptionLogsStatus `json:"sendSubscriptionLogs,omitempty"`
	// SendActivityLogs - Flag specifying if activity logs from Azure resources should be sent for the Monitor resource. Possible values include: 'SendActivityLogsStatusEnabled', 'SendActivityLogsStatusDisabled'
	SendActivityLogs SendActivityLogsStatus `json:"sendActivityLogs,omitempty"`
	// FilteringTags - List of filtering tags to be used for capturing logs. This only takes effect if SendActivityLogs flag is enabled. If empty, all resources will be captured.
	// If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
	FilteringTags *[]FilteringTag `json:"filteringTags,omitempty"`
}

// MetricRules set of rules for sending metrics for the Monitor resource.
type MetricRules struct {
	// FilteringTags - List of filtering tags to be used for capturing metrics. If empty, all resources will be captured. If only Exclude action is specified, the rules will apply to the list of all available resources. If Include actions are specified, the rules will only include resources with the associated tags.
	FilteringTags *[]FilteringTag `json:"filteringTags,omitempty"`
}

// MonitoredResource details of resource being monitored by Dynatrace monitor resource
type MonitoredResource struct {
	// ID - The ARM id of the resource.
	ID *string `json:"id,omitempty"`
	// SendingMetrics - Flag indicating if resource is sending metrics to Dynatrace. Possible values include: 'SendingMetricsStatusEnabled', 'SendingMetricsStatusDisabled'
	SendingMetrics SendingMetricsStatus `json:"sendingMetrics,omitempty"`
	// ReasonForMetricsStatus - Reason for why the resource is sending metrics (or why it is not sending).
	ReasonForMetricsStatus *string `json:"reasonForMetricsStatus,omitempty"`
	// SendingLogs - Flag indicating if resource is sending logs to Dynatrace. Possible values include: 'SendingLogsStatusEnabled', 'SendingLogsStatusDisabled'
	SendingLogs SendingLogsStatus `json:"sendingLogs,omitempty"`
	// ReasonForLogsStatus - Reason for why the resource is sending logs (or why it is not sending).
	ReasonForLogsStatus *string `json:"reasonForLogsStatus,omitempty"`
}

// MonitoredResourceListResponse list of all the resources being monitored by Dynatrace monitor resource
type MonitoredResourceListResponse struct {
	autorest.Response `json:"-"`
	// Value - The items on this page
	Value *[]MonitoredResource `json:"value,omitempty"`
	// NextLink - The link to the next page of items
	NextLink *string `json:"nextLink,omitempty"`
}

// MonitoredResourceListResponseIterator provides access to a complete listing of MonitoredResource values.
type MonitoredResourceListResponseIterator struct {
	i    int
	page MonitoredResourceListResponsePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *MonitoredResourceListResponseIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MonitoredResourceListResponseIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *MonitoredResourceListResponseIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter MonitoredResourceListResponseIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter MonitoredResourceListResponseIterator) Response() MonitoredResourceListResponse {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter MonitoredResourceListResponseIterator) Value() MonitoredResource {
	if !iter.page.NotDone() {
		return MonitoredResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the MonitoredResourceListResponseIterator type.
func NewMonitoredResourceListResponseIterator(page MonitoredResourceListResponsePage) MonitoredResourceListResponseIterator {
	return MonitoredResourceListResponseIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mrlr MonitoredResourceListResponse) IsEmpty() bool {
	return mrlr.Value == nil || len(*mrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mrlr MonitoredResourceListResponse) hasNextLink() bool {
	return mrlr.NextLink != nil && len(*mrlr.NextLink) != 0
}

// monitoredResourceListResponsePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mrlr MonitoredResourceListResponse) monitoredResourceListResponsePreparer(ctx context.Context) (*http.Request, error) {
	if !mrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mrlr.NextLink)))
}

// MonitoredResourceListResponsePage contains a page of MonitoredResource values.
type MonitoredResourceListResponsePage struct {
	fn   func(context.Context, MonitoredResourceListResponse) (MonitoredResourceListResponse, error)
	mrlr MonitoredResourceListResponse
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *MonitoredResourceListResponsePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MonitoredResourceListResponsePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mrlr)
		if err != nil {
			return err
		}
		page.mrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *MonitoredResourceListResponsePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page MonitoredResourceListResponsePage) NotDone() bool {
	return !page.mrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page MonitoredResourceListResponsePage) Response() MonitoredResourceListResponse {
	return page.mrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page MonitoredResourceListResponsePage) Values() []MonitoredResource {
	if page.mrlr.IsEmpty() {
		return nil
	}
	return *page.mrlr.Value
}

// Creates a new instance of the MonitoredResourceListResponsePage type.
func NewMonitoredResourceListResponsePage(cur MonitoredResourceListResponse, getNextPage func(context.Context, MonitoredResourceListResponse) (MonitoredResourceListResponse, error)) MonitoredResourceListResponsePage {
	return MonitoredResourceListResponsePage{
		fn:   getNextPage,
		mrlr: cur,
	}
}

// MonitoringTagRulesProperties properties for the Tag rules resource of a Monitor account.
type MonitoringTagRulesProperties struct {
	// LogRules - Set of rules for sending logs for the Monitor resource.
	LogRules *LogRules `json:"logRules,omitempty"`
	// MetricRules - Set of rules for sending metrics for the Monitor resource.
	MetricRules *MetricRules `json:"metricRules,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the resource. Possible values include: 'Accepted', 'Creating', 'Updating', 'Deleting', 'Succeeded', 'Failed', 'Canceled', 'Deleted', 'NotSpecified'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for MonitoringTagRulesProperties.
func (mtrp MonitoringTagRulesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mtrp.LogRules != nil {
		objectMap["logRules"] = mtrp.LogRules
	}
	if mtrp.MetricRules != nil {
		objectMap["metricRules"] = mtrp.MetricRules
	}
	return json.Marshal(objectMap)
}

// MonitorProperties properties specific to the monitor resource.
type MonitorProperties struct {
	// MonitoringStatus - Status of the monitor. Possible values include: 'Enabled', 'Disabled'
	MonitoringStatus MonitoringStatus `json:"monitoringStatus,omitempty"`
	// MarketplaceSubscriptionStatus - Marketplace subscription status. Possible values include: 'Active', 'Suspended'
	MarketplaceSubscriptionStatus MarketplaceSubscriptionStatus `json:"marketplaceSubscriptionStatus,omitempty"`
	// DynatraceEnvironmentProperties - Properties of the Dynatrace environment.
	DynatraceEnvironmentProperties *EnvironmentProperties `json:"dynatraceEnvironmentProperties,omitempty"`
	// UserInfo - User info.
	UserInfo *UserInfo `json:"userInfo,omitempty"`
	// PlanData - Billing plan information.
	PlanData *PlanData `json:"planData,omitempty"`
	// LiftrResourceCategory - READ-ONLY; Liftr Resource category. Possible values include: 'Unknown', 'MonitorLogs'
	LiftrResourceCategory LiftrResourceCategories `json:"liftrResourceCategory,omitempty"`
	// LiftrResourcePreference - READ-ONLY; The priority of the resource.
	LiftrResourcePreference *int32 `json:"liftrResourcePreference,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the resource. Possible values include: 'Accepted', 'Creating', 'Updating', 'Deleting', 'Succeeded', 'Failed', 'Canceled', 'Deleted', 'NotSpecified'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for MonitorProperties.
func (mp MonitorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mp.MonitoringStatus != "" {
		objectMap["monitoringStatus"] = mp.MonitoringStatus
	}
	if mp.MarketplaceSubscriptionStatus != "" {
		objectMap["marketplaceSubscriptionStatus"] = mp.MarketplaceSubscriptionStatus
	}
	if mp.DynatraceEnvironmentProperties != nil {
		objectMap["dynatraceEnvironmentProperties"] = mp.DynatraceEnvironmentProperties
	}
	if mp.UserInfo != nil {
		objectMap["userInfo"] = mp.UserInfo
	}
	if mp.PlanData != nil {
		objectMap["planData"] = mp.PlanData
	}
	return json.Marshal(objectMap)
}

// MonitorResource dynatrace Monitor Resource
type MonitorResource struct {
	autorest.Response `json:"-"`
	// MonitorProperties - The resource-specific properties for this resource.
	*MonitorProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; System metadata for this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// Identity - The managed service identities assigned to this resource.
	Identity *IdentityProperties `json:"identity,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for MonitorResource.
func (mr MonitorResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mr.MonitorProperties != nil {
		objectMap["properties"] = mr.MonitorProperties
	}
	if mr.Identity != nil {
		objectMap["identity"] = mr.Identity
	}
	if mr.Tags != nil {
		objectMap["tags"] = mr.Tags
	}
	if mr.Location != nil {
		objectMap["location"] = mr.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MonitorResource struct.
func (mr *MonitorResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var monitorProperties MonitorProperties
				err = json.Unmarshal(*v, &monitorProperties)
				if err != nil {
					return err
				}
				mr.MonitorProperties = &monitorProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				mr.SystemData = &systemData
			}
		case "identity":
			if v != nil {
				var identity IdentityProperties
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				mr.Identity = &identity
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				mr.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				mr.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mr.Type = &typeVar
			}
		}
	}

	return nil
}

// MonitorResourceListResult the response of a MonitorResource list operation.
type MonitorResourceListResult struct {
	autorest.Response `json:"-"`
	// Value - The items on this page
	Value *[]MonitorResource `json:"value,omitempty"`
	// NextLink - The link to the next page of items
	NextLink *string `json:"nextLink,omitempty"`
}

// MonitorResourceListResultIterator provides access to a complete listing of MonitorResource values.
type MonitorResourceListResultIterator struct {
	i    int
	page MonitorResourceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *MonitorResourceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MonitorResourceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *MonitorResourceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter MonitorResourceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter MonitorResourceListResultIterator) Response() MonitorResourceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter MonitorResourceListResultIterator) Value() MonitorResource {
	if !iter.page.NotDone() {
		return MonitorResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the MonitorResourceListResultIterator type.
func NewMonitorResourceListResultIterator(page MonitorResourceListResultPage) MonitorResourceListResultIterator {
	return MonitorResourceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mrlr MonitorResourceListResult) IsEmpty() bool {
	return mrlr.Value == nil || len(*mrlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mrlr MonitorResourceListResult) hasNextLink() bool {
	return mrlr.NextLink != nil && len(*mrlr.NextLink) != 0
}

// monitorResourceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mrlr MonitorResourceListResult) monitorResourceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !mrlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mrlr.NextLink)))
}

// MonitorResourceListResultPage contains a page of MonitorResource values.
type MonitorResourceListResultPage struct {
	fn   func(context.Context, MonitorResourceListResult) (MonitorResourceListResult, error)
	mrlr MonitorResourceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *MonitorResourceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MonitorResourceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mrlr)
		if err != nil {
			return err
		}
		page.mrlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *MonitorResourceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page MonitorResourceListResultPage) NotDone() bool {
	return !page.mrlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page MonitorResourceListResultPage) Response() MonitorResourceListResult {
	return page.mrlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page MonitorResourceListResultPage) Values() []MonitorResource {
	if page.mrlr.IsEmpty() {
		return nil
	}
	return *page.mrlr.Value
}

// Creates a new instance of the MonitorResourceListResultPage type.
func NewMonitorResourceListResultPage(cur MonitorResourceListResult, getNextPage func(context.Context, MonitorResourceListResult) (MonitorResourceListResult, error)) MonitorResourceListResultPage {
	return MonitorResourceListResultPage{
		fn:   getNextPage,
		mrlr: cur,
	}
}

// MonitorResourceUpdate the updatable properties of the MonitorResource.
type MonitorResourceUpdate struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// MonitoringStatus - Status of the monitor. Possible values include: 'Enabled', 'Disabled'
	MonitoringStatus MonitoringStatus `json:"monitoringStatus,omitempty"`
	// MarketplaceSubscriptionStatus - Marketplace subscription status. Possible values include: 'Active', 'Suspended'
	MarketplaceSubscriptionStatus MarketplaceSubscriptionStatus `json:"marketplaceSubscriptionStatus,omitempty"`
	// DynatraceEnvironmentProperties - Properties of the Dynatrace environment.
	DynatraceEnvironmentProperties *EnvironmentProperties `json:"dynatraceEnvironmentProperties,omitempty"`
	// UserInfo - User info.
	UserInfo *UserInfo `json:"userInfo,omitempty"`
	// PlanData - Billing plan information.
	PlanData *PlanData `json:"planData,omitempty"`
}

// MarshalJSON is the custom marshaler for MonitorResourceUpdate.
func (mru MonitorResourceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mru.Tags != nil {
		objectMap["tags"] = mru.Tags
	}
	if mru.MonitoringStatus != "" {
		objectMap["monitoringStatus"] = mru.MonitoringStatus
	}
	if mru.MarketplaceSubscriptionStatus != "" {
		objectMap["marketplaceSubscriptionStatus"] = mru.MarketplaceSubscriptionStatus
	}
	if mru.DynatraceEnvironmentProperties != nil {
		objectMap["dynatraceEnvironmentProperties"] = mru.DynatraceEnvironmentProperties
	}
	if mru.UserInfo != nil {
		objectMap["userInfo"] = mru.UserInfo
	}
	if mru.PlanData != nil {
		objectMap["planData"] = mru.PlanData
	}
	return json.Marshal(objectMap)
}

// MonitorsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type MonitorsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MonitorsClient) (MonitorResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MonitorsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MonitorsCreateOrUpdateFuture.Result.
func (future *MonitorsCreateOrUpdateFuture) result(client MonitorsClient) (mr MonitorResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "dynatrace.MonitorsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("dynatrace.MonitorsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mr.Response.Response, err = future.GetResult(sender); err == nil && mr.Response.Response.StatusCode != http.StatusNoContent {
		mr, err = client.CreateOrUpdateResponder(mr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "dynatrace.MonitorsCreateOrUpdateFuture", "Result", mr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// MonitorsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type MonitorsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MonitorsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MonitorsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MonitorsDeleteFuture.Result.
func (future *MonitorsDeleteFuture) result(client MonitorsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "dynatrace.MonitorsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("dynatrace.MonitorsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Operation details of a REST API operation, returned from the Resource Provider Operations API
type Operation struct {
	// Name - READ-ONLY; The name of the operation, as per Resource-Based Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action"
	Name *string `json:"name,omitempty"`
	// IsDataAction - READ-ONLY; Whether the operation applies to data-plane. This is "true" for data-plane operations and "false" for ARM/control-plane operations.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Localized display information for this particular operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit logs UX. Default value is "user,system". Possible values include: 'OriginUser', 'OriginSystem', 'OriginUsersystem'
	Origin Origin `json:"origin,omitempty"`
	// ActionType - READ-ONLY; Enum. Indicates the action type. "Internal" refers to actions that are for internal only APIs. Possible values include: 'Internal'
	ActionType ActionType `json:"actionType,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	return json.Marshal(objectMap)
}

// OperationDisplay localized display information for this particular operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; The localized friendly form of the resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft Compute".
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; The localized friendly name of the resource type related to this operation. E.g. "Virtual Machines" or "Job Schedule Collections".
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; The concise, localized friendly name for the operation; suitable for dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; The short, localized friendly description of the operation; suitable for tool tips and detailed views.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult a list of REST API operations supported by an Azure Resource Provider. It contains
// an URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; List of operations supported by the resource provider
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results (if there are any).
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// PlanData billing plan information.
type PlanData struct {
	// UsageType - different usage type like PAYG/COMMITTED. this could be enum
	UsageType *string `json:"usageType,omitempty"`
	// BillingCycle - different billing cycles like MONTHLY/WEEKLY. this could be enum
	BillingCycle *string `json:"billingCycle,omitempty"`
	// PlanDetails - plan id as published by Dynatrace
	PlanDetails *string `json:"planDetails,omitempty"`
	// EffectiveDate - date when plan was applied
	EffectiveDate *date.Time `json:"effectiveDate,omitempty"`
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SingleSignOnCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SingleSignOnCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SingleSignOnClient) (SingleSignOnResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SingleSignOnCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SingleSignOnCreateOrUpdateFuture.Result.
func (future *SingleSignOnCreateOrUpdateFuture) result(client SingleSignOnClient) (ssor SingleSignOnResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "dynatrace.SingleSignOnCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ssor.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("dynatrace.SingleSignOnCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ssor.Response.Response, err = future.GetResult(sender); err == nil && ssor.Response.Response.StatusCode != http.StatusNoContent {
		ssor, err = client.CreateOrUpdateResponder(ssor.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "dynatrace.SingleSignOnCreateOrUpdateFuture", "Result", ssor.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SingleSignOnProperties the details of a Dynatrace single sign-on.
type SingleSignOnProperties struct {
	// SingleSignOnState - State of Single Sign On. Possible values include: 'Initial', 'Enable', 'Disable', 'Existing'
	SingleSignOnState SingleSignOnStates `json:"singleSignOnState,omitempty"`
	// EnterpriseAppID - Version of the Dynatrace agent installed on the VM.
	EnterpriseAppID *string `json:"enterpriseAppId,omitempty"`
	// SingleSignOnURL - The login URL specific to this Dynatrace Environment
	SingleSignOnURL *string `json:"singleSignOnUrl,omitempty"`
	// AadDomains - array of Aad(azure active directory) domains
	AadDomains *[]string `json:"aadDomains,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the resource. Possible values include: 'Accepted', 'Creating', 'Updating', 'Deleting', 'Succeeded', 'Failed', 'Canceled', 'Deleted', 'NotSpecified'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for SingleSignOnProperties.
func (ssop SingleSignOnProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssop.SingleSignOnState != "" {
		objectMap["singleSignOnState"] = ssop.SingleSignOnState
	}
	if ssop.EnterpriseAppID != nil {
		objectMap["enterpriseAppId"] = ssop.EnterpriseAppID
	}
	if ssop.SingleSignOnURL != nil {
		objectMap["singleSignOnUrl"] = ssop.SingleSignOnURL
	}
	if ssop.AadDomains != nil {
		objectMap["aadDomains"] = ssop.AadDomains
	}
	return json.Marshal(objectMap)
}

// SingleSignOnResource single sign-on configurations for a given monitor resource.
type SingleSignOnResource struct {
	autorest.Response `json:"-"`
	// SingleSignOnProperties - The resource-specific properties for this resource.
	*SingleSignOnProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; System metadata for this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SingleSignOnResource.
func (ssor SingleSignOnResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ssor.SingleSignOnProperties != nil {
		objectMap["properties"] = ssor.SingleSignOnProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SingleSignOnResource struct.
func (ssor *SingleSignOnResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var singleSignOnProperties SingleSignOnProperties
				err = json.Unmarshal(*v, &singleSignOnProperties)
				if err != nil {
					return err
				}
				ssor.SingleSignOnProperties = &singleSignOnProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ssor.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ssor.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ssor.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ssor.Type = &typeVar
			}
		}
	}

	return nil
}

// SingleSignOnResourceListResult the response of a DynatraceSingleSignOnResource list operation.
type SingleSignOnResourceListResult struct {
	autorest.Response `json:"-"`
	// Value - The items on this page
	Value *[]SingleSignOnResource `json:"value,omitempty"`
	// NextLink - The link to the next page of items
	NextLink *string `json:"nextLink,omitempty"`
}

// SingleSignOnResourceListResultIterator provides access to a complete listing of SingleSignOnResource
// values.
type SingleSignOnResourceListResultIterator struct {
	i    int
	page SingleSignOnResourceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SingleSignOnResourceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SingleSignOnResourceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SingleSignOnResourceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SingleSignOnResourceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SingleSignOnResourceListResultIterator) Response() SingleSignOnResourceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SingleSignOnResourceListResultIterator) Value() SingleSignOnResource {
	if !iter.page.NotDone() {
		return SingleSignOnResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SingleSignOnResourceListResultIterator type.
func NewSingleSignOnResourceListResultIterator(page SingleSignOnResourceListResultPage) SingleSignOnResourceListResultIterator {
	return SingleSignOnResourceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ssorlr SingleSignOnResourceListResult) IsEmpty() bool {
	return ssorlr.Value == nil || len(*ssorlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ssorlr SingleSignOnResourceListResult) hasNextLink() bool {
	return ssorlr.NextLink != nil && len(*ssorlr.NextLink) != 0
}

// singleSignOnResourceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ssorlr SingleSignOnResourceListResult) singleSignOnResourceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ssorlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ssorlr.NextLink)))
}

// SingleSignOnResourceListResultPage contains a page of SingleSignOnResource values.
type SingleSignOnResourceListResultPage struct {
	fn     func(context.Context, SingleSignOnResourceListResult) (SingleSignOnResourceListResult, error)
	ssorlr SingleSignOnResourceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SingleSignOnResourceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SingleSignOnResourceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ssorlr)
		if err != nil {
			return err
		}
		page.ssorlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SingleSignOnResourceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SingleSignOnResourceListResultPage) NotDone() bool {
	return !page.ssorlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SingleSignOnResourceListResultPage) Response() SingleSignOnResourceListResult {
	return page.ssorlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SingleSignOnResourceListResultPage) Values() []SingleSignOnResource {
	if page.ssorlr.IsEmpty() {
		return nil
	}
	return *page.ssorlr.Value
}

// Creates a new instance of the SingleSignOnResourceListResultPage type.
func NewSingleSignOnResourceListResultPage(cur SingleSignOnResourceListResult, getNextPage func(context.Context, SingleSignOnResourceListResult) (SingleSignOnResourceListResult, error)) SingleSignOnResourceListResultPage {
	return SingleSignOnResourceListResultPage{
		fn:     getNextPage,
		ssorlr: cur,
	}
}

// SSODetailsRequest request for getting sso details for a user
type SSODetailsRequest struct {
	// UserPrincipal - user principal id of the user
	UserPrincipal *string `json:"userPrincipal,omitempty"`
}

// SSODetailsResponse SSO details from the Dynatrace partner
type SSODetailsResponse struct {
	autorest.Response `json:"-"`
	// IsSsoEnabled - Whether the SSO is enabled for this resource or not. Possible values include: 'SSOStatusEnabled', 'SSOStatusDisabled'
	IsSsoEnabled SSOStatus `json:"isSsoEnabled,omitempty"`
	// MetadataURL - URL for Azure AD metadata
	MetadataURL *string `json:"metadataUrl,omitempty"`
	// SingleSignOnURL - The login URL specific to this Dynatrace Environment
	SingleSignOnURL *string `json:"singleSignOnUrl,omitempty"`
	// AadDomains - array of Aad(azure active directory) domains
	AadDomains *[]string `json:"aadDomains,omitempty"`
	// AdminUsers - Array of admin user emails.
	AdminUsers *[]string `json:"adminUsers,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TagRule tag rules for a monitor resource
type TagRule struct {
	autorest.Response `json:"-"`
	// MonitoringTagRulesProperties - The resource-specific properties for this resource.
	*MonitoringTagRulesProperties `json:"properties,omitempty"`
	// SystemData - READ-ONLY; System metadata for this resource.
	SystemData *SystemData `json:"systemData,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TagRule.
func (tr TagRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.MonitoringTagRulesProperties != nil {
		objectMap["properties"] = tr.MonitoringTagRulesProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TagRule struct.
func (tr *TagRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var monitoringTagRulesProperties MonitoringTagRulesProperties
				err = json.Unmarshal(*v, &monitoringTagRulesProperties)
				if err != nil {
					return err
				}
				tr.MonitoringTagRulesProperties = &monitoringTagRulesProperties
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				tr.SystemData = &systemData
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				tr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				tr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				tr.Type = &typeVar
			}
		}
	}

	return nil
}

// TagRuleListResult the response of a TagRule list operation.
type TagRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - The items on this page
	Value *[]TagRule `json:"value,omitempty"`
	// NextLink - The link to the next page of items
	NextLink *string `json:"nextLink,omitempty"`
}

// TagRuleListResultIterator provides access to a complete listing of TagRule values.
type TagRuleListResultIterator struct {
	i    int
	page TagRuleListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TagRuleListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TagRuleListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TagRuleListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TagRuleListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TagRuleListResultIterator) Response() TagRuleListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TagRuleListResultIterator) Value() TagRule {
	if !iter.page.NotDone() {
		return TagRule{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TagRuleListResultIterator type.
func NewTagRuleListResultIterator(page TagRuleListResultPage) TagRuleListResultIterator {
	return TagRuleListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (trlr TagRuleListResult) IsEmpty() bool {
	return trlr.Value == nil || len(*trlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (trlr TagRuleListResult) hasNextLink() bool {
	return trlr.NextLink != nil && len(*trlr.NextLink) != 0
}

// tagRuleListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (trlr TagRuleListResult) tagRuleListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !trlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(trlr.NextLink)))
}

// TagRuleListResultPage contains a page of TagRule values.
type TagRuleListResultPage struct {
	fn   func(context.Context, TagRuleListResult) (TagRuleListResult, error)
	trlr TagRuleListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TagRuleListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TagRuleListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.trlr)
		if err != nil {
			return err
		}
		page.trlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TagRuleListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TagRuleListResultPage) NotDone() bool {
	return !page.trlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TagRuleListResultPage) Response() TagRuleListResult {
	return page.trlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TagRuleListResultPage) Values() []TagRule {
	if page.trlr.IsEmpty() {
		return nil
	}
	return *page.trlr.Value
}

// Creates a new instance of the TagRuleListResultPage type.
func NewTagRuleListResultPage(cur TagRuleListResult, getNextPage func(context.Context, TagRuleListResult) (TagRuleListResult, error)) TagRuleListResultPage {
	return TagRuleListResultPage{
		fn:   getNextPage,
		trlr: cur,
	}
}

// TagRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type TagRulesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(TagRulesClient) (TagRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *TagRulesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for TagRulesCreateOrUpdateFuture.Result.
func (future *TagRulesCreateOrUpdateFuture) result(client TagRulesClient) (tr TagRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "dynatrace.TagRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		tr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("dynatrace.TagRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if tr.Response.Response, err = future.GetResult(sender); err == nil && tr.Response.Response.StatusCode != http.StatusNoContent {
		tr, err = client.CreateOrUpdateResponder(tr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "dynatrace.TagRulesCreateOrUpdateFuture", "Result", tr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// TagRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type TagRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(TagRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *TagRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for TagRulesDeleteFuture.Result.
func (future *TagRulesDeleteFuture) result(client TagRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "dynatrace.TagRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("dynatrace.TagRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// TagRuleUpdate the updatable properties of the TagRule.
type TagRuleUpdate struct {
	// LogRules - Set of rules for sending logs for the Monitor resource.
	LogRules *LogRules `json:"logRules,omitempty"`
	// MetricRules - Set of rules for sending metrics for the Monitor resource.
	MetricRules *MetricRules `json:"metricRules,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// UserAssignedIdentity a managed identity assigned by the user.
type UserAssignedIdentity struct {
	// ClientID - The active directory client identifier for this principal.
	ClientID *string `json:"clientId,omitempty"`
	// PrincipalID - The active directory identifier for this principal.
	PrincipalID *string `json:"principalId,omitempty"`
}

// UserInfo user info.
type UserInfo struct {
	// FirstName - First Name of the user
	FirstName *string `json:"firstName,omitempty"`
	// LastName - Last Name of the user
	LastName *string `json:"lastName,omitempty"`
	// EmailAddress - Email of the user used by Dynatrace for contacting them if needed
	EmailAddress *string `json:"emailAddress,omitempty"`
	// PhoneNumber - Phone number of the user used by Dynatrace for contacting them if needed
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// Country - Country of the user
	Country *string `json:"country,omitempty"`
}

// VMExtensionPayload response of payload to be passed while installing VM agent.
type VMExtensionPayload struct {
	autorest.Response `json:"-"`
	// IngestionKey - Ingestion key of the environment
	IngestionKey *string `json:"ingestionKey,omitempty"`
	// EnvironmentID - Id of the environment created
	EnvironmentID *string `json:"environmentId,omitempty"`
}

// VMHostsListResponse response of a list VM Host Operation.
type VMHostsListResponse struct {
	autorest.Response `json:"-"`
	// Value - The items on this page
	Value *[]VMInfo `json:"value,omitempty"`
	// NextLink - The link to the next page of items
	NextLink *string `json:"nextLink,omitempty"`
}

// VMHostsListResponseIterator provides access to a complete listing of VMInfo values.
type VMHostsListResponseIterator struct {
	i    int
	page VMHostsListResponsePage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VMHostsListResponseIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VMHostsListResponseIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VMHostsListResponseIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VMHostsListResponseIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VMHostsListResponseIterator) Response() VMHostsListResponse {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VMHostsListResponseIterator) Value() VMInfo {
	if !iter.page.NotDone() {
		return VMInfo{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VMHostsListResponseIterator type.
func NewVMHostsListResponseIterator(page VMHostsListResponsePage) VMHostsListResponseIterator {
	return VMHostsListResponseIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vhlr VMHostsListResponse) IsEmpty() bool {
	return vhlr.Value == nil || len(*vhlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vhlr VMHostsListResponse) hasNextLink() bool {
	return vhlr.NextLink != nil && len(*vhlr.NextLink) != 0
}

// vMHostsListResponsePreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vhlr VMHostsListResponse) vMHostsListResponsePreparer(ctx context.Context) (*http.Request, error) {
	if !vhlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vhlr.NextLink)))
}

// VMHostsListResponsePage contains a page of VMInfo values.
type VMHostsListResponsePage struct {
	fn   func(context.Context, VMHostsListResponse) (VMHostsListResponse, error)
	vhlr VMHostsListResponse
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VMHostsListResponsePage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VMHostsListResponsePage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vhlr)
		if err != nil {
			return err
		}
		page.vhlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VMHostsListResponsePage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VMHostsListResponsePage) NotDone() bool {
	return !page.vhlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VMHostsListResponsePage) Response() VMHostsListResponse {
	return page.vhlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VMHostsListResponsePage) Values() []VMInfo {
	if page.vhlr.IsEmpty() {
		return nil
	}
	return *page.vhlr.Value
}

// Creates a new instance of the VMHostsListResponsePage type.
func NewVMHostsListResponsePage(cur VMHostsListResponse, getNextPage func(context.Context, VMHostsListResponse) (VMHostsListResponse, error)) VMHostsListResponsePage {
	return VMHostsListResponsePage{
		fn:   getNextPage,
		vhlr: cur,
	}
}

// VMInfo details of VM Resource having Dynatrace OneAgent installed
type VMInfo struct {
	// ResourceID - Azure VM resource ID
	ResourceID *string `json:"resourceId,omitempty"`
	// Version - Version of the Dynatrace agent installed on the VM.
	Version *string `json:"version,omitempty"`
	// MonitoringType - The monitoring mode of OneAgent. Possible values include: 'CLOUDINFRASTRUCTURE', 'FULLSTACK'
	MonitoringType MonitoringType `json:"monitoringType,omitempty"`
	// AutoUpdateSetting - Update settings of OneAgent. Possible values include: 'ENABLED', 'DISABLED'
	AutoUpdateSetting AutoUpdateSetting `json:"autoUpdateSetting,omitempty"`
	// UpdateStatus - The current update status of OneAgent. Possible values include: 'UpdateStatusINCOMPATIBLE', 'UpdateStatusOUTDATED', 'UpdateStatusSCHEDULED', 'UpdateStatusSUPPRESSED', 'UpdateStatusUNKNOWN', 'UpdateStatusUP2DATE', 'UpdateStatusUPDATEINPROGRESS', 'UpdateStatusUPDATEPENDING', 'UpdateStatusUPDATEPROBLEM'
	UpdateStatus UpdateStatus `json:"updateStatus,omitempty"`
	// AvailabilityState - The availability state of OneAgent. Possible values include: 'CRASHED', 'LOST', 'MONITORED', 'PREMONITORED', 'SHUTDOWN', 'UNEXPECTEDSHUTDOWN', 'UNKNOWN', 'UNMONITORED'
	AvailabilityState AvailabilityState `json:"availabilityState,omitempty"`
	// LogModule - Tells whether log modules are enabled or not. Possible values include: 'LogModuleENABLED', 'LogModuleDISABLED'
	LogModule LogModule `json:"logModule,omitempty"`
	// HostGroup - The name of the host group
	HostGroup *string `json:"hostGroup,omitempty"`
	// HostName - The name of the host
	HostName *string `json:"hostName,omitempty"`
}
