// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package elevation

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

type elevationClient struct {
	con *connection
	xmsClientID *string
}

// GetDataForBoundingBox - Applies to: S1 pricing tier.
// The Get Data for Bounding Box API provides elevation data at equally spaced locations within a bounding box. A bounding box is defined by the coordinates
// for two corners (southwest, northeast) and
// then subsequently divided into rows and columns.
// Elevations are returned for the vertices of the grid created by the rows and columns. Up to 2,000 elevations can be returned in a single request. The
// returned elevation values are ordered, starting at
// the southwest corner, and then proceeding west to east along the row. At the end of the row, it moves north to the next row, and repeats the process
// until it reaches the far northeast corner.
// If the operation fails it returns the *ErrorResponse error type.
func (client *elevationClient) GetDataForBoundingBox(ctx context.Context, formatParam ResponseFormat, bounds []string, rows int32, columns int32, options *ElevationGetDataForBoundingBoxOptions) (BoundingBoxResultResponse, error) {
	req, err := client.getDataForBoundingBoxCreateRequest(ctx, formatParam, bounds, rows, columns, options)
	if err != nil {
		return BoundingBoxResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BoundingBoxResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BoundingBoxResultResponse{}, client.getDataForBoundingBoxHandleError(resp)
	}
	return client.getDataForBoundingBoxHandleResponse(resp)
}

// getDataForBoundingBoxCreateRequest creates the GetDataForBoundingBox request.
func (client *elevationClient) getDataForBoundingBoxCreateRequest(ctx context.Context, formatParam ResponseFormat, bounds []string, rows int32, columns int32, options *ElevationGetDataForBoundingBoxOptions) (*azcore.Request, error) {
	urlPath := "/elevation/lattice/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("bounds", strings.Join(bounds, ","))
	reqQP.Set("rows", strconv.FormatInt(int64(rows), 10))
	reqQP.Set("columns", strconv.FormatInt(int64(columns), 10))
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDataForBoundingBoxHandleResponse handles the GetDataForBoundingBox response.
func (client *elevationClient) getDataForBoundingBoxHandleResponse(resp *azcore.Response) (BoundingBoxResultResponse, error) {
	var val *BoundingBoxResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BoundingBoxResultResponse{}, err
	}
return BoundingBoxResultResponse{RawResponse: resp.Response, BoundingBoxResult: val}, nil
}

// getDataForBoundingBoxHandleError handles the GetDataForBoundingBox error response.
func (client *elevationClient) getDataForBoundingBoxHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDataForPoints - Applies to: S1 pricing tier.
// The Get Data for Points API provides elevation data for one or more points. A point is defined in lat,long coordinate format.
// Due to the URL character length limit of 2048, it's not possible to pass more than 100 coordinates as a pipeline delimited string in a URL GET request.
// If you intend to pass more than 100 coordinates
// as a pipeline delimited string, use the POST Data For Points [https://docs.microsoft.com/en-us/rest/api/maps/elevation/postdataforpoints].
// If the operation fails it returns the *ErrorResponse error type.
func (client *elevationClient) GetDataForPoints(ctx context.Context, formatParam ResponseFormat, points []string, options *ElevationGetDataForPointsOptions) (PointsResultResponse, error) {
	req, err := client.getDataForPointsCreateRequest(ctx, formatParam, points, options)
	if err != nil {
		return PointsResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PointsResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PointsResultResponse{}, client.getDataForPointsHandleError(resp)
	}
	return client.getDataForPointsHandleResponse(resp)
}

// getDataForPointsCreateRequest creates the GetDataForPoints request.
func (client *elevationClient) getDataForPointsCreateRequest(ctx context.Context, formatParam ResponseFormat, points []string, options *ElevationGetDataForPointsOptions) (*azcore.Request, error) {
	urlPath := "/elevation/point/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.URL.RawQuery}
	unencodedParams = append(unencodedParams, "points="+strings.Join(points, "|"))
	req.URL.RawQuery = strings.Join(unencodedParams, "&")
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDataForPointsHandleResponse handles the GetDataForPoints response.
func (client *elevationClient) getDataForPointsHandleResponse(resp *azcore.Response) (PointsResultResponse, error) {
	var val *PointsResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PointsResultResponse{}, err
	}
return PointsResultResponse{RawResponse: resp.Response, PointsResult: val}, nil
}

// getDataForPointsHandleError handles the GetDataForPoints error response.
func (client *elevationClient) getDataForPointsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDataForPolyline - Applies to: S1 pricing tier.
// The Get Data for Polyline API provides elevation data along a polyline.
// A polyline is defined by passing in between 2 and N endpoint coordinates separated by a pipe ('|') character. In addition to passing in endpoints, customers
// can specify the number of sample points
// that will be used to divide polyline into equally spaced segments. Elevation data at both start and endpoints and equally spaced points along the polyline
// will be returned.
// A line between two endpoints is a straight Cartesian line, the shortest line between those two points in the coordinate reference system. Note that the
// point is chosen based on Euclidean distance and
// may markedly differ from the geodesic path along the curved surface of the reference ellipsoid.
// If the operation fails it returns the *ErrorResponse error type.
func (client *elevationClient) GetDataForPolyline(ctx context.Context, formatParam ResponseFormat, lines []string, options *ElevationGetDataForPolylineOptions) (LinesResultResponse, error) {
	req, err := client.getDataForPolylineCreateRequest(ctx, formatParam, lines, options)
	if err != nil {
		return LinesResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return LinesResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return LinesResultResponse{}, client.getDataForPolylineHandleError(resp)
	}
	return client.getDataForPolylineHandleResponse(resp)
}

// getDataForPolylineCreateRequest creates the GetDataForPolyline request.
func (client *elevationClient) getDataForPolylineCreateRequest(ctx context.Context, formatParam ResponseFormat, lines []string, options *ElevationGetDataForPolylineOptions) (*azcore.Request, error) {
	urlPath := "/elevation/line/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Samples != nil {
		reqQP.Set("samples", strconv.FormatInt(int64(*options.Samples), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	unencodedParams := []string{req.URL.RawQuery}
	unencodedParams = append(unencodedParams, "lines="+strings.Join(lines, "|"))
	req.URL.RawQuery = strings.Join(unencodedParams, "&")
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDataForPolylineHandleResponse handles the GetDataForPolyline response.
func (client *elevationClient) getDataForPolylineHandleResponse(resp *azcore.Response) (LinesResultResponse, error) {
	var val *LinesResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return LinesResultResponse{}, err
	}
return LinesResultResponse{RawResponse: resp.Response, LinesResult: val}, nil
}

// getDataForPolylineHandleError handles the GetDataForPolyline error response.
func (client *elevationClient) getDataForPolylineHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostDataForPoints - Applies to: S1 pricing tier.
// The Post Data for Points API provides elevation data for multiple points. A point is defined lon/lat coordinate format. Use the POST endpoint only if
// you intend to pass multiple points in the request.
// If you intend to pass a single coordinate into the API, use the GET Data For Points API [https://docs.microsoft.com/en-us/rest/api/maps/elevation/getdataforpoints].
// If the operation fails it returns the *ErrorResponse error type.
func (client *elevationClient) PostDataForPoints(ctx context.Context, formatParam ResponseFormat, pointsRequestBody []*CoordinatesPairAbbreviated, options *ElevationPostDataForPointsOptions) (PointsResultResponse, error) {
	req, err := client.postDataForPointsCreateRequest(ctx, formatParam, pointsRequestBody, options)
	if err != nil {
		return PointsResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PointsResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PointsResultResponse{}, client.postDataForPointsHandleError(resp)
	}
	return client.postDataForPointsHandleResponse(resp)
}

// postDataForPointsCreateRequest creates the PostDataForPoints request.
func (client *elevationClient) postDataForPointsCreateRequest(ctx context.Context, formatParam ResponseFormat, pointsRequestBody []*CoordinatesPairAbbreviated, options *ElevationPostDataForPointsOptions) (*azcore.Request, error) {
	urlPath := "/elevation/point/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(pointsRequestBody)
}

// postDataForPointsHandleResponse handles the PostDataForPoints response.
func (client *elevationClient) postDataForPointsHandleResponse(resp *azcore.Response) (PointsResultResponse, error) {
	var val *PointsResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PointsResultResponse{}, err
	}
return PointsResultResponse{RawResponse: resp.Response, PointsResult: val}, nil
}

// postDataForPointsHandleError handles the PostDataForPoints error response.
func (client *elevationClient) postDataForPointsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostDataForPolyline - Applies to: S1 pricing tier.
// The Post Data for Polyline API provides elevation data along a polyline. A polyline is defined by passing in between 2 and N endpoint coordinates separated
// by a pipe ('|') character. In addition to
// passing in endpoints, customers can specify the number of sample points that will be used to divide polyline into equally spaced segments.
// Elevation data at both start and end points and equally spaced points along the polyline will be returned. A line between two endpoints is a straight
// Cartesian line, the shortest line between those
// two points in the coordinate reference system. Note that the point is chosen based on Euclidean distance and may markedly differ from the geodesic path
// along the curved surface of the reference
// ellipsoid.
// If the operation fails it returns the *ErrorResponse error type.
func (client *elevationClient) PostDataForPolyline(ctx context.Context, formatParam ResponseFormat, linesRequestBody []*CoordinatesPairAbbreviated, options *ElevationPostDataForPolylineOptions) (LinesResultResponse, error) {
	req, err := client.postDataForPolylineCreateRequest(ctx, formatParam, linesRequestBody, options)
	if err != nil {
		return LinesResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return LinesResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return LinesResultResponse{}, client.postDataForPolylineHandleError(resp)
	}
	return client.postDataForPolylineHandleResponse(resp)
}

// postDataForPolylineCreateRequest creates the PostDataForPolyline request.
func (client *elevationClient) postDataForPolylineCreateRequest(ctx context.Context, formatParam ResponseFormat, linesRequestBody []*CoordinatesPairAbbreviated, options *ElevationPostDataForPolylineOptions) (*azcore.Request, error) {
	urlPath := "/elevation/line/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Samples != nil {
		reqQP.Set("samples", strconv.FormatInt(int64(*options.Samples), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(linesRequestBody)
}

// postDataForPolylineHandleResponse handles the PostDataForPolyline response.
func (client *elevationClient) postDataForPolylineHandleResponse(resp *azcore.Response) (LinesResultResponse, error) {
	var val *LinesResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return LinesResultResponse{}, err
	}
return LinesResultResponse{RawResponse: resp.Response, LinesResult: val}, nil
}

// postDataForPolylineHandleError handles the PostDataForPolyline error response.
func (client *elevationClient) postDataForPolylineHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

