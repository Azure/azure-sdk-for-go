// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package route

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

type routeClient struct {
	con *connection
	xmsClientID *string
}

// GetRouteDirections - Applies to: S0 and S1 pricing tiers.
// Returns a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as
// current traffic and the typical road speeds on
// the requested day of the week and time of day.
// Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as
// optimized waypoint order or turn by turn
// instructions is also available, depending on the options selected.
// Routing service provides a set of parameters for a detailed description of vehicle-specific Consumption Model. Please check Consumption Model
// [https://docs.microsoft.com/azure/azure-maps/consumption-model] for detailed explanation of the concepts and parameters involved.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) GetRouteDirections(ctx context.Context, formatParam TextFormat, query string, options *RouteGetRouteDirectionsOptions) (RouteDirectionsResponseResponse, error) {
	req, err := client.getRouteDirectionsCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return RouteDirectionsResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RouteDirectionsResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RouteDirectionsResponseResponse{}, client.getRouteDirectionsHandleError(resp)
	}
	return client.getRouteDirectionsHandleResponse(resp)
}

// getRouteDirectionsCreateRequest creates the GetRouteDirections request.
func (client *routeClient) getRouteDirectionsCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *RouteGetRouteDirectionsOptions) (*azcore.Request, error) {
	urlPath := "/route/directions/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.MaxAlternatives != nil {
		reqQP.Set("maxAlternatives", strconv.FormatInt(int64(*options.MaxAlternatives), 10))
	}
	if options != nil && options.AlternativeType != nil {
		reqQP.Set("alternativeType", string(*options.AlternativeType))
	}
	if options != nil && options.MinDeviationDistance != nil {
		reqQP.Set("minDeviationDistance", strconv.FormatInt(int64(*options.MinDeviationDistance), 10))
	}
	if options != nil && options.ArriveAt != nil {
		reqQP.Set("arriveAt", options.ArriveAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.DepartAt != nil {
		reqQP.Set("departAt", options.DepartAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.MinDeviationTime != nil {
		reqQP.Set("minDeviationTime", strconv.FormatInt(int64(*options.MinDeviationTime), 10))
	}
	if options != nil && options.InstructionsType != nil {
		reqQP.Set("instructionsType", string(*options.InstructionsType))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ComputeBestOrder != nil {
		reqQP.Set("computeBestOrder", strconv.FormatBool(*options.ComputeBestOrder))
	}
	if options != nil && options.RouteRepresentation != nil {
		reqQP.Set("routeRepresentation", string(*options.RouteRepresentation))
	}
	if options != nil && options.ComputeTravelTimeFor != nil {
		reqQP.Set("computeTravelTimeFor", string(*options.ComputeTravelTimeFor))
	}
	if options != nil && options.VehicleHeading != nil {
		reqQP.Set("vehicleHeading", strconv.FormatInt(int64(*options.VehicleHeading), 10))
	}
	if options != nil && options.Report != nil {
		reqQP.Set("report", *options.Report)
	}
	if options != nil && options.SectionType != nil {
		reqQP.Set("sectionType", string(*options.SectionType))
	}
	if options != nil && options.VehicleAxleWeight != nil {
		reqQP.Set("vehicleAxleWeight", strconv.FormatInt(int64(*options.VehicleAxleWeight), 10))
	}
	if options != nil && options.VehicleWidth != nil {
		reqQP.Set("vehicleWidth", strconv.FormatFloat(float64(*options.VehicleWidth), 'f', -1, 32))
	}
	if options != nil && options.VehicleHeight != nil {
		reqQP.Set("vehicleHeight", strconv.FormatFloat(float64(*options.VehicleHeight), 'f', -1, 32))
	}
	if options != nil && options.VehicleLength != nil {
		reqQP.Set("vehicleLength", strconv.FormatFloat(float64(*options.VehicleLength), 'f', -1, 32))
	}
	if options != nil && options.VehicleMaxSpeed != nil {
		reqQP.Set("vehicleMaxSpeed", strconv.FormatInt(int64(*options.VehicleMaxSpeed), 10))
	}
	if options != nil && options.VehicleWeight != nil {
		reqQP.Set("vehicleWeight", strconv.FormatInt(int64(*options.VehicleWeight), 10))
	}
	if options != nil && options.VehicleCommercial != nil {
		reqQP.Set("vehicleCommercial", strconv.FormatBool(*options.VehicleCommercial))
	}
	if options != nil && options.Windingness != nil {
		reqQP.Set("windingness", string(*options.Windingness))
	}
	if options != nil && options.Hilliness != nil {
		reqQP.Set("hilliness", string(*options.Hilliness))
	}
	if options != nil && options.TravelMode != nil {
		reqQP.Set("travelMode", string(*options.TravelMode))
	}
	if options != nil && options.Avoid != nil {
			for _, qv := range options.Avoid {
		reqQP.Add("avoid", qv)
	}
	}
	if options != nil && options.Traffic != nil {
		reqQP.Set("traffic", strconv.FormatBool(*options.Traffic))
	}
	if options != nil && options.RouteType != nil {
		reqQP.Set("routeType", string(*options.RouteType))
	}
	if options != nil && options.VehicleLoadType != nil {
		reqQP.Set("vehicleLoadType", string(*options.VehicleLoadType))
	}
	if options != nil && options.VehicleEngineType != nil {
		reqQP.Set("vehicleEngineType", string(*options.VehicleEngineType))
	}
	if options != nil && options.ConstantSpeedConsumptionInLitersPerHundredkm != nil {
		reqQP.Set("constantSpeedConsumptionInLitersPerHundredkm", strconv.FormatFloat(float64(*options.ConstantSpeedConsumptionInLitersPerHundredkm), 'f', -1, 32))
	}
	if options != nil && options.CurrentFuelInLiters != nil {
		reqQP.Set("currentFuelInLiters", strconv.FormatFloat(float64(*options.CurrentFuelInLiters), 'f', -1, 32))
	}
	if options != nil && options.AuxiliaryPowerInLitersPerHour != nil {
		reqQP.Set("auxiliaryPowerInLitersPerHour", strconv.FormatFloat(float64(*options.AuxiliaryPowerInLitersPerHour), 'f', -1, 32))
	}
	if options != nil && options.FuelEnergyDensityInMJoulesPerLiter != nil {
		reqQP.Set("fuelEnergyDensityInMJoulesPerLiter", strconv.FormatFloat(float64(*options.FuelEnergyDensityInMJoulesPerLiter), 'f', -1, 32))
	}
	if options != nil && options.AccelerationEfficiency != nil {
		reqQP.Set("accelerationEfficiency", strconv.FormatFloat(float64(*options.AccelerationEfficiency), 'f', -1, 32))
	}
	if options != nil && options.DecelerationEfficiency != nil {
		reqQP.Set("decelerationEfficiency", strconv.FormatFloat(float64(*options.DecelerationEfficiency), 'f', -1, 32))
	}
	if options != nil && options.UphillEfficiency != nil {
		reqQP.Set("uphillEfficiency", strconv.FormatFloat(float64(*options.UphillEfficiency), 'f', -1, 32))
	}
	if options != nil && options.DownhillEfficiency != nil {
		reqQP.Set("downhillEfficiency", strconv.FormatFloat(float64(*options.DownhillEfficiency), 'f', -1, 32))
	}
	if options != nil && options.ConstantSpeedConsumptionInkWhPerHundredkm != nil {
		reqQP.Set("constantSpeedConsumptionInkWhPerHundredkm", *options.ConstantSpeedConsumptionInkWhPerHundredkm)
	}
	if options != nil && options.CurrentChargeInkWh != nil {
		reqQP.Set("currentChargeInkWh", *options.CurrentChargeInkWh)
	}
	if options != nil && options.MaxChargeInkWh != nil {
		reqQP.Set("maxChargeInkWh", *options.MaxChargeInkWh)
	}
	if options != nil && options.AuxiliaryPowerInkW != nil {
		reqQP.Set("auxiliaryPowerInkW", *options.AuxiliaryPowerInkW)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getRouteDirectionsHandleResponse handles the GetRouteDirections response.
func (client *routeClient) getRouteDirectionsHandleResponse(resp *azcore.Response) (RouteDirectionsResponseResponse, error) {
	var val *RouteDirectionsResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RouteDirectionsResponseResponse{}, err
	}
return RouteDirectionsResponseResponse{RawResponse: resp.Response, RouteDirectionsResponse: val}, nil
}

// getRouteDirectionsHandleError handles the GetRouteDirections error response.
func (client *routeClient) getRouteDirectionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginGetRouteDirectionsBatch - DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download
// endpoint. This download URL can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * RouteDirectionsResponse [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse] - If the query completed
// successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 1 successful and 1 failed result:
// { "summary": { "successfulRequests": 1, "totalRequests": 2 }, "batchItems": [ { "statusCode": 200, "response": { "routes": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "legs": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "points": [ { "latitude": 47.62094,
// "longitude": -122.34892 }, { "latitude":
// 47.62094, "longitude": -122.3485 }, { "latitude": 47.62095, "longitude": -122.3476 } ] } ], "sections": [ { "startPointIndex": 0, "endPointIndex": 40,
// "sectionType": "TRAVEL_MODE", "travelMode":
// "bicycle" } ] } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." }
// } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) BeginGetRouteDirectionsBatch(ctx context.Context, formatParam string, options *RouteBeginGetRouteDirectionsBatchOptions) (RouteDirectionsBatchResponsePollerResponse, error) {
	resp, err := client.getRouteDirectionsBatch(ctx, formatParam, options)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	result := RouteDirectionsBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("routeClient.GetRouteDirectionsBatch",resp, client.con.Pipeline(), client.getRouteDirectionsBatchHandleError)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	poller := &routeDirectionsBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteDirectionsBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeGetRouteDirectionsBatch creates a new RouteDirectionsBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to RouteDirectionsBatchResponsePoller.ResumeToken().
func (client *routeClient) ResumeGetRouteDirectionsBatch(ctx context.Context, token string) (RouteDirectionsBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("routeClient.GetRouteDirectionsBatch",token, client.con.Pipeline(), client.getRouteDirectionsBatchHandleError)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	poller := &routeDirectionsBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	result := RouteDirectionsBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteDirectionsBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// GetRouteDirectionsBatch - DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download
// endpoint. This download URL can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * RouteDirectionsResponse [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse] - If the query completed
// successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 1 successful and 1 failed result:
// { "summary": { "successfulRequests": 1, "totalRequests": 2 }, "batchItems": [ { "statusCode": 200, "response": { "routes": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "legs": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "points": [ { "latitude": 47.62094,
// "longitude": -122.34892 }, { "latitude":
// 47.62094, "longitude": -122.3485 }, { "latitude": 47.62095, "longitude": -122.3476 } ] } ], "sections": [ { "startPointIndex": 0, "endPointIndex": 40,
// "sectionType": "TRAVEL_MODE", "travelMode":
// "bicycle" } ] } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." }
// } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) getRouteDirectionsBatch(ctx context.Context, formatParam string, options *RouteBeginGetRouteDirectionsBatchOptions) (*azcore.Response, error) {
	req, err := client.getRouteDirectionsBatchCreateRequest(ctx, formatParam, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.getRouteDirectionsBatchHandleError(resp)
	}
	 return resp, nil
}

// getRouteDirectionsBatchCreateRequest creates the GetRouteDirectionsBatch request.
func (client *routeClient) getRouteDirectionsBatchCreateRequest(ctx context.Context, formatParam string, options *RouteBeginGetRouteDirectionsBatchOptions) (*azcore.Request, error) {
	urlPath := "/route/directions/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(formatParam))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getRouteDirectionsBatchHandleError handles the GetRouteDirectionsBatch error response.
func (client *routeClient) getRouteDirectionsBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginGetRouteMatrix - If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results
// of the request. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
// DOWNLOAD SYNC RESULTS When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response
// array. The response body will contain the data
// and there will be no possibility to retrieve the results later.
// DOWNLOAD ASYNC RESULTS When a request issues a 202 Accepted response, the request is being processed using our async pipeline. You will be given a URL
// to check the progress of your async request in
// the location header of the response. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// The URL provided by the location header will return the following responses when a GET request is issued.
// > HTTP 202 Accepted - Matrix request was accepted but is still being processed. Please try again in some time.
// HTTP 200 OK - Matrix request successfully processed. The response body contains all of the results.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) BeginGetRouteMatrix(ctx context.Context, formatParam string, options *RouteBeginGetRouteMatrixOptions) (RouteMatrixResponsePollerResponse, error) {
	resp, err := client.getRouteMatrix(ctx, formatParam, options)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	result := RouteMatrixResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("routeClient.GetRouteMatrix",resp, client.con.Pipeline(), client.getRouteMatrixHandleError)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	poller := &routeMatrixResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteMatrixResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeGetRouteMatrix creates a new RouteMatrixResponsePoller from the specified resume token.
// token - The value must come from a previous call to RouteMatrixResponsePoller.ResumeToken().
func (client *routeClient) ResumeGetRouteMatrix(ctx context.Context, token string) (RouteMatrixResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("routeClient.GetRouteMatrix",token, client.con.Pipeline(), client.getRouteMatrixHandleError)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	poller := &routeMatrixResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	result := RouteMatrixResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteMatrixResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// GetRouteMatrix - If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results
// of the request. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
// DOWNLOAD SYNC RESULTS When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response
// array. The response body will contain the data
// and there will be no possibility to retrieve the results later.
// DOWNLOAD ASYNC RESULTS When a request issues a 202 Accepted response, the request is being processed using our async pipeline. You will be given a URL
// to check the progress of your async request in
// the location header of the response. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// The URL provided by the location header will return the following responses when a GET request is issued.
// > HTTP 202 Accepted - Matrix request was accepted but is still being processed. Please try again in some time.
// HTTP 200 OK - Matrix request successfully processed. The response body contains all of the results.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) getRouteMatrix(ctx context.Context, formatParam string, options *RouteBeginGetRouteMatrixOptions) (*azcore.Response, error) {
	req, err := client.getRouteMatrixCreateRequest(ctx, formatParam, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.getRouteMatrixHandleError(resp)
	}
	 return resp, nil
}

// getRouteMatrixCreateRequest creates the GetRouteMatrix request.
func (client *routeClient) getRouteMatrixCreateRequest(ctx context.Context, formatParam string, options *RouteBeginGetRouteMatrixOptions) (*azcore.Request, error) {
	urlPath := "/route/matrix/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(formatParam))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getRouteMatrixHandleError handles the GetRouteMatrix error response.
func (client *routeClient) getRouteMatrixHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetRouteRange - Route Range (Isochrone) API
// Applies to: S1 pricing tier.
// This service will calculate a set of locations that can be reached from the origin point based on fuel, energy, time or distance budget that is specified.
// A polygon boundary (or Isochrone) is returned
// in a counterclockwise orientation as well as the precise polygon center which was the result of the origin point.
// The returned polygon can be used for further processing such as Search Inside Geometry [https://docs.microsoft.com/rest/api/maps/search/postsearchinsidegeometry]
// to search for POIs within the provided
// Isochrone.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) GetRouteRange(ctx context.Context, formatParam TextFormat, query string, options *RouteGetRouteRangeOptions) (GetRouteRangeResponseResponse, error) {
	req, err := client.getRouteRangeCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return GetRouteRangeResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GetRouteRangeResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GetRouteRangeResponseResponse{}, client.getRouteRangeHandleError(resp)
	}
	return client.getRouteRangeHandleResponse(resp)
}

// getRouteRangeCreateRequest creates the GetRouteRange request.
func (client *routeClient) getRouteRangeCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *RouteGetRouteRangeOptions) (*azcore.Request, error) {
	urlPath := "/route/range/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.FuelBudgetInLiters != nil {
		reqQP.Set("fuelBudgetInLiters", strconv.FormatFloat(float64(*options.FuelBudgetInLiters), 'f', -1, 32))
	}
	if options != nil && options.EnergyBudgetInkWh != nil {
		reqQP.Set("energyBudgetInkWh", strconv.FormatFloat(float64(*options.EnergyBudgetInkWh), 'f', -1, 32))
	}
	if options != nil && options.TimeBudgetInSec != nil {
		reqQP.Set("timeBudgetInSec", strconv.FormatFloat(float64(*options.TimeBudgetInSec), 'f', -1, 32))
	}
	if options != nil && options.DistanceBudgetInMeters != nil {
		reqQP.Set("distanceBudgetInMeters", strconv.FormatFloat(float64(*options.DistanceBudgetInMeters), 'f', -1, 32))
	}
	if options != nil && options.DepartAt != nil {
		reqQP.Set("departAt", options.DepartAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.RouteType != nil {
		reqQP.Set("routeType", string(*options.RouteType))
	}
	if options != nil && options.Traffic != nil {
		reqQP.Set("traffic", strconv.FormatBool(*options.Traffic))
	}
	if options != nil && options.Avoid != nil {
			for _, qv := range options.Avoid {
		reqQP.Add("avoid", qv)
	}
	}
	if options != nil && options.TravelMode != nil {
		reqQP.Set("travelMode", string(*options.TravelMode))
	}
	if options != nil && options.Hilliness != nil {
		reqQP.Set("hilliness", string(*options.Hilliness))
	}
	if options != nil && options.Windingness != nil {
		reqQP.Set("windingness", string(*options.Windingness))
	}
	if options != nil && options.VehicleAxleWeight != nil {
		reqQP.Set("vehicleAxleWeight", strconv.FormatInt(int64(*options.VehicleAxleWeight), 10))
	}
	if options != nil && options.VehicleWidth != nil {
		reqQP.Set("vehicleWidth", strconv.FormatFloat(float64(*options.VehicleWidth), 'f', -1, 32))
	}
	if options != nil && options.VehicleHeight != nil {
		reqQP.Set("vehicleHeight", strconv.FormatFloat(float64(*options.VehicleHeight), 'f', -1, 32))
	}
	if options != nil && options.VehicleLength != nil {
		reqQP.Set("vehicleLength", strconv.FormatFloat(float64(*options.VehicleLength), 'f', -1, 32))
	}
	if options != nil && options.VehicleMaxSpeed != nil {
		reqQP.Set("vehicleMaxSpeed", strconv.FormatInt(int64(*options.VehicleMaxSpeed), 10))
	}
	if options != nil && options.VehicleWeight != nil {
		reqQP.Set("vehicleWeight", strconv.FormatInt(int64(*options.VehicleWeight), 10))
	}
	if options != nil && options.VehicleCommercial != nil {
		reqQP.Set("vehicleCommercial", strconv.FormatBool(*options.VehicleCommercial))
	}
	if options != nil && options.VehicleLoadType != nil {
		reqQP.Set("vehicleLoadType", string(*options.VehicleLoadType))
	}
	if options != nil && options.VehicleEngineType != nil {
		reqQP.Set("vehicleEngineType", string(*options.VehicleEngineType))
	}
	if options != nil && options.ConstantSpeedConsumptionInLitersPerHundredkm != nil {
		reqQP.Set("constantSpeedConsumptionInLitersPerHundredkm", strconv.FormatFloat(float64(*options.ConstantSpeedConsumptionInLitersPerHundredkm), 'f', -1, 32))
	}
	if options != nil && options.CurrentFuelInLiters != nil {
		reqQP.Set("currentFuelInLiters", strconv.FormatFloat(float64(*options.CurrentFuelInLiters), 'f', -1, 32))
	}
	if options != nil && options.AuxiliaryPowerInLitersPerHour != nil {
		reqQP.Set("auxiliaryPowerInLitersPerHour", strconv.FormatFloat(float64(*options.AuxiliaryPowerInLitersPerHour), 'f', -1, 32))
	}
	if options != nil && options.FuelEnergyDensityInMJoulesPerLiter != nil {
		reqQP.Set("fuelEnergyDensityInMJoulesPerLiter", strconv.FormatFloat(float64(*options.FuelEnergyDensityInMJoulesPerLiter), 'f', -1, 32))
	}
	if options != nil && options.AccelerationEfficiency != nil {
		reqQP.Set("accelerationEfficiency", strconv.FormatFloat(float64(*options.AccelerationEfficiency), 'f', -1, 32))
	}
	if options != nil && options.DecelerationEfficiency != nil {
		reqQP.Set("decelerationEfficiency", strconv.FormatFloat(float64(*options.DecelerationEfficiency), 'f', -1, 32))
	}
	if options != nil && options.UphillEfficiency != nil {
		reqQP.Set("uphillEfficiency", strconv.FormatFloat(float64(*options.UphillEfficiency), 'f', -1, 32))
	}
	if options != nil && options.DownhillEfficiency != nil {
		reqQP.Set("downhillEfficiency", strconv.FormatFloat(float64(*options.DownhillEfficiency), 'f', -1, 32))
	}
	if options != nil && options.ConstantSpeedConsumptionInkWhPerHundredkm != nil {
		reqQP.Set("constantSpeedConsumptionInkWhPerHundredkm", *options.ConstantSpeedConsumptionInkWhPerHundredkm)
	}
	if options != nil && options.CurrentChargeInkWh != nil {
		reqQP.Set("currentChargeInkWh", *options.CurrentChargeInkWh)
	}
	if options != nil && options.MaxChargeInkWh != nil {
		reqQP.Set("maxChargeInkWh", *options.MaxChargeInkWh)
	}
	if options != nil && options.AuxiliaryPowerInkW != nil {
		reqQP.Set("auxiliaryPowerInkW", *options.AuxiliaryPowerInkW)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getRouteRangeHandleResponse handles the GetRouteRange response.
func (client *routeClient) getRouteRangeHandleResponse(resp *azcore.Response) (GetRouteRangeResponseResponse, error) {
	var val *GetRouteRangeResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GetRouteRangeResponseResponse{}, err
	}
return GetRouteRangeResponseResponse{RawResponse: resp.Response, GetRouteRangeResponse: val}, nil
}

// getRouteRangeHandleError handles the GetRouteRange error response.
func (client *routeClient) getRouteRangeHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostRouteDirections - Applies to: S0 and S1 pricing tiers.
// Returns a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as
// current traffic and the typical road speeds on
// the requested day of the week and time of day.
// Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as
// optimized waypoint order or turn by turn
// instructions is also available, depending on the options selected.
// Routing service provides a set of parameters for a detailed description of a vehicle-specific Consumption Model. Please check Consumption Model
// [https://docs.microsoft.com/azure/azure-maps/consumption-model] for detailed explanation of the concepts and parameters involved.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) PostRouteDirections(ctx context.Context, formatParam TextFormat, query string, postRouteDirectionsRequestBody PostRouteDirectionsRequestBody, options *RoutePostRouteDirectionsOptions) (RouteDirectionsResponseResponse, error) {
	req, err := client.postRouteDirectionsCreateRequest(ctx, formatParam, query, postRouteDirectionsRequestBody, options)
	if err != nil {
		return RouteDirectionsResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RouteDirectionsResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RouteDirectionsResponseResponse{}, client.postRouteDirectionsHandleError(resp)
	}
	return client.postRouteDirectionsHandleResponse(resp)
}

// postRouteDirectionsCreateRequest creates the PostRouteDirections request.
func (client *routeClient) postRouteDirectionsCreateRequest(ctx context.Context, formatParam TextFormat, query string, postRouteDirectionsRequestBody PostRouteDirectionsRequestBody, options *RoutePostRouteDirectionsOptions) (*azcore.Request, error) {
	urlPath := "/route/directions/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.MaxAlternatives != nil {
		reqQP.Set("maxAlternatives", strconv.FormatInt(int64(*options.MaxAlternatives), 10))
	}
	if options != nil && options.AlternativeType != nil {
		reqQP.Set("alternativeType", string(*options.AlternativeType))
	}
	if options != nil && options.MinDeviationDistance != nil {
		reqQP.Set("minDeviationDistance", strconv.FormatInt(int64(*options.MinDeviationDistance), 10))
	}
	if options != nil && options.MinDeviationTime != nil {
		reqQP.Set("minDeviationTime", strconv.FormatInt(int64(*options.MinDeviationTime), 10))
	}
	if options != nil && options.InstructionsType != nil {
		reqQP.Set("instructionsType", string(*options.InstructionsType))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ComputeBestOrder != nil {
		reqQP.Set("computeBestOrder", strconv.FormatBool(*options.ComputeBestOrder))
	}
	if options != nil && options.RouteRepresentation != nil {
		reqQP.Set("routeRepresentation", string(*options.RouteRepresentation))
	}
	if options != nil && options.ComputeTravelTimeFor != nil {
		reqQP.Set("computeTravelTimeFor", string(*options.ComputeTravelTimeFor))
	}
	if options != nil && options.VehicleHeading != nil {
		reqQP.Set("vehicleHeading", strconv.FormatInt(int64(*options.VehicleHeading), 10))
	}
	if options != nil && options.Report != nil {
		reqQP.Set("report", *options.Report)
	}
	if options != nil && options.SectionType != nil {
		reqQP.Set("sectionType", string(*options.SectionType))
	}
	if options != nil && options.ArriveAt != nil {
		reqQP.Set("arriveAt", options.ArriveAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.DepartAt != nil {
		reqQP.Set("departAt", options.DepartAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.VehicleAxleWeight != nil {
		reqQP.Set("vehicleAxleWeight", strconv.FormatInt(int64(*options.VehicleAxleWeight), 10))
	}
	if options != nil && options.VehicleLength != nil {
		reqQP.Set("vehicleLength", strconv.FormatFloat(float64(*options.VehicleLength), 'f', -1, 32))
	}
	if options != nil && options.VehicleHeight != nil {
		reqQP.Set("vehicleHeight", strconv.FormatFloat(float64(*options.VehicleHeight), 'f', -1, 32))
	}
	if options != nil && options.VehicleWidth != nil {
		reqQP.Set("vehicleWidth", strconv.FormatFloat(float64(*options.VehicleWidth), 'f', -1, 32))
	}
	if options != nil && options.VehicleMaxSpeed != nil {
		reqQP.Set("vehicleMaxSpeed", strconv.FormatInt(int64(*options.VehicleMaxSpeed), 10))
	}
	if options != nil && options.VehicleWeight != nil {
		reqQP.Set("vehicleWeight", strconv.FormatInt(int64(*options.VehicleWeight), 10))
	}
	if options != nil && options.VehicleCommercial != nil {
		reqQP.Set("vehicleCommercial", strconv.FormatBool(*options.VehicleCommercial))
	}
	if options != nil && options.Windingness != nil {
		reqQP.Set("windingness", string(*options.Windingness))
	}
	if options != nil && options.Hilliness != nil {
		reqQP.Set("hilliness", string(*options.Hilliness))
	}
	if options != nil && options.TravelMode != nil {
		reqQP.Set("travelMode", string(*options.TravelMode))
	}
	if options != nil && options.Avoid != nil {
			for _, qv := range options.Avoid {
		reqQP.Add("avoid", qv)
	}
	}
	if options != nil && options.Traffic != nil {
		reqQP.Set("traffic", strconv.FormatBool(*options.Traffic))
	}
	if options != nil && options.RouteType != nil {
		reqQP.Set("routeType", string(*options.RouteType))
	}
	if options != nil && options.VehicleLoadType != nil {
		reqQP.Set("vehicleLoadType", string(*options.VehicleLoadType))
	}
	if options != nil && options.VehicleEngineType != nil {
		reqQP.Set("vehicleEngineType", string(*options.VehicleEngineType))
	}
	if options != nil && options.ConstantSpeedConsumptionInLitersPerHundredkm != nil {
		reqQP.Set("constantSpeedConsumptionInLitersPerHundredkm", strconv.FormatFloat(float64(*options.ConstantSpeedConsumptionInLitersPerHundredkm), 'f', -1, 32))
	}
	if options != nil && options.CurrentFuelInLiters != nil {
		reqQP.Set("currentFuelInLiters", strconv.FormatFloat(float64(*options.CurrentFuelInLiters), 'f', -1, 32))
	}
	if options != nil && options.AuxiliaryPowerInLitersPerHour != nil {
		reqQP.Set("auxiliaryPowerInLitersPerHour", strconv.FormatFloat(float64(*options.AuxiliaryPowerInLitersPerHour), 'f', -1, 32))
	}
	if options != nil && options.FuelEnergyDensityInMJoulesPerLiter != nil {
		reqQP.Set("fuelEnergyDensityInMJoulesPerLiter", strconv.FormatFloat(float64(*options.FuelEnergyDensityInMJoulesPerLiter), 'f', -1, 32))
	}
	if options != nil && options.AccelerationEfficiency != nil {
		reqQP.Set("accelerationEfficiency", strconv.FormatFloat(float64(*options.AccelerationEfficiency), 'f', -1, 32))
	}
	if options != nil && options.DecelerationEfficiency != nil {
		reqQP.Set("decelerationEfficiency", strconv.FormatFloat(float64(*options.DecelerationEfficiency), 'f', -1, 32))
	}
	if options != nil && options.UphillEfficiency != nil {
		reqQP.Set("uphillEfficiency", strconv.FormatFloat(float64(*options.UphillEfficiency), 'f', -1, 32))
	}
	if options != nil && options.DownhillEfficiency != nil {
		reqQP.Set("downhillEfficiency", strconv.FormatFloat(float64(*options.DownhillEfficiency), 'f', -1, 32))
	}
	if options != nil && options.ConstantSpeedConsumptionInkWhPerHundredkm != nil {
		reqQP.Set("constantSpeedConsumptionInkWhPerHundredkm", *options.ConstantSpeedConsumptionInkWhPerHundredkm)
	}
	if options != nil && options.CurrentChargeInkWh != nil {
		reqQP.Set("currentChargeInkWh", *options.CurrentChargeInkWh)
	}
	if options != nil && options.MaxChargeInkWh != nil {
		reqQP.Set("maxChargeInkWh", *options.MaxChargeInkWh)
	}
	if options != nil && options.AuxiliaryPowerInkW != nil {
		reqQP.Set("auxiliaryPowerInkW", *options.AuxiliaryPowerInkW)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(postRouteDirectionsRequestBody)
}

// postRouteDirectionsHandleResponse handles the PostRouteDirections response.
func (client *routeClient) postRouteDirectionsHandleResponse(resp *azcore.Response) (RouteDirectionsResponseResponse, error) {
	var val *RouteDirectionsResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RouteDirectionsResponseResponse{}, err
	}
return RouteDirectionsResponseResponse{RawResponse: resp.Response, RouteDirectionsResponse: val}, nil
}

// postRouteDirectionsHandleError handles the PostRouteDirections error response.
func (client *routeClient) postRouteDirectionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostRouteDirectionsBatch - Route Directions Batch API
// Applies to: S1 pricing tier.
// The Route Directions Batch API sends batches of queries to Route Directions API [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections]
// using just a single API call. You can call
// Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 700 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 700 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Route Directions Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0Note:- Please remember to add AUTH information (subscription-key/azure_auth - See Security)
// to the _status URI_ before running it.
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
// POST BODY FOR BATCH REQUEST To send the route directions queries you will use a POST request where the request body will contain the batchItems array
// in json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 3 route directions queries:
// { "batchItems": [ { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" }, { "query":
// "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" }, { "query": "?query=48.923159,-122.557362:32.621279,-116.840362"
// } ] }
// A route directions query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported route directions URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#uri-parameters]. The string values in the route directions query must be properly
// escaped (e.g. " character should be escaped
// with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 700 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * RouteDirectionsResponse [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse] - If the query completed
// successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 1 successful and 1 failed result:
// { "summary": { "successfulRequests": 1, "totalRequests": 2 }, "batchItems": [ { "statusCode": 200, "response": { "routes": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "legs": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "points": [ { "latitude": 47.62094,
// "longitude": -122.34892 }, { "latitude":
// 47.62094, "longitude": -122.3485 }, { "latitude": 47.62095, "longitude": -122.3476 } ] } ], "sections": [ { "startPointIndex": 0, "endPointIndex": 40,
// "sectionType": "TRAVEL_MODE", "travelMode":
// "bicycle" } ] } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." }
// } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) BeginPostRouteDirectionsBatch(ctx context.Context, formatParam ResponseFormat, postRouteDirectionsBatchRequestBody BatchRequestBody, options *RouteBeginPostRouteDirectionsBatchOptions) (RouteDirectionsBatchResponsePollerResponse, error) {
	resp, err := client.postRouteDirectionsBatch(ctx, formatParam, postRouteDirectionsBatchRequestBody, options)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	result := RouteDirectionsBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("routeClient.PostRouteDirectionsBatch",resp, client.con.Pipeline(), client.postRouteDirectionsBatchHandleError)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	poller := &routeDirectionsBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteDirectionsBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostRouteDirectionsBatch creates a new RouteDirectionsBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to RouteDirectionsBatchResponsePoller.ResumeToken().
func (client *routeClient) ResumePostRouteDirectionsBatch(ctx context.Context, token string) (RouteDirectionsBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("routeClient.PostRouteDirectionsBatch",token, client.con.Pipeline(), client.postRouteDirectionsBatchHandleError)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	poller := &routeDirectionsBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RouteDirectionsBatchResponsePollerResponse{}, err
	}
	result := RouteDirectionsBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteDirectionsBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostRouteDirectionsBatch - Route Directions Batch API
// Applies to: S1 pricing tier.
// The Route Directions Batch API sends batches of queries to Route Directions API [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections]
// using just a single API call. You can call
// Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 700 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 700 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Route Directions Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0Note:- Please remember to add AUTH information (subscription-key/azure_auth - See Security)
// to the _status URI_ before running it.
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
// POST BODY FOR BATCH REQUEST To send the route directions queries you will use a POST request where the request body will contain the batchItems array
// in json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 3 route directions queries:
// { "batchItems": [ { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" }, { "query":
// "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" }, { "query": "?query=48.923159,-122.557362:32.621279,-116.840362"
// } ] }
// A route directions query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported route directions URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#uri-parameters]. The string values in the route directions query must be properly
// escaped (e.g. " character should be escaped
// with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 700 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * RouteDirectionsResponse [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse] - If the query completed
// successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 1 successful and 1 failed result:
// { "summary": { "successfulRequests": 1, "totalRequests": 2 }, "batchItems": [ { "statusCode": 200, "response": { "routes": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "legs": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "points": [ { "latitude": 47.62094,
// "longitude": -122.34892 }, { "latitude":
// 47.62094, "longitude": -122.3485 }, { "latitude": 47.62095, "longitude": -122.3476 } ] } ], "sections": [ { "startPointIndex": 0, "endPointIndex": 40,
// "sectionType": "TRAVEL_MODE", "travelMode":
// "bicycle" } ] } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." }
// } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) postRouteDirectionsBatch(ctx context.Context, formatParam ResponseFormat, postRouteDirectionsBatchRequestBody BatchRequestBody, options *RouteBeginPostRouteDirectionsBatchOptions) (*azcore.Response, error) {
	req, err := client.postRouteDirectionsBatchCreateRequest(ctx, formatParam, postRouteDirectionsBatchRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postRouteDirectionsBatchHandleError(resp)
	}
	 return resp, nil
}

// postRouteDirectionsBatchCreateRequest creates the PostRouteDirectionsBatch request.
func (client *routeClient) postRouteDirectionsBatchCreateRequest(ctx context.Context, formatParam ResponseFormat, postRouteDirectionsBatchRequestBody BatchRequestBody, options *RouteBeginPostRouteDirectionsBatchOptions) (*azcore.Request, error) {
	urlPath := "/route/directions/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(postRouteDirectionsBatchRequestBody)
}

// postRouteDirectionsBatchHandleError handles the PostRouteDirectionsBatch error response.
func (client *routeClient) postRouteDirectionsBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostRouteDirectionsBatchSync - Route Directions Batch API
// Applies to: S1 pricing tier.
// The Route Directions Batch API sends batches of queries to Route Directions API [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections]
// using just a single API call. You can call
// Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 700 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 700 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Route Directions Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0Note:- Please remember to add AUTH information (subscription-key/azure_auth - See Security)
// to the _status URI_ before running it.
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
// POST BODY FOR BATCH REQUEST To send the route directions queries you will use a POST request where the request body will contain the batchItems array
// in json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 3 route directions queries:
// { "batchItems": [ { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" }, { "query":
// "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" }, { "query": "?query=48.923159,-122.557362:32.621279,-116.840362"
// } ] }
// A route directions query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported route directions URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#uri-parameters]. The string values in the route directions query must be properly
// escaped (e.g. " character should be escaped
// with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 700 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * RouteDirectionsResponse [https://docs.microsoft.com/en-us/rest/api/maps/route/getroutedirections#routedirectionsresponse] - If the query completed
// successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 1 successful and 1 failed result:
// { "summary": { "successfulRequests": 1, "totalRequests": 2 }, "batchItems": [ { "statusCode": 200, "response": { "routes": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "legs": [ { "summary": { "lengthInMeters":
// 1758, "travelTimeInSeconds": 387,
// "trafficDelayInSeconds": 0, "departureTime": "2018-07-17T00:49:56+00:00", "arrivalTime": "2018-07-17T00:56:22+00:00" }, "points": [ { "latitude": 47.62094,
// "longitude": -122.34892 }, { "latitude":
// 47.62094, "longitude": -122.3485 }, { "latitude": 47.62095, "longitude": -122.3476 } ] } ], "sections": [ { "startPointIndex": 0, "endPointIndex": 40,
// "sectionType": "TRAVEL_MODE", "travelMode":
// "bicycle" } ] } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." }
// } } ] }
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *routeClient) PostRouteDirectionsBatchSync(ctx context.Context, formatParam ResponseFormat, postRouteDirectionsBatchRequestBody BatchRequestBody, options *RoutePostRouteDirectionsBatchSyncOptions) (RouteDirectionsBatchResponseResponse, error) {
	req, err := client.postRouteDirectionsBatchSyncCreateRequest(ctx, formatParam, postRouteDirectionsBatchRequestBody, options)
	if err != nil {
		return RouteDirectionsBatchResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RouteDirectionsBatchResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RouteDirectionsBatchResponseResponse{}, client.postRouteDirectionsBatchSyncHandleError(resp)
	}
	return client.postRouteDirectionsBatchSyncHandleResponse(resp)
}

// postRouteDirectionsBatchSyncCreateRequest creates the PostRouteDirectionsBatchSync request.
func (client *routeClient) postRouteDirectionsBatchSyncCreateRequest(ctx context.Context, formatParam ResponseFormat, postRouteDirectionsBatchRequestBody BatchRequestBody, options *RoutePostRouteDirectionsBatchSyncOptions) (*azcore.Request, error) {
	urlPath := "/route/directions/batch/sync/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(postRouteDirectionsBatchRequestBody)
}

// postRouteDirectionsBatchSyncHandleResponse handles the PostRouteDirectionsBatchSync response.
func (client *routeClient) postRouteDirectionsBatchSyncHandleResponse(resp *azcore.Response) (RouteDirectionsBatchResponseResponse, error) {
	var val *RouteDirectionsBatchResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RouteDirectionsBatchResponseResponse{}, err
	}
return RouteDirectionsBatchResponseResponse{RawResponse: resp.Response, RouteDirectionsBatchResponse: val}, nil
}

// postRouteDirectionsBatchSyncHandleError handles the PostRouteDirectionsBatchSync error response.
func (client *routeClient) postRouteDirectionsBatchSyncHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostRouteMatrix - Applies to: S1 pricing tier.
// The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using
// an asynchronous (async) or synchronous (sync) POST
// request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set
// of destinations can be thought of as the column
// and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example,
// let's say a food delivery company has 20 drivers
// and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
// For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the
// Route Directions API.
// The maximum size of a matrix for async request is 700 and for sync request it's 100 (the number of origins multiplied by the number of destinations).
// SUBMIT SYNCHRONOUS ROUTE MATRIX REQUEST If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100,
// you might want to make synchronous request. The
// maximum size of a matrix for this API is 100 (the number of origins multiplied by the number of destinations). With that constraint in mind, examples
// of possible matrix dimensions are: 10x10, 6x8, 9x8
// (it does not need to be square).
// POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS ROUTE MATRIX REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When
// you make a request by using async request, by
// default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically
// until the response data or error information
// is available. If waitForResults parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
// The maximum size of a matrix for this API is 700 (the number of origins multiplied by the number of destinations). With that constraint in mind, examples
// of possible matrix dimensions are: 50x10,
// 10x10, 28x25. 10x70 (it does not need to be square).
// The asynchronous responses are stored for 14 days. The redirect URL returns a 404 response if used after the expiration period.
// POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
// Here's a typical sequence of asynchronous operations:
// 1. Client sends a Route Matrix POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Route Matrix request has been accepted.
//
//
// HTTP Error - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request.
// This status URI looks like the following:
//
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
//
//
// DOWNLOAD SYNC RESULTS When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response
// array. The response body will contain the data
// and there will be no possibility to retrieve the results later.
// DOWNLOAD ASYNC RESULTS When a request issues a 202 Accepted response, the request is being processed using our async pipeline. You will be given a URL
// to check the progress of your async request in
// the location header of the response. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// The URL provided by the location header will return the following responses when a GET request is issued.
// > HTTP 202 Accepted - Matrix request was accepted but is still being processed. Please try again in some time.
// HTTP 200 OK - Matrix request successfully processed. The response body contains all of the results.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) BeginPostRouteMatrix(ctx context.Context, formatParam ResponseFormat, postRouteMatrixRequestBody PostRouteMatrixRequestBody, options *RouteBeginPostRouteMatrixOptions) (RouteMatrixResponsePollerResponse, error) {
	resp, err := client.postRouteMatrix(ctx, formatParam, postRouteMatrixRequestBody, options)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	result := RouteMatrixResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("routeClient.PostRouteMatrix",resp, client.con.Pipeline(), client.postRouteMatrixHandleError)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	poller := &routeMatrixResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteMatrixResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostRouteMatrix creates a new RouteMatrixResponsePoller from the specified resume token.
// token - The value must come from a previous call to RouteMatrixResponsePoller.ResumeToken().
func (client *routeClient) ResumePostRouteMatrix(ctx context.Context, token string) (RouteMatrixResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("routeClient.PostRouteMatrix",token, client.con.Pipeline(), client.postRouteMatrixHandleError)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	poller := &routeMatrixResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return RouteMatrixResponsePollerResponse{}, err
	}
	result := RouteMatrixResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (RouteMatrixResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostRouteMatrix - Applies to: S1 pricing tier.
// The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using
// an asynchronous (async) or synchronous (sync) POST
// request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set
// of destinations can be thought of as the column
// and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example,
// let's say a food delivery company has 20 drivers
// and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
// For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the
// Route Directions API.
// The maximum size of a matrix for async request is 700 and for sync request it's 100 (the number of origins multiplied by the number of destinations).
// SUBMIT SYNCHRONOUS ROUTE MATRIX REQUEST If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100,
// you might want to make synchronous request. The
// maximum size of a matrix for this API is 100 (the number of origins multiplied by the number of destinations). With that constraint in mind, examples
// of possible matrix dimensions are: 10x10, 6x8, 9x8
// (it does not need to be square).
// POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS ROUTE MATRIX REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When
// you make a request by using async request, by
// default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically
// until the response data or error information
// is available. If waitForResults parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
// The maximum size of a matrix for this API is 700 (the number of origins multiplied by the number of destinations). With that constraint in mind, examples
// of possible matrix dimensions are: 50x10,
// 10x10, 28x25. 10x70 (it does not need to be square).
// The asynchronous responses are stored for 14 days. The redirect URL returns a 404 response if used after the expiration period.
// POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
// Here's a typical sequence of asynchronous operations:
// 1. Client sends a Route Matrix POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Route Matrix request has been accepted.
//
//
// HTTP Error - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request.
// This status URI looks like the following:
//
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
//
//
// DOWNLOAD SYNC RESULTS When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response
// array. The response body will contain the data
// and there will be no possibility to retrieve the results later.
// DOWNLOAD ASYNC RESULTS When a request issues a 202 Accepted response, the request is being processed using our async pipeline. You will be given a URL
// to check the progress of your async request in
// the location header of the response. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// The URL provided by the location header will return the following responses when a GET request is issued.
// > HTTP 202 Accepted - Matrix request was accepted but is still being processed. Please try again in some time.
// HTTP 200 OK - Matrix request successfully processed. The response body contains all of the results.
// If the operation fails it returns the *ErrorResponse error type.
func (client *routeClient) postRouteMatrix(ctx context.Context, formatParam ResponseFormat, postRouteMatrixRequestBody PostRouteMatrixRequestBody, options *RouteBeginPostRouteMatrixOptions) (*azcore.Response, error) {
	req, err := client.postRouteMatrixCreateRequest(ctx, formatParam, postRouteMatrixRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postRouteMatrixHandleError(resp)
	}
	 return resp, nil
}

// postRouteMatrixCreateRequest creates the PostRouteMatrix request.
func (client *routeClient) postRouteMatrixCreateRequest(ctx context.Context, formatParam ResponseFormat, postRouteMatrixRequestBody PostRouteMatrixRequestBody, options *RouteBeginPostRouteMatrixOptions) (*azcore.Request, error) {
	urlPath := "/route/matrix/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.WaitForResults != nil {
		reqQP.Set("waitForResults", strconv.FormatBool(*options.WaitForResults))
	}
	if options != nil && options.ComputeTravelTimeFor != nil {
		reqQP.Set("computeTravelTimeFor", string(*options.ComputeTravelTimeFor))
	}
	if options != nil && options.SectionType != nil {
		reqQP.Set("sectionType", string(*options.SectionType))
	}
	if options != nil && options.ArriveAt != nil {
		reqQP.Set("arriveAt", options.ArriveAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.DepartAt != nil {
		reqQP.Set("departAt", options.DepartAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.VehicleAxleWeight != nil {
		reqQP.Set("vehicleAxleWeight", strconv.FormatInt(int64(*options.VehicleAxleWeight), 10))
	}
	if options != nil && options.VehicleLength != nil {
		reqQP.Set("vehicleLength", strconv.FormatFloat(float64(*options.VehicleLength), 'f', -1, 32))
	}
	if options != nil && options.VehicleHeight != nil {
		reqQP.Set("vehicleHeight", strconv.FormatFloat(float64(*options.VehicleHeight), 'f', -1, 32))
	}
	if options != nil && options.VehicleWidth != nil {
		reqQP.Set("vehicleWidth", strconv.FormatFloat(float64(*options.VehicleWidth), 'f', -1, 32))
	}
	if options != nil && options.VehicleMaxSpeed != nil {
		reqQP.Set("vehicleMaxSpeed", strconv.FormatInt(int64(*options.VehicleMaxSpeed), 10))
	}
	if options != nil && options.VehicleWeight != nil {
		reqQP.Set("vehicleWeight", strconv.FormatInt(int64(*options.VehicleWeight), 10))
	}
	if options != nil && options.Windingness != nil {
		reqQP.Set("windingness", string(*options.Windingness))
	}
	if options != nil && options.Hilliness != nil {
		reqQP.Set("hilliness", string(*options.Hilliness))
	}
	if options != nil && options.TravelMode != nil {
		reqQP.Set("travelMode", string(*options.TravelMode))
	}
	if options != nil && options.Avoid != nil {
			for _, qv := range options.Avoid {
		reqQP.Add("avoid", qv)
	}
	}
	if options != nil && options.Traffic != nil {
		reqQP.Set("traffic", strconv.FormatBool(*options.Traffic))
	}
	if options != nil && options.RouteType != nil {
		reqQP.Set("routeType", string(*options.RouteType))
	}
	if options != nil && options.VehicleLoadType != nil {
		reqQP.Set("vehicleLoadType", string(*options.VehicleLoadType))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(postRouteMatrixRequestBody)
}

// postRouteMatrixHandleError handles the PostRouteMatrix error response.
func (client *routeClient) postRouteMatrixHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostRouteMatrixSync - Applies to: S1 pricing tier.
// The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using
// an asynchronous (async) or synchronous (sync) POST
// request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set
// of destinations can be thought of as the column
// and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example,
// let's say a food delivery company has 20 drivers
// and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
// For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the
// Route Directions API.
// The maximum size of a matrix for async request is 700 and for sync request it's 100 (the number of origins multiplied by the number of destinations).
// SUBMIT SYNCHRONOUS ROUTE MATRIX REQUEST If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100,
// you might want to make synchronous request. The
// maximum size of a matrix for this API is 100 (the number of origins multiplied by the number of destinations). With that constraint in mind, examples
// of possible matrix dimensions are: 10x10, 6x8, 9x8
// (it does not need to be square).
// POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS ROUTE MATRIX REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When
// you make a request by using async request, by
// default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically
// until the response data or error information
// is available. If waitForResults parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
// The maximum size of a matrix for this API is 700 (the number of origins multiplied by the number of destinations). With that constraint in mind, examples
// of possible matrix dimensions are: 50x10,
// 10x10, 28x25. 10x70 (it does not need to be square).
// The asynchronous responses are stored for 14 days. The redirect URL returns a 404 response if used after the expiration period.
// POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
// Here's a typical sequence of asynchronous operations:
// 1. Client sends a Route Matrix POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Route Matrix request has been accepted.
//
//
// HTTP Error - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request.
// This status URI looks like the following:
//
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
//
//
// DOWNLOAD SYNC RESULTS When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response
// array. The response body will contain the data
// and there will be no possibility to retrieve the results later.
// DOWNLOAD ASYNC RESULTS When a request issues a 202 Accepted response, the request is being processed using our async pipeline. You will be given a URL
// to check the progress of your async request in
// the location header of the response. This status URI looks like the following:
// GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
// The URL provided by the location header will return the following responses when a GET request is issued.
// > HTTP 202 Accepted - Matrix request was accepted but is still being processed. Please try again in some time.
// HTTP 200 OK - Matrix request successfully processed. The response body contains all of the results.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *routeClient) PostRouteMatrixSync(ctx context.Context, formatParam ResponseFormat, postRouteMatrixRequestBody PostRouteMatrixRequestBody, options *RoutePostRouteMatrixSyncOptions) (RouteMatrixResponseResponse, error) {
	req, err := client.postRouteMatrixSyncCreateRequest(ctx, formatParam, postRouteMatrixRequestBody, options)
	if err != nil {
		return RouteMatrixResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RouteMatrixResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RouteMatrixResponseResponse{}, client.postRouteMatrixSyncHandleError(resp)
	}
	return client.postRouteMatrixSyncHandleResponse(resp)
}

// postRouteMatrixSyncCreateRequest creates the PostRouteMatrixSync request.
func (client *routeClient) postRouteMatrixSyncCreateRequest(ctx context.Context, formatParam ResponseFormat, postRouteMatrixRequestBody PostRouteMatrixRequestBody, options *RoutePostRouteMatrixSyncOptions) (*azcore.Request, error) {
	urlPath := "/route/matrix/sync/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.WaitForResults != nil {
		reqQP.Set("waitForResults", strconv.FormatBool(*options.WaitForResults))
	}
	if options != nil && options.ComputeTravelTimeFor != nil {
		reqQP.Set("computeTravelTimeFor", string(*options.ComputeTravelTimeFor))
	}
	if options != nil && options.SectionType != nil {
		reqQP.Set("sectionType", string(*options.SectionType))
	}
	if options != nil && options.ArriveAt != nil {
		reqQP.Set("arriveAt", options.ArriveAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.DepartAt != nil {
		reqQP.Set("departAt", options.DepartAt.Format(time.RFC3339Nano))
	}
	if options != nil && options.VehicleAxleWeight != nil {
		reqQP.Set("vehicleAxleWeight", strconv.FormatInt(int64(*options.VehicleAxleWeight), 10))
	}
	if options != nil && options.VehicleLength != nil {
		reqQP.Set("vehicleLength", strconv.FormatFloat(float64(*options.VehicleLength), 'f', -1, 32))
	}
	if options != nil && options.VehicleHeight != nil {
		reqQP.Set("vehicleHeight", strconv.FormatFloat(float64(*options.VehicleHeight), 'f', -1, 32))
	}
	if options != nil && options.VehicleWidth != nil {
		reqQP.Set("vehicleWidth", strconv.FormatFloat(float64(*options.VehicleWidth), 'f', -1, 32))
	}
	if options != nil && options.VehicleMaxSpeed != nil {
		reqQP.Set("vehicleMaxSpeed", strconv.FormatInt(int64(*options.VehicleMaxSpeed), 10))
	}
	if options != nil && options.VehicleWeight != nil {
		reqQP.Set("vehicleWeight", strconv.FormatInt(int64(*options.VehicleWeight), 10))
	}
	if options != nil && options.Windingness != nil {
		reqQP.Set("windingness", string(*options.Windingness))
	}
	if options != nil && options.Hilliness != nil {
		reqQP.Set("hilliness", string(*options.Hilliness))
	}
	if options != nil && options.TravelMode != nil {
		reqQP.Set("travelMode", string(*options.TravelMode))
	}
	if options != nil && options.Avoid != nil {
			for _, qv := range options.Avoid {
		reqQP.Add("avoid", qv)
	}
	}
	if options != nil && options.Traffic != nil {
		reqQP.Set("traffic", strconv.FormatBool(*options.Traffic))
	}
	if options != nil && options.RouteType != nil {
		reqQP.Set("routeType", string(*options.RouteType))
	}
	if options != nil && options.VehicleLoadType != nil {
		reqQP.Set("vehicleLoadType", string(*options.VehicleLoadType))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(postRouteMatrixRequestBody)
}

// postRouteMatrixSyncHandleResponse handles the PostRouteMatrixSync response.
func (client *routeClient) postRouteMatrixSyncHandleResponse(resp *azcore.Response) (RouteMatrixResponseResponse, error) {
	var val *RouteMatrixResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return RouteMatrixResponseResponse{}, err
	}
return RouteMatrixResponseResponse{RawResponse: resp.Response, RouteMatrixResponse: val}, nil
}

// postRouteMatrixSyncHandleError handles the PostRouteMatrixSync error response.
func (client *routeClient) postRouteMatrixSyncHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

