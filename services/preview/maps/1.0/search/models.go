// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package search

import (
	"encoding/json"
	"reflect"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// BatchItem - An item returned from Batch API. Extend with 'response' property.
type BatchItem struct {
	// READ-ONLY; HTTP request status code.
	StatusCode *float32 `json:"statusCode,omitempty" azure:"ro"`
}

// BatchRequestBody - This type represents the request body for the Batch service.
type BatchRequestBody struct {
	// The list of queries to process.
	BatchItems []*BatchRequestBodyBatchItemsItem `json:"batchItems,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchRequestBody.
func (b BatchRequestBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "batchItems", b.BatchItems)
	return json.Marshal(objectMap)
}

// BatchRequestBodyBatchItemsItem - Batch Query object
type BatchRequestBodyBatchItemsItem struct {
	// Partial query string.
	Query *string `json:"query,omitempty"`
}

// BatchResponse - This object is returned from a successful Batch service call. Extend with 'batchItems' property.
type BatchResponse struct {
	// READ-ONLY; Summary for the batch request
	Summary *BatchResponseSummary `json:"summary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BatchResponse.
func (b BatchResponse) MarshalJSON() ([]byte, error) {
	objectMap := b.marshalInternal()
	return json.Marshal(objectMap)
}

func (b BatchResponse) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "summary", b.Summary)
	return objectMap
}

// BatchResponseSummary - Summary for the batch request
type BatchResponseSummary struct {
	// READ-ONLY; Number of successful requests in the batch
	SuccessfulRequests *int32 `json:"successfulRequests,omitempty" azure:"ro"`

	// READ-ONLY; Total number of requests in the batch
	TotalRequests *int32 `json:"totalRequests,omitempty" azure:"ro"`
}

// CoordinatesPairAbbreviated - A location represented as a latitude and longitude using short names 'lat' & 'lon'.
type CoordinatesPairAbbreviated struct {
	// Latitude property
	Lat *float64 `json:"lat,omitempty"`

	// Longitude property
	Lon *float64 `json:"lon,omitempty"`
}

// DataSources - Optional section. Reference ids for use with the Get Search Polygon [https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon]
// API.
type DataSources struct {
	// Information about the geometric shape of the result. Only present if type == Geography.
	Geometry *DataSourcesGeometry `json:"geometry,omitempty"`
}

// DataSourcesGeometry - Information about the geometric shape of the result. Only present if type == Geography.
type DataSourcesGeometry struct {
	// READ-ONLY; Pass this as geometryId to the Get Search Polygon [https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon] API to fetch geometry
	// information for this result.
	ID *string `json:"id,omitempty" azure:"ro"`
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// GeoJSONFeature - A valid GeoJSON Feature object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.2] for details.
type GeoJSONFeature struct {
	GeoJSONFeatureData
	GeoJSONObject
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeature.
func (g GeoJSONFeature) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONFeatureData.marshalInternal()
	for key, val := range g.GeoJSONObject.marshalInternal(*g.GetGeoJSONObject().Type) {
		objectMap[key] = val
	}
	return json.Marshal(objectMap)
}

func (g *GeoJSONFeature) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g *GeoJSONFeature) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := g.GeoJSONFeatureData.unmarshalInternal(rawMsg); err != nil {
		return err
	}

	return g.GeoJSONObject.unmarshalInternal(rawMsg)
}

// GeoJSONFeatureCollection - A valid GeoJSON FeatureCollection object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.3]
// for details.
type GeoJSONFeatureCollection struct {
	GeoJSONFeatureCollectionData
	GeoJSONObject
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeatureCollection.
func (g GeoJSONFeatureCollection) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONFeatureCollectionData.marshalInternal()
	for key, val := range g.GeoJSONObject.marshalInternal(*g.GetGeoJSONObject().Type) {
		objectMap[key] = val
	}
	return json.Marshal(objectMap)
}

func (g *GeoJSONFeatureCollection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g *GeoJSONFeatureCollection) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := g.GeoJSONFeatureCollectionData.unmarshalInternal(rawMsg); err != nil {
		return err
	}

	return g.GeoJSONObject.unmarshalInternal(rawMsg)
}

type GeoJSONFeatureCollectionData struct {
	// REQUIRED; Contains a list of valid GeoJSON Feature objects.
	Features []*GeoJSONFeature `json:"features,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeatureCollectionData.
func (g GeoJSONFeatureCollectionData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONFeatureCollectionData.
func (g *GeoJSONFeatureCollectionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONFeatureCollectionData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "features", g.Features)
	return objectMap
}

func (g *GeoJSONFeatureCollectionData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "features":
			err = unpopulate(val, &g.Features)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type GeoJSONFeatureData struct {
	// REQUIRED; A valid GeoJSON geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,
	// Polygon, MultiPolygon and GeometryCollection. Please
	// refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1] for details.
	Geometry GeoJSONGeometryClassification `json:"geometry,omitempty"`

	// The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value.
	FeatureType *string `json:"featureType,omitempty"`

	// Identifier for the feature.
	ID *string `json:"id,omitempty"`

	// Properties can contain any additional metadata about the Feature. Value can be any JSON object or a JSON null value
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeatureData.
func (g GeoJSONFeatureData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONFeatureData.
func (g *GeoJSONFeatureData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONFeatureData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "featureType", g.FeatureType)
	populate(objectMap, "geometry", g.Geometry)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "properties", g.Properties)
	return objectMap
}

func (g *GeoJSONFeatureData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "featureType":
			err = unpopulate(val, &g.FeatureType)
			delete(rawMsg, key)
		case "geometry":
			g.Geometry, err = unmarshalGeoJSONGeometryClassification(val)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &g.ID)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &g.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONGeometryClassification provides polymorphic access to related types.
// Call the interface's GetGeoJSONGeometry() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *GeoJSONGeometry, *GeoJsonGeometryCollection, *GeoJsonLineString, *GeoJsonMultiLineString, *GeoJsonMultiPoint, *GeoJsonMultiPolygon,
// - *GeoJsonPoint, *GeoJsonPolygon
type GeoJSONGeometryClassification interface {
	GeoJSONObjectClassification
	// GetGeoJSONGeometry returns the GeoJSONGeometry content of the underlying type.
	GetGeoJSONGeometry() *GeoJSONGeometry
}

// GeoJSONGeometry - A valid GeoJSON geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,
// Polygon, MultiPolygon and GeometryCollection. Please
// refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1] for details.
type GeoJSONGeometry struct {
	GeoJSONObject
}

// GetGeoJSONGeometry implements the GeoJSONGeometryClassification interface for type GeoJSONGeometry.
func (g *GeoJSONGeometry) GetGeoJSONGeometry() *GeoJSONGeometry { return g }

// MarshalJSON implements the json.Marshaller interface for type GeoJSONGeometry.
func (g GeoJSONGeometry) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal("GeoJsonGeometry")
	return json.Marshal(objectMap)
}

func (g GeoJSONGeometry) marshalInternal(discValue GeoJSONObjectType) map[string]interface{} {
	objectMap := g.GeoJSONObject.marshalInternal(discValue)
	return objectMap
}

func (g *GeoJSONGeometry) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	return g.GeoJSONObject.unmarshalInternal(rawMsg)
}

// GeoJSONGeometryCollection - A valid GeoJSON GeometryCollection object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.8]
// for details.
type GeoJSONGeometryCollection struct {
	GeoJSONGeometry
	GeoJSONGeometryCollectionData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONGeometryCollection.
func (g GeoJSONGeometryCollection) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONGeometryCollectionData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}
	return json.Marshal(objectMap)
}

func (g *GeoJSONGeometryCollection) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometryCollectionData.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONGeometry.UnmarshalJSON(data)
}

type GeoJSONGeometryCollectionData struct {
	// REQUIRED; Contains a list of valid GeoJSON geometry objects. Note that coordinates in GeoJSON are in x, y order (longitude, latitude).
	Geometries []GeoJSONGeometryClassification `json:"geometries,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONGeometryCollectionData.
func (g GeoJSONGeometryCollectionData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONGeometryCollectionData.
func (g *GeoJSONGeometryCollectionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONGeometryCollectionData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "geometries", g.Geometries)
	return objectMap
}

func (g *GeoJSONGeometryCollectionData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "geometries":
			g.Geometries, err = unmarshalGeoJSONGeometryClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONLineString - A valid GeoJSON LineString geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.4] for details.
type GeoJSONLineString struct {
	GeoJSONGeometry
	GeoJSONLineStringData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONLineString.
func (g GeoJSONLineString) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONLineStringData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONLineString) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONLineStringData.UnmarshalJSON(data)
}

type GeoJSONLineStringData struct {
	// REQUIRED; Coordinates for the GeoJson LineString geometry.
	Coordinates [][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONLineStringData.
func (g GeoJSONLineStringData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONLineStringData.
func (g *GeoJSONLineStringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONLineStringData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONLineStringData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONMultiLineString - A valid GeoJSON MultiLineString geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.5]
// for details.
type GeoJSONMultiLineString struct {
	GeoJSONGeometry
	GeoJSONMultiLineStringData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiLineString.
func (g GeoJSONMultiLineString) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONMultiLineStringData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONMultiLineString) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONMultiLineStringData.UnmarshalJSON(data)
}

type GeoJSONMultiLineStringData struct {
	// REQUIRED; Coordinates for the GeoJson MultiLineString geometry.
	Coordinates [][][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiLineStringData.
func (g GeoJSONMultiLineStringData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONMultiLineStringData.
func (g *GeoJSONMultiLineStringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONMultiLineStringData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONMultiLineStringData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONMultiPoint - A valid GeoJSON MultiPoint geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.3] for details.
type GeoJSONMultiPoint struct {
	GeoJSONGeometry
	GeoJSONMultiPointData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPoint.
func (g GeoJSONMultiPoint) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONMultiPointData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONMultiPoint) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONMultiPointData.UnmarshalJSON(data)
}

// GeoJSONMultiPointData - Data contained by a GeoJson MultiPoint.
type GeoJSONMultiPointData struct {
	// REQUIRED; Coordinates for the GeoJson MultiPoint geometry.
	Coordinates [][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPointData.
func (g GeoJSONMultiPointData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONMultiPointData.
func (g *GeoJSONMultiPointData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONMultiPointData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONMultiPointData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONMultiPolygon - A valid GeoJSON MultiPolygon object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.7] for details.
type GeoJSONMultiPolygon struct {
	GeoJSONGeometry
	GeoJSONMultiPolygonData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPolygon.
func (g GeoJSONMultiPolygon) MarshalJSON() ([]byte, error) {
	objectMapBase := g.GeoJSONMultiPolygonData.marshalInternal()
	for key, val := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMapBase[key] = val
	}

	return json.Marshal(objectMapBase)
}

func (g *GeoJSONMultiPolygon) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONMultiPolygonData.UnmarshalJSON(data)
}

type GeoJSONMultiPolygonData struct {
	// REQUIRED; Contains a list of valid GeoJSON Polygon objects. Note that coordinates in GeoJSON are in x, y order (longitude, latitude).
	Coordinates [][][][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPolygonData.
func (g GeoJSONMultiPolygonData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONMultiPolygonData.
func (g *GeoJSONMultiPolygonData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONMultiPolygonData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONMultiPolygonData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONObjectClassification provides polymorphic access to related types.
// Call the interface's GetGeoJSONObject() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *GeoJSONObject, *GeoJsonFeature, *GeoJsonFeatureCollection, *GeoJsonGeometry, *GeoJsonGeometryCollection, *GeoJsonLineString,
// - *GeoJsonMultiLineString, *GeoJsonMultiPoint, *GeoJsonMultiPolygon, *GeoJsonPoint, *GeoJsonPolygon
type GeoJSONObjectClassification interface {
	// GetGeoJSONObject returns the GeoJSONObject content of the underlying type.
	GetGeoJSONObject() *GeoJSONObject
}

// GeoJSONObject - A valid GeoJSON object. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3] for details.
type GeoJSONObject struct {
	// REQUIRED; Specifies the GeoJSON type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
	// GeometryCollection, Feature and
	// FeatureCollection.
	Type *GeoJSONObjectType `json:"type,omitempty"`
}

// GetGeoJSONObject implements the GeoJSONObjectClassification interface for type GeoJSONObject.
func (g *GeoJSONObject) GetGeoJSONObject() *GeoJSONObject { return g }

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONObject.
func (g *GeoJSONObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONObject) marshalInternal(discValue GeoJSONObjectType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	g.Type = &discValue
	objectMap["type"] = g.Type
	return objectMap
}

func (g *GeoJSONObject) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONPoint - A valid GeoJSON Point geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.2] for details.
type GeoJSONPoint struct {
	GeoJSONGeometry
	GeoJSONPointData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPoint.
func (g GeoJSONPoint) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONPointData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONPoint) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONPointData.UnmarshalJSON(data)
}

// GeoJSONPointData - Data contained by a GeoJson Point.
type GeoJSONPointData struct {
	// REQUIRED; A Position is an array of numbers with two or more elements. The first two elements are longitude and latitude, precisely in that order. Altitude/Elevation
	// is an optional third element. Please refer
	// to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.1] for details.
	Coordinates []*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPointData.
func (g GeoJSONPointData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONPointData.
func (g *GeoJSONPointData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONPointData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONPointData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONPolygon - A valid GeoJSON Polygon geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.6] for details.
type GeoJSONPolygon struct {
	GeoJSONGeometry
	GeoJSONPolygonData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPolygon.
func (g GeoJSONPolygon) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONPolygonData.marshalInternal()
	for key, val := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = val
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONPolygon) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONPolygonData.UnmarshalJSON(data)
}

type GeoJSONPolygonData struct {
	// REQUIRED; Coordinates for the GeoJson Polygon geometry type.
	Coordinates [][][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPolygonData.
func (g GeoJSONPolygonData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONPolygonData.
func (g *GeoJSONPolygonData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONPolygonData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONPolygonData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// PoiCategoryResult - POI category result
type PoiCategoryResult struct {
	// READ-ONLY; Array of child category ids
	ChildCategoryIDs []*int32 `json:"childCategoryIds,omitempty" azure:"ro"`

	// READ-ONLY; Unique ID for the category. ID can be used to restrict search results to specific categories through other Search Service APIs, like Get Search
	// POI
	// [https://docs.microsoft.com/rest/api/maps/search/getsearchpoi].
	ID *int32 `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of the category
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Array of alternative names of the category
	Synonyms []*string `json:"synonyms,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PoiCategoryResult.
func (p PoiCategoryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "childCategoryIds", p.ChildCategoryIDs)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "synonyms", p.Synonyms)
	return json.Marshal(objectMap)
}

// SearchAddressBatchItem - An item returned from Search Address Batch service call.
type SearchAddressBatchItem struct {
	BatchItem
	// READ-ONLY; The result of the query. SearchCommonResponse if the query completed successfully, ErrorResponse otherwise.
	Response *SearchAddressBatchItemResponse `json:"response,omitempty" azure:"ro"`
}

// SearchAddressBatchItemResponse - The result of the query. SearchCommonResponse if the query completed successfully, ErrorResponse otherwise.
type SearchAddressBatchItemResponse struct {
	ErrorResponse
	SearchCommonResponse
}

// SearchAddressBatchResponse - This object is returned from a successful Search Address Batch service call.
type SearchAddressBatchResponse struct {
	BatchResponse
	// READ-ONLY; Array containing the batch results.
	BatchItems []*SearchAddressBatchItem `json:"batchItems,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchAddressBatchResponse.
func (s SearchAddressBatchResponse) MarshalJSON() ([]byte, error) {
	objectMap := s.BatchResponse.marshalInternal()
	populate(objectMap, "batchItems", s.BatchItems)
	return json.Marshal(objectMap)
}

// SearchAddressReverseBatchItem - An item returned from Search Address Reverse Batch service call.
type SearchAddressReverseBatchItem struct {
	BatchItem
	// READ-ONLY; The result of the query. SearchAddressReverseResponse if the query completed successfully, ErrorResponse otherwise.
	Response *SearchAddressReverseBatchItemResponse `json:"response,omitempty" azure:"ro"`
}

// SearchAddressReverseBatchItemResponse - The result of the query. SearchAddressReverseResponse if the query completed successfully, ErrorResponse otherwise.
type SearchAddressReverseBatchItemResponse struct {
	ErrorResponse
	SearchAddressReverseResponse
}

// SearchAddressReverseBatchResponse - This object is returned from a successful Search Address Reverse Batch service call.
type SearchAddressReverseBatchResponse struct {
	BatchResponse
	// READ-ONLY; Array containing the batch results.
	BatchItems []*SearchAddressReverseBatchItem `json:"batchItems,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchAddressReverseBatchResponse.
func (s SearchAddressReverseBatchResponse) MarshalJSON() ([]byte, error) {
	objectMap := s.BatchResponse.marshalInternal()
	populate(objectMap, "batchItems", s.BatchItems)
	return json.Marshal(objectMap)
}

// SearchAddressReverseCrossStreetResponse - This object is returned from a successful Search Address Reverse CrossStreet call
type SearchAddressReverseCrossStreetResponse struct {
	// READ-ONLY; Addresses array
	Addresses []*SearchAddressReverseCrossStreetResult `json:"addresses,omitempty" azure:"ro"`

	// READ-ONLY; Summary object for a Search Address Reverse Cross Street response
	Summary *SearchCommonSummary `json:"summary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchAddressReverseCrossStreetResponse.
func (s SearchAddressReverseCrossStreetResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "addresses", s.Addresses)
	populate(objectMap, "summary", s.Summary)
	return json.Marshal(objectMap)
}

// SearchAddressReverseCrossStreetResult - Result object for a Search Address Reverse Cross Street response
type SearchAddressReverseCrossStreetResult struct {
	// READ-ONLY; The address of the result
	Address *SearchResultAddress `json:"address,omitempty" azure:"ro"`

	// READ-ONLY; Position property in the form of "{latitude},{longitude}"
	Position *string `json:"position,omitempty" azure:"ro"`
}

// SearchAddressReverseResponse - This object is returned from a successful Search Address Reverse call
type SearchAddressReverseResponse struct {
	// READ-ONLY; Addresses array
	Addresses []*SearchAddressReverseResult `json:"addresses,omitempty" azure:"ro"`

	// READ-ONLY; Summary object for a Search Address Reverse response
	Summary *SearchCommonSummary `json:"summary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchAddressReverseResponse.
func (s SearchAddressReverseResponse) MarshalJSON() ([]byte, error) {
	objectMap := s.marshalInternal()
	return json.Marshal(objectMap)
}

func (s SearchAddressReverseResponse) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "addresses", s.Addresses)
	populate(objectMap, "summary", s.Summary)
	return objectMap
}

// SearchAddressReverseResult - Result object for a Search Address Reverse response
type SearchAddressReverseResult struct {
	// READ-ONLY; The address of the result
	Address *SearchResultAddress `json:"address,omitempty" azure:"ro"`

	// READ-ONLY; Information on the type of match.
	// One of:
	// * AddressPoint
	// * HouseNumberRange
	// * Street
	MatchType *string `json:"matchType,omitempty" azure:"ro"`

	// READ-ONLY; Position property in the form of "{latitude},{longitude}"
	Position *string `json:"position,omitempty" azure:"ro"`
}

// SearchAlongRouteRequestBody - This type represents the request body for the Search Along Route service.
type SearchAlongRouteRequestBody struct {
	// A valid GeoJSON LineString geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.4] for details.
	Route *GeoJSONLineString `json:"route,omitempty"`
}

// SearchBeginGetSearchAddressBatchOptions contains the optional parameters for the Search.BeginGetSearchAddressBatch method.
type SearchBeginGetSearchAddressBatchOptions struct {
	// placeholder for future optional parameters
}

// SearchBeginGetSearchAddressReverseBatchOptions contains the optional parameters for the Search.BeginGetSearchAddressReverseBatch method.
type SearchBeginGetSearchAddressReverseBatchOptions struct {
	// placeholder for future optional parameters
}

// SearchBeginGetSearchFuzzyBatchOptions contains the optional parameters for the Search.BeginGetSearchFuzzyBatch method.
type SearchBeginGetSearchFuzzyBatchOptions struct {
	// placeholder for future optional parameters
}

// SearchBeginPostSearchAddressBatchOptions contains the optional parameters for the Search.BeginPostSearchAddressBatch method.
type SearchBeginPostSearchAddressBatchOptions struct {
	// placeholder for future optional parameters
}

// SearchBeginPostSearchAddressReverseBatchOptions contains the optional parameters for the Search.BeginPostSearchAddressReverseBatch method.
type SearchBeginPostSearchAddressReverseBatchOptions struct {
	// placeholder for future optional parameters
}

// SearchBeginPostSearchFuzzyBatchOptions contains the optional parameters for the Search.BeginPostSearchFuzzyBatch method.
type SearchBeginPostSearchFuzzyBatchOptions struct {
	// placeholder for future optional parameters
}

// SearchCommonResponse - This object is returned from a successful Search calls.
type SearchCommonResponse struct {
	// READ-ONLY; A list of Search API results.
	Results []*SearchCommonResult `json:"results,omitempty" azure:"ro"`

	// READ-ONLY; Summary object for a Search API response
	Summary *SearchCommonSummary `json:"summary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchCommonResponse.
func (s SearchCommonResponse) MarshalJSON() ([]byte, error) {
	objectMap := s.marshalInternal()
	return json.Marshal(objectMap)
}

func (s SearchCommonResponse) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "results", s.Results)
	populate(objectMap, "summary", s.Summary)
	return objectMap
}

// SearchCommonResult - Result object for a Search API response.
type SearchCommonResult struct {
	// Geography entity type. Present only when entityType was requested and is available.
	EntityType *EntityType `json:"entityType,omitempty"`

	// A location represented as a latitude and longitude using short names 'lat' & 'lon'.
	Position *CoordinatesPairAbbreviated `json:"position,omitempty"`

	// READ-ONLY; The address of the result
	Address *SearchResultAddress `json:"address,omitempty" azure:"ro"`

	// READ-ONLY; Describes the address range on both sides of the street for a search result. Coordinates for the start and end locations of the address range
	// are included.
	AddressRanges *SearchResultAddressRanges `json:"addressRanges,omitempty" azure:"ro"`

	// READ-ONLY; Optional section. Reference ids for use with the Get Search Polygon [https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon] API.
	DataSources *DataSources `json:"dataSources,omitempty" azure:"ro"`

	// READ-ONLY; Detour time in seconds
	DetourTime *float32 `json:"detourTime,omitempty" azure:"ro"`

	// READ-ONLY; Straight line distance between the result and geobias location in meters.
	Dist *float32 `json:"dist,omitempty" azure:"ro"`

	// READ-ONLY; Entry Points array
	EntryPoints []*SearchResultEntryPoint `json:"entryPoints,omitempty" azure:"ro"`

	// READ-ONLY; Id property
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Info property
	Info *string `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; Information on the type of match.
	// One of:
	// * AddressPoint
	// * HouseNumberRange
	// * Street
	MatchType *string `json:"matchType,omitempty" azure:"ro"`

	// READ-ONLY; Details of the returned POI including information such as the name, phone, url address, and classifications.
	Poi *SearchResultPoi `json:"poi,omitempty" azure:"ro"`

	// READ-ONLY; The value within a result set to indicate the relative matching score between results. You can use this to determine that result x is twice
	// as likely to be as relevant as result y if the value of x is
	// 2x the value of y. The values vary between queries and is only meant as a relative value for one result set.
	Score *float32 `json:"score,omitempty" azure:"ro"`

	// READ-ONLY; One of:
	// * POI
	// * Street
	// * Geography
	// * Point Address
	// * Address Range
	// * Cross Street
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; The viewport that covers the result represented by the top-left and bottom-right coordinates of the viewport.
	Viewport *SearchResultViewport `json:"viewport,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchCommonResult.
func (s SearchCommonResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "address", s.Address)
	populate(objectMap, "addressRanges", s.AddressRanges)
	populate(objectMap, "dataSources", s.DataSources)
	populate(objectMap, "detourTime", s.DetourTime)
	populate(objectMap, "dist", s.Dist)
	populate(objectMap, "entityType", s.EntityType)
	populate(objectMap, "entryPoints", s.EntryPoints)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "info", s.Info)
	populate(objectMap, "matchType", s.MatchType)
	populate(objectMap, "poi", s.Poi)
	populate(objectMap, "position", s.Position)
	populate(objectMap, "score", s.Score)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "viewport", s.Viewport)
	return json.Marshal(objectMap)
}

// SearchCommonSummary - Summary object for a Search API response.
type SearchCommonSummary struct {
	// READ-ONLY; FuzzyLevel property
	FuzzyLevel *int32 `json:"fuzzyLevel,omitempty" azure:"ro"`

	// READ-ONLY; Indication when the internal search engine has applied a geospatial bias to improve the ranking of results. In some methods, this can be affected
	// by setting the lat and lon parameters where available.
	// In other cases it is purely internal.
	GeoBias *SearchCommonSummaryGeoBias `json:"geoBias,omitempty" azure:"ro"`

	// READ-ONLY; Maximum number of responses that will be returned
	Limit *int32 `json:"limit,omitempty" azure:"ro"`

	// READ-ONLY; NumResults property
	NumResults *int32 `json:"numResults,omitempty" azure:"ro"`

	// READ-ONLY; Offset property
	Offset *int32 `json:"offset,omitempty" azure:"ro"`

	// READ-ONLY; Query property
	Query *string `json:"query,omitempty" azure:"ro"`

	// READ-ONLY; QueryTime property
	QueryTime *int32 `json:"queryTime,omitempty" azure:"ro"`

	// READ-ONLY; QueryType property
	QueryType *string `json:"queryType,omitempty" azure:"ro"`

	// READ-ONLY; TotalResults property
	TotalResults *int32 `json:"totalResults,omitempty" azure:"ro"`
}

// SearchCommonSummaryGeoBias - Indication when the internal search engine has applied a geospatial bias to improve the ranking of results. In some methods,
// this can be affected by setting the lat and lon parameters where available.
// In other cases it is purely internal.
type SearchCommonSummaryGeoBias struct {
	CoordinatesPairAbbreviated
}

// SearchFuzzyBatchItem - An item returned from Search Fuzzy Batch service call.
type SearchFuzzyBatchItem struct {
	BatchItem
	// READ-ONLY; The result of the query. SearchCommonResponse if the query completed successfully, ErrorResponse otherwise.
	Response *SearchFuzzyBatchItemResponse `json:"response,omitempty" azure:"ro"`
}

// SearchFuzzyBatchItemResponse - The result of the query. SearchCommonResponse if the query completed successfully, ErrorResponse otherwise.
type SearchFuzzyBatchItemResponse struct {
	ErrorResponse
	SearchCommonResponse
}

// SearchFuzzyBatchResponse - This object is returned from a successful Search Fuzzy Batch service call.
type SearchFuzzyBatchResponse struct {
	BatchResponse
	// READ-ONLY; Array containing the batch results.
	BatchItems []*SearchFuzzyBatchItem `json:"batchItems,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchFuzzyBatchResponse.
func (s SearchFuzzyBatchResponse) MarshalJSON() ([]byte, error) {
	objectMap := s.BatchResponse.marshalInternal()
	populate(objectMap, "batchItems", s.BatchItems)
	return json.Marshal(objectMap)
}

// SearchGetSearchAddressOptions contains the optional parameters for the Search.GetSearchAddress method.
type SearchGetSearchAddressOptions struct {
	// Bottom right position of the bounding box. E.g. 37.553,-122.453
	BtmRight *string
	// Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries
	CountrySet []string
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **Addr** = Address ranges
	// **Geo** = Geographies
	// **PAD** = Point Addresses
	// **POI** = Points of Interest
	// **Str** = Streets
	// **XStr** = Cross Streets (intersections)
	// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
	// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to
	// be explicitly requested when needed.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=PAD,Addr,POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Latitude where results should be biased. E.g. 37.337
	Lat *float32
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// Longitude where results should be biased. E.g. -121.89
	Lon *float32
	// Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900
	Ofs *int32
	// The radius in meters to for the results to be constrained to the defined area
	Radius *float32
	// Top left position of the bounding box. E.g. 37.553,-122.453
	TopLeft *string
	// Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode
	Typeahead *bool
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchAddressReverseCrossStreetOptions contains the optional parameters for the Search.GetSearchAddressReverseCrossStreet method.
type SearchGetSearchAddressReverseCrossStreetOptions struct {
	// The directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is North, 90 is East and so on, values range from -360 to
	// 360. The precision can include upto one decimal place
	Heading *float32
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// The radius in meters to for the results to be constrained to the defined area
	Radius *float32
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchAddressReverseOptions contains the optional parameters for the Search.GetSearchAddressReverse method.
type SearchGetSearchAddressReverseOptions struct {
	// Format of newlines in the formatted address.
	// If true, the address will contain newlines.
	// If false, newlines will be converted to commas.
	AllowFreeformNewline *bool
	// Specifies the level of filtering performed on geographies. Narrows the search for specified geography entity types, e.g. return only municipality. The
	// resulting response will contain the geography ID as well as the entity type matched. If you provide more than one entity as a comma separated list, endpoint
	// will return the 'smallest entity available'. Returned Geometry ID can be used to get the geometry of that geography via [Get Search Polygon](https://docs.microsoft.com/rest/api/maps/search/getsearchpolygon)
	// API. The following parameters are ignored when entityType is set:
	// * heading
	// * number
	// * returnRoadUse
	// * returnSpeedLimit
	// * roadUse
	// * returnMatchType
	EntityType *EntityType
	// The directional heading of the vehicle in degrees, for travel along a segment of roadway. 0 is North, 90 is East and so on, values range from -360 to
	// 360. The precision can include upto one decimal place
	Heading *float32
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// If a number is sent in along with the request, the response may include the side of the street (Left/Right) and also an offset position for that number
	Number *string
	// The radius in meters to for the results to be constrained to the defined area
	Radius *float32
	// Include information on the type of match the geocoder achieved in the response.
	ReturnMatchType *bool
	// Boolean. To enable return of the road use array for reverse geocodes at street level
	ReturnRoadUse *bool
	// Boolean. To enable return of the posted speed limit
	ReturnSpeedLimit *bool
	// To restrict reverse geocodes to a certain type of road use. The road use array for reverse geocodes can be one or more of LimitedAccess, Arterial, Terminal,
	// Ramp, Rotary, LocalStreet
	RoadUse *string
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchAddressStructuredOptions contains the optional parameters for the Search.GetSearchAddressStructured method.
type SearchGetSearchAddressStructuredOptions struct {
	// The 2 or 3 letter [ISO3166-1](https://www.iso.org/iso-3166-country-codes.html) country code portion of an address. E.g. US.
	CountryCode *string
	// The county for the structured address
	CountrySecondarySubdivision *string
	// The country subdivision portion of an address
	CountrySubdivision *string
	// The named area for the structured address
	CountryTertiarySubdivision *string
	// The cross street name for the structured address
	CrossStreet *string
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **Addr** = Address ranges
	// **Geo** = Geographies
	// **PAD** = Point Addresses
	// **POI** = Points of Interest
	// **Str** = Streets
	// **XStr** = Cross Streets (intersections)
	// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
	// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to
	// be explicitly requested when needed.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=PAD,Addr,POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// The municipality portion of an address
	Municipality *string
	// The municipality subdivision (sub/super city) for the structured address
	MunicipalitySubdivision *string
	// Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900
	Ofs *int32
	// The postal code portion of an address
	PostalCode *string
	// The street name portion of an address
	StreetName *string
	// The street number portion of an address
	StreetNumber *string
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchFuzzyOptions contains the optional parameters for the Search.GetSearchFuzzy method.
type SearchGetSearchFuzzyOptions struct {
	// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands
	// are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a "," in their name should be put
	// into quotes.
	// Usage examples:
	// brandSet=Foo
	// brandSet=Foo,Bar
	// brandSet="A,B,C Comma",Bar
	BrandSet []string
	// Bottom right position of the bounding box. E.g. 37.553,-122.453
	BtmRight *string
	// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter.
	// When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The
	// list of supported categories can be discovered using [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
	// * **categorySet=7315** (Search Points of Interest from category Restaurant)
	// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant)
	CategorySet []int32
	// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types.
	// Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
	// Available connector types are:
	// * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard
	// Voltage and standard Amperage. See also: [Plug & socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
	// * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the
	// standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
	// * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
	// * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
	// * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination
	// with up to 240V single phase or up to 420V three phase infrastructure.
	// * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is
	// also known as the TEPCO's connector. It supports fast DC charging.
	// * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination
	// of the standard, the color and the fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
	// * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
	// * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla's proprietary connector, sometimes
	// referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
	// Usage examples:
	// connectorSet=IEC62196Type2CableAttached
	// connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
	ConnectorSet []ConnectorSet
	// Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries
	CountrySet []string
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **Addr** = Address ranges
	// **Geo** = Geographies
	// **PAD** = Point Addresses
	// **POI** = Points of Interest
	// **Str** = Streets
	// **XStr** = Cross Streets (intersections)
	// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
	// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to
	// be explicitly requested when needed.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=PAD,Addr,POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are: Addr = Address range interpolation,
	// Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections)
	IdxSet []SearchIndexSet
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Latitude where results should be biased. E.g. 37.337
	Lat *float32
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// Longitude where results should be biased. E.g. -121.89
	Lon *float32
	// Maximum fuzziness level to be used. Default: 2, minimum: 1 and maximum: 4
	// * Level 1 has no spell checking.
	// * Level 2 uses normal n-gram spell checking. For example, query "restrant" can be matched to "restaurant."
	// * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for "rstrnt" to "restaurant" matching. Shingle spell
	// checking is for "mountainview" to "mountain view" matching.
	// * Level 4 doesn’t add any more spell checking functions.
	// The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop searching at the level specified by maxFuzzyLevel.
	MaxFuzzyLevel *int32
	// Minimum fuzziness level to be used. Default: 1, minimum: 1 and maximum: 4
	// * Level 1 has no spell checking.
	// * Level 2 uses normal n-gram spell checking. For example, query "restrant" can be matched to "restaurant."
	// * Level 3 uses sound-like spell checking, and shingle spell checking. Sound-like spell checking is for "rstrnt" to "restaurant" matching. Shingle spell
	// checking is for "mountainview" to "mountain view" matching.
	// * Level 4 doesn’t add any more spell checking functions.
	// The search engine will start looking for a match on the level defined by minFuzzyLevel, and will stop searching at the level specified by maxFuzzyLevel.
	MinFuzzyLevel *int32
	// Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900
	Ofs *int32
	// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
	// Supported value: nextSevenDays
	OpeningHours *OpeningHours
	// The radius in meters to for the results to be constrained to the defined area
	Radius *float32
	// Top left position of the bounding box. E.g. 37.553,-122.453
	TopLeft *string
	// Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode
	Typeahead *bool
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchNearbyOptions contains the optional parameters for the Search.GetSearchNearby method.
type SearchGetSearchNearbyOptions struct {
	// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands
	// are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a "," in their name should be put
	// into quotes.
	// Usage examples:
	// brandSet=Foo
	// brandSet=Foo,Bar
	// brandSet="A,B,C Comma",Bar
	BrandSet []string
	// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter.
	// When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The
	// list of supported categories can be discovered using [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
	// * **categorySet=7315** (Search Points of Interest from category Restaurant)
	// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant)
	CategorySet []int32
	// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types.
	// Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
	// Available connector types are:
	// * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard
	// Voltage and standard Amperage. See also: [Plug & socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
	// * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the
	// standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
	// * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
	// * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
	// * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination
	// with up to 240V single phase or up to 420V three phase infrastructure.
	// * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is
	// also known as the TEPCO's connector. It supports fast DC charging.
	// * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination
	// of the standard, the color and the fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
	// * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
	// * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla's proprietary connector, sometimes
	// referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
	// Usage examples:
	// connectorSet=IEC62196Type2CableAttached
	// connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
	ConnectorSet []ConnectorSet
	// Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries
	CountrySet []string
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **Addr** = Address ranges
	// **Geo** = Geographies
	// **PAD** = Point Addresses
	// **POI** = Points of Interest
	// **Str** = Streets
	// **XStr** = Cross Streets (intersections)
	// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
	// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to
	// be explicitly requested when needed.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=PAD,Addr,POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900
	Ofs *int32
	// The radius in meters to for the results to be constrained to the defined area, Min value is 1, Max Value is 50000.
	Radius *float32
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchPOICategoryOptions contains the optional parameters for the Search.GetSearchPOICategory method.
type SearchGetSearchPOICategoryOptions struct {
	// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands
	// are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a "," in their name should be put
	// into quotes.
	// Usage examples:
	// brandSet=Foo
	// brandSet=Foo,Bar
	// brandSet="A,B,C Comma",Bar
	BrandSet []string
	// Bottom right position of the bounding box. E.g. 37.553,-122.453
	BtmRight *string
	// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter.
	// When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The
	// list of supported categories can be discovered using [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
	// * **categorySet=7315** (Search Points of Interest from category Restaurant)
	// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant)
	CategorySet []int32
	// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types.
	// Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
	// Available connector types are:
	// * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard
	// Voltage and standard Amperage. See also: [Plug & socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
	// * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the
	// standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
	// * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
	// * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
	// * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination
	// with up to 240V single phase or up to 420V three phase infrastructure.
	// * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is
	// also known as the TEPCO's connector. It supports fast DC charging.
	// * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination
	// of the standard, the color and the fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
	// * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
	// * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla's proprietary connector, sometimes
	// referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
	// Usage examples:
	// connectorSet=IEC62196Type2CableAttached
	// connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
	ConnectorSet []ConnectorSet
	// Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries
	CountrySet []string
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **Addr** = Address ranges
	// **Geo** = Geographies
	// **PAD** = Point Addresses
	// **POI** = Points of Interest
	// **Str** = Streets
	// **XStr** = Cross Streets (intersections)
	// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
	// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to
	// be explicitly requested when needed.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=PAD,Addr,POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Latitude where results should be biased. E.g. 37.337
	Lat *float32
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// Longitude where results should be biased. E.g. -121.89
	Lon *float32
	// Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900
	Ofs *int32
	// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
	// Supported value: nextSevenDays
	OpeningHours *OpeningHours
	// The radius in meters to for the results to be constrained to the defined area
	Radius *float32
	// Top left position of the bounding box. E.g. 37.553,-122.453
	TopLeft *string
	// Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode
	Typeahead *bool
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchPOICategoryTreePreviewOptions contains the optional parameters for the Search.GetSearchPOICategoryTreePreview method.
type SearchGetSearchPOICategoryTreePreviewOptions struct {
	// Language in which search results should be returned. Should be one of supported IETF language tags, except NGT and NGT-Latn. Language tag is case insensitive.
	// When data in specified language is not available for a specific field, default language is used (English).
	// Please refer to [Supported Languages](https://docs.microsoft.com/azure/azure-maps/supported-languages) for details.
	Language *string
}

// SearchGetSearchPOIOptions contains the optional parameters for the Search.GetSearchPOI method.
type SearchGetSearchPOIOptions struct {
	// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands
	// are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a "," in their name should be put
	// into quotes.
	// Usage examples:
	// brandSet=Foo
	// brandSet=Foo,Bar
	// brandSet="A,B,C Comma",Bar
	BrandSet []string
	// Bottom right position of the bounding box. E.g. 37.553,-122.453
	BtmRight *string
	// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter.
	// When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The
	// list of supported categories can be discovered using [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
	// * **categorySet=7315** (Search Points of Interest from category Restaurant)
	// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant)
	CategorySet []int32
	// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types.
	// Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
	// Available connector types are:
	// * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard
	// Voltage and standard Amperage. See also: [Plug & socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
	// * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the
	// standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
	// * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
	// * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
	// * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination
	// with up to 240V single phase or up to 420V three phase infrastructure.
	// * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is
	// also known as the TEPCO's connector. It supports fast DC charging.
	// * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination
	// of the standard, the color and the fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
	// * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
	// * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla's proprietary connector, sometimes
	// referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
	// Usage examples:
	// connectorSet=IEC62196Type2CableAttached
	// connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
	ConnectorSet []ConnectorSet
	// Comma separated string of country codes, e.g. FR,ES. This will limit the search to the specified countries
	CountrySet []string
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **POI** = Points of Interest
	// Value should be **POI** or **None** to disable extended postal codes.
	// By default extended postal codes are included.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Latitude where results should be biased. E.g. 37.337
	Lat *float32
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// Longitude where results should be biased. E.g. -121.89
	Lon *float32
	// Starting offset of the returned results within the full result set. Default: 0, minimum: 0 and maximum: 1900
	Ofs *int32
	// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
	// Supported value: nextSevenDays
	OpeningHours *OpeningHours
	// The radius in meters to for the results to be constrained to the defined area
	Radius *float32
	// Top left position of the bounding box. E.g. 37.553,-122.453
	TopLeft *string
	// Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode
	Typeahead *bool
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchGetSearchPolygonOptions contains the optional parameters for the Search.GetSearchPolygon method.
type SearchGetSearchPolygonOptions struct {
}

// SearchInsideGeometryRequestBody - This type represents the request body for the Search Inside Geometry service.
type SearchInsideGeometryRequestBody struct {
	// A valid GeoJSON object. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3] for details.
	Geometry GeoJSONObjectClassification `json:"geometry,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchInsideGeometryRequestBody.
func (s SearchInsideGeometryRequestBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "geometry", s.Geometry)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SearchInsideGeometryRequestBody.
func (s *SearchInsideGeometryRequestBody) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "geometry":
			s.Geometry, err = unmarshalGeoJSONObjectClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SearchPoiCategoryTreeResponse - This object is returned from a successful POI Category Tree call
type SearchPoiCategoryTreeResponse struct {
	// READ-ONLY; Categories array
	PoiCategories []*PoiCategoryResult `json:"poiCategories,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchPoiCategoryTreeResponse.
func (s SearchPoiCategoryTreeResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "poiCategories", s.PoiCategories)
	return json.Marshal(objectMap)
}

// SearchPolygonResponse - This object is returned from a successful Search Polygon call
type SearchPolygonResponse struct {
	// READ-ONLY; Results array
	AdditionalData []*SearchPolygonResult `json:"additionalData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchPolygonResponse.
func (s SearchPolygonResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalData", s.AdditionalData)
	return json.Marshal(objectMap)
}

type SearchPolygonResult struct {
	// Geometry data in GeoJSON format. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946] for details. Present only if "error" is not present.
	GeometryData GeoJSONObjectClassification `json:"geometryData,omitempty"`

	// READ-ONLY; Reason for the failure to obtain data for this provider.
	Error *string `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; ID of the returned entity
	ProviderID *string `json:"providerID,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchPolygonResult.
func (s SearchPolygonResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", s.Error)
	populate(objectMap, "geometryData", s.GeometryData)
	populate(objectMap, "providerID", s.ProviderID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SearchPolygonResult.
func (s *SearchPolygonResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &s.Error)
			delete(rawMsg, key)
		case "geometryData":
			s.GeometryData, err = unmarshalGeoJSONObjectClassification(val)
			delete(rawMsg, key)
		case "providerID":
			err = unpopulate(val, &s.ProviderID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SearchPostSearchAddressBatchSyncOptions contains the optional parameters for the Search.PostSearchAddressBatchSync method.
type SearchPostSearchAddressBatchSyncOptions struct {
	// placeholder for future optional parameters
}

// SearchPostSearchAddressReverseBatchSyncOptions contains the optional parameters for the Search.PostSearchAddressReverseBatchSync method.
type SearchPostSearchAddressReverseBatchSyncOptions struct {
	// placeholder for future optional parameters
}

// SearchPostSearchAlongRouteOptions contains the optional parameters for the Search.PostSearchAlongRoute method.
type SearchPostSearchAlongRouteOptions struct {
	// A comma-separated list of brand names which could be used to restrict the result to specific brands. Item order does not matter. When multiple brands
	// are provided, only results that belong to (at least) one of the provided list will be returned. Brands that contain a "," in their name should be put
	// into quotes.
	// Usage examples:
	// brandSet=Foo
	// brandSet=Foo,Bar
	// brandSet="A,B,C Comma",Bar
	BrandSet []string
	// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter.
	// When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The
	// list of supported categories can be discovered using [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
	// * **categorySet=7315** (Search Points of Interest from category Restaurant)
	// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant)
	CategorySet []int32
	// A comma-separated list of connector types which could be used to restrict the result to Electric Vehicle Station supporting specific connector types.
	// Item order does not matter. When multiple connector types are provided, only results that belong to (at least) one of the provided list will be returned.
	// Available connector types are:
	// * `StandardHouseholdCountrySpecific` - These are the standard household connectors for a certain region. They are all AC single phase and the standard
	// Voltage and standard Amperage. See also: [Plug & socket types - World Standards](https://www.worldstandards.eu/electricity/plugs-and-sockets).
	// * `IEC62196Type1` - Type 1 connector as defined in the IEC 62196-2 standard. Also called Yazaki after the original manufacturer or SAE J1772 after the
	// standard that first published it. Mostly used in combination with 120V single phase or up to 240V single phase infrastructure.
	// * `IEC62196Type1CCS` - Type 1 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 1 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type2CableAttached` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a cable and plug attached to the charging point.
	// * `IEC62196Type2Outlet` - Type 2 connector as defined in the IEC 62196-2 standard. Provided as a socket set into the charging point.
	// * `IEC62196Type2CCS` - Type 2 based combo connector as defined in the IEC 62196-3 standard. The connector is based on the Type 2 connector – as defined
	// in the IEC 62196-2 standard – with two additional direct current (DC) contacts to allow DC fast charging.
	// * `IEC62196Type3` - Type 3 connector as defined in the IEC 62196-2 standard. Also called Scame after the original manufacturer. Mostly used in combination
	// with up to 240V single phase or up to 420V three phase infrastructure.
	// * `Chademo` - CHAdeMO connector named after an association formed by the Tokyo Electric Power Company and industrial partners. Because of this is is
	// also known as the TEPCO's connector. It supports fast DC charging.
	// * `IEC60309AC1PhaseBlue` - Industrial Blue connector is a connector defined in the IEC 60309 standard. It is sometime referred to as by some combination
	// of the standard, the color and the fact that is a single phase connector. The connector usually has the "P+N+E, 6h" configuration.
	// * `IEC60309DCWhite` - Industrial White connector is a DC connector defined in the IEC 60309 standard.
	// * `Tesla` - The Tesla connector is the regionally specific Tesla Supercharger connector. I.e. it refers to either Tesla's proprietary connector, sometimes
	// referred to as Tesla Port mostly limited to North America or the modified Type 2 (DC over Type 2) in Europe.
	// Usage examples:
	// connectorSet=IEC62196Type2CableAttached
	// connectorSet=IEC62196Type2Outlet,IEC62196Type2CableAttached
	ConnectorSet []ConnectorSet
	// Maximum number of responses that will be returned. Default value is 10. Max value is 20
	Limit *int32
	// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
	// Supported value: nextSevenDays
	OpeningHours *OpeningHours
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchPostSearchFuzzyBatchSyncOptions contains the optional parameters for the Search.PostSearchFuzzyBatchSync method.
type SearchPostSearchFuzzyBatchSyncOptions struct {
	// placeholder for future optional parameters
}

// SearchPostSearchInsideGeometryOptions contains the optional parameters for the Search.PostSearchInsideGeometry method.
type SearchPostSearchInsideGeometryOptions struct {
	// A comma-separated list of category set IDs which could be used to restrict the result to specific Points of Interest categories. ID order does not matter.
	// When multiple category identifiers are provided, only POIs that belong to (at least) one of the categories from the provided list will be returned. The
	// list of supported categories can be discovered using [POI Categories API](https://aka.ms/AzureMapsPOICategoryTree). Usage examples:
	// * **categorySet=7315** (Search Points of Interest from category Restaurant)
	// * **categorySet=7315025,7315017** (Search Points of Interest of category either Italian or French Restaurant)
	CategorySet []int32
	// Indexes for which extended postal codes should be included in the results.
	// Available indexes are:
	// **Addr** = Address ranges
	// **Geo** = Geographies
	// **PAD** = Point Addresses
	// **POI** = Points of Interest
	// **Str** = Streets
	// **XStr** = Cross Streets (intersections)
	// Value should be a comma separated list of index types (in any order) or **None** for no indexes.
	// By default extended postal codes are included for all indexes except Geo. Extended postal code lists for geographies can be quite long so they have to
	// be explicitly requested when needed.
	// Usage examples:
	// extendedPostalCodesFor=POI
	// extendedPostalCodesFor=PAD,Addr,POI
	// extendedPostalCodesFor=None
	// Extended postal code is returned as an **extendedPostalCode** property of an address. Availability is region-dependent.
	ExtendedPostalCodesFor *string
	// A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are: Addr = Address range interpolation,
	// Geo = Geographies, PAD = Point Addresses, POI = Points of interest, Str = Streets, Xstr = Cross Streets (intersections)
	IdxSet []SearchIndexSet
	// Language in which search results should be returned. Should be one of supported IETF language tags, case insensitive. When data in specified language
	// is not available for a specific field, default language is used.
	// Please refer to [Supported Languages](https://docs.microsoft.com/en-us/azure/azure-maps/supported-languages) for details.
	Language *string
	// Maximum number of responses that will be returned. Default: 10, minimum: 1 and maximum: 100
	Limit *int32
	// Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available.
	// Supported value: nextSevenDays
	OpeningHours *OpeningHours
	// The View parameter specifies which set of geopolitically disputed content is returned via Azure Maps services, including borders and labels displayed
	// on the map. The View parameter (also referred to as “user region parameter”) will show the correct maps for that country/region. By default, the View
	// parameter is set to “Unified” even if you haven’t defined it in the request. It is your responsibility to determine the location of your users, and then
	// set the View parameter correctly for that location. Alternatively, you have the option to set ‘View=Auto’, which will return the map data based on the
	// IP address of the request. The View parameter in Azure Maps must be used in compliance with applicable laws, including those regarding mapping, of the
	// country where maps, images and other data and third party content that you are authorized to access via Azure Maps is made available. Example: view=IN.
	// Please refer to [Supported Views](https://aka.ms/AzureMapsLocalizationViews) for details and to see the available Views.
	View *string
}

// SearchResultAddress - The address of the result
type SearchResultAddress struct {
	// READ-ONLY; Bounding box coordinates.
	BoundingBox map[string]interface{} `json:"boundingBox,omitempty" azure:"ro"`

	// READ-ONLY; Building Number property
	BuildingNumber *string `json:"buildingNumber,omitempty" azure:"ro"`

	// READ-ONLY; Country property
	Country *string `json:"country,omitempty" azure:"ro"`

	// READ-ONLY; Country Code property
	CountryCode *string `json:"countryCode,omitempty" azure:"ro"`

	// READ-ONLY; Country Code ISO3 property
	CountryCodeISO3 *string `json:"countryCodeISO3,omitempty" azure:"ro"`

	// READ-ONLY; Country Secondary Subdivision property
	CountrySecondarySubdivision *string `json:"countrySecondarySubdivision,omitempty" azure:"ro"`

	// READ-ONLY; Country Subdivision property
	CountrySubdivision *string `json:"countrySubdivision,omitempty" azure:"ro"`

	// READ-ONLY; Country Subdivision Name property
	CountrySubdivisionName *string `json:"countrySubdivisionName,omitempty" azure:"ro"`

	// READ-ONLY; Country Tertiary Subdivision property
	CountryTertiarySubdivision *string `json:"countryTertiarySubdivision,omitempty" azure:"ro"`

	// READ-ONLY; Cross Street property
	CrossStreet *string `json:"crossStreet,omitempty" azure:"ro"`

	// READ-ONLY; Extended Postal Code property
	ExtendedPostalCode *string `json:"extendedPostalCode,omitempty" azure:"ro"`

	// READ-ONLY; Free form Address property
	FreeformAddress *string `json:"freeformAddress,omitempty" azure:"ro"`

	// READ-ONLY; An address component which represents the name of a geographic area or locality that groups a number of addressable objects for addressing
	// purposes, without being an administrative unit. This field is
	// used to build the freeformAddress property.
	LocalName *string `json:"localName,omitempty" azure:"ro"`

	// READ-ONLY; Municipality property
	Municipality *string `json:"municipality,omitempty" azure:"ro"`

	// READ-ONLY; Municipality Subdivision property
	MunicipalitySubdivision *string `json:"municipalitySubdivision,omitempty" azure:"ro"`

	// READ-ONLY; Postal Code property
	PostalCode *string `json:"postalCode,omitempty" azure:"ro"`

	// READ-ONLY; number of routes
	RouteNumbers []*int32 `json:"routeNumbers,omitempty" azure:"ro"`

	// READ-ONLY; Street property
	Street *string `json:"street,omitempty" azure:"ro"`

	// READ-ONLY; Street Name property
	StreetName *string `json:"streetName,omitempty" azure:"ro"`

	// READ-ONLY; Street Name and Number property
	StreetNameAndNumber *string `json:"streetNameAndNumber,omitempty" azure:"ro"`

	// READ-ONLY; Street Number property
	StreetNumber *string `json:"streetNumber,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchResultAddress.
func (s SearchResultAddress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "boundingBox", s.BoundingBox)
	populate(objectMap, "buildingNumber", s.BuildingNumber)
	populate(objectMap, "country", s.Country)
	populate(objectMap, "countryCode", s.CountryCode)
	populate(objectMap, "countryCodeISO3", s.CountryCodeISO3)
	populate(objectMap, "countrySecondarySubdivision", s.CountrySecondarySubdivision)
	populate(objectMap, "countrySubdivision", s.CountrySubdivision)
	populate(objectMap, "countrySubdivisionName", s.CountrySubdivisionName)
	populate(objectMap, "countryTertiarySubdivision", s.CountryTertiarySubdivision)
	populate(objectMap, "crossStreet", s.CrossStreet)
	populate(objectMap, "extendedPostalCode", s.ExtendedPostalCode)
	populate(objectMap, "freeformAddress", s.FreeformAddress)
	populate(objectMap, "localName", s.LocalName)
	populate(objectMap, "municipality", s.Municipality)
	populate(objectMap, "municipalitySubdivision", s.MunicipalitySubdivision)
	populate(objectMap, "postalCode", s.PostalCode)
	populate(objectMap, "routeNumbers", s.RouteNumbers)
	populate(objectMap, "street", s.Street)
	populate(objectMap, "streetName", s.StreetName)
	populate(objectMap, "streetNameAndNumber", s.StreetNameAndNumber)
	populate(objectMap, "streetNumber", s.StreetNumber)
	return json.Marshal(objectMap)
}

// SearchResultAddressRanges - Describes the address range on both sides of the street for a search result. Coordinates for the start and end locations
// of the address range are included.
type SearchResultAddressRanges struct {
	// A location represented as a latitude and longitude using short names 'lat' & 'lon'.
	From *CoordinatesPairAbbreviated `json:"from,omitempty"`

	// Address range on the left side of the street.
	RangeLeft *string `json:"rangeLeft,omitempty"`

	// Address range on the right side of the street.
	RangeRight *string `json:"rangeRight,omitempty"`

	// A location represented as a latitude and longitude using short names 'lat' & 'lon'.
	To *CoordinatesPairAbbreviated `json:"to,omitempty"`
}

// SearchResultEntryPoint - The entry point for the POI being returned.
type SearchResultEntryPoint struct {
	// A location represented as a latitude and longitude using short names 'lat' & 'lon'.
	Position *CoordinatesPairAbbreviated `json:"position,omitempty"`

	// READ-ONLY; The type of entry point. Value can be either main or minor.
	Type *EntryPointType `json:"type,omitempty" azure:"ro"`
}

// SearchResultPoi - Details of the returned POI including information such as the name, phone, url address, and classifications.
type SearchResultPoi struct {
	// Opening hours for a POI (Points of Interest).
	OpeningHours *SearchResultPoiOpeningHours `json:"openingHours,omitempty"`

	// READ-ONLY; Brands array. The name of the brand for the POI being returned.
	Brands []*SearchResultPoiBrand `json:"brands,omitempty" azure:"ro"`

	// READ-ONLY; [Deprecated] Use classifications instead. Categories array
	Categories []*string `json:"categories,omitempty" azure:"ro"`

	// READ-ONLY; The list of the most specific POI categories
	CategorySet []*SearchResultPoiCategorySet `json:"categorySet,omitempty" azure:"ro"`

	// READ-ONLY; Classification array
	Classifications []*SearchResultPoiClassification `json:"classifications,omitempty" azure:"ro"`

	// READ-ONLY; Name of the POI property
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Telephone number property
	Phone *string `json:"phone,omitempty" azure:"ro"`

	// READ-ONLY; Website URL property
	URL *string `json:"url,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchResultPoi.
func (s SearchResultPoi) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "brands", s.Brands)
	populate(objectMap, "categories", s.Categories)
	populate(objectMap, "categorySet", s.CategorySet)
	populate(objectMap, "classifications", s.Classifications)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "openingHours", s.OpeningHours)
	populate(objectMap, "phone", s.Phone)
	populate(objectMap, "url", s.URL)
	return json.Marshal(objectMap)
}

// SearchResultPoiBrand - The name of the brand for the POI being returned
type SearchResultPoiBrand struct {
	// READ-ONLY; Name of the brand
	Name *string `json:"name,omitempty" azure:"ro"`
}

// SearchResultPoiCategorySet - POI category
type SearchResultPoiCategorySet struct {
	// READ-ONLY; Category ID
	ID *int32 `json:"id,omitempty" azure:"ro"`
}

// SearchResultPoiClassification - The classification for the POI being returned
type SearchResultPoiClassification struct {
	// READ-ONLY; Code property
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Names array
	Names []*SearchResultPoiClassificationName `json:"names,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchResultPoiClassification.
func (s SearchResultPoiClassification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", s.Code)
	populate(objectMap, "names", s.Names)
	return json.Marshal(objectMap)
}

// SearchResultPoiClassificationName - Name for the classification
type SearchResultPoiClassificationName struct {
	// READ-ONLY; Name property
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Name Locale property
	NameLocale *string `json:"nameLocale,omitempty" azure:"ro"`
}

// SearchResultPoiOpeningHours - Opening hours for a POI (Points of Interest).
type SearchResultPoiOpeningHours struct {
	// READ-ONLY; Value used in the Request
	Mode *string `json:"mode,omitempty" azure:"ro"`

	// READ-ONLY; List of time ranges for the next 7 days
	TimeRanges []*SearchResultPoiOpeningHoursTimeRange `json:"timeRanges,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SearchResultPoiOpeningHours.
func (s SearchResultPoiOpeningHours) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "mode", s.Mode)
	populate(objectMap, "timeRanges", s.TimeRanges)
	return json.Marshal(objectMap)
}

// SearchResultPoiOpeningHoursTimeRange - Open time range for a day
type SearchResultPoiOpeningHoursTimeRange struct {
	// The point in the next 7 days range when a given POI is being closed, or the beginning of the range if it was closed before the range.
	EndTime *SearchResultPoiOpeningHoursTimeRangeTime `json:"endTime,omitempty"`

	// The point in the next 7 days range when a given POI is being opened, or the beginning of the range if it was opened before the range.
	StartTime *SearchResultPoiOpeningHoursTimeRangeTime `json:"startTime,omitempty"`
}

// SearchResultPoiOpeningHoursTimeRangeTime - Represents a date and time
type SearchResultPoiOpeningHoursTimeRangeTime struct {
	// READ-ONLY; Represents current day in calendar year in POI time zone.
	Date *string `json:"date,omitempty" azure:"ro"`

	// READ-ONLY; Hours are in the 24 hour format in the local time of a POI; possible values are 0 - 23.
	Hour *int32 `json:"hour,omitempty" azure:"ro"`

	// READ-ONLY; Minutes are in the local time of a POI; possible values are 0 - 59.
	Minute *int32 `json:"minute,omitempty" azure:"ro"`
}

// SearchResultViewport - The viewport that covers the result represented by the top-left and bottom-right coordinates of the viewport.
type SearchResultViewport struct {
	// A location represented as a latitude and longitude using short names 'lat' & 'lon'.
	BtmRightPoint *CoordinatesPairAbbreviated `json:"btmRightPoint,omitempty"`

	// A location represented as a latitude and longitude using short names 'lat' & 'lon'.
	TopLeftPoint *CoordinatesPairAbbreviated `json:"topLeftPoint,omitempty"`
}

// SearchSummaryGeoBias - Indication when the internal search engine has applied a geospatial bias to improve the ranking of results. In some methods, this
// can be affected by setting the lat and lon parameters where available.
// In other cases it is purely internal.
type SearchSummaryGeoBias struct {
	// READ-ONLY; Latitude property
	Lat *float32 `json:"lat,omitempty" azure:"ro"`

	// READ-ONLY; Longitude property
	Lon *float32 `json:"lon,omitempty" azure:"ro"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
