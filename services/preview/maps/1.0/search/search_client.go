// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package search

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

type searchClient struct {
	con *connection
	xmsClientID *string
}

// GetSearchAddress - Address Geocoding
// Applies to: S0 and S1 pricing tiers.
// In many cases, the complete search service might be too much, for instance if you are only interested in traditional geocoding. Search can also be accessed
// for address look up exclusively. The
// geocoding is performed by hitting the geocode endpoint with just the address or partial address in question. The geocoding search index will be queried
// for everything above the street level data. No
// POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete addresses. It will also handle everything from exact street addresses
// or street or intersections as well as
// higher level geographies such as city centers, counties, states etc.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchAddress(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchAddressOptions) (SearchCommonResponseResponse, error) {
	req, err := client.getSearchAddressCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.getSearchAddressHandleError(resp)
	}
	return client.getSearchAddressHandleResponse(resp)
}

// getSearchAddressCreateRequest creates the GetSearchAddress request.
func (client *searchClient) getSearchAddressCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchAddressOptions) (*azcore.Request, error) {
	urlPath := "/search/address/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Typeahead != nil {
		reqQP.Set("typeahead", strconv.FormatBool(*options.Typeahead))
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Ofs != nil {
		reqQP.Set("ofs", strconv.FormatInt(int64(*options.Ofs), 10))
	}
	if options != nil && options.CountrySet != nil {
		reqQP.Set("countrySet", strings.Join(options.CountrySet, ","))
	}
	if options != nil && options.Lat != nil {
		reqQP.Set("lat", strconv.FormatFloat(float64(*options.Lat), 'f', -1, 32))
	}
	if options != nil && options.Lon != nil {
		reqQP.Set("lon", strconv.FormatFloat(float64(*options.Lon), 'f', -1, 32))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.TopLeft != nil {
		reqQP.Set("topLeft", *options.TopLeft)
	}
	if options != nil && options.BtmRight != nil {
		reqQP.Set("btmRight", *options.BtmRight)
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchAddressHandleResponse handles the GetSearchAddress response.
func (client *searchClient) getSearchAddressHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// getSearchAddressHandleError handles the GetSearchAddress error response.
func (client *searchClient) getSearchAddressHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginGetSearchAddressBatch - Search Address Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress]
// using just a single API call. You can call Search
// Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync API
// up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 5 search address queries:
// { "batchItems": [ {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"}, {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"}, {"query":
// "?query=350 5th Ave, New York, NY
// 10118&limit=1"}, {"query": "?query=Pike Pl, Seattle, WA 98101&lat=47.610970&lon=-122.342469&radius=1000"}, {"query": "?query=Champ de Mars, 5 Avenue
// Anatole France, 75007 Paris, France&limit=1"} ] }
// A search address query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported search address URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters]. The string values in the search address query must be properly
// escaped (e.g. " character should be escaped with
// \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "one microsoft
// way redmond wa 98052" }, "results": [ {
// "position": { "lat": 47.63989, "lon": -122.12509 } } ] } }, { "statusCode": 200, "response": { "summary": { "query": "pike pl seattle wa 98101" }, "results":
// [ { "position": { "lat": 47.60963, "lon":
// -122.34215 } } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." } }
// } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) BeginGetSearchAddressBatch(ctx context.Context, formatParam string, options *SearchBeginGetSearchAddressBatchOptions) (SearchAddressBatchResponsePollerResponse, error) {
	resp, err := client.getSearchAddressBatch(ctx, formatParam, options)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	result := SearchAddressBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("searchClient.GetSearchAddressBatch",resp, client.con.Pipeline(), client.getSearchAddressBatchHandleError)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeGetSearchAddressBatch creates a new SearchAddressBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to SearchAddressBatchResponsePoller.ResumeToken().
func (client *searchClient) ResumeGetSearchAddressBatch(ctx context.Context, token string) (SearchAddressBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("searchClient.GetSearchAddressBatch",token, client.con.Pipeline(), client.getSearchAddressBatchHandleError)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	result := SearchAddressBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// GetSearchAddressBatch - Search Address Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress]
// using just a single API call. You can call Search
// Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync API
// up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 5 search address queries:
// { "batchItems": [ {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"}, {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"}, {"query":
// "?query=350 5th Ave, New York, NY
// 10118&limit=1"}, {"query": "?query=Pike Pl, Seattle, WA 98101&lat=47.610970&lon=-122.342469&radius=1000"}, {"query": "?query=Champ de Mars, 5 Avenue
// Anatole France, 75007 Paris, France&limit=1"} ] }
// A search address query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported search address URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters]. The string values in the search address query must be properly
// escaped (e.g. " character should be escaped with
// \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "one microsoft
// way redmond wa 98052" }, "results": [ {
// "position": { "lat": 47.63989, "lon": -122.12509 } } ] } }, { "statusCode": 200, "response": { "summary": { "query": "pike pl seattle wa 98101" }, "results":
// [ { "position": { "lat": 47.60963, "lon":
// -122.34215 } } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." } }
// } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) getSearchAddressBatch(ctx context.Context, formatParam string, options *SearchBeginGetSearchAddressBatchOptions) (*azcore.Response, error) {
	req, err := client.getSearchAddressBatchCreateRequest(ctx, formatParam, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.getSearchAddressBatchHandleError(resp)
	}
	 return resp, nil
}

// getSearchAddressBatchCreateRequest creates the GetSearchAddressBatch request.
func (client *searchClient) getSearchAddressBatchCreateRequest(ctx context.Context, formatParam string, options *SearchBeginGetSearchAddressBatchOptions) (*azcore.Request, error) {
	urlPath := "/search/address/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(formatParam))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchAddressBatchHandleError handles the GetSearchAddressBatch error response.
func (client *searchClient) getSearchAddressBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchAddressReverse - Reverse Geocode to an Address
// Applies to: S0 and S1 pricing tiers.
// There may be times when you need to translate a coordinate (example: 37.786505, -122.3862) into a human understandable street address. Most often this
// is needed in tracking applications where you
// receive a GPS feed from the device or asset and wish to know what address where the coordinate is located. This endpoint will return address information
// for a given coordinate.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchAddressReverse(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchAddressReverseOptions) (SearchAddressReverseResponseResponse, error) {
	req, err := client.getSearchAddressReverseCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SearchAddressReverseResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchAddressReverseResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchAddressReverseResponseResponse{}, client.getSearchAddressReverseHandleError(resp)
	}
	return client.getSearchAddressReverseHandleResponse(resp)
}

// getSearchAddressReverseCreateRequest creates the GetSearchAddressReverse request.
func (client *searchClient) getSearchAddressReverseCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchAddressReverseOptions) (*azcore.Request, error) {
	urlPath := "/search/address/reverse/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ReturnSpeedLimit != nil {
		reqQP.Set("returnSpeedLimit", strconv.FormatBool(*options.ReturnSpeedLimit))
	}
	if options != nil && options.Heading != nil {
		reqQP.Set("heading", strconv.FormatFloat(float64(*options.Heading), 'f', -1, 32))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.Number != nil {
		reqQP.Set("number", *options.Number)
	}
	if options != nil && options.ReturnRoadUse != nil {
		reqQP.Set("returnRoadUse", strconv.FormatBool(*options.ReturnRoadUse))
	}
	if options != nil && options.RoadUse != nil {
		reqQP.Set("roadUse", *options.RoadUse)
	}
	if options != nil && options.AllowFreeformNewline != nil {
		reqQP.Set("allowFreeformNewline", strconv.FormatBool(*options.AllowFreeformNewline))
	}
	if options != nil && options.ReturnMatchType != nil {
		reqQP.Set("returnMatchType", strconv.FormatBool(*options.ReturnMatchType))
	}
	if options != nil && options.EntityType != nil {
		reqQP.Set("entityType", string(*options.EntityType))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchAddressReverseHandleResponse handles the GetSearchAddressReverse response.
func (client *searchClient) getSearchAddressReverseHandleResponse(resp *azcore.Response) (SearchAddressReverseResponseResponse, error) {
	var val *SearchAddressReverseResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchAddressReverseResponseResponse{}, err
	}
return SearchAddressReverseResponseResponse{RawResponse: resp.Response, SearchAddressReverseResponse: val}, nil
}

// getSearchAddressReverseHandleError handles the GetSearchAddressReverse error response.
func (client *searchClient) getSearchAddressReverseHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginGetSearchAddressReverseBatch - Search Address Reverse Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address Reverse API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse]
// using just a single API call. You
// can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000
// queries and sync API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address reverse queries you will use a POST request where the request body will contain the batchItems
// array in json format and the Content-Type header
// will be set to application/json. Here's a sample request body containing 5 search address reverse queries:
// { "batchItems": [ {"query": "?query=48.858561,2.294911"}, {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"}, {"query": "?query=47.621028,-122.348170"},
// {"query":
// "?query=43.722990,10.396695"}, {"query": "?query=40.750958,-73.982336"} ] }
// A search address reverse query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept
// any of the supported search address reverse URI
// parameters [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters]. The string values in the search address reverse
// query must be properly escaped (e.g. "
// character should be escaped with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchAddressReverseResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse] - If the
// query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "queryTime": 11 }, "addresses":
// [ { "address": { "country": "France",
// "freeformAddress": "Avenue Anatole France, 75007 Paris" }, "position": "48.858490,2.294820" } ] } }, { "statusCode": 200, "response": { "summary": {
// "queryTime": 1 }, "addresses": [ { "address": {
// "country": "United States of America", "freeformAddress": "157th Pl NE, Redmond WA 98052" }, "position": "47.640470,-122.129430" } ] } }, { "statusCode":
// 400, "response": { "error": { "code": "400
// BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) BeginGetSearchAddressReverseBatch(ctx context.Context, formatParam string, options *SearchBeginGetSearchAddressReverseBatchOptions) (SearchAddressReverseBatchResponsePollerResponse, error) {
	resp, err := client.getSearchAddressReverseBatch(ctx, formatParam, options)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	result := SearchAddressReverseBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("searchClient.GetSearchAddressReverseBatch",resp, client.con.Pipeline(), client.getSearchAddressReverseBatchHandleError)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressReverseBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressReverseBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeGetSearchAddressReverseBatch creates a new SearchAddressReverseBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to SearchAddressReverseBatchResponsePoller.ResumeToken().
func (client *searchClient) ResumeGetSearchAddressReverseBatch(ctx context.Context, token string) (SearchAddressReverseBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("searchClient.GetSearchAddressReverseBatch",token, client.con.Pipeline(), client.getSearchAddressReverseBatchHandleError)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressReverseBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	result := SearchAddressReverseBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressReverseBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// GetSearchAddressReverseBatch - Search Address Reverse Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address Reverse API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse]
// using just a single API call. You
// can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000
// queries and sync API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address reverse queries you will use a POST request where the request body will contain the batchItems
// array in json format and the Content-Type header
// will be set to application/json. Here's a sample request body containing 5 search address reverse queries:
// { "batchItems": [ {"query": "?query=48.858561,2.294911"}, {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"}, {"query": "?query=47.621028,-122.348170"},
// {"query":
// "?query=43.722990,10.396695"}, {"query": "?query=40.750958,-73.982336"} ] }
// A search address reverse query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept
// any of the supported search address reverse URI
// parameters [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters]. The string values in the search address reverse
// query must be properly escaped (e.g. "
// character should be escaped with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchAddressReverseResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse] - If the
// query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "queryTime": 11 }, "addresses":
// [ { "address": { "country": "France",
// "freeformAddress": "Avenue Anatole France, 75007 Paris" }, "position": "48.858490,2.294820" } ] } }, { "statusCode": 200, "response": { "summary": {
// "queryTime": 1 }, "addresses": [ { "address": {
// "country": "United States of America", "freeformAddress": "157th Pl NE, Redmond WA 98052" }, "position": "47.640470,-122.129430" } ] } }, { "statusCode":
// 400, "response": { "error": { "code": "400
// BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) getSearchAddressReverseBatch(ctx context.Context, formatParam string, options *SearchBeginGetSearchAddressReverseBatchOptions) (*azcore.Response, error) {
	req, err := client.getSearchAddressReverseBatchCreateRequest(ctx, formatParam, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.getSearchAddressReverseBatchHandleError(resp)
	}
	 return resp, nil
}

// getSearchAddressReverseBatchCreateRequest creates the GetSearchAddressReverseBatch request.
func (client *searchClient) getSearchAddressReverseBatchCreateRequest(ctx context.Context, formatParam string, options *SearchBeginGetSearchAddressReverseBatchOptions) (*azcore.Request, error) {
	urlPath := "/search/address/reverse/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(formatParam))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchAddressReverseBatchHandleError handles the GetSearchAddressReverseBatch error response.
func (client *searchClient) getSearchAddressReverseBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchAddressReverseCrossStreet - Reverse Geocode to a Cross Street
// Applies to: S0 and S1 pricing tiers.
// There may be times when you need to translate a coordinate (example: 37.786505, -122.3862) into a human understandable cross street. Most often this
// is needed in tracking applications where you
// receive a GPS feed from the device or asset and wish to know what address where the coordinate is located. This endpoint will return cross street information
// for a given coordinate.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchAddressReverseCrossStreet(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchAddressReverseCrossStreetOptions) (SearchAddressReverseCrossStreetResponseResponse, error) {
	req, err := client.getSearchAddressReverseCrossStreetCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SearchAddressReverseCrossStreetResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchAddressReverseCrossStreetResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchAddressReverseCrossStreetResponseResponse{}, client.getSearchAddressReverseCrossStreetHandleError(resp)
	}
	return client.getSearchAddressReverseCrossStreetHandleResponse(resp)
}

// getSearchAddressReverseCrossStreetCreateRequest creates the GetSearchAddressReverseCrossStreet request.
func (client *searchClient) getSearchAddressReverseCrossStreetCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchAddressReverseCrossStreetOptions) (*azcore.Request, error) {
	urlPath := "/search/address/reverse/crossStreet/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Heading != nil {
		reqQP.Set("heading", strconv.FormatFloat(float64(*options.Heading), 'f', -1, 32))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchAddressReverseCrossStreetHandleResponse handles the GetSearchAddressReverseCrossStreet response.
func (client *searchClient) getSearchAddressReverseCrossStreetHandleResponse(resp *azcore.Response) (SearchAddressReverseCrossStreetResponseResponse, error) {
	var val *SearchAddressReverseCrossStreetResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchAddressReverseCrossStreetResponseResponse{}, err
	}
return SearchAddressReverseCrossStreetResponseResponse{RawResponse: resp.Response, SearchAddressReverseCrossStreetResponse: val}, nil
}

// getSearchAddressReverseCrossStreetHandleError handles the GetSearchAddressReverseCrossStreet error response.
func (client *searchClient) getSearchAddressReverseCrossStreetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchAddressStructured - Structured Address Geocoding
// Applies to: S0 and S1 pricing tiers.
// Azure Address Geocoding can also be accessed for structured address look up exclusively. The geocoding search index will be queried for everything above
// the street level data. No POIs will be
// returned. Note that the geocoder is very tolerant of typos and incomplete addresses. It will also handle everything from exact street addresses or street
// or intersections as well as higher level
// geographies such as city centers, counties, states etc.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchAddressStructured(ctx context.Context, formatParam TextFormat, options *SearchGetSearchAddressStructuredOptions) (SearchCommonResponseResponse, error) {
	req, err := client.getSearchAddressStructuredCreateRequest(ctx, formatParam, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.getSearchAddressStructuredHandleError(resp)
	}
	return client.getSearchAddressStructuredHandleResponse(resp)
}

// getSearchAddressStructuredCreateRequest creates the GetSearchAddressStructured request.
func (client *searchClient) getSearchAddressStructuredCreateRequest(ctx context.Context, formatParam TextFormat, options *SearchGetSearchAddressStructuredOptions) (*azcore.Request, error) {
	urlPath := "/search/address/structured/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.CountryCode != nil {
		reqQP.Set("countryCode", *options.CountryCode)
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Ofs != nil {
		reqQP.Set("ofs", strconv.FormatInt(int64(*options.Ofs), 10))
	}
	if options != nil && options.StreetNumber != nil {
		reqQP.Set("streetNumber", *options.StreetNumber)
	}
	if options != nil && options.StreetName != nil {
		reqQP.Set("streetName", *options.StreetName)
	}
	if options != nil && options.CrossStreet != nil {
		reqQP.Set("crossStreet", *options.CrossStreet)
	}
	if options != nil && options.Municipality != nil {
		reqQP.Set("municipality", *options.Municipality)
	}
	if options != nil && options.MunicipalitySubdivision != nil {
		reqQP.Set("municipalitySubdivision", *options.MunicipalitySubdivision)
	}
	if options != nil && options.CountryTertiarySubdivision != nil {
		reqQP.Set("countryTertiarySubdivision", *options.CountryTertiarySubdivision)
	}
	if options != nil && options.CountrySecondarySubdivision != nil {
		reqQP.Set("countrySecondarySubdivision", *options.CountrySecondarySubdivision)
	}
	if options != nil && options.CountrySubdivision != nil {
		reqQP.Set("countrySubdivision", *options.CountrySubdivision)
	}
	if options != nil && options.PostalCode != nil {
		reqQP.Set("postalCode", *options.PostalCode)
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchAddressStructuredHandleResponse handles the GetSearchAddressStructured response.
func (client *searchClient) getSearchAddressStructuredHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// getSearchAddressStructuredHandleError handles the GetSearchAddressStructured error response.
func (client *searchClient) getSearchAddressStructuredHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchFuzzy - Free Form Search
// Applies to: S0 and S1 pricing tiers.
// The basic default API is Free Form Search which handles the most fuzzy of inputs handling any combination of address or POI tokens. This search API is
// the canonical 'single line search'. The Free Form
// Search API is a seamless combination of POI search and geocoding. The API can also be weighted with a contextual position (lat./lon. pair), or fully
// constrained by a coordinate and radius, or it can
// be executed more generally without any geo biasing anchor point.
// We strongly advise you to use the 'countrySet' parameter to specify only the countries for which your application needs coverage, as the default behavior
// will be to search the entire world,
// potentially returning unnecessary results.
// E.g.: countrySet=US,FR
// Please see Search Coverage [https://docs.microsoft.com/azure/location-based-services/geocoding-coverage] for a complete list of all the supported countries.
// Most Search queries default to maxFuzzyLevel=2 to gain performance and also reduce unusual results. This new default can be overridden as needed per
// request by passing in the query param maxFuzzyLevel
// =3 or 4.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchFuzzy(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchFuzzyOptions) (SearchCommonResponseResponse, error) {
	req, err := client.getSearchFuzzyCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.getSearchFuzzyHandleError(resp)
	}
	return client.getSearchFuzzyHandleResponse(resp)
}

// getSearchFuzzyCreateRequest creates the GetSearchFuzzy request.
func (client *searchClient) getSearchFuzzyCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchFuzzyOptions) (*azcore.Request, error) {
	urlPath := "/search/fuzzy/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Typeahead != nil {
		reqQP.Set("typeahead", strconv.FormatBool(*options.Typeahead))
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Ofs != nil {
		reqQP.Set("ofs", strconv.FormatInt(int64(*options.Ofs), 10))
	}
	if options != nil && options.CategorySet != nil {
		reqQP.Set("categorySet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.CategorySet), "[]")), ","))
	}
	if options != nil && options.CountrySet != nil {
		reqQP.Set("countrySet", strings.Join(options.CountrySet, ","))
	}
	if options != nil && options.Lat != nil {
		reqQP.Set("lat", strconv.FormatFloat(float64(*options.Lat), 'f', -1, 32))
	}
	if options != nil && options.Lon != nil {
		reqQP.Set("lon", strconv.FormatFloat(float64(*options.Lon), 'f', -1, 32))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.TopLeft != nil {
		reqQP.Set("topLeft", *options.TopLeft)
	}
	if options != nil && options.BtmRight != nil {
		reqQP.Set("btmRight", *options.BtmRight)
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.MinFuzzyLevel != nil {
		reqQP.Set("minFuzzyLevel", strconv.FormatInt(int64(*options.MinFuzzyLevel), 10))
	}
	if options != nil && options.MaxFuzzyLevel != nil {
		reqQP.Set("maxFuzzyLevel", strconv.FormatInt(int64(*options.MaxFuzzyLevel), 10))
	}
	if options != nil && options.IdxSet != nil {
		reqQP.Set("idxSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.IdxSet), "[]")), ","))
	}
	if options != nil && options.BrandSet != nil {
		reqQP.Set("brandSet", strings.Join(options.BrandSet, ","))
	}
	if options != nil && options.ConnectorSet != nil {
		reqQP.Set("connectorSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ConnectorSet), "[]")), ","))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	if options != nil && options.OpeningHours != nil {
		reqQP.Set("openingHours", string(*options.OpeningHours))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchFuzzyHandleResponse handles the GetSearchFuzzy response.
func (client *searchClient) getSearchFuzzyHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// getSearchFuzzyHandleError handles the GetSearchFuzzy error response.
func (client *searchClient) getSearchFuzzyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginGetSearchFuzzyBatch - Search Fuzzy Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Fuzzy API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy] using
// just a single API call. You can call Search
// Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search fuzzy queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be set
// to application/json. Here's a sample request body containing 5 search fuzzy queries:
// { "batchItems": [ {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"}, {"query": "?query=Statue Of Liberty&limit=2"}, {"query":
// "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"}, {"query": "?query=Space Needle"}, {"query": "?query=pizza&limit=10"} ] }
// A search fuzzy query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of the
// supported search fuzzy URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters]. The string values in the search fuzzy query must be properly escaped
// (e.g. " character should be escaped with \ )
// and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "atm" }, "results":
// [ { "type": "POI", "poi": { "name": "ATM at
// Wells Fargo" }, "address": { "country": "United States Of America", "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052" } } ] } }, { "statusCode":
// 200, "response": { "summary": { "query":
// "statue of liberty" }, "results": [ { "type": "POI", "poi": { "name": "Statue of Liberty" }, "address": { "country": "United States Of America", "freeformAddress":
// "New York, NY 10004" } } ] } }, {
// "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are
// mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) BeginGetSearchFuzzyBatch(ctx context.Context, formatParam string, options *SearchBeginGetSearchFuzzyBatchOptions) (SearchFuzzyBatchResponsePollerResponse, error) {
	resp, err := client.getSearchFuzzyBatch(ctx, formatParam, options)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	result := SearchFuzzyBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("searchClient.GetSearchFuzzyBatch",resp, client.con.Pipeline(), client.getSearchFuzzyBatchHandleError)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	poller := &searchFuzzyBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchFuzzyBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeGetSearchFuzzyBatch creates a new SearchFuzzyBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to SearchFuzzyBatchResponsePoller.ResumeToken().
func (client *searchClient) ResumeGetSearchFuzzyBatch(ctx context.Context, token string) (SearchFuzzyBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("searchClient.GetSearchFuzzyBatch",token, client.con.Pipeline(), client.getSearchFuzzyBatchHandleError)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	poller := &searchFuzzyBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	result := SearchFuzzyBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchFuzzyBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// GetSearchFuzzyBatch - Search Fuzzy Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Fuzzy API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy] using
// just a single API call. You can call Search
// Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search fuzzy queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be set
// to application/json. Here's a sample request body containing 5 search fuzzy queries:
// { "batchItems": [ {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"}, {"query": "?query=Statue Of Liberty&limit=2"}, {"query":
// "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"}, {"query": "?query=Space Needle"}, {"query": "?query=pizza&limit=10"} ] }
// A search fuzzy query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of the
// supported search fuzzy URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters]. The string values in the search fuzzy query must be properly escaped
// (e.g. " character should be escaped with \ )
// and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "atm" }, "results":
// [ { "type": "POI", "poi": { "name": "ATM at
// Wells Fargo" }, "address": { "country": "United States Of America", "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052" } } ] } }, { "statusCode":
// 200, "response": { "summary": { "query":
// "statue of liberty" }, "results": [ { "type": "POI", "poi": { "name": "Statue of Liberty" }, "address": { "country": "United States Of America", "freeformAddress":
// "New York, NY 10004" } } ] } }, {
// "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are
// mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) getSearchFuzzyBatch(ctx context.Context, formatParam string, options *SearchBeginGetSearchFuzzyBatchOptions) (*azcore.Response, error) {
	req, err := client.getSearchFuzzyBatchCreateRequest(ctx, formatParam, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.getSearchFuzzyBatchHandleError(resp)
	}
	 return resp, nil
}

// getSearchFuzzyBatchCreateRequest creates the GetSearchFuzzyBatch request.
func (client *searchClient) getSearchFuzzyBatchCreateRequest(ctx context.Context, formatParam string, options *SearchBeginGetSearchFuzzyBatchOptions) (*azcore.Request, error) {
	urlPath := "/search/fuzzy/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(formatParam))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchFuzzyBatchHandleError handles the GetSearchFuzzyBatch error response.
func (client *searchClient) getSearchFuzzyBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchNearby - Nearby Search
// Applies to: S0 and S1 pricing tiers.
// If you have a use case for only retrieving POI results around a specific location, the nearby search method may be the right choice. This endpoint will
// only return POI results, and does not take in a
// search query parameter.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchNearby(ctx context.Context, formatParam TextFormat, lat float32, lon float32, options *SearchGetSearchNearbyOptions) (SearchCommonResponseResponse, error) {
	req, err := client.getSearchNearbyCreateRequest(ctx, formatParam, lat, lon, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.getSearchNearbyHandleError(resp)
	}
	return client.getSearchNearbyHandleResponse(resp)
}

// getSearchNearbyCreateRequest creates the GetSearchNearby request.
func (client *searchClient) getSearchNearbyCreateRequest(ctx context.Context, formatParam TextFormat, lat float32, lon float32, options *SearchGetSearchNearbyOptions) (*azcore.Request, error) {
	urlPath := "/search/nearby/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("lat", strconv.FormatFloat(float64(lat), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(lon), 'f', -1, 32))
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Ofs != nil {
		reqQP.Set("ofs", strconv.FormatInt(int64(*options.Ofs), 10))
	}
	if options != nil && options.CategorySet != nil {
		reqQP.Set("categorySet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.CategorySet), "[]")), ","))
	}
	if options != nil && options.CountrySet != nil {
		reqQP.Set("countrySet", strings.Join(options.CountrySet, ","))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.BrandSet != nil {
		reqQP.Set("brandSet", strings.Join(options.BrandSet, ","))
	}
	if options != nil && options.ConnectorSet != nil {
		reqQP.Set("connectorSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ConnectorSet), "[]")), ","))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchNearbyHandleResponse handles the GetSearchNearby response.
func (client *searchClient) getSearchNearbyHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// getSearchNearbyHandleError handles the GetSearchNearby error response.
func (client *searchClient) getSearchNearbyHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchPOI - Get POI by Name
// Applies to: S0 and S1 pricing tiers.
// Points of Interest (POI) Search allows you to request POI results by name. Search supports additional query parameters such as language and filtering
// results by area of interest driven by country or
// bounding box. Endpoint will return only POI results matching the query string. Response includes POI details such as address, coordinate location and
// category.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchPOI(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchPOIOptions) (SearchCommonResponseResponse, error) {
	req, err := client.getSearchPOICreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.getSearchPOIHandleError(resp)
	}
	return client.getSearchPOIHandleResponse(resp)
}

// getSearchPOICreateRequest creates the GetSearchPOI request.
func (client *searchClient) getSearchPOICreateRequest(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchPOIOptions) (*azcore.Request, error) {
	urlPath := "/search/poi/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Typeahead != nil {
		reqQP.Set("typeahead", strconv.FormatBool(*options.Typeahead))
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Ofs != nil {
		reqQP.Set("ofs", strconv.FormatInt(int64(*options.Ofs), 10))
	}
	if options != nil && options.CategorySet != nil {
		reqQP.Set("categorySet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.CategorySet), "[]")), ","))
	}
	if options != nil && options.CountrySet != nil {
		reqQP.Set("countrySet", strings.Join(options.CountrySet, ","))
	}
	if options != nil && options.Lat != nil {
		reqQP.Set("lat", strconv.FormatFloat(float64(*options.Lat), 'f', -1, 32))
	}
	if options != nil && options.Lon != nil {
		reqQP.Set("lon", strconv.FormatFloat(float64(*options.Lon), 'f', -1, 32))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.TopLeft != nil {
		reqQP.Set("topLeft", *options.TopLeft)
	}
	if options != nil && options.BtmRight != nil {
		reqQP.Set("btmRight", *options.BtmRight)
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.BrandSet != nil {
		reqQP.Set("brandSet", strings.Join(options.BrandSet, ","))
	}
	if options != nil && options.ConnectorSet != nil {
		reqQP.Set("connectorSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ConnectorSet), "[]")), ","))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	if options != nil && options.OpeningHours != nil {
		reqQP.Set("openingHours", string(*options.OpeningHours))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchPOIHandleResponse handles the GetSearchPOI response.
func (client *searchClient) getSearchPOIHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// getSearchPOIHandleError handles the GetSearchPOI error response.
func (client *searchClient) getSearchPOIHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchPOICategory - Get POI by Category
// Applies to: S0 and S1 pricing tiers.
// Points of Interest (POI) Category Search allows you to request POI results from given category. Search allows to query POIs from one category at a time.
// Endpoint will only return POI results which are
// categorized as specified. Response includes POI details such as address, coordinate location and classification.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchPOICategory(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchPOICategoryOptions) (SearchCommonResponseResponse, error) {
	req, err := client.getSearchPOICategoryCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.getSearchPOICategoryHandleError(resp)
	}
	return client.getSearchPOICategoryHandleResponse(resp)
}

// getSearchPOICategoryCreateRequest creates the GetSearchPOICategory request.
func (client *searchClient) getSearchPOICategoryCreateRequest(ctx context.Context, formatParam TextFormat, query string, options *SearchGetSearchPOICategoryOptions) (*azcore.Request, error) {
	urlPath := "/search/poi/category/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Typeahead != nil {
		reqQP.Set("typeahead", strconv.FormatBool(*options.Typeahead))
	}
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Ofs != nil {
		reqQP.Set("ofs", strconv.FormatInt(int64(*options.Ofs), 10))
	}
	if options != nil && options.CategorySet != nil {
		reqQP.Set("categorySet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.CategorySet), "[]")), ","))
	}
	if options != nil && options.CountrySet != nil {
		reqQP.Set("countrySet", strings.Join(options.CountrySet, ","))
	}
	if options != nil && options.Lat != nil {
		reqQP.Set("lat", strconv.FormatFloat(float64(*options.Lat), 'f', -1, 32))
	}
	if options != nil && options.Lon != nil {
		reqQP.Set("lon", strconv.FormatFloat(float64(*options.Lon), 'f', -1, 32))
	}
	if options != nil && options.Radius != nil {
		reqQP.Set("radius", strconv.FormatFloat(float64(*options.Radius), 'f', -1, 32))
	}
	if options != nil && options.TopLeft != nil {
		reqQP.Set("topLeft", *options.TopLeft)
	}
	if options != nil && options.BtmRight != nil {
		reqQP.Set("btmRight", *options.BtmRight)
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.BrandSet != nil {
		reqQP.Set("brandSet", strings.Join(options.BrandSet, ","))
	}
	if options != nil && options.ConnectorSet != nil {
		reqQP.Set("connectorSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ConnectorSet), "[]")), ","))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	if options != nil && options.OpeningHours != nil {
		reqQP.Set("openingHours", string(*options.OpeningHours))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchPOICategoryHandleResponse handles the GetSearchPOICategory response.
func (client *searchClient) getSearchPOICategoryHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// getSearchPOICategoryHandleError handles the GetSearchPOICategory error response.
func (client *searchClient) getSearchPOICategoryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchPOICategoryTreePreview - Get POI Category Tree
// Applies to: S0 and S1 pricing tiers.
// POI Category API provides a full list of supported Points of Interest (POI) categories and subcategories together with their translations and synonyms.
// The returned content can be used to provide more
// meaningful results through other Search Service APIs, like Get Search POI [https://docs.microsoft.com/rest/api/maps/search/getsearchpoi].
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchPOICategoryTreePreview(ctx context.Context, formatParam ResponseFormat, options *SearchGetSearchPOICategoryTreePreviewOptions) (SearchPoiCategoryTreeResponseResponse, error) {
	req, err := client.getSearchPOICategoryTreePreviewCreateRequest(ctx, formatParam, options)
	if err != nil {
		return SearchPoiCategoryTreeResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchPoiCategoryTreeResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchPoiCategoryTreeResponseResponse{}, client.getSearchPOICategoryTreePreviewHandleError(resp)
	}
	return client.getSearchPOICategoryTreePreviewHandleResponse(resp)
}

// getSearchPOICategoryTreePreviewCreateRequest creates the GetSearchPOICategoryTreePreview request.
func (client *searchClient) getSearchPOICategoryTreePreviewCreateRequest(ctx context.Context, formatParam ResponseFormat, options *SearchGetSearchPOICategoryTreePreviewOptions) (*azcore.Request, error) {
	urlPath := "/search/poi/category/tree/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchPOICategoryTreePreviewHandleResponse handles the GetSearchPOICategoryTreePreview response.
func (client *searchClient) getSearchPOICategoryTreePreviewHandleResponse(resp *azcore.Response) (SearchPoiCategoryTreeResponseResponse, error) {
	var val *SearchPoiCategoryTreeResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchPoiCategoryTreeResponseResponse{}, err
	}
return SearchPoiCategoryTreeResponseResponse{RawResponse: resp.Response, SearchPoiCategoryTreeResponse: val}, nil
}

// getSearchPOICategoryTreePreviewHandleError handles the GetSearchPOICategoryTreePreview error response.
func (client *searchClient) getSearchPOICategoryTreePreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSearchPolygon - Get Polygon
// Applies to: S1 pricing tier.
// The Get Polygon service allows you to request the geometry data such as a city or country outline for a set of entities, previously retrieved from an
// Online Search request in GeoJSON format. The
// geometry ID is returned in the dataSources object under "geometry" and "id" in either a Search Address or Search Fuzzy call.
// Please note that any geometry ID retrieved from an Online Search endpoint has a limited lifetime. The client should not store geometry IDs in persistent
// storage for later referral, as the stability of
// these identifiers is not guaranteed for a long period of time. It is expected that a request to the Polygon method is made within a few minutes of the
// request to the Online Search method that provided
// the ID. The service allows for batch requests up to 20 identifiers.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) GetSearchPolygon(ctx context.Context, formatParam ResponseFormat, geometries []string, options *SearchGetSearchPolygonOptions) (SearchPolygonResponseResponse, error) {
	req, err := client.getSearchPolygonCreateRequest(ctx, formatParam, geometries, options)
	if err != nil {
		return SearchPolygonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchPolygonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchPolygonResponseResponse{}, client.getSearchPolygonHandleError(resp)
	}
	return client.getSearchPolygonHandleResponse(resp)
}

// getSearchPolygonCreateRequest creates the GetSearchPolygon request.
func (client *searchClient) getSearchPolygonCreateRequest(ctx context.Context, formatParam ResponseFormat, geometries []string, options *SearchGetSearchPolygonOptions) (*azcore.Request, error) {
	urlPath := "/search/polygon/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("geometries", strings.Join(geometries, ","))
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSearchPolygonHandleResponse handles the GetSearchPolygon response.
func (client *searchClient) getSearchPolygonHandleResponse(resp *azcore.Response) (SearchPolygonResponseResponse, error) {
	var val *SearchPolygonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchPolygonResponseResponse{}, err
	}
return SearchPolygonResponseResponse{RawResponse: resp.Response, SearchPolygonResponse: val}, nil
}

// getSearchPolygonHandleError handles the GetSearchPolygon error response.
func (client *searchClient) getSearchPolygonHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostSearchAddressBatch - Search Address Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress]
// using just a single API call. You can call Search
// Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync API
// up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 5 search address queries:
// { "batchItems": [ {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"}, {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"}, {"query":
// "?query=350 5th Ave, New York, NY
// 10118&limit=1"}, {"query": "?query=Pike Pl, Seattle, WA 98101&lat=47.610970&lon=-122.342469&radius=1000"}, {"query": "?query=Champ de Mars, 5 Avenue
// Anatole France, 75007 Paris, France&limit=1"} ] }
// A search address query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported search address URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters]. The string values in the search address query must be properly
// escaped (e.g. " character should be escaped with
// \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "one microsoft
// way redmond wa 98052" }, "results": [ {
// "position": { "lat": 47.63989, "lon": -122.12509 } } ] } }, { "statusCode": 200, "response": { "summary": { "query": "pike pl seattle wa 98101" }, "results":
// [ { "position": { "lat": 47.60963, "lon":
// -122.34215 } } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." } }
// } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) BeginPostSearchAddressBatch(ctx context.Context, formatParam ResponseFormat, searchAddressBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchAddressBatchOptions) (SearchAddressBatchResponsePollerResponse, error) {
	resp, err := client.postSearchAddressBatch(ctx, formatParam, searchAddressBatchRequestBody, options)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	result := SearchAddressBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("searchClient.PostSearchAddressBatch",resp, client.con.Pipeline(), client.postSearchAddressBatchHandleError)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostSearchAddressBatch creates a new SearchAddressBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to SearchAddressBatchResponsePoller.ResumeToken().
func (client *searchClient) ResumePostSearchAddressBatch(ctx context.Context, token string) (SearchAddressBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("searchClient.PostSearchAddressBatch",token, client.con.Pipeline(), client.postSearchAddressBatchHandleError)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SearchAddressBatchResponsePollerResponse{}, err
	}
	result := SearchAddressBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostSearchAddressBatch - Search Address Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress]
// using just a single API call. You can call Search
// Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync API
// up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 5 search address queries:
// { "batchItems": [ {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"}, {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"}, {"query":
// "?query=350 5th Ave, New York, NY
// 10118&limit=1"}, {"query": "?query=Pike Pl, Seattle, WA 98101&lat=47.610970&lon=-122.342469&radius=1000"}, {"query": "?query=Champ de Mars, 5 Avenue
// Anatole France, 75007 Paris, France&limit=1"} ] }
// A search address query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported search address URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters]. The string values in the search address query must be properly
// escaped (e.g. " character should be escaped with
// \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "one microsoft
// way redmond wa 98052" }, "results": [ {
// "position": { "lat": 47.63989, "lon": -122.12509 } } ] } }, { "statusCode": 200, "response": { "summary": { "query": "pike pl seattle wa 98101" }, "results":
// [ { "position": { "lat": 47.60963, "lon":
// -122.34215 } } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." } }
// } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) postSearchAddressBatch(ctx context.Context, formatParam ResponseFormat, searchAddressBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchAddressBatchOptions) (*azcore.Response, error) {
	req, err := client.postSearchAddressBatchCreateRequest(ctx, formatParam, searchAddressBatchRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postSearchAddressBatchHandleError(resp)
	}
	 return resp, nil
}

// postSearchAddressBatchCreateRequest creates the PostSearchAddressBatch request.
func (client *searchClient) postSearchAddressBatchCreateRequest(ctx context.Context, formatParam ResponseFormat, searchAddressBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchAddressBatchOptions) (*azcore.Request, error) {
	urlPath := "/search/address/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchAddressBatchRequestBody)
}

// postSearchAddressBatchHandleError handles the PostSearchAddressBatch error response.
func (client *searchClient) postSearchAddressBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostSearchAddressBatchSync - Search Address Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress]
// using just a single API call. You can call Search
// Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync API
// up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be
// set to application/json. Here's a sample request body containing 5 search address queries:
// { "batchItems": [ {"query": "?query=400 Broad St, Seattle, WA 98109&limit=3"}, {"query": "?query=One, Microsoft Way, Redmond, WA 98052&limit=3"}, {"query":
// "?query=350 5th Ave, New York, NY
// 10118&limit=1"}, {"query": "?query=Pike Pl, Seattle, WA 98101&lat=47.610970&lon=-122.342469&radius=1000"}, {"query": "?query=Champ de Mars, 5 Avenue
// Anatole France, 75007 Paris, France&limit=1"} ] }
// A search address query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of
// the supported search address URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#uri-parameters]. The string values in the search address query must be properly
// escaped (e.g. " character should be escaped with
// \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddress#SearchCommonResponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "one microsoft
// way redmond wa 98052" }, "results": [ {
// "position": { "lat": 47.63989, "lon": -122.12509 } } ] } }, { "statusCode": 200, "response": { "summary": { "query": "pike pl seattle wa 98101" }, "results":
// [ { "position": { "lat": 47.60963, "lon":
// -122.34215 } } ] } }, { "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly
// specified or are mutually exclusive." } }
// } ] }
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *searchClient) PostSearchAddressBatchSync(ctx context.Context, formatParam ResponseFormat, searchAddressBatchRequestBody BatchRequestBody, options *SearchPostSearchAddressBatchSyncOptions) (SearchAddressBatchResponseResponse, error) {
	req, err := client.postSearchAddressBatchSyncCreateRequest(ctx, formatParam, searchAddressBatchRequestBody, options)
	if err != nil {
		return SearchAddressBatchResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchAddressBatchResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchAddressBatchResponseResponse{}, client.postSearchAddressBatchSyncHandleError(resp)
	}
	return client.postSearchAddressBatchSyncHandleResponse(resp)
}

// postSearchAddressBatchSyncCreateRequest creates the PostSearchAddressBatchSync request.
func (client *searchClient) postSearchAddressBatchSyncCreateRequest(ctx context.Context, formatParam ResponseFormat, searchAddressBatchRequestBody BatchRequestBody, options *SearchPostSearchAddressBatchSyncOptions) (*azcore.Request, error) {
	urlPath := "/search/address/batch/sync/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchAddressBatchRequestBody)
}

// postSearchAddressBatchSyncHandleResponse handles the PostSearchAddressBatchSync response.
func (client *searchClient) postSearchAddressBatchSyncHandleResponse(resp *azcore.Response) (SearchAddressBatchResponseResponse, error) {
	var val *SearchAddressBatchResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchAddressBatchResponseResponse{}, err
	}
return SearchAddressBatchResponseResponse{RawResponse: resp.Response, SearchAddressBatchResponse: val}, nil
}

// postSearchAddressBatchSyncHandleError handles the PostSearchAddressBatchSync error response.
func (client *searchClient) postSearchAddressBatchSyncHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostSearchAddressReverseBatch - Search Address Reverse Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address Reverse API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse]
// using just a single API call. You
// can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000
// queries and sync API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address reverse queries you will use a POST request where the request body will contain the batchItems
// array in json format and the Content-Type header
// will be set to application/json. Here's a sample request body containing 5 search address reverse queries:
// { "batchItems": [ {"query": "?query=48.858561,2.294911"}, {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"}, {"query": "?query=47.621028,-122.348170"},
// {"query":
// "?query=43.722990,10.396695"}, {"query": "?query=40.750958,-73.982336"} ] }
// A search address reverse query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept
// any of the supported search address reverse URI
// parameters [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters]. The string values in the search address reverse
// query must be properly escaped (e.g. "
// character should be escaped with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchAddressReverseResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse] - If the
// query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "queryTime": 11 }, "addresses":
// [ { "address": { "country": "France",
// "freeformAddress": "Avenue Anatole France, 75007 Paris" }, "position": "48.858490,2.294820" } ] } }, { "statusCode": 200, "response": { "summary": {
// "queryTime": 1 }, "addresses": [ { "address": {
// "country": "United States of America", "freeformAddress": "157th Pl NE, Redmond WA 98052" }, "position": "47.640470,-122.129430" } ] } }, { "statusCode":
// 400, "response": { "error": { "code": "400
// BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) BeginPostSearchAddressReverseBatch(ctx context.Context, formatParam ResponseFormat, searchAddressReverseBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchAddressReverseBatchOptions) (SearchAddressReverseBatchResponsePollerResponse, error) {
	resp, err := client.postSearchAddressReverseBatch(ctx, formatParam, searchAddressReverseBatchRequestBody, options)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	result := SearchAddressReverseBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("searchClient.PostSearchAddressReverseBatch",resp, client.con.Pipeline(), client.postSearchAddressReverseBatchHandleError)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressReverseBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressReverseBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostSearchAddressReverseBatch creates a new SearchAddressReverseBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to SearchAddressReverseBatchResponsePoller.ResumeToken().
func (client *searchClient) ResumePostSearchAddressReverseBatch(ctx context.Context, token string) (SearchAddressReverseBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("searchClient.PostSearchAddressReverseBatch",token, client.con.Pipeline(), client.postSearchAddressReverseBatchHandleError)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	poller := &searchAddressReverseBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SearchAddressReverseBatchResponsePollerResponse{}, err
	}
	result := SearchAddressReverseBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchAddressReverseBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostSearchAddressReverseBatch - Search Address Reverse Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address Reverse API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse]
// using just a single API call. You
// can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000
// queries and sync API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address reverse queries you will use a POST request where the request body will contain the batchItems
// array in json format and the Content-Type header
// will be set to application/json. Here's a sample request body containing 5 search address reverse queries:
// { "batchItems": [ {"query": "?query=48.858561,2.294911"}, {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"}, {"query": "?query=47.621028,-122.348170"},
// {"query":
// "?query=43.722990,10.396695"}, {"query": "?query=40.750958,-73.982336"} ] }
// A search address reverse query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept
// any of the supported search address reverse URI
// parameters [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters]. The string values in the search address reverse
// query must be properly escaped (e.g. "
// character should be escaped with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchAddressReverseResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse] - If the
// query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "queryTime": 11 }, "addresses":
// [ { "address": { "country": "France",
// "freeformAddress": "Avenue Anatole France, 75007 Paris" }, "position": "48.858490,2.294820" } ] } }, { "statusCode": 200, "response": { "summary": {
// "queryTime": 1 }, "addresses": [ { "address": {
// "country": "United States of America", "freeformAddress": "157th Pl NE, Redmond WA 98052" }, "position": "47.640470,-122.129430" } ] } }, { "statusCode":
// 400, "response": { "error": { "code": "400
// BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) postSearchAddressReverseBatch(ctx context.Context, formatParam ResponseFormat, searchAddressReverseBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchAddressReverseBatchOptions) (*azcore.Response, error) {
	req, err := client.postSearchAddressReverseBatchCreateRequest(ctx, formatParam, searchAddressReverseBatchRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postSearchAddressReverseBatchHandleError(resp)
	}
	 return resp, nil
}

// postSearchAddressReverseBatchCreateRequest creates the PostSearchAddressReverseBatch request.
func (client *searchClient) postSearchAddressReverseBatchCreateRequest(ctx context.Context, formatParam ResponseFormat, searchAddressReverseBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchAddressReverseBatchOptions) (*azcore.Request, error) {
	urlPath := "/search/address/reverse/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchAddressReverseBatchRequestBody)
}

// postSearchAddressReverseBatchHandleError handles the PostSearchAddressReverseBatch error response.
func (client *searchClient) postSearchAddressReverseBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostSearchAddressReverseBatchSync - Search Address Reverse Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Address Reverse API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse]
// using just a single API call. You
// can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000
// queries and sync API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/address/reverse/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search address reverse queries you will use a POST request where the request body will contain the batchItems
// array in json format and the Content-Type header
// will be set to application/json. Here's a sample request body containing 5 search address reverse queries:
// { "batchItems": [ {"query": "?query=48.858561,2.294911"}, {"query": "?query=47.639765,-122.127896&radius=5000&limit=2"}, {"query": "?query=47.621028,-122.348170"},
// {"query":
// "?query=43.722990,10.396695"}, {"query": "?query=40.750958,-73.982336"} ] }
// A search address reverse query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept
// any of the supported search address reverse URI
// parameters [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#uri-parameters]. The string values in the search address reverse
// query must be properly escaped (e.g. "
// character should be escaped with \ ) and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchAddressReverseResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchaddressreverse#searchaddressreverseresponse] - If the
// query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "queryTime": 11 }, "addresses":
// [ { "address": { "country": "France",
// "freeformAddress": "Avenue Anatole France, 75007 Paris" }, "position": "48.858490,2.294820" } ] } }, { "statusCode": 200, "response": { "summary": {
// "queryTime": 1 }, "addresses": [ { "address": {
// "country": "United States of America", "freeformAddress": "157th Pl NE, Redmond WA 98052" }, "position": "47.640470,-122.129430" } ] } }, { "statusCode":
// 400, "response": { "error": { "code": "400
// BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive." } } } ] }
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *searchClient) PostSearchAddressReverseBatchSync(ctx context.Context, formatParam ResponseFormat, searchAddressReverseBatchRequestBody BatchRequestBody, options *SearchPostSearchAddressReverseBatchSyncOptions) (SearchAddressReverseBatchResponseResponse, error) {
	req, err := client.postSearchAddressReverseBatchSyncCreateRequest(ctx, formatParam, searchAddressReverseBatchRequestBody, options)
	if err != nil {
		return SearchAddressReverseBatchResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchAddressReverseBatchResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchAddressReverseBatchResponseResponse{}, client.postSearchAddressReverseBatchSyncHandleError(resp)
	}
	return client.postSearchAddressReverseBatchSyncHandleResponse(resp)
}

// postSearchAddressReverseBatchSyncCreateRequest creates the PostSearchAddressReverseBatchSync request.
func (client *searchClient) postSearchAddressReverseBatchSyncCreateRequest(ctx context.Context, formatParam ResponseFormat, searchAddressReverseBatchRequestBody BatchRequestBody, options *SearchPostSearchAddressReverseBatchSyncOptions) (*azcore.Request, error) {
	urlPath := "/search/address/reverse/batch/sync/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchAddressReverseBatchRequestBody)
}

// postSearchAddressReverseBatchSyncHandleResponse handles the PostSearchAddressReverseBatchSync response.
func (client *searchClient) postSearchAddressReverseBatchSyncHandleResponse(resp *azcore.Response) (SearchAddressReverseBatchResponseResponse, error) {
	var val *SearchAddressReverseBatchResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchAddressReverseBatchResponseResponse{}, err
	}
return SearchAddressReverseBatchResponseResponse{RawResponse: resp.Response, SearchAddressReverseBatchResponse: val}, nil
}

// postSearchAddressReverseBatchSyncHandleError handles the PostSearchAddressReverseBatchSync error response.
func (client *searchClient) postSearchAddressReverseBatchSyncHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostSearchAlongRoute - Applies to: S0 and S1 pricing tiers.
// The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified route. This search is constrained by specifying the maxDetourTime
// limiting measure.
// To send the route-points you will use a POST request where the request body will contain the route object represented as a GeoJSON LineString type and
// the Content-Type header will be set to
// application/json. Each route-point in route is represented as a GeoJSON Position type i.e. an array where the longitude value is followed by the latitude
// value and the altitude value is ignored. The
// route should contain at least 2 route-points.
// It is possible that original route will be altered, some of it's points may be skipped. If the route that passes through the found point is faster than
// the original one, the detourTime value in the
// response is negative.
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) PostSearchAlongRoute(ctx context.Context, formatParam TextFormat, query string, maxDetourTime int32, searchAlongRouteRequestBody SearchAlongRouteRequestBody, options *SearchPostSearchAlongRouteOptions) (SearchCommonResponseResponse, error) {
	req, err := client.postSearchAlongRouteCreateRequest(ctx, formatParam, query, maxDetourTime, searchAlongRouteRequestBody, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.postSearchAlongRouteHandleError(resp)
	}
	return client.postSearchAlongRouteHandleResponse(resp)
}

// postSearchAlongRouteCreateRequest creates the PostSearchAlongRoute request.
func (client *searchClient) postSearchAlongRouteCreateRequest(ctx context.Context, formatParam TextFormat, query string, maxDetourTime int32, searchAlongRouteRequestBody SearchAlongRouteRequestBody, options *SearchPostSearchAlongRouteOptions) (*azcore.Request, error) {
	urlPath := "/search/alongRoute/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.CategorySet != nil {
		reqQP.Set("categorySet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.CategorySet), "[]")), ","))
	}
	reqQP.Set("maxDetourTime", strconv.FormatInt(int64(maxDetourTime), 10))
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.BrandSet != nil {
		reqQP.Set("brandSet", strings.Join(options.BrandSet, ","))
	}
	if options != nil && options.ConnectorSet != nil {
		reqQP.Set("connectorSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.ConnectorSet), "[]")), ","))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	if options != nil && options.OpeningHours != nil {
		reqQP.Set("openingHours", string(*options.OpeningHours))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchAlongRouteRequestBody)
}

// postSearchAlongRouteHandleResponse handles the PostSearchAlongRoute response.
func (client *searchClient) postSearchAlongRouteHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// postSearchAlongRouteHandleError handles the PostSearchAlongRoute error response.
func (client *searchClient) postSearchAlongRouteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginPostSearchFuzzyBatch - Search Fuzzy Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Fuzzy API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy] using
// just a single API call. You can call Search
// Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search fuzzy queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be set
// to application/json. Here's a sample request body containing 5 search fuzzy queries:
// { "batchItems": [ {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"}, {"query": "?query=Statue Of Liberty&limit=2"}, {"query":
// "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"}, {"query": "?query=Space Needle"}, {"query": "?query=pizza&limit=10"} ] }
// A search fuzzy query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of the
// supported search fuzzy URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters]. The string values in the search fuzzy query must be properly escaped
// (e.g. " character should be escaped with \ )
// and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "atm" }, "results":
// [ { "type": "POI", "poi": { "name": "ATM at
// Wells Fargo" }, "address": { "country": "United States Of America", "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052" } } ] } }, { "statusCode":
// 200, "response": { "summary": { "query":
// "statue of liberty" }, "results": [ { "type": "POI", "poi": { "name": "Statue of Liberty" }, "address": { "country": "United States Of America", "freeformAddress":
// "New York, NY 10004" } } ] } }, {
// "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are
// mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) BeginPostSearchFuzzyBatch(ctx context.Context, formatParam ResponseFormat, searchFuzzyBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchFuzzyBatchOptions) (SearchFuzzyBatchResponsePollerResponse, error) {
	resp, err := client.postSearchFuzzyBatch(ctx, formatParam, searchFuzzyBatchRequestBody, options)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	result := SearchFuzzyBatchResponsePollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("searchClient.PostSearchFuzzyBatch",resp, client.con.Pipeline(), client.postSearchFuzzyBatchHandleError)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	poller := &searchFuzzyBatchResponsePoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchFuzzyBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumePostSearchFuzzyBatch creates a new SearchFuzzyBatchResponsePoller from the specified resume token.
// token - The value must come from a previous call to SearchFuzzyBatchResponsePoller.ResumeToken().
func (client *searchClient) ResumePostSearchFuzzyBatch(ctx context.Context, token string) (SearchFuzzyBatchResponsePollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("searchClient.PostSearchFuzzyBatch",token, client.con.Pipeline(), client.postSearchFuzzyBatchHandleError)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	poller := &searchFuzzyBatchResponsePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return SearchFuzzyBatchResponsePollerResponse{}, err
	}
	result := SearchFuzzyBatchResponsePollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (SearchFuzzyBatchResponseResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// PostSearchFuzzyBatch - Search Fuzzy Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Fuzzy API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy] using
// just a single API call. You can call Search
// Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search fuzzy queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be set
// to application/json. Here's a sample request body containing 5 search fuzzy queries:
// { "batchItems": [ {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"}, {"query": "?query=Statue Of Liberty&limit=2"}, {"query":
// "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"}, {"query": "?query=Space Needle"}, {"query": "?query=pizza&limit=10"} ] }
// A search fuzzy query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of the
// supported search fuzzy URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters]. The string values in the search fuzzy query must be properly escaped
// (e.g. " character should be escaped with \ )
// and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "atm" }, "results":
// [ { "type": "POI", "poi": { "name": "ATM at
// Wells Fargo" }, "address": { "country": "United States Of America", "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052" } } ] } }, { "statusCode":
// 200, "response": { "summary": { "query":
// "statue of liberty" }, "results": [ { "type": "POI", "poi": { "name": "Statue of Liberty" }, "address": { "country": "United States Of America", "freeformAddress":
// "New York, NY 10004" } } ] } }, {
// "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are
// mutually exclusive." } } } ] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) postSearchFuzzyBatch(ctx context.Context, formatParam ResponseFormat, searchFuzzyBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchFuzzyBatchOptions) (*azcore.Response, error) {
	req, err := client.postSearchFuzzyBatchCreateRequest(ctx, formatParam, searchFuzzyBatchRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.postSearchFuzzyBatchHandleError(resp)
	}
	 return resp, nil
}

// postSearchFuzzyBatchCreateRequest creates the PostSearchFuzzyBatch request.
func (client *searchClient) postSearchFuzzyBatchCreateRequest(ctx context.Context, formatParam ResponseFormat, searchFuzzyBatchRequestBody BatchRequestBody, options *SearchBeginPostSearchFuzzyBatchOptions) (*azcore.Request, error) {
	urlPath := "/search/fuzzy/batch/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchFuzzyBatchRequestBody)
}

// postSearchFuzzyBatchHandleError handles the PostSearchFuzzyBatch error response.
func (client *searchClient) postSearchFuzzyBatchHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostSearchFuzzyBatchSync - Search Fuzzy Batch API
// Applies to: S1 pricing tier.
// The Search Address Batch API sends batches of queries to Search Fuzzy API [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy] using
// just a single API call. You can call Search
// Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to 10,000 queries and sync
// API up to 100 queries.
// SUBMIT SYNCHRONOUS BATCH REQUEST The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond
// as soon as the batch items are calculated and
// there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer
// than 60 seconds. The number of batch items is
// limited to 100 for this API.
// POST https://atlas.microsoft.com/search/fuzzy/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
// SUBMIT ASYNCHRONOUS BATCH REQUEST The Asynchronous API is appropriate for processing big volumes of relatively complex search requests
// * It allows the retrieval of results in a separate call (multiple downloads are possible).
// * The asynchronous API is optimized for reliability and is not expected to run into a timeout.
// * The number of batch items is limited to 10,000 for this API.
// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the
// response header. This URL should be checked
// periodically until the response data or error information is available. The asynchronous responses are stored for 14 days. The redirect URL returns a
// 404 response if used after the expiration period.
// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
// 1. Client sends a Search Address Batch POST request to Azure Maps
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request has been accepted.
//
//
// HTTP Error - There was an error processing your Batch request. This could either be a 400 Bad Request or any other Error status code.
//
//
// 3. If the batch request was accepted successfully, the Location header in the response contains the URL to download the results of the batch request.
// This status URI looks like following:
//
// GET https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
//
//
// 4. Client issues a GET request on the download URL obtained in Step 3 to download the batch results.
//
//
// POST BODY FOR BATCH REQUEST To send the search fuzzy queries you will use a POST request where the request body will contain the batchItems array in
// json format and the Content-Type header will be set
// to application/json. Here's a sample request body containing 5 search fuzzy queries:
// { "batchItems": [ {"query": "?query=atm&lat=47.639769&lon=-122.128362&radius=5000&limit=5"}, {"query": "?query=Statue Of Liberty&limit=2"}, {"query":
// "?query=Starbucks&lat=47.639769&lon=-122.128362&radius=5000"}, {"query": "?query=Space Needle"}, {"query": "?query=pizza&limit=10"} ] }
// A search fuzzy query in a batch is just a partial URL without the protocol, base URL, path, api-version and subscription-key. It can accept any of the
// supported search fuzzy URI parameters
// [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#uri-parameters]. The string values in the search fuzzy query must be properly escaped
// (e.g. " character should be escaped with \ )
// and it should also be properly URL-encoded.
// The async API allows caller to batch up to 10,000 queries and sync API up to 100 queries, and the batch should contain at least 1 query.
// DOWNLOAD ASYNCHRONOUS BATCH RESULTS To download the async batch results you will issue a GET request to the batch download endpoint. This download URL
// can be obtained from the Location header of a
// successful POST batch request and looks like the following:
// https://atlas.microsoft.com/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
// Here's the typical sequence of operations for downloading the batch results:
// 1. Client sends a GET request using the download URL.
//
//
// 2. The server will respond with one of the following:
//
// > HTTP 202 Accepted - Batch request was accepted but is still being processed. Please try again in some time.
//
//
// HTTP 200 OK - Batch request successfully processed. The response body contains all the batch results.
//
//
// BATCH RESPONSE MODEL The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the
// batch has finished processing, the response body
// contains the batch response. This batch response contains a summary component that indicates the totalRequests that were part of the original batch request
// and successfulRequestsi.e. queries which
// were executed successfully. The batch response also includes a batchItems array which contains a response for each and every query in the batch request.
// The batchItems will contain the results in the
// exact same order the original queries were sent in the batch request. Each item in batchItems contains statusCode and response fields. Each response
// in batchItems is of one of the following types:
// * SearchCommonResponse [https://docs.microsoft.com/en-us/rest/api/maps/search/getsearchfuzzy#searchcommonresponse] - If the query completed successfully.
//
//
// * Error - If the query failed. The response will contain a code and a message in this case.
//
//
// Here's a sample Batch Response with 2 successful and 1 failed result:
// { "summary": { "successfulRequests": 2, "totalRequests": 3 }, "batchItems": [ { "statusCode": 200, "response": { "summary": { "query": "atm" }, "results":
// [ { "type": "POI", "poi": { "name": "ATM at
// Wells Fargo" }, "address": { "country": "United States Of America", "freeformAddress": "3240 157th Ave NE, Redmond, WA 98052" } } ] } }, { "statusCode":
// 200, "response": { "summary": { "query":
// "statue of liberty" }, "results": [ { "type": "POI", "poi": { "name": "Statue of Liberty" }, "address": { "country": "United States Of America", "freeformAddress":
// "New York, NY 10004" } } ] } }, {
// "statusCode": 400, "response": { "error": { "code": "400 BadRequest", "message": "Bad request: one or more parameters were incorrectly specified or are
// mutually exclusive." } } } ] }
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *searchClient) PostSearchFuzzyBatchSync(ctx context.Context, formatParam ResponseFormat, searchFuzzyBatchRequestBody BatchRequestBody, options *SearchPostSearchFuzzyBatchSyncOptions) (SearchFuzzyBatchResponseResponse, error) {
	req, err := client.postSearchFuzzyBatchSyncCreateRequest(ctx, formatParam, searchFuzzyBatchRequestBody, options)
	if err != nil {
		return SearchFuzzyBatchResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchFuzzyBatchResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchFuzzyBatchResponseResponse{}, client.postSearchFuzzyBatchSyncHandleError(resp)
	}
	return client.postSearchFuzzyBatchSyncHandleResponse(resp)
}

// postSearchFuzzyBatchSyncCreateRequest creates the PostSearchFuzzyBatchSync request.
func (client *searchClient) postSearchFuzzyBatchSyncCreateRequest(ctx context.Context, formatParam ResponseFormat, searchFuzzyBatchRequestBody BatchRequestBody, options *SearchPostSearchFuzzyBatchSyncOptions) (*azcore.Request, error) {
	urlPath := "/search/fuzzy/batch/sync/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchFuzzyBatchRequestBody)
}

// postSearchFuzzyBatchSyncHandleResponse handles the PostSearchFuzzyBatchSync response.
func (client *searchClient) postSearchFuzzyBatchSyncHandleResponse(resp *azcore.Response) (SearchFuzzyBatchResponseResponse, error) {
	var val *SearchFuzzyBatchResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchFuzzyBatchResponseResponse{}, err
	}
return SearchFuzzyBatchResponseResponse{RawResponse: resp.Response, SearchFuzzyBatchResponse: val}, nil
}

// postSearchFuzzyBatchSyncHandleError handles the PostSearchFuzzyBatchSync error response.
func (client *searchClient) postSearchFuzzyBatchSyncHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostSearchInsideGeometry - Applies to: S0 and S1 pricing tiers.
// The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the
// geometry/geometries will be returned.
// To send the geometry you will use a POST request where the request body will contain the geometry object represented as a GeoJSON type and the Content-Type
// header will be set to application/json. The
// geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following GeoJSON types: * GeoJSON
// FeatureCollection The geometry can be
// represented as a GeoJSON FeatureCollection object. This is the recommended option if the geometry contains both Polygons and Circles. The FeatureCollection
// can contain a max of 50 GeoJSON Feature
// objects. Each Feature object should represent either a Polygon or a Circle with the following conditions: * A Feature object for the Polygon geometry
// can have a max of 50 coordinates and it's
// properties must be empty. * A Feature object for the Circle geometry is composed of a center represented using a GeoJSON Point type and a radius value
// (in meters) which must be specified in the
// object's properties along with the subType property whose value should be 'Circle'.
// Please see the Examples section below for a sample FeatureCollection representation.
// * GeoJSON GeometryCollection The geometry can be represented as a GeoJSON GeometryCollection object. This is the recommended option if the geometry contains
// a list of Polygons only. The
// GeometryCollection can contain a max of 50 GeoJSON Polygon objects. Each Polygon object can have a max of 50 coordinates. Please see the Examples section
// below for a sample GeometryCollection
// representation.
//
//
// * GeoJSON Polygon The geometry can be represented as a GeoJSON Polygon object. This is the recommended option if the geometry contains a single Polygon.
// The Polygon object can have a max of 50
// coordinates. Please see the Examples section below for a sample Polygon representation.
//
//
// .
// If the operation fails it returns the *ErrorResponse error type.
func (client *searchClient) PostSearchInsideGeometry(ctx context.Context, formatParam TextFormat, query string, searchInsideGeometryRequestBody SearchInsideGeometryRequestBody, options *SearchPostSearchInsideGeometryOptions) (SearchCommonResponseResponse, error) {
	req, err := client.postSearchInsideGeometryCreateRequest(ctx, formatParam, query, searchInsideGeometryRequestBody, options)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SearchCommonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SearchCommonResponseResponse{}, client.postSearchInsideGeometryHandleError(resp)
	}
	return client.postSearchInsideGeometryHandleResponse(resp)
}

// postSearchInsideGeometryCreateRequest creates the PostSearchInsideGeometry request.
func (client *searchClient) postSearchInsideGeometryCreateRequest(ctx context.Context, formatParam TextFormat, query string, searchInsideGeometryRequestBody SearchInsideGeometryRequestBody, options *SearchPostSearchInsideGeometryOptions) (*azcore.Request, error) {
	urlPath := "/search/geometry/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.CategorySet != nil {
		reqQP.Set("categorySet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.CategorySet), "[]")), ","))
	}
	if options != nil && options.ExtendedPostalCodesFor != nil {
		reqQP.Set("extendedPostalCodesFor", *options.ExtendedPostalCodesFor)
	}
	if options != nil && options.IdxSet != nil {
		reqQP.Set("idxSet", strings.Join(strings.Fields(strings.Trim(fmt.Sprint(options.IdxSet), "[]")), ","))
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	if options != nil && options.OpeningHours != nil {
		reqQP.Set("openingHours", string(*options.OpeningHours))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchInsideGeometryRequestBody)
}

// postSearchInsideGeometryHandleResponse handles the PostSearchInsideGeometry response.
func (client *searchClient) postSearchInsideGeometryHandleResponse(resp *azcore.Response) (SearchCommonResponseResponse, error) {
	var val *SearchCommonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SearchCommonResponseResponse{}, err
	}
return SearchCommonResponseResponse{RawResponse: resp.Response, SearchCommonResponse: val}, nil
}

// postSearchInsideGeometryHandleError handles the PostSearchInsideGeometry error response.
func (client *searchClient) postSearchInsideGeometryHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

