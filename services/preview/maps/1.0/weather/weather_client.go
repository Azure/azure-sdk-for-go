// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package weather

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

type weatherClient struct {
	con *connection
	xmsClientID *string
}

// GetCurrentConditions - Get Current Conditions
// Applies to: S0 and S1 pricing tiers.
// Get Current Conditions service returns detailed current weather conditions such as precipitation, temperature and wind for a given coordinate location.
// Also, observations from the past 6 or 24 hours
// for a particular location can be retrieved. The basic information returned with the response include details such as observation date and time, brief
// description of the weather conditions, weather
// icon, precipitation indicator flags, and temperature. Additional details such as RealFeelâ„¢ Temperature and UV index are also returned.
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetCurrentConditions(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetCurrentConditionsOptions) (CurrentConditionsResponseResponse, error) {
	req, err := client.getCurrentConditionsCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return CurrentConditionsResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CurrentConditionsResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CurrentConditionsResponseResponse{}, client.getCurrentConditionsHandleError(resp)
	}
	return client.getCurrentConditionsHandleResponse(resp)
}

// getCurrentConditionsCreateRequest creates the GetCurrentConditions request.
func (client *weatherClient) getCurrentConditionsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetCurrentConditionsOptions) (*azcore.Request, error) {
	urlPath := "/weather/currentConditions/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Details != nil {
		reqQP.Set("details", *options.Details)
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCurrentConditionsHandleResponse handles the GetCurrentConditions response.
func (client *weatherClient) getCurrentConditionsHandleResponse(resp *azcore.Response) (CurrentConditionsResponseResponse, error) {
	var val *CurrentConditionsResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CurrentConditionsResponseResponse{}, err
	}
return CurrentConditionsResponseResponse{RawResponse: resp.Response, CurrentConditionsResponse: val}, nil
}

// getCurrentConditionsHandleError handles the GetCurrentConditions error response.
func (client *weatherClient) getCurrentConditionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyForecast - Get Daily Forecast
// Applies to: S0 and S1 pricing tiers.
// The service returns detailed weather forecast such as temperature and wind by day for the next 1, 5, 10, 15, 25, or 45 days for a given coordinate location.
// The response include details such as
// temperature, wind, precipitation, air quality, and UV index.
// In S0 you can request daily forecast for the next 1, 5, 10, and 15 days. In S1 you can also request daily forecast for the next 25 days, and 45 days.
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetDailyForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyForecastOptions) (DailyForecastResponseResponse, error) {
	req, err := client.getDailyForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return DailyForecastResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DailyForecastResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DailyForecastResponseResponse{}, client.getDailyForecastHandleError(resp)
	}
	return client.getDailyForecastHandleResponse(resp)
}

// getDailyForecastCreateRequest creates the GetDailyForecast request.
func (client *weatherClient) getDailyForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyForecastHandleResponse handles the GetDailyForecast response.
func (client *weatherClient) getDailyForecastHandleResponse(resp *azcore.Response) (DailyForecastResponseResponse, error) {
	var val *DailyForecastResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DailyForecastResponseResponse{}, err
	}
return DailyForecastResponseResponse{RawResponse: resp.Response, DailyForecastResponse: val}, nil
}

// getDailyForecastHandleError handles the GetDailyForecast error response.
func (client *weatherClient) getDailyForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetDailyIndices - Get Daily Indices
// Applies to: S0 and S1 pricing tiers.
// There may be times when you want to know if the weather conditions are optimal for a specific activity, for example, for outdoor construction, indoor
// activities, running or farming including soil
// moisture information. Azure Maps Indices API returns index values that will guide end users to plan future activities. For example, a health mobile application
// can notify users that today is good
// weather for running or for other outdoors activities like for playing golf, and retail stores can optimize their digital marketing campaigns based on
// predicted index values. The service returns in
// daily indices values for current and next 5, 10 and 15 days starting from current day.
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetDailyIndices(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyIndicesOptions) (DailyIndicesResponseResponse, error) {
	req, err := client.getDailyIndicesCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return DailyIndicesResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DailyIndicesResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DailyIndicesResponseResponse{}, client.getDailyIndicesHandleError(resp)
	}
	return client.getDailyIndicesHandleResponse(resp)
}

// getDailyIndicesCreateRequest creates the GetDailyIndices request.
func (client *weatherClient) getDailyIndicesCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetDailyIndicesOptions) (*azcore.Request, error) {
	urlPath := "/weather/indices/daily/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.IndexID != nil {
		reqQP.Set("indexId", strconv.FormatInt(int64(*options.IndexID), 10))
	}
	if options != nil && options.IndexGroupID != nil {
		reqQP.Set("indexGroupId", strconv.FormatInt(int64(*options.IndexGroupID), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getDailyIndicesHandleResponse handles the GetDailyIndices response.
func (client *weatherClient) getDailyIndicesHandleResponse(resp *azcore.Response) (DailyIndicesResponseResponse, error) {
	var val *DailyIndicesResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return DailyIndicesResponseResponse{}, err
	}
return DailyIndicesResponseResponse{RawResponse: resp.Response, DailyIndicesResponse: val}, nil
}

// getDailyIndicesHandleError handles the GetDailyIndices error response.
func (client *weatherClient) getDailyIndicesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetHourlyForecast - Get Hourly Forecast
// Applies to: S0 and S1 pricing tiers.
// Request detailed weather forecast by the hour for the next 1, 12, 24 (1 day), 72 (3 days), 120 (5 days), and 240 hours (10 days) for the given the given
// coordinate location. The API returns details
// such as temperature, humidity, wind, precipitation, and ultraviolet (UV) index.
// In S0 you can request hourly forecast for the next 1, 12, 24 hours (1 day), and 72 hours (3 days). In S1 you can also request hourly forecast for the
// next 120 (5 days) and 240 hours (10 days).
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetHourlyForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetHourlyForecastOptions) (HourlyForecastResponseResponse, error) {
	req, err := client.getHourlyForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return HourlyForecastResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return HourlyForecastResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return HourlyForecastResponseResponse{}, client.getHourlyForecastHandleError(resp)
	}
	return client.getHourlyForecastHandleResponse(resp)
}

// getHourlyForecastCreateRequest creates the GetHourlyForecast request.
func (client *weatherClient) getHourlyForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetHourlyForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/hourly/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getHourlyForecastHandleResponse handles the GetHourlyForecast response.
func (client *weatherClient) getHourlyForecastHandleResponse(resp *azcore.Response) (HourlyForecastResponseResponse, error) {
	var val *HourlyForecastResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return HourlyForecastResponseResponse{}, err
	}
return HourlyForecastResponseResponse{RawResponse: resp.Response, HourlyForecastResponse: val}, nil
}

// getHourlyForecastHandleError handles the GetHourlyForecast error response.
func (client *weatherClient) getHourlyForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMinuteForecast - Get Minute Forecast
// Applies to: S1 pricing tier.
// Get Minute Forecast service returns minute-by-minute forecasts for a given location for the next 120 minutes. Users can request weather forecasts in
// the interval of 1, 5 and 15 minutes. The response
// will include details such as the type of precipitation (including rain, snow, or a mixture of both), start time, and precipitation intensity value (dBZ).
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetMinuteForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetMinuteForecastOptions) (MinuteForecastResponseResponse, error) {
	req, err := client.getMinuteForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return MinuteForecastResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MinuteForecastResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MinuteForecastResponseResponse{}, client.getMinuteForecastHandleError(resp)
	}
	return client.getMinuteForecastHandleResponse(resp)
}

// getMinuteForecastCreateRequest creates the GetMinuteForecast request.
func (client *weatherClient) getMinuteForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetMinuteForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/minute/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Interval != nil {
		reqQP.Set("interval", strconv.FormatInt(int64(*options.Interval), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getMinuteForecastHandleResponse handles the GetMinuteForecast response.
func (client *weatherClient) getMinuteForecastHandleResponse(resp *azcore.Response) (MinuteForecastResponseResponse, error) {
	var val *MinuteForecastResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MinuteForecastResponseResponse{}, err
	}
return MinuteForecastResponseResponse{RawResponse: resp.Response, MinuteForecastResponse: val}, nil
}

// getMinuteForecastHandleError handles the GetMinuteForecast error response.
func (client *weatherClient) getMinuteForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetQuarterDayForecast - Get Quarter-Day Forecast
// Applies to: S0 and S1 pricing tiers.
// Service returns detailed weather forecast by quarter-day for the next 1, 5, 10, or 15 days for a given location. Response data is presented by quarters
// of the day - morning, afternoon, evening, and
// overnight. Details such as temperature, humidity, wind, precipitation, and UV index are returned.
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetQuarterDayForecast(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetQuarterDayForecastOptions) (QuarterDayForecastResponseResponse, error) {
	req, err := client.getQuarterDayForecastCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return QuarterDayForecastResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return QuarterDayForecastResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return QuarterDayForecastResponseResponse{}, client.getQuarterDayForecastHandleError(resp)
	}
	return client.getQuarterDayForecastHandleResponse(resp)
}

// getQuarterDayForecastCreateRequest creates the GetQuarterDayForecast request.
func (client *weatherClient) getQuarterDayForecastCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetQuarterDayForecastOptions) (*azcore.Request, error) {
	urlPath := "/weather/forecast/quarterDay/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Unit != nil {
		reqQP.Set("unit", string(*options.Unit))
	}
	if options != nil && options.Duration != nil {
		reqQP.Set("duration", strconv.FormatInt(int64(*options.Duration), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getQuarterDayForecastHandleResponse handles the GetQuarterDayForecast response.
func (client *weatherClient) getQuarterDayForecastHandleResponse(resp *azcore.Response) (QuarterDayForecastResponseResponse, error) {
	var val *QuarterDayForecastResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return QuarterDayForecastResponseResponse{}, err
	}
return QuarterDayForecastResponseResponse{RawResponse: resp.Response, QuarterDayForecastResponse: val}, nil
}

// getQuarterDayForecastHandleError handles the GetQuarterDayForecast error response.
func (client *weatherClient) getQuarterDayForecastHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetSevereWeatherAlerts - Get Severe Weather Alerts
// Applies to: S0 and S1 pricing tiers.
// Severe weather phenomenon can significantly impact our everyday life and business operations. For example, severe weather conditions such as tropical
// storms, high winds or flooding can close roads and
// force logistics companies to reroute their fleet causing delays in reaching destinations and breaking the cold chain of refrigerated food products. Azure
// Maps Severe Weather Alerts API returns the
// severe weather alerts that are available worldwide from both official Government Meteorological Agencies and leading global to regional weather alert
// providers. The service can return details such as
// alert type, category, level and detailed description about the active severe alerts for the requested location, like hurricanes, thunderstorms, lightning,
// heat waves or forest fires.
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetSevereWeatherAlerts(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetSevereWeatherAlertsOptions) (SevereWeatherAlertsResponseResponse, error) {
	req, err := client.getSevereWeatherAlertsCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return SevereWeatherAlertsResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return SevereWeatherAlertsResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return SevereWeatherAlertsResponseResponse{}, client.getSevereWeatherAlertsHandleError(resp)
	}
	return client.getSevereWeatherAlertsHandleResponse(resp)
}

// getSevereWeatherAlertsCreateRequest creates the GetSevereWeatherAlerts request.
func (client *weatherClient) getSevereWeatherAlertsCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetSevereWeatherAlertsOptions) (*azcore.Request, error) {
	urlPath := "/weather/severe/alerts/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.Details != nil {
		reqQP.Set("details", *options.Details)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getSevereWeatherAlertsHandleResponse handles the GetSevereWeatherAlerts response.
func (client *weatherClient) getSevereWeatherAlertsHandleResponse(resp *azcore.Response) (SevereWeatherAlertsResponseResponse, error) {
	var val *SevereWeatherAlertsResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return SevereWeatherAlertsResponseResponse{}, err
	}
return SevereWeatherAlertsResponseResponse{RawResponse: resp.Response, SevereWeatherAlertsResponse: val}, nil
}

// getSevereWeatherAlertsHandleError handles the GetSevereWeatherAlerts error response.
func (client *weatherClient) getSevereWeatherAlertsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetWeatherAlongRoute - Get Weather along route
// Applies to: S1 pricing tier.
// Weather along a route API returns hyper local (one kilometer or less), up-to-the-minute weather nowcasts, weather hazard assessments, and notifications
// along a route described as a sequence of
// waypoints. This includes a list of weather hazards affecting the waypoint or route, and the aggregated hazard index for each waypoint might be used to
// paint each portion of a route according to how
// safe it is for the driver. When submitting the waypoints, it is recommended to stay within, or close to, the distance that can be traveled within 120-mins
// or shortly after. Data is updated every five
// minutes.
// The service supplements Azure Maps Route Service [https://docs.microsoft.com/rest/api/maps/route] that allows you to first request a route between an
// origin and a destination and use that as an input
// for Weather Along Route endpoint.
// In addition, the service supports scenarios to generate weather notifications for waypoints that experience an increase in intensity of a weather hazard.
// For example, if the vehicle is expected to
// begin experiencing heavy rain as it reaches a waypoint, a weather notification for heavy rain will be generated for that waypoint allowing the end product
// to display a heavy rain notification before
// the driver reaches that waypoint. The trigger for when to display the notification for a waypoint could be based, for example, on a geofence
// [https://docs.microsoft.com/azure/azure-maps/tutorial-iot-hub-maps], or selectable distance to the waypoint.
// The API covers all regions of the planet except latitudes above Greenland and Antarctica.
// If the operation fails it returns the *ErrorResponse error type.
func (client *weatherClient) GetWeatherAlongRoute(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetWeatherAlongRouteOptions) (WeatherAlongRouteResponseResponse, error) {
	req, err := client.getWeatherAlongRouteCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return WeatherAlongRouteResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return WeatherAlongRouteResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return WeatherAlongRouteResponseResponse{}, client.getWeatherAlongRouteHandleError(resp)
	}
	return client.getWeatherAlongRouteHandleResponse(resp)
}

// getWeatherAlongRouteCreateRequest creates the GetWeatherAlongRoute request.
func (client *weatherClient) getWeatherAlongRouteCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *WeatherGetWeatherAlongRouteOptions) (*azcore.Request, error) {
	urlPath := "/weather/route/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getWeatherAlongRouteHandleResponse handles the GetWeatherAlongRoute response.
func (client *weatherClient) getWeatherAlongRouteHandleResponse(resp *azcore.Response) (WeatherAlongRouteResponseResponse, error) {
	var val *WeatherAlongRouteResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return WeatherAlongRouteResponseResponse{}, err
	}
return WeatherAlongRouteResponseResponse{RawResponse: resp.Response, WeatherAlongRouteResponse: val}, nil
}

// getWeatherAlongRouteHandleError handles the GetWeatherAlongRoute error response.
func (client *weatherClient) getWeatherAlongRouteHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

