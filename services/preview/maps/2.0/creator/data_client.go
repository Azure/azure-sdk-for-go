// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package creator

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
	"time"
)

type dataClient struct {
	con *connection
	xmsClientID *string
}

// DeletePreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// This API allows the caller to delete a previously uploaded data content.
// You can use this API in a scenario like removing geofences previously uploaded using the Data Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview]
// for use in our Azure
// Maps Geofencing Service [https://docs.microsoft.com/en-us/rest/api/maps/spatial]. You can also use this API to delete old/unused uploaded content and
// create space for new content.
// SUBMIT DELETE REQUEST To delete your content you will issue a DELETE request where the path will contain the udid of the data to delete.
// For example, to delete a collection of geofences previously uploaded using the Upload API, set the udid parameter in the path to the udid of the data
// received previously in the upload API response.
// DELETE DATA RESPONSE The Data Delete API returns a HTTP 204 No Content response with an empty body, if the data resource was deleted successfully.
// A HTTP 400 Bad Request error response will be returned if the data resource with the passed-in udid is not found.
// If the operation fails it returns the *ErrorResponse error type.
func (client *dataClient) DeletePreview(ctx context.Context, uniqueDataID string, options *DataDeletePreviewOptions) (*http.Response, error) {
	req, err := client.deletePreviewCreateRequest(ctx, uniqueDataID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deletePreviewHandleError(resp)
	}
	return resp.Response, nil
}

// deletePreviewCreateRequest creates the DeletePreview request.
func (client *dataClient) deletePreviewCreateRequest(ctx context.Context, uniqueDataID string, options *DataDeletePreviewOptions) (*azcore.Request, error) {
	urlPath := "/mapData/{udid}"
	if uniqueDataID == "" {
		return nil, errors.New("parameter uniqueDataID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{udid}", url.PathEscape(uniqueDataID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deletePreviewHandleError handles the DeletePreview error response.
func (client *dataClient) deletePreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DownloadPreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// This API allows the caller to download a previously uploaded data content.
// You can use this API in a scenario like downloading an existing collection of geofences uploaded previously using the Data Upload API
// [https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview] for use in our Azure Maps Geofencing Service [https://docs.microsoft.com/en-us/rest/api/maps/spatial].
// SUBMIT DOWNLOAD REQUEST To download your content you will use a GET request where the path will contain the udid of the data to download. Optionally,
// you can also pass in an Accept header to specify a
// preference for the Content-Type of the data response. For example, to download a collection of geofences previously uploaded using the Upload API, set
// the udid parameter in the path to the udid of the
// data received previously in the upload API response and set the Accept header to either one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// DOWNLOAD DATA RESPONSE The Download API will return a HTTP 200 OK response if the data resource with the passed-in udid is found, where the response
// body will contain the content of the data resource.
// A HTTP 400 Bad Request error response will be returned if the data resource with the passed-in udid is not found.
// Here's a sample response body for a simple geofence represented in GeoJSON uploaded previously using the Upload API:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *dataClient) DownloadPreview(ctx context.Context, uniqueDataID string, options *DataDownloadPreviewOptions) (DataDownloadPreviewResponse, error) {
	req, err := client.downloadPreviewCreateRequest(ctx, uniqueDataID, options)
	if err != nil {
		return DataDownloadPreviewResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return DataDownloadPreviewResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return DataDownloadPreviewResponse{}, client.downloadPreviewHandleError(resp)
	}
	return client.downloadPreviewHandleResponse(resp)
}

// downloadPreviewCreateRequest creates the DownloadPreview request.
func (client *dataClient) downloadPreviewCreateRequest(ctx context.Context, uniqueDataID string, options *DataDownloadPreviewOptions) (*azcore.Request, error) {
	urlPath := "/mapData/{udid}"
	if uniqueDataID == "" {
		return nil, errors.New("parameter uniqueDataID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{udid}", url.PathEscape(uniqueDataID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json, application/vnd.geo+json, application/octet-stream")
	return req, nil
}

// downloadPreviewHandleResponse handles the DownloadPreview response.
func (client *dataClient) downloadPreviewHandleResponse(resp *azcore.Response) (DataDownloadPreviewResponse, error) {
	result := DataDownloadPreviewResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// downloadPreviewHandleError handles the DownloadPreview error response.
func (client *dataClient) downloadPreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetOperationPreview - This path will be obtained from a call to POST /mapData. While in progress, an http200 will be returned with no extra headers -
// followed by an http200 with Resource-Location header once completed.
// If the operation fails it returns the *ErrorResponse error type.
func (client *dataClient) GetOperationPreview(ctx context.Context, operationID string, options *DataGetOperationPreviewOptions) (LongRunningOperationResultResponse, error) {
	req, err := client.getOperationPreviewCreateRequest(ctx, operationID, options)
	if err != nil {
		return LongRunningOperationResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return LongRunningOperationResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return LongRunningOperationResultResponse{}, client.getOperationPreviewHandleError(resp)
	}
	return client.getOperationPreviewHandleResponse(resp)
}

// getOperationPreviewCreateRequest creates the GetOperationPreview request.
func (client *dataClient) getOperationPreviewCreateRequest(ctx context.Context, operationID string, options *DataGetOperationPreviewOptions) (*azcore.Request, error) {
	urlPath := "/mapData/operations/{operationId}"
	if operationID == "" {
		return nil, errors.New("parameter operationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{operationId}", url.PathEscape(operationID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getOperationPreviewHandleResponse handles the GetOperationPreview response.
func (client *dataClient) getOperationPreviewHandleResponse(resp *azcore.Response) (LongRunningOperationResultResponse, error) {
	var val *LongRunningOperationResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return LongRunningOperationResultResponse{}, err
	}
	result := LongRunningOperationResultResponse{RawResponse: resp.Response, LongRunningOperationResult: val}
	if val := resp.Header.Get("Resource-Location"); val != "" {
		result.ResourceLocation = &val
	}
	return result, nil
}

// getOperationPreviewHandleError handles the GetOperationPreview error response.
func (client *dataClient) getOperationPreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListPreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// This API allows the caller to fetch a list of all content uploaded previously using the Data Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data%20v2/uploadpreview].
// SUBMIT LIST REQUEST To list all your map data content you will issue a GET request with no additional parameters.
// LIST DATA RESPONSE The Data List API returns the complete list of all data in json format. The response contains the following details for each data
// resource:
// > udid - The unique data id for the data resource.
// location - The location of the data resource. Execute a HTTP GET on this location to download the data.
// Here's a sample response returning the udid and location of 3 data resources:
// { "mapDataList": [ { "udid": "9a1288fa-1858-4a3b-b68d-13a8j5af7d7c", "location": "https://us.atlas.microsoft.com/mapData/9a1288fa-1858-4a3b-b68d-13a8j5af7d7c?api-version=1.0",
// "sizeInBytes": 29920,
// "uploadStatus": "Completed" }, { "udid": "8b1288fa-1958-4a2b-b68e-13a7i5af7d7c", "location": "https://us.atlas.microsoft.com/mapData/8b1288fa-1958-4a2b-b68e-13a7i5af7d7c?api-version=1.0",
// "sizeInBytes": 1339, "uploadStatus": "Completed" }, { "udid": "7c1288fa-2058-4a1b-b68f-13a6h5af7d7c", "location":
// "https://us.atlas.microsoft.com/mapData/7c1288fa-2058-4a1b-b68f-13a6h5af7d7c?api-version=1.0", "sizeInBytes": 1650, "uploadStatus": "Pending" }] }
// If the operation fails it returns the *ErrorResponse error type.
func (client *dataClient) ListPreview(ctx context.Context, options *DataListPreviewOptions) (MapDataListResponseResponse, error) {
	req, err := client.listPreviewCreateRequest(ctx, options)
	if err != nil {
		return MapDataListResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return MapDataListResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return MapDataListResponseResponse{}, client.listPreviewHandleError(resp)
	}
	return client.listPreviewHandleResponse(resp)
}

// listPreviewCreateRequest creates the ListPreview request.
func (client *dataClient) listPreviewCreateRequest(ctx context.Context, options *DataListPreviewOptions) (*azcore.Request, error) {
	urlPath := "/mapData"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listPreviewHandleResponse handles the ListPreview response.
func (client *dataClient) listPreviewHandleResponse(resp *azcore.Response) (MapDataListResponseResponse, error) {
	var val *MapDataListResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return MapDataListResponseResponse{}, err
	}
return MapDataListResponseResponse{RawResponse: resp.Response, MapDataListResponse: val}, nil
}

// listPreviewHandleError handles the ListPreview error response.
func (client *dataClient) listPreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginUpdatePreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// The Data Update API allows the caller to update a previously uploaded data content.
// You can use this API in a scenario like adding or removing geofences to or from an existing collection of geofences. Geofences are uploaded using the
// Data Upload API
// [https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview], for use in the Azure Maps Geofencing Service [https://docs.microsoft.com/rest/api/maps/spatial].
// Please note that the Update API will replace and override the existing data content.
// SUBMIT UPDATE REQUEST To update your content you will use a PUT request. The request body will contain the new data that will replace the existing data.
// The Content-Type header will be set to the
// content type of the data, and the path will contain the udid of the data to be update.
// For example, to update a collection of geofences that were previously uploaded using the Upload API, place the new geofence content in the request body.
// Set the udid parameter in the path to the udid
// of the data received previously in the upload API response. And set the Content-Type header to one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a center point and a radius. The sample below
// is in GeoJSON:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
// The Data Update API performs along-running request [https://aka.ms/am-creator-lrt-v2].
// DATA UPDATE LIMITS Please, be aware that currently every Azure Maps account has a data storage limit
// [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits]. Once the storage limit
// is reached, all the new upload API calls will
// return a 409 Conflict http error response. You can always use the Data Delete API [https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview]
// to delete old/unused content and create space for
// new uploads.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *dataClient) BeginUpdatePreview(ctx context.Context, uniqueDataID string, updateContent map[string]interface{}, options *DataBeginUpdatePreviewOptions) (LongRunningOperationResultPollerResponse, error) {
	resp, err := client.updatePreview(ctx, uniqueDataID, updateContent, options)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	result := LongRunningOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("dataClient.UpdatePreview",resp, client.con.Pipeline(), client.updatePreviewHandleError)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	poller := &longRunningOperationResultPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (LongRunningOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUpdatePreview creates a new LongRunningOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to LongRunningOperationResultPoller.ResumeToken().
func (client *dataClient) ResumeUpdatePreview(ctx context.Context, token string) (LongRunningOperationResultPollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("dataClient.UpdatePreview",token, client.con.Pipeline(), client.updatePreviewHandleError)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	poller := &longRunningOperationResultPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	result := LongRunningOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (LongRunningOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// UpdatePreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// The Data Update API allows the caller to update a previously uploaded data content.
// You can use this API in a scenario like adding or removing geofences to or from an existing collection of geofences. Geofences are uploaded using the
// Data Upload API
// [https://docs.microsoft.com/rest/api/maps/data%20v2/uploadpreview], for use in the Azure Maps Geofencing Service [https://docs.microsoft.com/rest/api/maps/spatial].
// Please note that the Update API will replace and override the existing data content.
// SUBMIT UPDATE REQUEST To update your content you will use a PUT request. The request body will contain the new data that will replace the existing data.
// The Content-Type header will be set to the
// content type of the data, and the path will contain the udid of the data to be update.
// For example, to update a collection of geofences that were previously uploaded using the Upload API, place the new geofence content in the request body.
// Set the udid parameter in the path to the udid
// of the data received previously in the upload API response. And set the Content-Type header to one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// Here's a sample request body for updating a simple Geofence. It's represented as a circle geometry using a center point and a radius. The sample below
// is in GeoJSON:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// The previously uploaded geofence had a radius of 100m. The above request will update it to 500m.
// The Data Update API performs along-running request [https://aka.ms/am-creator-lrt-v2].
// DATA UPDATE LIMITS Please, be aware that currently every Azure Maps account has a data storage limit
// [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits]. Once the storage limit
// is reached, all the new upload API calls will
// return a 409 Conflict http error response. You can always use the Data Delete API [https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview]
// to delete old/unused content and create space for
// new uploads.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *dataClient) updatePreview(ctx context.Context, uniqueDataID string, updateContent map[string]interface{}, options *DataBeginUpdatePreviewOptions) (*azcore.Response, error) {
	req, err := client.updatePreviewCreateRequest(ctx, uniqueDataID, updateContent, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.updatePreviewHandleError(resp)
	}
	 return resp, nil
}

// updatePreviewCreateRequest creates the UpdatePreview request.
func (client *dataClient) updatePreviewCreateRequest(ctx context.Context, uniqueDataID string, updateContent map[string]interface{}, options *DataBeginUpdatePreviewOptions) (*azcore.Request, error) {
	urlPath := "/mapData/{udid}"
	if uniqueDataID == "" {
		return nil, errors.New("parameter uniqueDataID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{udid}", url.PathEscape(uniqueDataID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	if options != nil && options.UploadDataDescription != nil {
		reqQP.Set("description", *options.UploadDataDescription)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(updateContent)
}

// updatePreviewHandleError handles the UpdatePreview error response.
func (client *dataClient) updatePreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginUploadPreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API in a scenario like uploading a collection
// of Geofences in GeoJSON format, for use in our
// Azure Maps Geofencing Service [https://docs.microsoft.com/rest/api/maps/spatial].
// SUBMIT UPLOAD REQUEST To upload your content you will use a POST request. The request body will contain the data to upload. ThedataFormat query parameter
// will contain the format for the data, the
// dataSharingLevel query parameter can contain the sharing level for the data. The Content-Type header will be set to the content type of the data.
// For example, to upload a collection of geofences in GeoJSON format, set the request body to the geofence content. Set the dataFormat query parameter
// to geojson, and set the Content-Type header to
// either one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center point and a radius. The sample below is
// in GeoJSON:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// The Data Upload API performs along-running request [https://aka.ms/am-creator-lrt-v2].
// DATA UPLOAD LIMITS Please, be aware that currently every Azure Maps account has a data storage limit
// [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits]. Once the storage limit
// is reached, all the new upload API calls will
// return a 409 Conflict http error response. You can always use the Data Delete API [https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview]
// to delete old/unused content and create space for
// new uploads.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *dataClient) BeginUploadPreview(ctx context.Context, uploadDataFormat UploadDataFormat, uploadContent azcore.ReadSeekCloser, options *DataBeginUploadPreviewOptions) (LongRunningOperationResultPollerResponse, error) {
	resp, err := client.uploadPreview(ctx, uploadDataFormat, uploadContent, options)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	result := LongRunningOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("dataClient.UploadPreview",resp, client.con.Pipeline(), client.uploadPreviewHandleError)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	poller := &longRunningOperationResultPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (LongRunningOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUploadPreview creates a new LongRunningOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to LongRunningOperationResultPoller.ResumeToken().
func (client *dataClient) ResumeUploadPreview(ctx context.Context, token string) (LongRunningOperationResultPollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("dataClient.UploadPreview",token, client.con.Pipeline(), client.uploadPreviewHandleError)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	poller := &longRunningOperationResultPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	result := LongRunningOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (LongRunningOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// UploadPreview - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API in a scenario like uploading a collection
// of Geofences in GeoJSON format, for use in our
// Azure Maps Geofencing Service [https://docs.microsoft.com/rest/api/maps/spatial].
// SUBMIT UPLOAD REQUEST To upload your content you will use a POST request. The request body will contain the data to upload. ThedataFormat query parameter
// will contain the format for the data, the
// dataSharingLevel query parameter can contain the sharing level for the data. The Content-Type header will be set to the content type of the data.
// For example, to upload a collection of geofences in GeoJSON format, set the request body to the geofence content. Set the dataFormat query parameter
// to geojson, and set the Content-Type header to
// either one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center point and a radius. The sample below is
// in GeoJSON:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// The Data Upload API performs along-running request [https://aka.ms/am-creator-lrt-v2].
// DATA UPLOAD LIMITS Please, be aware that currently every Azure Maps account has a data storage limit
// [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits]. Once the storage limit
// is reached, all the new upload API calls will
// return a 409 Conflict http error response. You can always use the Data Delete API [https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview]
// to delete old/unused content and create space for
// new uploads.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *dataClient) uploadPreview(ctx context.Context, uploadDataFormat UploadDataFormat, uploadContent azcore.ReadSeekCloser, options *DataBeginUploadPreviewOptions) (*azcore.Response, error) {
	req, err := client.uploadPreviewCreateRequest(ctx, uploadDataFormat, uploadContent, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.uploadPreviewHandleError(resp)
	}
	 return resp, nil
}

// uploadPreviewCreateRequest creates the UploadPreview request.
func (client *dataClient) uploadPreviewCreateRequest(ctx context.Context, uploadDataFormat UploadDataFormat, uploadContent azcore.ReadSeekCloser, options *DataBeginUploadPreviewOptions) (*azcore.Request, error) {
	urlPath := "/mapData"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	if options != nil && options.UploadDataDescription != nil {
		reqQP.Set("description", *options.UploadDataDescription)
	}
	reqQP.Set("dataFormat", string(uploadDataFormat))
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.SetBody(uploadContent, "application/octet-stream")
}

// uploadPreviewHandleError handles the UploadPreview error response.
func (client *dataClient) uploadPreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// BeginUploadPreviewWithAnyObject - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API in a scenario like uploading a collection
// of Geofences in GeoJSON format, for use in our
// Azure Maps Geofencing Service [https://docs.microsoft.com/rest/api/maps/spatial].
// SUBMIT UPLOAD REQUEST To upload your content you will use a POST request. The request body will contain the data to upload. ThedataFormat query parameter
// will contain the format for the data, the
// dataSharingLevel query parameter can contain the sharing level for the data. The Content-Type header will be set to the content type of the data.
// For example, to upload a collection of geofences in GeoJSON format, set the request body to the geofence content. Set the dataFormat query parameter
// to geojson, and set the Content-Type header to
// either one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center point and a radius. The sample below is
// in GeoJSON:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// The Data Upload API performs along-running request [https://aka.ms/am-creator-lrt-v2].
// DATA UPLOAD LIMITS Please, be aware that currently every Azure Maps account has a data storage limit
// [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits]. Once the storage limit
// is reached, all the new upload API calls will
// return a 409 Conflict http error response. You can always use the Data Delete API [https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview]
// to delete old/unused content and create space for
// new uploads.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *dataClient) BeginUploadPreviewWithAnyObject(ctx context.Context, uploadDataFormat UploadDataFormat, uploadContent map[string]interface{}, options *DataBeginUploadPreviewWithAnyObjectOptions) (LongRunningOperationResultPollerResponse, error) {
	resp, err := client.uploadPreviewWithAnyObject(ctx, uploadDataFormat, uploadContent, options)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	result := LongRunningOperationResultPollerResponse{
		RawResponse: resp.Response,
	}
	pt, err := azcore.NewLROPoller("dataClient.UploadPreviewWithAnyObject",resp, client.con.Pipeline(), client.uploadPreviewWithAnyObjectHandleError)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	poller := &longRunningOperationResultPoller{
		pt: pt,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (LongRunningOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// ResumeUploadPreviewWithAnyObject creates a new LongRunningOperationResultPoller from the specified resume token.
// token - The value must come from a previous call to LongRunningOperationResultPoller.ResumeToken().
func (client *dataClient) ResumeUploadPreviewWithAnyObject(ctx context.Context, token string) (LongRunningOperationResultPollerResponse, error) {
	pt, err := azcore.NewLROPollerFromResumeToken("dataClient.UploadPreviewWithAnyObject",token, client.con.Pipeline(), client.uploadPreviewWithAnyObjectHandleError)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	poller := &longRunningOperationResultPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return LongRunningOperationResultPollerResponse{}, err
	}
	result := LongRunningOperationResultPollerResponse{
		RawResponse: resp,
	}
	result.Poller = poller
	result.PollUntilDone = func(ctx context.Context, frequency time.Duration) (LongRunningOperationResultResponse, error) {
		return poller.pollUntilDone(ctx, frequency)
	}
	return result, nil
}

// UploadPreviewWithAnyObject - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// The Data Upload API allows the caller to upload data content to the Azure Maps service. You can use this API in a scenario like uploading a collection
// of Geofences in GeoJSON format, for use in our
// Azure Maps Geofencing Service [https://docs.microsoft.com/rest/api/maps/spatial].
// SUBMIT UPLOAD REQUEST To upload your content you will use a POST request. The request body will contain the data to upload. ThedataFormat query parameter
// will contain the format for the data, the
// dataSharingLevel query parameter can contain the sharing level for the data. The Content-Type header will be set to the content type of the data.
// For example, to upload a collection of geofences in GeoJSON format, set the request body to the geofence content. Set the dataFormat query parameter
// to geojson, and set the Content-Type header to
// either one of the following media types:
// * application/json
// * application/vnd.geo+json
// * application/octet-stream
// Here's a sample request body for uploading a simple Geofence represented as a circle geometry using a center point and a radius. The sample below is
// in GeoJSON:
// { "type": "FeatureCollection", "features": [{ "type": "Feature", "geometry": { "type": "Point", "coordinates": [-122.126986, 47.639754] }, "properties":
// { "geometryId": "001", "radius": 500 } }] }
// The Data Upload API performs along-running request [https://aka.ms/am-creator-lrt-v2].
// DATA UPLOAD LIMITS Please, be aware that currently every Azure Maps account has a data storage limit
// [https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/azure-subscription-service-limits#azure-maps-limits]. Once the storage limit
// is reached, all the new upload API calls will
// return a 409 Conflict http error response. You can always use the Data Delete API [https://docs.microsoft.com/rest/api/maps/data%20v2/deletepreview]
// to delete old/unused content and create space for
// new uploads.
// If the operation fails it returns one of the following error types.
// - *ErrorResponse, *ErrorResponse
func (client *dataClient) uploadPreviewWithAnyObject(ctx context.Context, uploadDataFormat UploadDataFormat, uploadContent map[string]interface{}, options *DataBeginUploadPreviewWithAnyObjectOptions) (*azcore.Response, error) {
	req, err := client.uploadPreviewWithAnyObjectCreateRequest(ctx, uploadDataFormat, uploadContent, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK, http.StatusAccepted) {
		return nil, client.uploadPreviewWithAnyObjectHandleError(resp)
	}
	 return resp, nil
}

// uploadPreviewWithAnyObjectCreateRequest creates the UploadPreviewWithAnyObject request.
func (client *dataClient) uploadPreviewWithAnyObjectCreateRequest(ctx context.Context, uploadDataFormat UploadDataFormat, uploadContent map[string]interface{}, options *DataBeginUploadPreviewWithAnyObjectOptions) (*azcore.Request, error) {
	urlPath := "/mapData"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	if options != nil && options.UploadDataDescription != nil {
		reqQP.Set("description", *options.UploadDataDescription)
	}
	reqQP.Set("dataFormat", string(uploadDataFormat))
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(uploadContent)
}

// uploadPreviewWithAnyObjectHandleError handles the UploadPreviewWithAnyObject error response.
func (client *dataClient) uploadPreviewWithAnyObjectHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

