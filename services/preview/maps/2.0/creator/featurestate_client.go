// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package creator

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strings"
)

type featureStateClient struct {
	con *connection
}

// CreateStateset - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This POST API allows the user to create a new Stateset and define stateset style using request body.
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. The Feature State API is part of
// Creator.
// The Feature State service allows the user to update the states of a feature and query them to be used in other services. The dynamic properties of a
// feature that don't belong to the dataset are
// referred to as states here.
// This Feature State service pivot on the Stateset. Like Tileset, Stateset encapsulates the storage mechanism for feature states for a dataset.
// Once the stateset is created, users can use that statesetId to post feature state updates and retrieve the current feature states. A feature can have
// only one state at a given point in time.
// Feature state is defined by the key name, value and the timestamp. When a feature state update is posted to Azure Maps, the state value gets updated
// only if the provided stateâ€™s timestamp is later
// than the stored timestamp.
// Azure Maps MapControl provides a way to use these feature states to style the features. Please refer to the State Tile documentation for more information.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) CreateStateset(ctx context.Context, datasetID string, statesetCreateRequestBody StylesObject, options *FeatureStateCreateStatesetOptions) (StatesetCreatedResponseResponse, error) {
	req, err := client.createStatesetCreateRequest(ctx, datasetID, statesetCreateRequestBody, options)
	if err != nil {
		return StatesetCreatedResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StatesetCreatedResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StatesetCreatedResponseResponse{}, client.createStatesetHandleError(resp)
	}
	return client.createStatesetHandleResponse(resp)
}

// createStatesetCreateRequest creates the CreateStateset request.
func (client *featureStateClient) createStatesetCreateRequest(ctx context.Context, datasetID string, statesetCreateRequestBody StylesObject, options *FeatureStateCreateStatesetOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets"
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	reqQP.Set("datasetId", datasetID)
	if options != nil && options.Description != nil {
		reqQP.Set("description", *options.Description)
	}
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(statesetCreateRequestBody)
}

// createStatesetHandleResponse handles the CreateStateset response.
func (client *featureStateClient) createStatesetHandleResponse(resp *azcore.Response) (StatesetCreatedResponseResponse, error) {
	var val *StatesetCreatedResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StatesetCreatedResponseResponse{}, err
	}
return StatesetCreatedResponseResponse{RawResponse: resp.Response, StatesetCreatedResponse: val}, nil
}

// createStatesetHandleError handles the CreateStateset error response.
func (client *featureStateClient) createStatesetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteState - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This API deletes the state information identified by the StateKeyName parameter for the feature identified by the FeatureId parameter in the the stateset.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) DeleteState(ctx context.Context, statesetID string, featureID string, stateKeyName string, options *FeatureStateDeleteStateOptions) (*http.Response, error) {
	req, err := client.deleteStateCreateRequest(ctx, statesetID, featureID, stateKeyName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteStateHandleError(resp)
	}
	return resp.Response, nil
}

// deleteStateCreateRequest creates the DeleteState request.
func (client *featureStateClient) deleteStateCreateRequest(ctx context.Context, statesetID string, featureID string, stateKeyName string, options *FeatureStateDeleteStateOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets/{statesetId}/featureStates/{featureId}"
	if statesetID == "" {
		return nil, errors.New("parameter statesetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{statesetId}", url.PathEscape(statesetID))
	if featureID == "" {
		return nil, errors.New("parameter featureID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{featureId}", url.PathEscape(featureID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	reqQP.Set("stateKeyName", stateKeyName)
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStateHandleError handles the DeleteState error response.
func (client *featureStateClient) deleteStateHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// DeleteStateset - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This DELETE API allows the user to delete the stateset and the associated data.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) DeleteStateset(ctx context.Context, statesetID string, options *FeatureStateDeleteStatesetOptions) (*http.Response, error) {
	req, err := client.deleteStatesetCreateRequest(ctx, statesetID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteStatesetHandleError(resp)
	}
	return resp.Response, nil
}

// deleteStatesetCreateRequest creates the DeleteStateset request.
func (client *featureStateClient) deleteStatesetCreateRequest(ctx context.Context, statesetID string, options *FeatureStateDeleteStatesetOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets/{statesetId}"
	if statesetID == "" {
		return nil, errors.New("parameter statesetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{statesetId}", url.PathEscape(statesetID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteStatesetHandleError handles the DeleteStateset error response.
func (client *featureStateClient) deleteStatesetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetStates - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This API returns the current state information associated with the given feature in the given stateset.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) GetStates(ctx context.Context, statesetID string, featureID string, options *FeatureStateGetStatesOptions) (FeatureStatesStructureResponse, error) {
	req, err := client.getStatesCreateRequest(ctx, statesetID, featureID, options)
	if err != nil {
		return FeatureStatesStructureResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FeatureStatesStructureResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FeatureStatesStructureResponse{}, client.getStatesHandleError(resp)
	}
	return client.getStatesHandleResponse(resp)
}

// getStatesCreateRequest creates the GetStates request.
func (client *featureStateClient) getStatesCreateRequest(ctx context.Context, statesetID string, featureID string, options *FeatureStateGetStatesOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets/{statesetId}/featureStates/{featureId}"
	if statesetID == "" {
		return nil, errors.New("parameter statesetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{statesetId}", url.PathEscape(statesetID))
	if featureID == "" {
		return nil, errors.New("parameter featureID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{featureId}", url.PathEscape(featureID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getStatesHandleResponse handles the GetStates response.
func (client *featureStateClient) getStatesHandleResponse(resp *azcore.Response) (FeatureStatesStructureResponse, error) {
	var val *FeatureStatesStructure
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FeatureStatesStructureResponse{}, err
	}
return FeatureStatesStructureResponse{RawResponse: resp.Response, FeatureStatesStructure: val}, nil
}

// getStatesHandleError handles the GetStates error response.
func (client *featureStateClient) getStatesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetStateset - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This GET API allows the user to get the stateset Information.
// The stateset Information includes the datasetId associated to the stateset, and the styles of that stateset.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) GetStateset(ctx context.Context, statesetID string, options *FeatureStateGetStatesetOptions) (StatesetGetResponseResponse, error) {
	req, err := client.getStatesetCreateRequest(ctx, statesetID, options)
	if err != nil {
		return StatesetGetResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return StatesetGetResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return StatesetGetResponseResponse{}, client.getStatesetHandleError(resp)
	}
	return client.getStatesetHandleResponse(resp)
}

// getStatesetCreateRequest creates the GetStateset request.
func (client *featureStateClient) getStatesetCreateRequest(ctx context.Context, statesetID string, options *FeatureStateGetStatesetOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets/{statesetId}"
	if statesetID == "" {
		return nil, errors.New("parameter statesetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{statesetId}", url.PathEscape(statesetID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getStatesetHandleResponse handles the GetStateset response.
func (client *featureStateClient) getStatesetHandleResponse(resp *azcore.Response) (StatesetGetResponseResponse, error) {
	var val *StatesetGetResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StatesetGetResponseResponse{}, err
	}
return StatesetGetResponseResponse{RawResponse: resp.Response, StatesetGetResponse: val}, nil
}

// getStatesetHandleError handles the GetStateset error response.
func (client *featureStateClient) getStatesetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// ListStateset - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This API allows the caller to fetch a list of all previously successfully created statesets.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) ListStateset(options *FeatureStateListStatesetOptions) (StatesetListResponsePager) {
	return &statesetListResponsePager{
		pipeline: client.con.Pipeline(),
		requester: func(ctx context.Context) (*azcore.Request, error) {
			return client.listStatesetCreateRequest(ctx, options)
		},
		responder: client.listStatesetHandleResponse,
		errorer:   client.listStatesetHandleError,
		advancer: func(ctx context.Context, resp StatesetListResponseResponse) (*azcore.Request, error) {
			return azcore.NewRequest(ctx, http.MethodGet, *resp.StatesetListResponse.NextLink)
		},
		statusCodes: []int{http.StatusOK},
	}
}

// listStatesetCreateRequest creates the ListStateset request.
func (client *featureStateClient) listStatesetCreateRequest(ctx context.Context, options *FeatureStateListStatesetOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// listStatesetHandleResponse handles the ListStateset response.
func (client *featureStateClient) listStatesetHandleResponse(resp *azcore.Response) (StatesetListResponseResponse, error) {
	var val *StatesetListResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return StatesetListResponseResponse{}, err
	}
return StatesetListResponseResponse{RawResponse: resp.Response, StatesetListResponse: val}, nil
}

// listStatesetHandleError handles the ListStateset error response.
func (client *featureStateClient) listStatesetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PutStateset - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This PUT API allows the user to update the stateset style rules.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) PutStateset(ctx context.Context, statesetID string, statesetStyleUpdateRequestBody StylesObject, options *FeatureStatePutStatesetOptions) (*http.Response, error) {
	req, err := client.putStatesetCreateRequest(ctx, statesetID, statesetStyleUpdateRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.putStatesetHandleError(resp)
	}
	return resp.Response, nil
}

// putStatesetCreateRequest creates the PutStateset request.
func (client *featureStateClient) putStatesetCreateRequest(ctx context.Context, statesetID string, statesetStyleUpdateRequestBody StylesObject, options *FeatureStatePutStatesetOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets/{statesetId}"
	if statesetID == "" {
		return nil, errors.New("parameter statesetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{statesetId}", url.PathEscape(statesetID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(statesetStyleUpdateRequestBody)
}

// putStatesetHandleError handles the PutStateset error response.
func (client *featureStateClient) putStatesetHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// UpdateStates - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This PUT API allows the user to update the state of the given feature in the given stateset.
// If the operation fails it returns the *ErrorResponse error type.
func (client *featureStateClient) UpdateStates(ctx context.Context, statesetID string, featureID string, featureStateUpdateRequestBody FeatureStatesStructure, options *FeatureStateUpdateStatesOptions) (*http.Response, error) {
	req, err := client.updateStatesCreateRequest(ctx, statesetID, featureID, featureStateUpdateRequestBody, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return nil, client.updateStatesHandleError(resp)
	}
	return resp.Response, nil
}

// updateStatesCreateRequest creates the UpdateStates request.
func (client *featureStateClient) updateStatesCreateRequest(ctx context.Context, statesetID string, featureID string, featureStateUpdateRequestBody FeatureStatesStructure, options *FeatureStateUpdateStatesOptions) (*azcore.Request, error) {
	urlPath := "/featureStateSets/{statesetId}/featureStates/{featureId}"
	if statesetID == "" {
		return nil, errors.New("parameter statesetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{statesetId}", url.PathEscape(statesetID))
	if featureID == "" {
		return nil, errors.New("parameter featureID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{featureId}", url.PathEscape(featureID))
	req, err := azcore.NewRequest(ctx, http.MethodPut, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(featureStateUpdateRequestBody)
}

// updateStatesHandleError handles the UpdateStates error response.
func (client *featureStateClient) updateStatesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

