// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package creator

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// AliasAssignOptions contains the optional parameters for the Alias.Assign method.
type AliasAssignOptions struct {
	// placeholder for future optional parameters
}

// AliasCreateOptions contains the optional parameters for the Alias.Create method.
type AliasCreateOptions struct {
	// The unique id that references a creator data item to be aliased.
	CreatorDataItemID *string
}

// AliasDeleteOptions contains the optional parameters for the Alias.Delete method.
type AliasDeleteOptions struct {
	// placeholder for future optional parameters
}

// AliasGetDetailsOptions contains the optional parameters for the Alias.GetDetails method.
type AliasGetDetailsOptions struct {
	// placeholder for future optional parameters
}

// AliasListItem - Detailed information for the alias.
type AliasListItem struct {
	// READ-ONLY; The id for the alias.
	AliasID *string `json:"aliasId,omitempty" azure:"ro"`

	// READ-ONLY; The created timestamp for the alias.
	CreatedTimestamp *string `json:"createdTimestamp,omitempty" azure:"ro"`

	// READ-ONLY; The id for the creator data item that this alias references (could be null if the alias has not been assigned).
	CreatorDataItemID *string `json:"creatorDataItemId,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of the last time the alias was assigned.
	LastUpdatedTimestamp *string `json:"lastUpdatedTimestamp,omitempty" azure:"ro"`
}

// AliasListOptions contains the optional parameters for the Alias.List method.
type AliasListOptions struct {
	// placeholder for future optional parameters
}

// AliasListResponse - The response model for the List API. Returns a list of all the previously created aliases.
type AliasListResponse struct {
	// READ-ONLY; A list of all the previously created aliases.
	Aliases []*AliasListItem `json:"aliases,omitempty" azure:"ro"`

	// READ-ONLY; If present, the location of the next page of data.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AliasListResponse.
func (a AliasListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aliases", a.Aliases)
	populate(objectMap, "nextLink", a.NextLink)
	return json.Marshal(objectMap)
}

// AliasesCreateResponse - The response model for the Alias Create API for the case when the alias was successfully created.
type AliasesCreateResponse struct {
	// READ-ONLY; The id for the alias.
	AliasID *string `json:"aliasId,omitempty" azure:"ro"`

	// READ-ONLY; The created timestamp for the alias.
	CreatedTimestamp *string `json:"createdTimestamp,omitempty" azure:"ro"`

	// READ-ONLY; The id for the creator data item that this alias references (could be null if the alias has not been assigned).
	CreatorDataItemID *string `json:"creatorDataItemId,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of the last time the alias was assigned.
	LastUpdatedTimestamp *string `json:"lastUpdatedTimestamp,omitempty" azure:"ro"`
}

// BooleanRuleObject - The boolean rule. The color is selected based on the logic value of the key.
type BooleanRuleObject struct {
	// The color when value is false. Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255,
	// 0)"), RGBA ("rgba(255, 255, 0, 1)"),
	// HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
	False *string `json:"false,omitempty"`

	// The color when value is true. Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255, 255,
	// 0)"), RGBA ("rgba(255, 255, 0, 1)"), HSL("hsl(100,
	// 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
	True *string `json:"true,omitempty"`
}

// BooleanTypeStyleRule - The boolean type style rule object.
type BooleanTypeStyleRule struct {
	StyleObject
	// REQUIRED; Boolean style rules.
	Rules []*BooleanRuleObject `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BooleanTypeStyleRule.
func (b BooleanTypeStyleRule) MarshalJSON() ([]byte, error) {
	objectMap := b.StyleObject.marshalInternal(StyleObjectTypeBooleanTypeStyleRule)
	populate(objectMap, "rules", b.Rules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BooleanTypeStyleRule.
func (b *BooleanTypeStyleRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rules":
			err = unpopulate(val, &b.Rules)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return b.StyleObject.unmarshalInternal(rawMsg)
}

// BufferRequestBody - An object with a FeatureCollection and a list of distances. All the feature's properties should contain geometryId, which is used
// for identifying the geometry and is case-sensitive.
type BufferRequestBody struct {
	// List of the distances to compute the buffer for, one-to-one per Feature in the collection, or one for all Features in the collection.
	Distances []*float32 `json:"distances,omitempty"`

	// A valid GeoJSON FeatureCollection object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.3] for details.
	Geometries GeoJSONObjectClassification `json:"geometries,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BufferRequestBody.
func (b BufferRequestBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "distances", b.Distances)
	populate(objectMap, "geometries", b.Geometries)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BufferRequestBody.
func (b *BufferRequestBody) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distances":
			err = unpopulate(val, &b.Distances)
			delete(rawMsg, key)
		case "geometries":
			b.Geometries, err = unmarshalGeoJSONObjectClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BufferResponse - This object is returned from a successful Spatial Buffer call.
type BufferResponse struct {
	// The FeatureCollection of buffers for the input.
	Result GeoJSONObjectClassification `json:"result,omitempty"`

	// READ-ONLY; Summary of the call.
	Summary *BufferResponseSummary `json:"summary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BufferResponse.
func (b BufferResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "result", b.Result)
	populate(objectMap, "summary", b.Summary)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BufferResponse.
func (b *BufferResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "result":
			b.Result, err = unmarshalGeoJSONObjectClassification(val)
			delete(rawMsg, key)
		case "summary":
			err = unpopulate(val, &b.Summary)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BufferResponseSummary - Summary of the call.
type BufferResponseSummary struct {
	// READ-ONLY; The information about what happened during the call.
	Information *string `json:"information,omitempty" azure:"ro"`

	// READ-ONLY; The udid for the user data if one exists
	Udid *string `json:"udid,omitempty" azure:"ro"`
}

// ClosestPointResponse - This object is returned from a successful Spatial Closest Point call
type ClosestPointResponse struct {
	// Closest Point Result Array
	Result []*ClosestPointResultEntry `json:"result,omitempty"`

	// READ-ONLY; Closest Point Summary object
	Summary *ClosestPointSummary `json:"summary,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ClosestPointResponse.
func (c ClosestPointResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "result", c.Result)
	populate(objectMap, "summary", c.Summary)
	return json.Marshal(objectMap)
}

// ClosestPointResultEntry - Closest Point Result Entry Object
type ClosestPointResultEntry struct {
	// A location represented as a latitude and longitude
	Position *SpatialCoordinate `json:"position,omitempty"`

	// READ-ONLY; The distance in meters from the source point to the closest point
	DistanceInMeters *float32 `json:"distanceInMeters,omitempty" azure:"ro"`

	// READ-ONLY; The unique id identifies a geometry
	GeometryID *string `json:"geometryId,omitempty" azure:"ro"`
}

// ClosestPointSummary - Closest Point Summary object
type ClosestPointSummary struct {
	// A location represented as a latitude and longitude
	SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`

	// READ-ONLY; Processing information
	Information *string `json:"information,omitempty" azure:"ro"`

	// READ-ONLY; A unique data id (udid) for the uploaded content
	Udid *string `json:"udid,omitempty" azure:"ro"`
}

// CollectionDefinitionResponse - collection of GeoJSON features
type CollectionDefinitionResponse struct {
	// REQUIRED; type of features returned
	FeatureTypes []*string `json:"featureTypes,omitempty"`

	// REQUIRED; type of geometry returned
	GeometryType *GeoJSONGeometryType `json:"geometryType,omitempty"`

	// REQUIRED; prefix of the collection used
	IDPrefix *string `json:"idPrefix,omitempty"`

	// REQUIRED; identifier of the collection used, for example, in URIs
	Name *string `json:"name,omitempty"`

	// describes the collection
	Description *string `json:"description,omitempty"`

	// Links to other WFS endpoints.
	Links []*WfsEndpointLink `json:"links,omitempty"`

	// attributes of the collection used
	Properties []*DefinitionProperties `json:"properties,omitempty"`

	// title of collection
	Title *string `json:"title,omitempty"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CollectionDefinitionResponse.
func (c CollectionDefinitionResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	populate(objectMap, "featureTypes", c.FeatureTypes)
	populate(objectMap, "geometryType", c.GeometryType)
	populate(objectMap, "idPrefix", c.IDPrefix)
	populate(objectMap, "links", c.Links)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "ontology", c.Ontology)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "title", c.Title)
	return json.Marshal(objectMap)
}

type CollectionInfo struct {
	// REQUIRED; Links to other WFS endpoints.
	Links []*WfsEndpointLink `json:"links,omitempty"`

	// REQUIRED; identifier of the collection used, for example, in URIs
	Name *string `json:"name,omitempty"`

	// a description of the features in the collection
	Description *string `json:"description,omitempty"`

	// human readable title of the collection
	Title *string `json:"title,omitempty"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CollectionInfo.
func (c CollectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", c.Description)
	populate(objectMap, "links", c.Links)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "ontology", c.Ontology)
	populate(objectMap, "title", c.Title)
	return json.Marshal(objectMap)
}

type CollectionsResponse struct {
	// REQUIRED; All the collections in a given dataset.
	Collections []*CollectionInfo `json:"collections,omitempty"`

	// REQUIRED; Links to other WFS endpoints.
	Links []*WfsEndpointLink `json:"links,omitempty"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CollectionsResponse.
func (c CollectionsResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "collections", c.Collections)
	populate(objectMap, "links", c.Links)
	populate(objectMap, "ontology", c.Ontology)
	return json.Marshal(objectMap)
}

type ConformanceResponse struct {
	// REQUIRED; List of requirements classes that the server conforms to.
	ConformsTo []*string `json:"conformsTo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConformanceResponse.
func (c ConformanceResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "conformsTo", c.ConformsTo)
	return json.Marshal(objectMap)
}

// ConversionBeginConvertOptions contains the optional parameters for the Conversion.BeginConvert method.
type ConversionBeginConvertOptions struct {
	// User provided description of the content being converted.
	Description *string
}

// ConversionDeleteOptions contains the optional parameters for the Conversion.Delete method.
type ConversionDeleteOptions struct {
	// placeholder for future optional parameters
}

// ConversionGetOperationOptions contains the optional parameters for the Conversion.GetOperation method.
type ConversionGetOperationOptions struct {
	// placeholder for future optional parameters
}

// ConversionGetOptions contains the optional parameters for the Conversion.Get method.
type ConversionGetOptions struct {
	// placeholder for future optional parameters
}

// ConversionListDetailInfo - Detail information for the conversion requests.
type ConversionListDetailInfo struct {
	// READ-ONLY; A unique id that represents the artifact of a successfully completed conversion process.
	ConversionID *string `json:"conversionId,omitempty" azure:"ro"`

	// READ-ONLY; The date and time of this conversion.
	Created *string `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; User provided description of the content being converted.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; A summary of feature counts in this conversion.
	FeatureCounts map[string]interface{} `json:"featureCounts,omitempty" azure:"ro"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`

	// READ-ONLY; The unique id of the content provided to create this conversion.
	Udid *string `json:"udid,omitempty" azure:"ro"`
}

// ConversionListOptions contains the optional parameters for the Conversion.List method.
type ConversionListOptions struct {
	// placeholder for future optional parameters
}

// ConversionListResponse - The response model for the Conversion List API.
type ConversionListResponse struct {
	// READ-ONLY; A list of all the previously submitted conversion requests.
	Conversions []*ConversionListDetailInfo `json:"conversions,omitempty" azure:"ro"`

	// READ-ONLY; If present, the location of the next page of data.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConversionListResponse.
func (c ConversionListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "conversions", c.Conversions)
	populate(objectMap, "nextLink", c.NextLink)
	return json.Marshal(objectMap)
}

// DataBeginUpdatePreviewOptions contains the optional parameters for the Data.BeginUpdatePreview method.
type DataBeginUpdatePreviewOptions struct {
	// The description to be given to the upload.
	UploadDataDescription *string
}

// DataBeginUploadPreviewOptions contains the optional parameters for the Data.BeginUploadPreview method.
type DataBeginUploadPreviewOptions struct {
	// The description to be given to the upload.
	UploadDataDescription *string
}

// DataBeginUploadPreviewWithAnyObjectOptions contains the optional parameters for the Data.BeginUploadPreviewWithAnyObject method.
type DataBeginUploadPreviewWithAnyObjectOptions struct {
	// The description to be given to the upload.
	UploadDataDescription *string
}

// DataDeletePreviewOptions contains the optional parameters for the Data.DeletePreview method.
type DataDeletePreviewOptions struct {
	// placeholder for future optional parameters
}

// DataDownloadPreviewOptions contains the optional parameters for the Data.DownloadPreview method.
type DataDownloadPreviewOptions struct {
	// placeholder for future optional parameters
}

// DataGetOperationPreviewOptions contains the optional parameters for the Data.GetOperationPreview method.
type DataGetOperationPreviewOptions struct {
	// placeholder for future optional parameters
}

// DataListPreviewOptions contains the optional parameters for the Data.ListPreview method.
type DataListPreviewOptions struct {
}

// DatasetBeginCreateOptions contains the optional parameters for the Dataset.BeginCreate method.
type DatasetBeginCreateOptions struct {
	// The ID for the dataset to append with. The dataset must originate from a previous dataset creation call that matches the datasetId
	DatasetID *string
	// The description to be given to the dataset.
	DescriptionDataset *string
}

// DatasetDeleteOptions contains the optional parameters for the Dataset.Delete method.
type DatasetDeleteOptions struct {
	// placeholder for future optional parameters
}

// DatasetDetailInfo - Detail information for the dataset.
type DatasetDetailInfo struct {
	// Information about the details of the create request for the dataset.
	DatasetSources *DatasetSources `json:"datasetSources,omitempty"`

	// READ-ONLY; The created timestamp for the dataset.
	Created *string `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The id for the dataset.
	DatasetID *string `json:"datasetId,omitempty" azure:"ro"`

	// READ-ONLY; The description for the dataset.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The feature counts for the dataset.
	FeatureCounts map[string]interface{} `json:"featureCounts,omitempty" azure:"ro"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// DatasetGetOperationOptions contains the optional parameters for the Dataset.GetOperation method.
type DatasetGetOperationOptions struct {
	// placeholder for future optional parameters
}

// DatasetGetOptions contains the optional parameters for the Dataset.Get method.
type DatasetGetOptions struct {
	// placeholder for future optional parameters
}

// DatasetListOptions contains the optional parameters for the Dataset.List method.
type DatasetListOptions struct {
	// placeholder for future optional parameters
}

// DatasetListResponse - The response model for the Dataset List API. The response body will contain a list of all the previously created datasets.
type DatasetListResponse struct {
	// READ-ONLY; A list of all the previously created datasets.
	Datasets []*DatasetDetailInfo `json:"datasets,omitempty" azure:"ro"`

	// READ-ONLY; If present, the location of the next page of data.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetListResponse.
func (d DatasetListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasets", d.Datasets)
	populate(objectMap, "nextLink", d.NextLink)
	return json.Marshal(objectMap)
}

// DatasetSources - Information about the details of the create request for the dataset.
type DatasetSources struct {
	// READ-ONLY; The dataset that was appended to to create the current dataset.
	AppendDatasetID *string `json:"appendDatasetId,omitempty" azure:"ro"`

	// READ-ONLY; The list of conversionId that were used to create the dataset.
	ConversionIDs []*string `json:"conversionIds,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatasetSources.
func (d DatasetSources) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appendDatasetId", d.AppendDatasetID)
	populate(objectMap, "conversionIds", d.ConversionIDs)
	return json.Marshal(objectMap)
}

type DefinitionProperties struct {
	// REQUIRED; name of attribute
	Name *string `json:"name,omitempty"`

	// REQUIRED; is attribute required
	Required *bool `json:"required,omitempty"`

	// REQUIRED; type of attribute
	Type map[string]interface{} `json:"type,omitempty"`
}

// ErrorAdditionalInfo - The resource management error additional info.
type ErrorAdditionalInfo struct {
	// READ-ONLY; The additional info.
	Info map[string]interface{} `json:"info,omitempty" azure:"ro"`

	// READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ErrorDetail - The error detail.
type ErrorDetail struct {
	// READ-ONLY; The error additional info.
	AdditionalInfo []*ErrorAdditionalInfo `json:"additionalInfo,omitempty" azure:"ro"`

	// READ-ONLY; The error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; The error details.
	Details []*ErrorDetail `json:"details,omitempty" azure:"ro"`

	// READ-ONLY; The error message.
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; The error target.
	Target *string `json:"target,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// ErrorResponse - Common error response for all Azure Resource Manager APIs to return error details for failed operations. (This also follows the OData
// error response format.).
// Implements the error and azcore.HTTPResponse interfaces.
type ErrorResponse struct {
	raw string
	// The error object.
	InnerError *ErrorDetail `json:"error,omitempty"`
}

// Error implements the error interface for type ErrorResponse.
// The contents of the error text are not contractual and subject to change.
func (e ErrorResponse) Error() string {
	return e.raw
}

// ExtendedGeoJSONFeatureCollection - A valid GeoJSON FeatureCollection object type extended with numberReturned and links array. Please refer to RFC 7946
// [https://tools.ietf.org/html/rfc7946#section-3.3] for details.
type ExtendedGeoJSONFeatureCollection struct {
	ExtendedGeoJSONFeatureCollectionData
	GeoJSONFeatureCollection
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedGeoJSONFeatureCollection.
func (e ExtendedGeoJSONFeatureCollection) MarshalJSON() ([]byte, error) {
	objectMap := e.ExtendedGeoJSONFeatureCollectionData.marshalInternal()
	for key, val := range e.GeoJSONFeatureCollection.marshalInternal(*e.GetGeoJSONFeatureCollection().Type) {
		objectMap[key] = val
	}

	return json.Marshal(objectMap)
}

func (e *ExtendedGeoJSONFeatureCollection) UnmarshalJSON(data []byte) error {
	if err := e.GeoJSONFeatureCollectionData.UnmarshalJSON(data); err != nil {
		return err
	}

	return e.ExtendedGeoJSONFeatureCollectionData.UnmarshalJSON(data)
}

type ExtendedGeoJSONFeatureCollectionData struct {
	// Links to other WFS endpoints.
	Links []*WfsEndpointLink `json:"links,omitempty"`

	// Number of returned features.
	NumberReturned *int32 `json:"numberReturned,omitempty"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ExtendedGeoJSONFeatureCollectionData.
func (e ExtendedGeoJSONFeatureCollectionData) MarshalJSON() ([]byte, error) {
	objectMap := e.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExtendedGeoJSONFeatureCollectionData.
func (e *ExtendedGeoJSONFeatureCollectionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return e.unmarshalInternal(rawMsg)
}

func (e ExtendedGeoJSONFeatureCollectionData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "links", e.Links)
	populate(objectMap, "numberReturned", e.NumberReturned)
	populate(objectMap, "ontology", e.Ontology)
	return objectMap
}

func (e *ExtendedGeoJSONFeatureCollectionData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "links":
			err = unpopulate(val, &e.Links)
			delete(rawMsg, key)
		case "numberReturned":
			err = unpopulate(val, &e.NumberReturned)
			delete(rawMsg, key)
		case "ontology":
			err = unpopulate(val, &e.Ontology)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type FeatureResponse struct {
	// REQUIRED; A valid GeoJSON Feature object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.2] for details.
	Feature *GeoJSONFeature `json:"feature,omitempty"`

	// Links to other WFS endpoints.
	Links []*WfsEndpointLink `json:"links,omitempty"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type FeatureResponse.
func (f FeatureResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "feature", f.Feature)
	populate(objectMap, "links", f.Links)
	populate(objectMap, "ontology", f.Ontology)
	return json.Marshal(objectMap)
}

// FeatureStateCreateStatesetOptions contains the optional parameters for the FeatureState.CreateStateset method.
type FeatureStateCreateStatesetOptions struct {
	// Description for the stateset. Max length allowed is 1000.
	Description *string
}

// FeatureStateDeleteStateOptions contains the optional parameters for the FeatureState.DeleteState method.
type FeatureStateDeleteStateOptions struct {
	// placeholder for future optional parameters
}

// FeatureStateDeleteStatesetOptions contains the optional parameters for the FeatureState.DeleteStateset method.
type FeatureStateDeleteStatesetOptions struct {
	// placeholder for future optional parameters
}

// FeatureStateGetStatesOptions contains the optional parameters for the FeatureState.GetStates method.
type FeatureStateGetStatesOptions struct {
	// placeholder for future optional parameters
}

// FeatureStateGetStatesetOptions contains the optional parameters for the FeatureState.GetStateset method.
type FeatureStateGetStatesetOptions struct {
	// placeholder for future optional parameters
}

// FeatureStateListStatesetOptions contains the optional parameters for the FeatureState.ListStateset method.
type FeatureStateListStatesetOptions struct {
	// placeholder for future optional parameters
}

// FeatureStateObject - Single feature state model.
type FeatureStateObject struct {
	// Valid Timestamp when the feature state was captured.
	EventTimestamp *string `json:"eventTimestamp,omitempty"`

	// Feature state Keyname. Maximum length allowed is 1000.
	KeyName *string `json:"keyName,omitempty"`

	// Value for the feature state. Type should comply with the style definition attached to the featurestate. Maximum length allowed for string type is 1024.
	Value interface{} `json:"value,omitempty"`
}

// FeatureStatePutStatesetOptions contains the optional parameters for the FeatureState.PutStateset method.
type FeatureStatePutStatesetOptions struct {
	// placeholder for future optional parameters
}

// FeatureStateUpdateStatesOptions contains the optional parameters for the FeatureState.UpdateStates method.
type FeatureStateUpdateStatesOptions struct {
	// placeholder for future optional parameters
}

// FeatureStatesStructure - The feature states model for a feature.
type FeatureStatesStructure struct {
	// The feature states array.
	States []*FeatureStateObject `json:"states,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FeatureStatesStructure.
func (f FeatureStatesStructure) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "states", f.States)
	return json.Marshal(objectMap)
}

// GeoJSONFeature - A valid GeoJSON Feature object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.2] for details.
type GeoJSONFeature struct {
	GeoJSONFeatureData
	GeoJSONObject
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeature.
func (g GeoJSONFeature) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONObject.marshalInternal(*g.GeoJSONObject.Type)
	for key, val := range g.GeoJSONFeatureData.marshalInternal() {
		objectMap[key] = val
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONFeature) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONObject.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONFeatureData.UnmarshalJSON(data)
}

// GeoJSONFeatureCollectionClassification provides polymorphic access to related types.
// Call the interface's GetGeoJSONFeatureCollection() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ExtendedGeoJsonFeatureCollection, *GeoJSONFeatureCollection
type GeoJSONFeatureCollectionClassification interface {
	GeoJSONObjectClassification
	// GetGeoJSONFeatureCollection returns the GeoJSONFeatureCollection content of the underlying type.
	GetGeoJSONFeatureCollection() *GeoJSONFeatureCollection
}

// GeoJSONFeatureCollection - A valid GeoJSON FeatureCollection object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.3]
// for details.
type GeoJSONFeatureCollection struct {
	GeoJSONFeatureCollectionData
	GeoJSONObject
}

// GetGeoJSONFeatureCollection implements the GeoJSONFeatureCollectionClassification interface for type GeoJSONFeatureCollection.
func (g *GeoJSONFeatureCollection) GetGeoJSONFeatureCollection() *GeoJSONFeatureCollection { return g }

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeatureCollection.
func (g GeoJSONFeatureCollection) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal(GeoJSONObjectTypeGeoJSONFeatureCollection)
	return json.Marshal(objectMap)
}

func (g GeoJSONFeatureCollection) marshalInternal(discValue GeoJSONObjectType) map[string]interface{} {
	objectMap := g.GeoJSONFeatureCollectionData.marshalInternal()
	for key, val := range g.GeoJSONObject.marshalInternal(*g.GetGeoJSONObject().Type) {
		objectMap[key] = val
	}

	return objectMap
}

func (g *GeoJSONFeatureCollection) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	if err := g.GeoJSONFeatureCollectionData.unmarshalInternal(rawMsg); err != nil {
		return err
	}

	return g.GeoJSONObject.unmarshalInternal(rawMsg)
}

type GeoJSONFeatureCollectionData struct {
	// REQUIRED; Contains a list of valid GeoJSON Feature objects.
	Features []*GeoJSONFeature `json:"features,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeatureCollectionData.
func (g GeoJSONFeatureCollectionData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONFeatureCollectionData.
func (g *GeoJSONFeatureCollectionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONFeatureCollectionData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "features", g.Features)
	return objectMap
}

func (g *GeoJSONFeatureCollectionData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "features":
			err = unpopulate(val, &g.Features)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type GeoJSONFeatureData struct {
	// REQUIRED; A valid GeoJSON geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,
	// Polygon, MultiPolygon and GeometryCollection. Please
	// refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1] for details.
	Geometry GeoJSONGeometryClassification `json:"geometry,omitempty"`

	// The type of the feature. The value depends on the data model the current feature is part of. Some data models may have an empty value.
	FeatureType *string `json:"featureType,omitempty"`

	// Identifier for the feature.
	ID *string `json:"id,omitempty"`

	// Properties can contain any additional metadata about the Feature. Value can be any JSON object or a JSON null value
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONFeatureData.
func (g GeoJSONFeatureData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONFeatureData.
func (g *GeoJSONFeatureData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONFeatureData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "featureType", g.FeatureType)
	populate(objectMap, "geometry", g.Geometry)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "properties", g.Properties)
	return objectMap
}

func (g *GeoJSONFeatureData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "featureType":
			err = unpopulate(val, &g.FeatureType)
			delete(rawMsg, key)
		case "geometry":
			g.Geometry, err = unmarshalGeoJSONGeometryClassification(val)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &g.ID)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &g.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONGeometryClassification provides polymorphic access to related types.
// Call the interface's GetGeoJSONGeometry() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *GeoJSONGeometry, *GeoJsonGeometryCollection, *GeoJsonLineString, *GeoJsonMultiLineString, *GeoJsonMultiPoint, *GeoJsonMultiPolygon,
// - *GeoJsonPoint, *GeoJsonPolygon
type GeoJSONGeometryClassification interface {
	GeoJSONObjectClassification
	// GetGeoJSONGeometry returns the GeoJSONGeometry content of the underlying type.
	GetGeoJSONGeometry() *GeoJSONGeometry
}

// GeoJSONGeometry - A valid GeoJSON geometry object. The type must be one of the seven valid GeoJSON geometry types - Point, MultiPoint, LineString, MultiLineString,
// Polygon, MultiPolygon and GeometryCollection. Please
// refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1] for details.
type GeoJSONGeometry struct {
	GeoJSONObject
}

// GetGeoJSONGeometry implements the GeoJSONGeometryClassification interface for type GeoJSONGeometry.
func (g *GeoJSONGeometry) GetGeoJSONGeometry() *GeoJSONGeometry { return g }

// MarshalJSON implements the json.Marshaller interface for type GeoJSONGeometry.
func (g GeoJSONGeometry) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal("GeoJsonGeometry")
	return json.Marshal(objectMap)
}

func (g GeoJSONGeometry) marshalInternal(discValue GeoJSONObjectType) map[string]interface{} {
	objectMap := g.GeoJSONObject.marshalInternal(discValue)
	return objectMap
}

func (g *GeoJSONGeometry) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	return g.GeoJSONObject.unmarshalInternal(rawMsg)
}

// GeoJSONGeometryCollection - A valid GeoJSON GeometryCollection object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.8]
// for details.
type GeoJSONGeometryCollection struct {
	GeoJSONGeometry
	GeoJSONGeometryCollectionData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONGeometryCollection.
func (g GeoJSONGeometryCollection) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONGeometryCollectionData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}
	return json.Marshal(objectMap)
}

func (g *GeoJSONGeometryCollection) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometryCollectionData.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONGeometry.UnmarshalJSON(data)
}

type GeoJSONGeometryCollectionData struct {
	// REQUIRED; Contains a list of valid GeoJSON geometry objects. Note that coordinates in GeoJSON are in x, y order (longitude, latitude).
	Geometries []GeoJSONGeometryClassification `json:"geometries,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONGeometryCollectionData.
func (g GeoJSONGeometryCollectionData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONGeometryCollectionData.
func (g *GeoJSONGeometryCollectionData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONGeometryCollectionData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "geometries", g.Geometries)
	return objectMap
}

func (g *GeoJSONGeometryCollectionData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "geometries":
			g.Geometries, err = unmarshalGeoJSONGeometryClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONLineString - A valid GeoJSON LineString geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.4] for details.
type GeoJSONLineString struct {
	GeoJSONGeometry
	GeoJSONLineStringData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONLineString.
func (g GeoJSONLineString) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONLineStringData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONLineString) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONLineStringData.UnmarshalJSON(data)
}

type GeoJSONLineStringData struct {
	// REQUIRED; Coordinates for the GeoJson LineString geometry.
	Coordinates [][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONLineStringData.
func (g GeoJSONLineStringData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONLineStringData.
func (g *GeoJSONLineStringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONLineStringData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONLineStringData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONMultiLineString - A valid GeoJSON MultiLineString geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.5]
// for details.
type GeoJSONMultiLineString struct {
	GeoJSONGeometry
	GeoJSONMultiLineStringData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiLineString.
func (g GeoJSONMultiLineString) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONMultiLineStringData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONMultiLineString) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONMultiLineStringData.UnmarshalJSON(data)
}

type GeoJSONMultiLineStringData struct {
	// REQUIRED; Coordinates for the GeoJson MultiLineString geometry.
	Coordinates [][][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiLineStringData.
func (g GeoJSONMultiLineStringData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONMultiLineStringData.
func (g *GeoJSONMultiLineStringData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONMultiLineStringData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONMultiLineStringData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONMultiPoint - A valid GeoJSON MultiPoint geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.3] for details.
type GeoJSONMultiPoint struct {
	GeoJSONGeometry
	GeoJSONMultiPointData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPoint.
func (g GeoJSONMultiPoint) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONMultiPointData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONMultiPoint) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONMultiPointData.UnmarshalJSON(data)
}

// GeoJSONMultiPointData - Data contained by a GeoJson MultiPoint.
type GeoJSONMultiPointData struct {
	// REQUIRED; Coordinates for the GeoJson MultiPoint geometry.
	Coordinates [][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPointData.
func (g GeoJSONMultiPointData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONMultiPointData.
func (g *GeoJSONMultiPointData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONMultiPointData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONMultiPointData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONMultiPolygon - A valid GeoJSON MultiPolygon object type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.7] for details.
type GeoJSONMultiPolygon struct {
	GeoJSONGeometry
	GeoJSONMultiPolygonData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPolygon.
func (g GeoJSONMultiPolygon) MarshalJSON() ([]byte, error) {
	objectMapBase := g.GeoJSONMultiPolygonData.marshalInternal()
	for key, val := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMapBase[key] = val
	}

	return json.Marshal(objectMapBase)
}

func (g *GeoJSONMultiPolygon) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONMultiPolygonData.UnmarshalJSON(data)
}

type GeoJSONMultiPolygonData struct {
	// REQUIRED; Contains a list of valid GeoJSON Polygon objects. Note that coordinates in GeoJSON are in x, y order (longitude, latitude).
	Coordinates [][][][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONMultiPolygonData.
func (g GeoJSONMultiPolygonData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONMultiPolygonData.
func (g *GeoJSONMultiPolygonData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONMultiPolygonData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONMultiPolygonData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONObjectClassification provides polymorphic access to related types.
// Call the interface's GetGeoJSONObject() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ExtendedGeoJsonFeatureCollection, *GeoJSONObject, *GeoJsonFeature, *GeoJsonGeometry, *GeoJsonGeometryCollection, *GeoJsonLineString,
// - *GeoJsonMultiLineString, *GeoJsonMultiPoint, *GeoJsonMultiPolygon, *GeoJsonPoint, *GeoJsonPolygon
type GeoJSONObjectClassification interface {
	// GetGeoJSONObject returns the GeoJSONObject content of the underlying type.
	GetGeoJSONObject() *GeoJSONObject
}

// GeoJSONObject - A valid GeoJSON object. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3] for details.
type GeoJSONObject struct {
	// REQUIRED; Specifies the GeoJSON type. Must be one of the nine valid GeoJSON object types - Point, MultiPoint, LineString, MultiLineString, Polygon, MultiPolygon,
	// GeometryCollection, Feature and
	// FeatureCollection.
	Type *GeoJSONObjectType `json:"type,omitempty"`
}

// GetGeoJSONObject implements the GeoJSONObjectClassification interface for type GeoJSONObject.
func (g *GeoJSONObject) GetGeoJSONObject() *GeoJSONObject { return g }

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONObject.
func (g *GeoJSONObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONObject) marshalInternal(discValue GeoJSONObjectType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	g.Type = &discValue
	objectMap["type"] = g.Type
	return objectMap
}

func (g *GeoJSONObject) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
			err = unpopulate(val, &g.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONPoint - A valid GeoJSON Point geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.2] for details.
type GeoJSONPoint struct {
	GeoJSONGeometry
	GeoJSONPointData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPoint.
func (g GeoJSONPoint) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONPointData.marshalInternal()
	for key, value := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = value
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONPoint) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONPointData.UnmarshalJSON(data)
}

// GeoJSONPointData - Data contained by a GeoJson Point.
type GeoJSONPointData struct {
	// REQUIRED; A Position is an array of numbers with two or more elements. The first two elements are longitude and latitude, precisely in that order. Altitude/Elevation
	// is an optional third element. Please refer
	// to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.1] for details.
	Coordinates []*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPointData.
func (g GeoJSONPointData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONPointData.
func (g *GeoJSONPointData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONPointData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONPointData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeoJSONPolygon - A valid GeoJSON Polygon geometry type. Please refer to RFC 7946 [https://tools.ietf.org/html/rfc7946#section-3.1.6] for details.
type GeoJSONPolygon struct {
	GeoJSONGeometry
	GeoJSONPolygonData
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPolygon.
func (g GeoJSONPolygon) MarshalJSON() ([]byte, error) {
	objectMap := g.GeoJSONPolygonData.marshalInternal()
	for key, val := range g.GeoJSONGeometry.marshalInternal(*g.GeoJSONGeometry.Type) {
		objectMap[key] = val
	}

	return json.Marshal(objectMap)
}

func (g *GeoJSONPolygon) UnmarshalJSON(data []byte) error {
	if err := g.GeoJSONGeometry.UnmarshalJSON(data); err != nil {
		return err
	}

	return g.GeoJSONPolygonData.UnmarshalJSON(data)
}

type GeoJSONPolygonData struct {
	// REQUIRED; Coordinates for the GeoJson Polygon geometry type.
	Coordinates [][][]*float64 `json:"coordinates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GeoJSONPolygonData.
func (g GeoJSONPolygonData) MarshalJSON() ([]byte, error) {
	objectMap := g.marshalInternal()
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GeoJSONPolygonData.
func (g *GeoJSONPolygonData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return g.unmarshalInternal(rawMsg)
}

func (g GeoJSONPolygonData) marshalInternal() map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "coordinates", g.Coordinates)
	return objectMap
}

func (g *GeoJSONPolygonData) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "coordinates":
			err = unpopulate(val, &g.Coordinates)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GeofenceGeometry - The geofencing geometry.
type GeofenceGeometry struct {
	// READ-ONLY; ID of the device.
	DeviceID *string `json:"deviceId,omitempty" azure:"ro"`

	// READ-ONLY; Distance from the coordinate to the closest border of the geofence. Positive means the coordinate is outside of the geofence. If the coordinate
	// is outside of the geofence, but more than the value of
	// searchBuffer away from the closest geofence border, then the value is 999. Negative means the coordinate is inside of the geofence. If the coordinate
	// is inside the polygon, but more than the value of
	// searchBuffer away from the closest geofencing border, then the value is -999. A value of 999 means that there is great confidence the coordinate is well
	// outside the geofence. A value of -999 means
	// that there is great confidence the coordinate is well within the geofence.
	Distance *float32 `json:"distance,omitempty" azure:"ro"`

	// READ-ONLY; The unique id identifies a geometry.
	GeometryID *string `json:"geometryId,omitempty" azure:"ro"`

	// READ-ONLY; Latitude of the nearest point of the geometry.
	NearestLat *float32 `json:"nearestLat,omitempty" azure:"ro"`

	// READ-ONLY; Longitude of the nearest point of the geometry.
	NearestLon *float32 `json:"nearestLon,omitempty" azure:"ro"`

	// READ-ONLY; Sea level in meter of the nearest point on the 2D extrusion geometry. This will only be presented in response when value is provided for 'zInMeter'
	// in the request.
	NearestZ *float32 `json:"nearestZ,omitempty" azure:"ro"`

	// READ-ONLY; The unique id returned from Data Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] after uploading a valid GeoJSON
	// FeatureCollection object. Please refer to RFC 7946
	// [https://tools.ietf.org/html/rfc7946#section-3.3] for details. All the feature's properties should contain geometryId, which is used for identifying
	// the geometry and is case-sensitive.
	UdID *string `json:"udId,omitempty" azure:"ro"`
}

// GeofenceResponse - This object is returned from a geofence proximity call.
type GeofenceResponse struct {
	// READ-ONLY; Lists of the geometry ID of the geofence which is expired relative to the user time in the request.
	ExpiredGeofenceGeometryID []*string `json:"expiredGeofenceGeometryId,omitempty" azure:"ro"`

	// READ-ONLY; Lists the fence geometries that contain the coordinate position or overlap the searchBuffer around the position.
	Geometries []*GeofenceGeometry `json:"geometries,omitempty" azure:"ro"`

	// READ-ONLY; Lists of the geometry ID of the geofence which is in invalid period relative to the user time in the request.
	InvalidPeriodGeofenceGeometryID []*string `json:"invalidPeriodGeofenceGeometryId,omitempty" azure:"ro"`

	// READ-ONLY; True if at least one event is published to the Azure Maps event subscriber, false if no event is published to the Azure Maps event subscriber.
	// This will only be presented in response when 'isAsync'
	// query parameter is set to true.
	IsEventPublished *bool `json:"isEventPublished,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GeofenceResponse.
func (g GeofenceResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "expiredGeofenceGeometryId", g.ExpiredGeofenceGeometryID)
	populate(objectMap, "geometries", g.Geometries)
	populate(objectMap, "invalidPeriodGeofenceGeometryId", g.InvalidPeriodGeofenceGeometryID)
	populate(objectMap, "isEventPublished", g.IsEventPublished)
	return json.Marshal(objectMap)
}

// GreatCircleDistanceResponse - This object is returned from a successful Great Circle Distance call
type GreatCircleDistanceResponse struct {
	// READ-ONLY; Result Object
	Result *GreatCircleDistanceResponseResult `json:"result,omitempty" azure:"ro"`

	// READ-ONLY; Summary object
	Summary *GreatCircleDistanceResponseSummary `json:"summary,omitempty" azure:"ro"`
}

// GreatCircleDistanceResponseResult - Result Object
type GreatCircleDistanceResponseResult struct {
	// READ-ONLY; The great circle distance in meters from the source point to the target point
	DistanceInMeters *float32 `json:"distanceInMeters,omitempty" azure:"ro"`
}

// GreatCircleDistanceResponseSummary - Summary object
type GreatCircleDistanceResponseSummary struct {
	// A location represented as a latitude and longitude
	SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`

	// A location represented as a latitude and longitude
	TargetPoint *SpatialCoordinate `json:"targetPoint,omitempty"`
}

type LandingPageResponse struct {
	// REQUIRED; Links to other WFS endpoints.
	Links []*WfsEndpointLink `json:"links,omitempty"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LandingPageResponse.
func (l LandingPageResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "links", l.Links)
	populate(objectMap, "ontology", l.Ontology)
	return json.Marshal(objectMap)
}

// LongRunningOperationResult - The response model for a Long-Running Operations API.
type LongRunningOperationResult struct {
	// The error detail.
	Error *ErrorDetail `json:"error,omitempty"`

	// The Id for this long-running operation.
	OperationID *string `json:"operationId,omitempty"`

	// The error detail.
	Warning *ErrorDetail `json:"warning,omitempty"`

	// READ-ONLY; The created timestamp.
	Created *string `json:"created,omitempty" azure:"ro"`

	// READ-ONLY; The status state of the request.
	Status *LroStatus `json:"status,omitempty" azure:"ro"`
}

// MapDataDetailInfo - Detail information for the data.
type MapDataDetailInfo struct {
	// READ-ONLY; The current data format.
	DataFormat *string `json:"dataFormat,omitempty" azure:"ro"`

	// READ-ONLY; The current description.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The location of the data. Execute a HTTP GET on this location to download the data.
	Location *string `json:"location,omitempty" azure:"ro"`

	// READ-ONLY; The size of the content in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty" azure:"ro"`

	// READ-ONLY; The unique data id for the data.
	Udid *string `json:"udid,omitempty" azure:"ro"`

	// READ-ONLY; The current upload status of the content.
	UploadStatus *string `json:"uploadStatus,omitempty" azure:"ro"`
}

// MapDataListResponse - The response model for the Data List API. Returns a list of all the previously uploaded data.
type MapDataListResponse struct {
	// READ-ONLY; A list of all the previously uploaded data.
	MapDataList []*MapDataDetailInfo `json:"mapDataList,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MapDataListResponse.
func (m MapDataListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "mapDataList", m.MapDataList)
	return json.Marshal(objectMap)
}

// NumberRuleObject - The numeric rule. The color is selected from the first range it falls into.
type NumberRuleObject struct {
	// The color when value is within the range. Color is a JSON string in a variety of permitted formats, HTML-style hex values, RGB ("#ff0", "#ffff00", "rgb(255,
	// 255, 0)"), RGBA ("rgba(255, 255, 0, 1)"),
	// HSL("hsl(100, 50%, 50%)"), and HSLA("hsla(100, 50%, 50%, 1)"). Predefined HTML colors names, like yellow and blue, are also permitted.
	Color *string `json:"color,omitempty"`

	// The numeric value range for this style rule. If the value is in the range, all the conditions must hold true.
	Range *RangeObject `json:"range,omitempty"`
}

// NumberTypeStyleRule - The numeric type style rule object.
type NumberTypeStyleRule struct {
	StyleObject
	// REQUIRED; Numeric style rules.
	Rules []*NumberRuleObject `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NumberTypeStyleRule.
func (n NumberTypeStyleRule) MarshalJSON() ([]byte, error) {
	objectMap := n.StyleObject.marshalInternal(StyleObjectTypeNumberTypeStyleRule)
	populate(objectMap, "rules", n.Rules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NumberTypeStyleRule.
func (n *NumberTypeStyleRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rules":
			err = unpopulate(val, &n.Rules)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return n.StyleObject.unmarshalInternal(rawMsg)
}

// PointInPolygonResponse - Returns true if point is within the polygon, false otherwise
type PointInPolygonResponse struct {
	// Point In Polygon Result Object
	Result *PointInPolygonResult `json:"result,omitempty"`

	// READ-ONLY; Point In Polygon Summary object
	Summary *PointInPolygonSummary `json:"summary,omitempty" azure:"ro"`
}

// PointInPolygonResult - Point In Polygon Result Object
type PointInPolygonResult struct {
	// READ-ONLY; Geometries array
	IntersectingGeometries []*string `json:"intersectingGeometries,omitempty" azure:"ro"`

	// READ-ONLY; Point In Polygons Property
	PointInPolygons *bool `json:"pointInPolygons,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PointInPolygonResult.
func (p PointInPolygonResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "intersectingGeometries", p.IntersectingGeometries)
	populate(objectMap, "pointInPolygons", p.PointInPolygons)
	return json.Marshal(objectMap)
}

// PointInPolygonSummary - Point In Polygon Summary object
type PointInPolygonSummary struct {
	// A location represented as a latitude and longitude
	SourcePoint *SpatialCoordinate `json:"sourcePoint,omitempty"`

	// READ-ONLY; Processing information
	Information *string `json:"information,omitempty" azure:"ro"`

	// READ-ONLY; A unique data id (udid) for the uploaded content. Udid is not applicable for POST spatial operations(set to null)
	Udid *string `json:"udid,omitempty" azure:"ro"`
}

// RangeObject - The numeric value range for this style rule. If the value is in the range, all the conditions must hold true.
type RangeObject struct {
	// All the number x that x < exclusiveMaximum.
	ExclusiveMaximum *float64 `json:"exclusiveMaximum,omitempty"`

	// All the number x that x > exclusiveMinimum.
	ExclusiveMinimum *float64 `json:"exclusiveMinimum,omitempty"`

	// All the number x that x ≤ maximum.
	Maximum *float64 `json:"maximum,omitempty"`

	// All the number x that x ≥ minimum.
	Minimum *float64 `json:"minimum,omitempty"`
}

// SpatialCoordinate - A location represented as a latitude and longitude
type SpatialCoordinate struct {
	// READ-ONLY; Latitude property
	Lat *float64 `json:"lat,omitempty" azure:"ro"`

	// READ-ONLY; Longitude property
	Lon *float64 `json:"lon,omitempty" azure:"ro"`
}

// SpatialGetBufferOptions contains the optional parameters for the Spatial.GetBuffer method.
type SpatialGetBufferOptions struct {
	// placeholder for future optional parameters
}

// SpatialGetClosestPointOptions contains the optional parameters for the Spatial.GetClosestPoint method.
type SpatialGetClosestPointOptions struct {
	// The number of closest points expected from response. Default: 1, minimum: 1 and maximum: 50
	NumberOfClosestPoints *int32
}

// SpatialGetGeofenceOptions contains the optional parameters for the Spatial.GetGeofence method.
type SpatialGetGeofenceOptions struct {
	// If true, the request will use async event mechanism; if false, the request will be synchronized and do not trigger any event. The default value is false.
	IsAsync *bool
	// Mode of the geofencing async event mechanism.
	Mode *GeofenceMode
	// The radius of the buffer around the geofence in meters that defines how far to search inside and outside the border of the fence against the coordinate
	// that was provided when calculating the result. The minimum value is 0, and the maximum is 500. The default value is 50.
	SearchBuffer *float32
	// The user request time. If not presented in the request, the default value is DateTime.Now.
	UserTime *time.Time
	// The sea level in meter of the location being passed. If this parameter is presented, 2D extrusion is used. Example: 200.
	Z *float32
}

// SpatialGetGreatCircleDistanceOptions contains the optional parameters for the Spatial.GetGreatCircleDistance method.
type SpatialGetGreatCircleDistanceOptions struct {
	// placeholder for future optional parameters
}

// SpatialGetPointInPolygonOptions contains the optional parameters for the Spatial.GetPointInPolygon method.
type SpatialGetPointInPolygonOptions struct {
	// placeholder for future optional parameters
}

// SpatialPostBufferOptions contains the optional parameters for the Spatial.PostBuffer method.
type SpatialPostBufferOptions struct {
	// placeholder for future optional parameters
}

// SpatialPostClosestPointOptions contains the optional parameters for the Spatial.PostClosestPoint method.
type SpatialPostClosestPointOptions struct {
	// The number of closest points expected from response. Default: 1, minimum: 1 and maximum: 50
	NumberOfClosestPoints *int32
}

// SpatialPostGeofenceOptions contains the optional parameters for the Spatial.PostGeofence method.
type SpatialPostGeofenceOptions struct {
	// If true, the request will use async event mechanism; if false, the request will be synchronized and do not trigger any event. The default value is false.
	IsAsync *bool
	// Mode of the geofencing async event mechanism.
	Mode *GeofenceMode
	// The radius of the buffer around the geofence in meters that defines how far to search inside and outside the border of the fence against the coordinate
	// that was provided when calculating the result. The minimum value is 0, and the maximum is 500. The default value is 50.
	SearchBuffer *float32
	// The user request time. If not presented in the request, the default value is DateTime.UtcNow.
	UserTime *time.Time
	// The sea level in meter of the location being passed. If this parameter is presented, 2D extrusion geofencing is applied. Example: 200.
	Z *float32
}

// SpatialPostPointInPolygonOptions contains the optional parameters for the Spatial.PostPointInPolygon method.
type SpatialPostPointInPolygonOptions struct {
	// placeholder for future optional parameters
}

// StatesetCreatedResponse - The response model for the successful Stateset Create API.
type StatesetCreatedResponse struct {
	// READ-ONLY; The ID for the new stateset created.
	StatesetID *string `json:"statesetId,omitempty" azure:"ro"`
}

// StatesetGetResponse - The response model for the successful Stateset Get API.
type StatesetGetResponse struct {
	// Dataset ID associated with the stateset.
	DatasetIDs []*string `json:"datasetIds,omitempty"`

	// The styles model.
	StatesetStyle *StylesObject `json:"statesetStyle,omitempty"`

	// READ-ONLY; Description associated with the stateset.
	Description *string `json:"description,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StatesetGetResponse.
func (s StatesetGetResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasetIds", s.DatasetIDs)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "statesetStyle", s.StatesetStyle)
	return json.Marshal(objectMap)
}

// StatesetInfoObject - The stateset information detail.
type StatesetInfoObject struct {
	// Dataset ID associated with the stateset.
	DatasetIDs []*string `json:"datasetIds,omitempty"`

	// The stateset ID of this stateset.
	StatesetID *string `json:"statesetId,omitempty"`

	// The styles model.
	StatesetStyle *StylesObject `json:"statesetStyle,omitempty"`

	// READ-ONLY; Description associated with the stateset.
	Description *string `json:"description,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StatesetInfoObject.
func (s StatesetInfoObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "datasetIds", s.DatasetIDs)
	populate(objectMap, "description", s.Description)
	populate(objectMap, "statesetId", s.StatesetID)
	populate(objectMap, "statesetStyle", s.StatesetStyle)
	return json.Marshal(objectMap)
}

// StatesetListResponse - The response model for the successful Stateset List API.
type StatesetListResponse struct {
	// A list of statesets information.
	Statesets []*StatesetInfoObject `json:"statesets,omitempty"`

	// READ-ONLY; If present, the location of the next page of data.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StatesetListResponse.
func (s StatesetListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "statesets", s.Statesets)
	return json.Marshal(objectMap)
}

// StringTypeStyleRule - The string type style rule object.
type StringTypeStyleRule struct {
	StyleObject
	// REQUIRED; String style rules.
	Rules []map[string]*string `json:"rules,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StringTypeStyleRule.
func (s StringTypeStyleRule) MarshalJSON() ([]byte, error) {
	objectMap := s.StyleObject.marshalInternal(StyleObjectTypeStringTypeStyleRule)
	populate(objectMap, "rules", s.Rules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StringTypeStyleRule.
func (s *StringTypeStyleRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "rules":
			err = unpopulate(val, &s.Rules)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.StyleObject.unmarshalInternal(rawMsg)
}

// StyleObjectClassification provides polymorphic access to related types.
// Call the interface's GetStyleObject() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *BooleanTypeStyleRule, *NumberTypeStyleRule, *StringTypeStyleRule, *StyleObject
type StyleObjectClassification interface {
	// GetStyleObject returns the StyleObject content of the underlying type.
	GetStyleObject() *StyleObject
}

// StyleObject - The stateset style model. The style rule could be a numeric type style rule or a boolean type style rule. Refer to NumberRuleObject, StringRuleObject
// and BooleanRuleObject definitions here
// [https://aka.ms/AzureMapsStatesetStylesObject].
type StyleObject struct {
	// REQUIRED; Stateset style key name. Key names are random strings but they should be unique inside style array.
	KeyName *string `json:"keyName,omitempty"`

	// REQUIRED; The type of stateset style.
	Type *StyleObjectType `json:"type,omitempty"`
}

// GetStyleObject implements the StyleObjectClassification interface for type StyleObject.
func (s *StyleObject) GetStyleObject() *StyleObject { return s }

// UnmarshalJSON implements the json.Unmarshaller interface for type StyleObject.
func (s *StyleObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s StyleObject) marshalInternal(discValue StyleObjectType) map[string]interface{} {
	objectMap := make(map[string]interface{})
	populate(objectMap, "keyName", s.KeyName)
	s.Type = &discValue
	objectMap["type"] = s.Type
	return objectMap
}

func (s *StyleObject) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "keyName":
			err = unpopulate(val, &s.KeyName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StylesObject - The styles model.
type StylesObject struct {
	// An array of stateset styles. The style rule could be a numeric or string or a boolean type style rule. Refer to NumberRuleObject, StringRuleObject and
	// BooleanRuleObject definitions here
	// [https://aka.ms/AzureMapsStatesetStylesObject].
	Styles []StyleObjectClassification `json:"styles,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StylesObject.
func (s StylesObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "styles", s.Styles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StylesObject.
func (s *StylesObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "styles":
			s.Styles, err = unmarshalStyleObjectClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TilesetBeginCreateOptions contains the optional parameters for the Tileset.BeginCreate method.
type TilesetBeginCreateOptions struct {
	// User provided description of the tileset.
	Description *string
}

// TilesetDeleteOptions contains the optional parameters for the Tileset.Delete method.
type TilesetDeleteOptions struct {
	// placeholder for future optional parameters
}

// TilesetDetailInfo - Detail information for the data.
type TilesetDetailInfo struct {
	// READ-ONLY; Bounding box which all features of the tileset lay within. Projection used - EPSG:3857. Format : 'minLon, minLat, maxLon, maxLat'.
	Bbox []*float32 `json:"bbox,omitempty" azure:"ro"`

	// READ-ONLY; The unique dataset Id used to create the tileset.
	DatasetID *string `json:"datasetId,omitempty" azure:"ro"`

	// READ-ONLY; The description the caller provided when creating the tileset. Maximum length 1024 characters.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; The highest tile zoom level tile generated for the tileset.
	MaxZoom *int32 `json:"maxZoom,omitempty" azure:"ro"`

	// READ-ONLY; The lowest tile zoom level tile generated for the tileset.
	MinZoom *int32 `json:"minZoom,omitempty" azure:"ro"`

	// READ-ONLY; The ontology version of this dataset.
	Ontology *string `json:"ontology,omitempty" azure:"ro"`

	// READ-ONLY; The unique tileset id for the tileset.
	TilesetID *string `json:"tilesetId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TilesetDetailInfo.
func (t TilesetDetailInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bbox", t.Bbox)
	populate(objectMap, "datasetId", t.DatasetID)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "maxZoom", t.MaxZoom)
	populate(objectMap, "minZoom", t.MinZoom)
	populate(objectMap, "ontology", t.Ontology)
	populate(objectMap, "tilesetId", t.TilesetID)
	return json.Marshal(objectMap)
}

// TilesetGetOperationOptions contains the optional parameters for the Tileset.GetOperation method.
type TilesetGetOperationOptions struct {
	// placeholder for future optional parameters
}

// TilesetGetOptions contains the optional parameters for the Tileset.Get method.
type TilesetGetOptions struct {
	// placeholder for future optional parameters
}

// TilesetListOptions contains the optional parameters for the Tileset.List method.
type TilesetListOptions struct {
	// placeholder for future optional parameters
}

// TilesetListResponse - The response model for the Tileset List API. Returns a list of all tilesets.
type TilesetListResponse struct {
	// READ-ONLY; If present, the location of the next page of data.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; A list of all tilesets.
	Tilesets []*TilesetDetailInfo `json:"tilesets,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TilesetListResponse.
func (t TilesetListResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "tilesets", t.Tilesets)
	return json.Marshal(objectMap)
}

// WFSDeleteFeatureOptions contains the optional parameters for the WFS.DeleteFeature method.
type WFSDeleteFeatureOptions struct {
	// placeholder for future optional parameters
}

// WFSGetCollectionDefinitionOptions contains the optional parameters for the WFS.GetCollectionDefinition method.
type WFSGetCollectionDefinitionOptions struct {
	// placeholder for future optional parameters
}

// WFSGetCollectionOptions contains the optional parameters for the WFS.GetCollection method.
type WFSGetCollectionOptions struct {
	// placeholder for future optional parameters
}

// WFSGetCollectionsOptions contains the optional parameters for the WFS.GetCollections method.
type WFSGetCollectionsOptions struct {
	// placeholder for future optional parameters
}

// WFSGetConformanceOptions contains the optional parameters for the WFS.GetConformance method.
type WFSGetConformanceOptions struct {
	// placeholder for future optional parameters
}

// WFSGetFeatureOptions contains the optional parameters for the WFS.GetFeature method.
type WFSGetFeatureOptions struct {
	// placeholder for future optional parameters
}

// WFSGetFeaturesOptions contains the optional parameters for the WFS.GetFeatures method.
type WFSGetFeaturesOptions struct {
	// Only features that have a geometry that intersects the supplied bounding box are selected.
	// * Lower left corner, coordinate axis 1 * Lower left corner, coordinate axis 2 * Upper right corner, coordinate axis 1 * Upper right corner, coordinate
	// axis 2
	// The coordinate reference system of the values is WGS84 longitude/latitude (http://www.opengis.net/def/crs/OGC/1.3/CRS84) unless a different coordinate
	// reference system is specified in the parameter `bbox-crs`.
	// For WGS84 longitude/latitude the values are in most cases the sequence of minimum longitude, minimum latitude, maximum longitude and maximum latitude.
	// However, in cases where the box spans the antimeridian the first value (west-most box edge) is larger than the third value (east-most box edge).
	Bbox *string
	// Filter expression to search for features with specific property values in a given collection. Only feature properties of scalar type and equals operator
	// are supported.
	// This is a special parameter where the parameter name is a case sensitive property name. The scheme for this parameter is {property name}={property value}.
	// Unless "filter" is one of the property names in the collection, "filter" should not be used as a parameter name. To search for features with "name" property
	// value "21N13", use "name=21N13".
	// Multiple filters are supported and should be represented as multiple query parameters. E.g., <property1>=<value1>&<property2>=<value2> String values
	// are case sensitive.
	Filter *string
	// The optional limit parameter limits the number of features that are presented in the response document.
	// Only features that are on the first level of the collection in the response document are counted. Nested objects contained within the explicitly requested
	// features shall not be counted.
	// * Minimum = 1 * Maximum = 50 * Default = 10
	Limit *int32
}

// WFSGetLandingPageOptions contains the optional parameters for the WFS.GetLandingPage method.
type WFSGetLandingPageOptions struct {
}

// WfsEndpointLink - Links to other WFS endpoints
type WfsEndpointLink struct {
	// REQUIRED; The link target.
	Href *string `json:"href,omitempty"`

	// A hint indicating what the language of the result of dereferencing the link should be.
	Hreflang *string `json:"hreflang,omitempty"`

	// The relation type.
	Rel *string `json:"rel,omitempty"`

	// Used to label the destination of a link such that it can be used as a human-readable identifier (e.g., a menu entry) in the language indicated by the
	// Content-Language header field (if present).
	Title *string `json:"title,omitempty"`

	// A hint indicating what the media type of the result of dereferencing the link should be.
	Type *string `json:"type,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
