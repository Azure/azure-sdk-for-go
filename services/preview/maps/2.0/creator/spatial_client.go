// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package creator

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// SpatialClient contains the methods for the Spatial group.
// Don't use this type directly, use NewSpatialClient() instead.
type SpatialClient struct {
	con         *Connection
	xmsClientID *string
}

// NewSpatialClient creates a new instance of SpatialClient with the specified values.
func NewSpatialClient(con *Connection, xmsClientID *string) *SpatialClient {
	return &SpatialClient{
		con:         NewConnection(con.cp.geography, ClientIdCredScaffold{con.cp.cred, xmsClientID}, con.cp.options),
		xmsClientID: xmsClientID,
	}
}

// GetBuffer - Applies to: S1 pricing tier.
// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the input. The buffer could be either
// on the outside or the inside of the provided
// Feature, depending on the distance provided in the input. There must be either one distance provided per Feature in the FeatureCollection input, or if
// only one distance is provided, then that distance
// is applied to every Feature in the collection. The positive (or negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the
// geometry with a circle of radius equal to the
// absolute value of the buffer distance. The buffer API always returns a polygonal result. The negative or zero-distance buffer of lines and points is
// always an empty polygon. The input features are
// provided by a GeoJSON file which is uploaded via Data Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] and referenced by
// a unique udid. The GeoJSON file may contain a
// collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.
// To test this API, you can upload the sample data from Post Buffer API [https://docs.microsoft.com/en-us/rest/api/maps/spatial/postbuffer#examples] examples(Request
// Body without distances array) via
// Data Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] and replace the [udid] from the sample request below
// [https://docs.microsoft.com/en-us/rest/api/maps/spatial/getbuffer#examples] with the udid returned by Data Upload API.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) GetBuffer(ctx context.Context, formatParam ResponseFormat, udid string, distances string, options *SpatialGetBufferOptions) (BufferResponseResponse, error) {
	req, err := client.getBufferCreateRequest(ctx, formatParam, udid, distances, options)
	if err != nil {
		return BufferResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BufferResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BufferResponseResponse{}, client.getBufferHandleError(resp)
	}
	return client.getBufferHandleResponse(resp)
}

// getBufferCreateRequest creates the GetBuffer request.
func (client *SpatialClient) getBufferCreateRequest(ctx context.Context, formatParam ResponseFormat, udid string, distances string, options *SpatialGetBufferOptions) (*azcore.Request, error) {
	urlPath := "/spatial/buffer/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("udid", udid)
	reqQP.Set("distances", distances)
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getBufferHandleResponse handles the GetBuffer response.
func (client *SpatialClient) getBufferHandleResponse(resp *azcore.Response) (BufferResponseResponse, error) {
	var val *BufferResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BufferResponseResponse{}, err
	}
	return BufferResponseResponse{RawResponse: resp.Response, BufferResponse: val}, nil
}

// getBufferHandleError handles the GetBuffer error response.
func (client *SpatialClient) getBufferHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetClosestPoint - Applies to: S1 pricing tier.
// This API returns the closest point between a base point and a given set of points in the user uploaded data set identified by udid. The set of target
// points is provided by a GeoJSON file which is
// uploaded via Data Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] and referenced by a unique udid. The GeoJSON file may
// only contain a collection of Point geometry.
// MultiPoint or other geometries will be ignored if provided. The maximum number of points accepted is 100,000. The algorithm does not take into account
// routing or traffic. Information returned includes
// closest point latitude, longitude, and distance in meters from the closest point.
// To test this API, you can upload the sample data from Post Closest Point API [https://docs.microsoft.com/en-us/rest/api/maps/spatial/postclosestpoint#examples]
// examples(Request Body) via Data Upload
// API [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] and replace the [udid] from the sample request below
// [https://docs.microsoft.com/en-us/rest/api/maps/spatial/getclosestpoint#examples] with the udid returned by Data Upload API.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) GetClosestPoint(ctx context.Context, formatParam ResponseFormat, udid string, latitude float32, longitude float32, options *SpatialGetClosestPointOptions) (ClosestPointResponseResponse, error) {
	req, err := client.getClosestPointCreateRequest(ctx, formatParam, udid, latitude, longitude, options)
	if err != nil {
		return ClosestPointResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ClosestPointResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ClosestPointResponseResponse{}, client.getClosestPointHandleError(resp)
	}
	return client.getClosestPointHandleResponse(resp)
}

// getClosestPointCreateRequest creates the GetClosestPoint request.
func (client *SpatialClient) getClosestPointCreateRequest(ctx context.Context, formatParam ResponseFormat, udid string, latitude float32, longitude float32, options *SpatialGetClosestPointOptions) (*azcore.Request, error) {
	urlPath := "/spatial/closestPoint/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("udid", udid)
	reqQP.Set("lat", strconv.FormatFloat(float64(latitude), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(longitude), 'f', -1, 32))
	if options != nil && options.NumberOfClosestPoints != nil {
		reqQP.Set("numberOfClosestPoints", strconv.FormatInt(int64(*options.NumberOfClosestPoints), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getClosestPointHandleResponse handles the GetClosestPoint response.
func (client *SpatialClient) getClosestPointHandleResponse(resp *azcore.Response) (ClosestPointResponseResponse, error) {
	var val *ClosestPointResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ClosestPointResponseResponse{}, err
	}
	return ClosestPointResponseResponse{RawResponse: resp.Response, ClosestPointResponse: val}, nil
}

// getClosestPointHandleError handles the GetClosestPoint error response.
func (client *SpatialClient) getClosestPointHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetGeofence - Search Geofence Get API
// Applies to: S1 Pricing tier.
// The Geofence Get API allows you to retrieve the proximity of a coordinate to a geofence that has been uploaded to the Data service. You can use theData
// Upload API
// [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] to upload a geofence or set of fences. See Geofencing GeoJSON data
// [https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson] for more details on the geofence data format. To query the proximity of a coordinate,
// you supply the location of the object you are
// tracking as well as the ID for the fence or set of fences, and the response will contain information about the distance from the outer edge of the geofence.
// A negative value signifies that the
// coordinate is inside of the fence while a positive value means that it is outside of the fence.
// This API can be used for a variety of scenarios that include things like asset tracking, fleet management, or setting up alerts for moving objects.
// The API supports integration with Event Grid [https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration]. The isAsync parameter is
// used to enable integration with Event Grid
// (disabled by default). To test this API, you can upload the sample data from Post Geofence API examples(Request Body) via Data Upload API and replace
// the [udid] from the sample request below with the
// udid returned by Data Upload API.
// GEOFENCING INNERERROR CODE In geofencing response error contract, innererror is an object containing service specific information about the error. code
// is a property in innererror which can map to a
// specific geofencing error type. The table belows shows the code mapping between all the known client error type to the corresponding geofencing error
// message.
// INNERERROR.CODE ERROR.MESSAGE
// NullDeviceId Device Id should not be null.
// NullUdid Udid should not be null.
// UdidWrongFormat Udid should be acquired from user data ingestion API.
// InvalidUserTime Usertime is invalid.
// InvalidSearchBuffer Searchbuffer is invalid.
// InvalidSearchRange The value range of searchbuffer should be from 0 to 500 meters.
// InvalidLatLon Lat and/or lon parameters are invalid.
// InvalidIsAsyncValue The IsAsync parameter is invalid.
// InvalidModeValue The mode parameter invalid.
// InvalidJson Geofencing data is not a valid json file.
// NotSupportedGeoJson Geofencing data can't be read as a Feature or FeatureCollections.
// InvalidGeoJson Geofencing data is invalid.
// NoUserDataWithAccountOrSubscription Can't find user geofencing data with provided account-id and/or subscription-id.
// NoUserDataWithUdid Can't find user geofencing data with provided udid.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) GetGeofence(ctx context.Context, formatParam ResponseFormat, deviceID string, udid string, latitude float32, longitude float32, options *SpatialGetGeofenceOptions) (GeofenceResponseResponse, error) {
	req, err := client.getGeofenceCreateRequest(ctx, formatParam, deviceID, udid, latitude, longitude, options)
	if err != nil {
		return GeofenceResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GeofenceResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GeofenceResponseResponse{}, client.getGeofenceHandleError(resp)
	}
	return client.getGeofenceHandleResponse(resp)
}

// getGeofenceCreateRequest creates the GetGeofence request.
func (client *SpatialClient) getGeofenceCreateRequest(ctx context.Context, formatParam ResponseFormat, deviceID string, udid string, latitude float32, longitude float32, options *SpatialGetGeofenceOptions) (*azcore.Request, error) {
	urlPath := "/spatial/geofence/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("deviceId", deviceID)
	reqQP.Set("udid", udid)
	reqQP.Set("lat", strconv.FormatFloat(float64(latitude), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(longitude), 'f', -1, 32))
	if options != nil && options.Z != nil {
		reqQP.Set("z", strconv.FormatFloat(float64(*options.Z), 'f', -1, 32))
	}
	if options != nil && options.UserTime != nil {
		reqQP.Set("userTime", options.UserTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.SearchBuffer != nil {
		reqQP.Set("searchBuffer", strconv.FormatFloat(float64(*options.SearchBuffer), 'f', -1, 32))
	}
	if options != nil && options.IsAsync != nil {
		reqQP.Set("isAsync", strconv.FormatBool(*options.IsAsync))
	}
	if options != nil && options.Mode != nil {
		reqQP.Set("mode", string(*options.Mode))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGeofenceHandleResponse handles the GetGeofence response.
func (client *SpatialClient) getGeofenceHandleResponse(resp *azcore.Response) (GeofenceResponseResponse, error) {
	var val *GeofenceResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GeofenceResponseResponse{}, err
	}
	result := GeofenceResponseResponse{RawResponse: resp.Response, GeofenceResponse: val}
	if val := resp.Header.Get("X-Correlation-id"); val != "" {
		result.XCorrelationID = &val
	}
	return result, nil
}

// getGeofenceHandleError handles the GetGeofence error response.
func (client *SpatialClient) getGeofenceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetGreatCircleDistance - Applies to: S1 pricing tier.
// This API will return the great-circle or shortest distance between two points on the surface of a sphere, measured along the surface of the sphere. This
// differs from calculating a straight line
// through the sphere's interior. This method is helpful for estimating travel distances for airplanes by calculating the shortest distance between airports.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) GetGreatCircleDistance(ctx context.Context, formatParam ResponseFormat, query string, options *SpatialGetGreatCircleDistanceOptions) (GreatCircleDistanceResponseResponse, error) {
	req, err := client.getGreatCircleDistanceCreateRequest(ctx, formatParam, query, options)
	if err != nil {
		return GreatCircleDistanceResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GreatCircleDistanceResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GreatCircleDistanceResponseResponse{}, client.getGreatCircleDistanceHandleError(resp)
	}
	return client.getGreatCircleDistanceHandleResponse(resp)
}

// getGreatCircleDistanceCreateRequest creates the GetGreatCircleDistance request.
func (client *SpatialClient) getGreatCircleDistanceCreateRequest(ctx context.Context, formatParam ResponseFormat, query string, options *SpatialGetGreatCircleDistanceOptions) (*azcore.Request, error) {
	urlPath := "/spatial/greatCircleDistance/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("query", query)
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getGreatCircleDistanceHandleResponse handles the GetGreatCircleDistance response.
func (client *SpatialClient) getGreatCircleDistanceHandleResponse(resp *azcore.Response) (GreatCircleDistanceResponseResponse, error) {
	var val *GreatCircleDistanceResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GreatCircleDistanceResponseResponse{}, err
	}
	return GreatCircleDistanceResponseResponse{RawResponse: resp.Response, GreatCircleDistanceResponse: val}, nil
}

// getGreatCircleDistanceHandleError handles the GetGreatCircleDistance error response.
func (client *SpatialClient) getGreatCircleDistanceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetPointInPolygon - Applies to: S1 pricing tier.
// This API returns a boolean value indicating whether a point is inside a set of polygons. The set of polygons is provided by a GeoJSON file which is uploaded
// via Data Upload API
// [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] and referenced by a unique udid. The GeoJSON file may contain Polygon and MultiPolygon
// geometries, other geometries will be ignored
// if provided. If the point is inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value returned is
// false. When the point is inside multiple
// polygons, the result will give intersecting geometries section to show all valid geometries(referenced by geometryId) in user data. The maximum number
// of vertices accepted to form a Polygon is 10,000.
// To test this API, you can upload the sample data from Post Point In Polygon API [https://docs.microsoft.com/en-us/rest/api/maps/spatial/postpointinpolygon#examples]
// examples(Request Body) via Data
// Upload API [https://docs.microsoft.com/en-us/rest/api/maps/data/uploadPreview] and replace the [udid] from the sample request below
// [https://docs.microsoft.com/en-us/rest/api/maps/spatial/getpointinpolygon#examples] with the udid returned by Data Upload API.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) GetPointInPolygon(ctx context.Context, formatParam ResponseFormat, udid string, latitude float32, longitude float32, options *SpatialGetPointInPolygonOptions) (PointInPolygonResponseResponse, error) {
	req, err := client.getPointInPolygonCreateRequest(ctx, formatParam, udid, latitude, longitude, options)
	if err != nil {
		return PointInPolygonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PointInPolygonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PointInPolygonResponseResponse{}, client.getPointInPolygonHandleError(resp)
	}
	return client.getPointInPolygonHandleResponse(resp)
}

// getPointInPolygonCreateRequest creates the GetPointInPolygon request.
func (client *SpatialClient) getPointInPolygonCreateRequest(ctx context.Context, formatParam ResponseFormat, udid string, latitude float32, longitude float32, options *SpatialGetPointInPolygonOptions) (*azcore.Request, error) {
	urlPath := "/spatial/pointInPolygon/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("udid", udid)
	reqQP.Set("lat", strconv.FormatFloat(float64(latitude), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(longitude), 'f', -1, 32))
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getPointInPolygonHandleResponse handles the GetPointInPolygon response.
func (client *SpatialClient) getPointInPolygonHandleResponse(resp *azcore.Response) (PointInPolygonResponseResponse, error) {
	var val *PointInPolygonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PointInPolygonResponseResponse{}, err
	}
	return PointInPolygonResponseResponse{RawResponse: resp.Response, PointInPolygonResponse: val}, nil
}

// getPointInPolygonHandleError handles the GetPointInPolygon error response.
func (client *SpatialClient) getPointInPolygonHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostBuffer - Applies to: S1 pricing tier.
// This API returns a FeatureCollection where each Feature is a buffer around the corresponding indexed Feature of the input. The buffer could be either
// on the outside or the inside of the provided
// Feature, depending on the distance provided in the input. There must be either one distance provided per Feature in the FeatureCollection input, or if
// only one distance is provided, then that distance
// is applied to every Feature in the collection. The positive (or negative) buffer of a geometry is defined as the Minkowski sum (or difference) of the
// geometry with a circle of radius equal to the
// absolute value of the buffer distance. The buffer API always returns a polygonal result. The negative or zero-distance buffer of lines and points is
// always an empty polygon. The input may contain a
// collection of Point, MultiPoint, Polygon, MultiPolygon, LineString and MultiLineString. GeometryCollection will be ignored if provided.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) PostBuffer(ctx context.Context, formatParam ResponseFormat, bufferRequestBody BufferRequestBody, options *SpatialPostBufferOptions) (BufferResponseResponse, error) {
	req, err := client.postBufferCreateRequest(ctx, formatParam, bufferRequestBody, options)
	if err != nil {
		return BufferResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return BufferResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return BufferResponseResponse{}, client.postBufferHandleError(resp)
	}
	return client.postBufferHandleResponse(resp)
}

// postBufferCreateRequest creates the PostBuffer request.
func (client *SpatialClient) postBufferCreateRequest(ctx context.Context, formatParam ResponseFormat, bufferRequestBody BufferRequestBody, options *SpatialPostBufferOptions) (*azcore.Request, error) {
	urlPath := "/spatial/buffer/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(bufferRequestBody)
}

// postBufferHandleResponse handles the PostBuffer response.
func (client *SpatialClient) postBufferHandleResponse(resp *azcore.Response) (BufferResponseResponse, error) {
	var val *BufferResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return BufferResponseResponse{}, err
	}
	return BufferResponseResponse{RawResponse: resp.Response, BufferResponse: val}, nil
}

// postBufferHandleError handles the PostBuffer error response.
func (client *SpatialClient) postBufferHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostClosestPoint - Applies to: S1 pricing tier.
// This API returns the closest point between a base point and a given set of target points. The set of target points is provided by user data in post request
// body. The user data may only contain a
// collection of Point geometry. MultiPoint or other geometries will be ignored if provided. The algorithm does not take into account routing or traffic.
// The maximum number of points accepted is 100,000.
// Information returned includes closest point latitude, longitude, and distance in meters from the closest point.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) PostClosestPoint(ctx context.Context, formatParam ResponseFormat, latitude float32, longitude float32, closestPointRequestBody GeoJSONFeatureCollectionClassification, options *SpatialPostClosestPointOptions) (ClosestPointResponseResponse, error) {
	req, err := client.postClosestPointCreateRequest(ctx, formatParam, latitude, longitude, closestPointRequestBody, options)
	if err != nil {
		return ClosestPointResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ClosestPointResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ClosestPointResponseResponse{}, client.postClosestPointHandleError(resp)
	}
	return client.postClosestPointHandleResponse(resp)
}

// postClosestPointCreateRequest creates the PostClosestPoint request.
func (client *SpatialClient) postClosestPointCreateRequest(ctx context.Context, formatParam ResponseFormat, latitude float32, longitude float32, closestPointRequestBody GeoJSONFeatureCollectionClassification, options *SpatialPostClosestPointOptions) (*azcore.Request, error) {
	urlPath := "/spatial/closestPoint/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("lat", strconv.FormatFloat(float64(latitude), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(longitude), 'f', -1, 32))
	if options != nil && options.NumberOfClosestPoints != nil {
		reqQP.Set("numberOfClosestPoints", strconv.FormatInt(int64(*options.NumberOfClosestPoints), 10))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(closestPointRequestBody)
}

// postClosestPointHandleResponse handles the PostClosestPoint response.
func (client *SpatialClient) postClosestPointHandleResponse(resp *azcore.Response) (ClosestPointResponseResponse, error) {
	var val *ClosestPointResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ClosestPointResponseResponse{}, err
	}
	return ClosestPointResponseResponse{RawResponse: resp.Response, ClosestPointResponse: val}, nil
}

// postClosestPointHandleError handles the PostClosestPoint error response.
func (client *SpatialClient) postClosestPointHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostGeofence - Search Geofence Post APIApplies to: S1 Pricing tier. The Geofence Post API allows you to retrieve the proximity of a coordinate to a provided
// geofence or set of fences. With POST call, you do not have
// to upload the fence data in advance, instead you supply the location of the object you are tracking in query parameters as well as the fence or set of
// fences data in post request body. See Geofencing
// GeoJSON data [https://docs.microsoft.com/en-us/azure/azure-maps/geofence-geojson] for more details on the geofence data format. The response will contain
// information about the distance from the outer
// edge of the geofence. A negative value signifies that the coordinate is inside of the fence while a positive value means that it is outside of the fence.
// This API can be used for a variety of scenarios that include things like asset tracking, fleet management, or setting up alerts for moving objects.
// The API supports integration with Event Grid [https://docs.microsoft.com/azure/azure-maps/azure-maps-event-grid-integration]. The isAsync parameter is
// used to enable integration with Event Grid
// (disabled by default).
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) PostGeofence(ctx context.Context, formatParam ResponseFormat, deviceID string, latitude float32, longitude float32, searchGeofenceRequestBody GeoJSONFeatureCollectionClassification, options *SpatialPostGeofenceOptions) (GeofenceResponseResponse, error) {
	req, err := client.postGeofenceCreateRequest(ctx, formatParam, deviceID, latitude, longitude, searchGeofenceRequestBody, options)
	if err != nil {
		return GeofenceResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GeofenceResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GeofenceResponseResponse{}, client.postGeofenceHandleError(resp)
	}
	return client.postGeofenceHandleResponse(resp)
}

// postGeofenceCreateRequest creates the PostGeofence request.
func (client *SpatialClient) postGeofenceCreateRequest(ctx context.Context, formatParam ResponseFormat, deviceID string, latitude float32, longitude float32, searchGeofenceRequestBody GeoJSONFeatureCollectionClassification, options *SpatialPostGeofenceOptions) (*azcore.Request, error) {
	urlPath := "/spatial/geofence/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("deviceId", deviceID)
	reqQP.Set("lat", strconv.FormatFloat(float64(latitude), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(longitude), 'f', -1, 32))
	if options != nil && options.Z != nil {
		reqQP.Set("z", strconv.FormatFloat(float64(*options.Z), 'f', -1, 32))
	}
	if options != nil && options.UserTime != nil {
		reqQP.Set("userTime", options.UserTime.Format(time.RFC3339Nano))
	}
	if options != nil && options.SearchBuffer != nil {
		reqQP.Set("searchBuffer", strconv.FormatFloat(float64(*options.SearchBuffer), 'f', -1, 32))
	}
	if options != nil && options.IsAsync != nil {
		reqQP.Set("isAsync", strconv.FormatBool(*options.IsAsync))
	}
	if options != nil && options.Mode != nil {
		reqQP.Set("mode", string(*options.Mode))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(searchGeofenceRequestBody)
}

// postGeofenceHandleResponse handles the PostGeofence response.
func (client *SpatialClient) postGeofenceHandleResponse(resp *azcore.Response) (GeofenceResponseResponse, error) {
	var val *GeofenceResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GeofenceResponseResponse{}, err
	}
	result := GeofenceResponseResponse{RawResponse: resp.Response, GeofenceResponse: val}
	if val := resp.Header.Get("X-Correlation-id"); val != "" {
		result.XCorrelationID = &val
	}
	return result, nil
}

// postGeofenceHandleError handles the PostGeofence error response.
func (client *SpatialClient) postGeofenceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// PostPointInPolygon - Applies to: S1 pricing tier.
// This API returns a boolean value indicating whether a point is inside a set of polygons. The user data may contain Polygon and MultiPolygon geometries,
// other geometries will be ignored if provided. If
// the point is inside or on the boundary of one of these polygons, the value returned is true. In all other cases, the value returned is false. When the
// point is inside multiple polygons, the result
// will give intersecting geometries section to show all valid geometries (referenced by geometryId) in user data. The maximum number of vertices accepted
// to form a Polygon is 10,000.
// If the operation fails it returns the *ErrorResponse error type.
func (client *SpatialClient) PostPointInPolygon(ctx context.Context, formatParam ResponseFormat, latitude float32, longitude float32, pointInPolygonRequestBody GeoJSONFeatureCollectionClassification, options *SpatialPostPointInPolygonOptions) (PointInPolygonResponseResponse, error) {
	req, err := client.postPointInPolygonCreateRequest(ctx, formatParam, latitude, longitude, pointInPolygonRequestBody, options)
	if err != nil {
		return PointInPolygonResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return PointInPolygonResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return PointInPolygonResponseResponse{}, client.postPointInPolygonHandleError(resp)
	}
	return client.postPointInPolygonHandleResponse(resp)
}

// postPointInPolygonCreateRequest creates the PostPointInPolygon request.
func (client *SpatialClient) postPointInPolygonCreateRequest(ctx context.Context, formatParam ResponseFormat, latitude float32, longitude float32, pointInPolygonRequestBody GeoJSONFeatureCollectionClassification, options *SpatialPostPointInPolygonOptions) (*azcore.Request, error) {
	urlPath := "/spatial/pointInPolygon/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodPost, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("lat", strconv.FormatFloat(float64(latitude), 'f', -1, 32))
	reqQP.Set("lon", strconv.FormatFloat(float64(longitude), 'f', -1, 32))
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, req.MarshalAsJSON(pointInPolygonRequestBody)
}

// postPointInPolygonHandleResponse handles the PostPointInPolygon response.
func (client *SpatialClient) postPointInPolygonHandleResponse(resp *azcore.Response) (PointInPolygonResponseResponse, error) {
	var val *PointInPolygonResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return PointInPolygonResponseResponse{}, err
	}
	return PointInPolygonResponseResponse{RawResponse: resp.Response, PointInPolygonResponse: val}, nil
}

// postPointInPolygonHandleError handles the PostPointInPolygon error response.
func (client *SpatialClient) postPointInPolygonHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
