// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package creator

import (
	"context"
	"errors"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

type wfsClient struct {
	con *connection
	xmsClientID *string
}

// DeleteFeature - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema. The Delete Feature API deletes the feature identified by the provided id in the given collection. At this point this API supports
// only facility features. Deleting a facility
// feature deletes all the child features of that facility recursively.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) DeleteFeature(ctx context.Context, datasetID string, collectionID string, featureID string, options *WFSDeleteFeatureOptions) (*http.Response, error) {
	req, err := client.deleteFeatureCreateRequest(ctx, datasetID, collectionID, featureID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return nil, err
	}
	if !resp.HasStatusCode(http.StatusNoContent) {
		return nil, client.deleteFeatureHandleError(resp)
	}
	return resp.Response, nil
}

// deleteFeatureCreateRequest creates the DeleteFeature request.
func (client *wfsClient) deleteFeatureCreateRequest(ctx context.Context, datasetID string, collectionID string, featureID string, options *WFSDeleteFeatureOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/collections/{collectionId}/items/{featureId}"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	if collectionID == "" {
		return nil, errors.New("parameter collectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionId}", url.PathEscape(collectionID))
	if featureID == "" {
		return nil, errors.New("parameter featureID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{featureId}", url.PathEscape(featureID))
	req, err := azcore.NewRequest(ctx, http.MethodDelete, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// deleteFeatureHandleError handles the DeleteFeature error response.
func (client *wfsClient) deleteFeatureHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCollection - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema.
// The Collection Description API provides the description of a given collection. It includes the links to the operations that can be performed on the collection.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetCollection(ctx context.Context, datasetID string, collectionID string, options *WFSGetCollectionOptions) (CollectionInfoResponse, error) {
	req, err := client.getCollectionCreateRequest(ctx, datasetID, collectionID, options)
	if err != nil {
		return CollectionInfoResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CollectionInfoResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CollectionInfoResponse{}, client.getCollectionHandleError(resp)
	}
	return client.getCollectionHandleResponse(resp)
}

// getCollectionCreateRequest creates the GetCollection request.
func (client *wfsClient) getCollectionCreateRequest(ctx context.Context, datasetID string, collectionID string, options *WFSGetCollectionOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/collections/{collectionId}"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	if collectionID == "" {
		return nil, errors.New("parameter collectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionId}", url.PathEscape(collectionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCollectionHandleResponse handles the GetCollection response.
func (client *wfsClient) getCollectionHandleResponse(resp *azcore.Response) (CollectionInfoResponse, error) {
	var val *CollectionInfo
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CollectionInfoResponse{}, err
	}
return CollectionInfoResponse{RawResponse: resp.Response, CollectionInfo: val}, nil
}

// getCollectionHandleError handles the GetCollection error response.
func (client *wfsClient) getCollectionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCollectionDefinition - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// This [https://docs.microsoft.com/en-us/azure/azure-maps/creator-indoor-maps] article introduces concepts and tools that apply to Azure Maps Creator.
// WFS API follows the Open Geospatial Consortium API
// standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html] to query Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview].
// A dataset consists of
// multiple feature collections. A feature collection is a collection of features of a similar type, based on a common schema.
// The Collection Definition API provides the detailed data model of a given collection.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetCollectionDefinition(ctx context.Context, datasetID string, collectionID string, options *WFSGetCollectionDefinitionOptions) (CollectionDefinitionResponseResponse, error) {
	req, err := client.getCollectionDefinitionCreateRequest(ctx, datasetID, collectionID, options)
	if err != nil {
		return CollectionDefinitionResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CollectionDefinitionResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CollectionDefinitionResponseResponse{}, client.getCollectionDefinitionHandleError(resp)
	}
	return client.getCollectionDefinitionHandleResponse(resp)
}

// getCollectionDefinitionCreateRequest creates the GetCollectionDefinition request.
func (client *wfsClient) getCollectionDefinitionCreateRequest(ctx context.Context, datasetID string, collectionID string, options *WFSGetCollectionDefinitionOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/collections/{collectionId}/definition"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	if collectionID == "" {
		return nil, errors.New("parameter collectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionId}", url.PathEscape(collectionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCollectionDefinitionHandleResponse handles the GetCollectionDefinition response.
func (client *wfsClient) getCollectionDefinitionHandleResponse(resp *azcore.Response) (CollectionDefinitionResponseResponse, error) {
	var val *CollectionDefinitionResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CollectionDefinitionResponseResponse{}, err
	}
return CollectionDefinitionResponseResponse{RawResponse: resp.Response, CollectionDefinitionResponse: val}, nil
}

// getCollectionDefinitionHandleError handles the GetCollectionDefinition error response.
func (client *wfsClient) getCollectionDefinitionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCollections - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema. The Collections Description API provides descriptions of all the collections in a given dataset.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetCollections(ctx context.Context, datasetID string, options *WFSGetCollectionsOptions) (CollectionsResponseResponse, error) {
	req, err := client.getCollectionsCreateRequest(ctx, datasetID, options)
	if err != nil {
		return CollectionsResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return CollectionsResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return CollectionsResponseResponse{}, client.getCollectionsHandleError(resp)
	}
	return client.getCollectionsHandleResponse(resp)
}

// getCollectionsCreateRequest creates the GetCollections request.
func (client *wfsClient) getCollectionsCreateRequest(ctx context.Context, datasetID string, options *WFSGetCollectionsOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/collections"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCollectionsHandleResponse handles the GetCollections response.
func (client *wfsClient) getCollectionsHandleResponse(resp *azcore.Response) (CollectionsResponseResponse, error) {
	var val *CollectionsResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return CollectionsResponseResponse{}, err
	}
return CollectionsResponseResponse{RawResponse: resp.Response, CollectionsResponse: val}, nil
}

// getCollectionsHandleError handles the GetCollections error response.
func (client *wfsClient) getCollectionsHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetConformance - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema. The Get Requirements Classes lists all requirements classes specified in the standard that the server conforms to.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetConformance(ctx context.Context, datasetID string, options *WFSGetConformanceOptions) (ConformanceResponseResponse, error) {
	req, err := client.getConformanceCreateRequest(ctx, datasetID, options)
	if err != nil {
		return ConformanceResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ConformanceResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ConformanceResponseResponse{}, client.getConformanceHandleError(resp)
	}
	return client.getConformanceHandleResponse(resp)
}

// getConformanceCreateRequest creates the GetConformance request.
func (client *wfsClient) getConformanceCreateRequest(ctx context.Context, datasetID string, options *WFSGetConformanceOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/conformance"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getConformanceHandleResponse handles the GetConformance response.
func (client *wfsClient) getConformanceHandleResponse(resp *azcore.Response) (ConformanceResponseResponse, error) {
	var val *ConformanceResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ConformanceResponseResponse{}, err
	}
return ConformanceResponseResponse{RawResponse: resp.Response, ConformanceResponse: val}, nil
}

// getConformanceHandleError handles the GetConformance error response.
func (client *wfsClient) getConformanceHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetFeature - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema. The Get Feature API returns the feature identified by the provided id in the given collection.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetFeature(ctx context.Context, datasetID string, collectionID string, featureID string, options *WFSGetFeatureOptions) (FeatureResponseResponse, error) {
	req, err := client.getFeatureCreateRequest(ctx, datasetID, collectionID, featureID, options)
	if err != nil {
		return FeatureResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return FeatureResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return FeatureResponseResponse{}, client.getFeatureHandleError(resp)
	}
	return client.getFeatureHandleResponse(resp)
}

// getFeatureCreateRequest creates the GetFeature request.
func (client *wfsClient) getFeatureCreateRequest(ctx context.Context, datasetID string, collectionID string, featureID string, options *WFSGetFeatureOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/collections/{collectionId}/items/{featureId}"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	if collectionID == "" {
		return nil, errors.New("parameter collectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionId}", url.PathEscape(collectionID))
	if featureID == "" {
		return nil, errors.New("parameter featureID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{featureId}", url.PathEscape(featureID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFeatureHandleResponse handles the GetFeature response.
func (client *wfsClient) getFeatureHandleResponse(resp *azcore.Response) (FeatureResponseResponse, error) {
	var val *FeatureResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return FeatureResponseResponse{}, err
	}
return FeatureResponseResponse{RawResponse: resp.Response, FeatureResponse: val}, nil
}

// getFeatureHandleError handles the GetFeature error response.
func (client *wfsClient) getFeatureHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetFeatures - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema. The Get Features API returns the list of features in the given collection.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetFeatures(ctx context.Context, datasetID string, collectionID string, options *WFSGetFeaturesOptions) (ExtendedGeoJSONFeatureCollectionResponse, error) {
	req, err := client.getFeaturesCreateRequest(ctx, datasetID, collectionID, options)
	if err != nil {
		return ExtendedGeoJSONFeatureCollectionResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return ExtendedGeoJSONFeatureCollectionResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return ExtendedGeoJSONFeatureCollectionResponse{}, client.getFeaturesHandleError(resp)
	}
	return client.getFeaturesHandleResponse(resp)
}

// getFeaturesCreateRequest creates the GetFeatures request.
func (client *wfsClient) getFeaturesCreateRequest(ctx context.Context, datasetID string, collectionID string, options *WFSGetFeaturesOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/collections/{collectionId}/items"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	if collectionID == "" {
		return nil, errors.New("parameter collectionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{collectionId}", url.PathEscape(collectionID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	if options != nil && options.Limit != nil {
		reqQP.Set("limit", strconv.FormatInt(int64(*options.Limit), 10))
	}
	if options != nil && options.Bbox != nil {
		reqQP.Set("bbox", *options.Bbox)
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("filter", *options.Filter)
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getFeaturesHandleResponse handles the GetFeatures response.
func (client *wfsClient) getFeaturesHandleResponse(resp *azcore.Response) (ExtendedGeoJSONFeatureCollectionResponse, error) {
	var val *ExtendedGeoJSONFeatureCollection
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return ExtendedGeoJSONFeatureCollectionResponse{}, err
	}
return ExtendedGeoJSONFeatureCollectionResponse{RawResponse: resp.Response, ExtendedGeoJSONFeatureCollection: val}, nil
}

// getFeaturesHandleError handles the GetFeatures error response.
func (client *wfsClient) getFeaturesHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetLandingPage - Applies to: see pricing tiers [https://aka.ms/AzureMapsPricingTier].
// Creator makes it possible to develop applications based on your private indoor map data using Azure Maps API and SDK. This [https://docs.microsoft.com/azure/azure-maps/creator-indoor-maps]
// article
// introduces concepts and tools that apply to Azure Maps Creator.
// The Web Feature Service (WFS) API is part of Creator. WFS API follows the Open Geospatial Consortium API standard for Features [http://docs.opengeospatial.org/is/17-069r3/17-069r3.html]
// to query
// Datasets [https://docs.microsoft.com/en-us/rest/api/maps/dataset/createpreview]. A dataset consists of multiple feature collections. A feature collection
// is a collection of features of a similar type,
// based on a common schema. The Get Landing Page API provides links to the API definition, the Conformance statements and the metadata about the feature
// data in this dataset.
// If the operation fails it returns the *ErrorResponse error type.
func (client *wfsClient) GetLandingPage(ctx context.Context, datasetID string, options *WFSGetLandingPageOptions) (LandingPageResponseResponse, error) {
	req, err := client.getLandingPageCreateRequest(ctx, datasetID, options)
	if err != nil {
		return LandingPageResponseResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return LandingPageResponseResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return LandingPageResponseResponse{}, client.getLandingPageHandleError(resp)
	}
	return client.getLandingPageHandleResponse(resp)
}

// getLandingPageCreateRequest creates the GetLandingPage request.
func (client *wfsClient) getLandingPageCreateRequest(ctx context.Context, datasetID string, options *WFSGetLandingPageOptions) (*azcore.Request, error) {
	urlPath := "/wfs/datasets/{datasetId}/"
	if datasetID == "" {
		return nil, errors.New("parameter datasetID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{datasetId}", url.PathEscape(datasetID))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getLandingPageHandleResponse handles the GetLandingPage response.
func (client *wfsClient) getLandingPageHandleResponse(resp *azcore.Response) (LandingPageResponseResponse, error) {
	var val *LandingPageResponse
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return LandingPageResponseResponse{}, err
	}
return LandingPageResponseResponse{RawResponse: resp.Response, LandingPageResponse: val}, nil
}

// getLandingPageHandleError handles the GetLandingPage error response.
func (client *wfsClient) getLandingPageHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

