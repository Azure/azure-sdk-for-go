// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package render

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// RenderClient contains the methods for the Render group.
// Don't use this type directly, use NewRenderClient() instead.
type RenderClient struct {
	con         *Connection
	xmsClientID *string
}

// NewRenderClient creates a new instance of RenderClient with the specified values.
func NewRenderClient(con *Connection, xmsClientID *string) *RenderClient {
	return &RenderClient{
		con:         NewConnection(con.cp.geography, ClientIdCredScaffold{con.cp.cred, xmsClientID}, con.cp.options),
		xmsClientID: xmsClientID,
	}
}

// GetCopyrightCaption - Applies to: S0 and S1 pricing tiers.
// Copyrights API is designed to serve copyright information for Render Tile service. In addition to basic copyright for the whole map, API is serving specific
// groups of copyrights for some countries.
// As an alternative to copyrights for map request, one can receive captions for displaying the map provider information on the map.
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetCopyrightCaption(ctx context.Context, formatParam TextFormat, options *RenderGetCopyrightCaptionOptions) (GetCopyrightCaptionResultResponse, error) {
	req, err := client.getCopyrightCaptionCreateRequest(ctx, formatParam, options)
	if err != nil {
		return GetCopyrightCaptionResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GetCopyrightCaptionResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GetCopyrightCaptionResultResponse{}, client.getCopyrightCaptionHandleError(resp)
	}
	return client.getCopyrightCaptionHandleResponse(resp)
}

// getCopyrightCaptionCreateRequest creates the GetCopyrightCaption request.
func (client *RenderClient) getCopyrightCaptionCreateRequest(ctx context.Context, formatParam TextFormat, options *RenderGetCopyrightCaptionOptions) (*azcore.Request, error) {
	urlPath := "/map/copyright/caption/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCopyrightCaptionHandleResponse handles the GetCopyrightCaption response.
func (client *RenderClient) getCopyrightCaptionHandleResponse(resp *azcore.Response) (GetCopyrightCaptionResultResponse, error) {
	var val *GetCopyrightCaptionResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GetCopyrightCaptionResultResponse{}, err
	}
	return GetCopyrightCaptionResultResponse{RawResponse: resp.Response, GetCopyrightCaptionResult: val}, nil
}

// getCopyrightCaptionHandleError handles the GetCopyrightCaption error response.
func (client *RenderClient) getCopyrightCaptionHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCopyrightForTile - Applies to: S0 and S1 pricing tiers.
// Copyrights API is designed to serve copyright information for Render Tile service. In addition to basic copyright for the whole map, API is serving specific
// groups of copyrights for some countries.
// Returns the copyright information for a given tile. To obtain the copyright information for a particular tile, the request should specify the tile's
// zoom level and x and y coordinates (see: Zoom
// Levels and Tile Grid).
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetCopyrightForTile(ctx context.Context, formatParam TextFormat, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderGetCopyrightForTileOptions) (GetCopyrightForTileResultResponse, error) {
	req, err := client.getCopyrightForTileCreateRequest(ctx, formatParam, zoom, xTileIndex, yTileIndex, options)
	if err != nil {
		return GetCopyrightForTileResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GetCopyrightForTileResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GetCopyrightForTileResultResponse{}, client.getCopyrightForTileHandleError(resp)
	}
	return client.getCopyrightForTileHandleResponse(resp)
}

// getCopyrightForTileCreateRequest creates the GetCopyrightForTile request.
func (client *RenderClient) getCopyrightForTileCreateRequest(ctx context.Context, formatParam TextFormat, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderGetCopyrightForTileOptions) (*azcore.Request, error) {
	urlPath := "/map/copyright/tile/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("zoom", strconv.FormatInt(int64(zoom), 10))
	reqQP.Set("x", strconv.FormatInt(int64(xTileIndex), 10))
	reqQP.Set("y", strconv.FormatInt(int64(yTileIndex), 10))
	if options != nil && options.Text != nil {
		reqQP.Set("text", string(*options.Text))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCopyrightForTileHandleResponse handles the GetCopyrightForTile response.
func (client *RenderClient) getCopyrightForTileHandleResponse(resp *azcore.Response) (GetCopyrightForTileResultResponse, error) {
	var val *GetCopyrightForTileResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GetCopyrightForTileResultResponse{}, err
	}
	return GetCopyrightForTileResultResponse{RawResponse: resp.Response, GetCopyrightForTileResult: val}, nil
}

// getCopyrightForTileHandleError handles the GetCopyrightForTile error response.
func (client *RenderClient) getCopyrightForTileHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCopyrightForWorld - Applies to: S0 and S1 pricing tiers.
// Copyrights API is designed to serve copyright information for Render Tile service. In addition to basic copyright for the whole map, API is serving specific
// groups of copyrights for some countries.
// Returns the copyright information for the world. To obtain the default copyright information for the whole world, do not specify a tile or bounding box.
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetCopyrightForWorld(ctx context.Context, formatParam TextFormat, options *RenderGetCopyrightForWorldOptions) (GetCopyrightForWorldResultResponse, error) {
	req, err := client.getCopyrightForWorldCreateRequest(ctx, formatParam, options)
	if err != nil {
		return GetCopyrightForWorldResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GetCopyrightForWorldResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GetCopyrightForWorldResultResponse{}, client.getCopyrightForWorldHandleError(resp)
	}
	return client.getCopyrightForWorldHandleResponse(resp)
}

// getCopyrightForWorldCreateRequest creates the GetCopyrightForWorld request.
func (client *RenderClient) getCopyrightForWorldCreateRequest(ctx context.Context, formatParam TextFormat, options *RenderGetCopyrightForWorldOptions) (*azcore.Request, error) {
	urlPath := "/map/copyright/world/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Text != nil {
		reqQP.Set("text", string(*options.Text))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCopyrightForWorldHandleResponse handles the GetCopyrightForWorld response.
func (client *RenderClient) getCopyrightForWorldHandleResponse(resp *azcore.Response) (GetCopyrightForWorldResultResponse, error) {
	var val *GetCopyrightForWorldResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GetCopyrightForWorldResultResponse{}, err
	}
	return GetCopyrightForWorldResultResponse{RawResponse: resp.Response, GetCopyrightForWorldResult: val}, nil
}

// getCopyrightForWorldHandleError handles the GetCopyrightForWorld error response.
func (client *RenderClient) getCopyrightForWorldHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetCopyrightFromBoundingBox - Applies to: S0 and S1 pricing tiers.
// Returns copyright information for a given bounding box. Bounding-box requests should specify the minimum and maximum longitude and latitude (EPSG-3857)
// coordinates
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetCopyrightFromBoundingBox(ctx context.Context, formatParam TextFormat, mincoordinates string, maxcoordinates string, options *RenderGetCopyrightFromBoundingBoxOptions) (GetCopyrightFromBoundingBoxResultResponse, error) {
	req, err := client.getCopyrightFromBoundingBoxCreateRequest(ctx, formatParam, mincoordinates, maxcoordinates, options)
	if err != nil {
		return GetCopyrightFromBoundingBoxResultResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return GetCopyrightFromBoundingBoxResultResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return GetCopyrightFromBoundingBoxResultResponse{}, client.getCopyrightFromBoundingBoxHandleError(resp)
	}
	return client.getCopyrightFromBoundingBoxHandleResponse(resp)
}

// getCopyrightFromBoundingBoxCreateRequest creates the GetCopyrightFromBoundingBox request.
func (client *RenderClient) getCopyrightFromBoundingBoxCreateRequest(ctx context.Context, formatParam TextFormat, mincoordinates string, maxcoordinates string, options *RenderGetCopyrightFromBoundingBoxOptions) (*azcore.Request, error) {
	urlPath := "/map/copyright/bounding/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("mincoordinates", mincoordinates)
	reqQP.Set("maxcoordinates", maxcoordinates)
	if options != nil && options.Text != nil {
		reqQP.Set("text", string(*options.Text))
	}
	req.URL.RawQuery = reqQP.Encode()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json")
	return req, nil
}

// getCopyrightFromBoundingBoxHandleResponse handles the GetCopyrightFromBoundingBox response.
func (client *RenderClient) getCopyrightFromBoundingBoxHandleResponse(resp *azcore.Response) (GetCopyrightFromBoundingBoxResultResponse, error) {
	var val *GetCopyrightFromBoundingBoxResult
	if err := resp.UnmarshalAsJSON(&val); err != nil {
		return GetCopyrightFromBoundingBoxResultResponse{}, err
	}
	return GetCopyrightFromBoundingBoxResultResponse{RawResponse: resp.Response, GetCopyrightFromBoundingBoxResult: val}, nil
}

// getCopyrightFromBoundingBoxHandleError handles the GetCopyrightFromBoundingBox error response.
func (client *RenderClient) getCopyrightFromBoundingBoxHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMapImageryTile - Applies to: S1 pricing tier.
// This service returns a map image tile with size 256x256, given the x and y coordinates and zoom level. Zoom level ranges from 1 to 19. The current available
// style value is 'satellite' which provides
// satellite imagery alone.
// Note: We recommend to start to use the new Get Map Tile V2 API [https://aka.ms/GetMapTileV2].
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetMapImageryTile(ctx context.Context, formatParam RasterTileFormat, style MapImageryStyle, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderGetMapImageryTileOptions) (RenderGetMapImageryTileResponse, error) {
	req, err := client.getMapImageryTileCreateRequest(ctx, formatParam, style, zoom, xTileIndex, yTileIndex, options)
	if err != nil {
		return RenderGetMapImageryTileResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RenderGetMapImageryTileResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RenderGetMapImageryTileResponse{}, client.getMapImageryTileHandleError(resp)
	}
	return client.getMapImageryTileHandleResponse(resp)
}

// getMapImageryTileCreateRequest creates the GetMapImageryTile request.
func (client *RenderClient) getMapImageryTileCreateRequest(ctx context.Context, formatParam RasterTileFormat, style MapImageryStyle, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderGetMapImageryTileOptions) (*azcore.Request, error) {
	urlPath := "/map/imagery/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("style", string(style))
	reqQP.Set("zoom", strconv.FormatInt(int64(zoom), 10))
	reqQP.Set("x", strconv.FormatInt(int64(xTileIndex), 10))
	reqQP.Set("y", strconv.FormatInt(int64(yTileIndex), 10))
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json, image/jpeg, image/png")
	return req, nil
}

// getMapImageryTileHandleResponse handles the GetMapImageryTile response.
func (client *RenderClient) getMapImageryTileHandleResponse(resp *azcore.Response) (RenderGetMapImageryTileResponse, error) {
	result := RenderGetMapImageryTileResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// getMapImageryTileHandleError handles the GetMapImageryTile error response.
func (client *RenderClient) getMapImageryTileHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMapStateTilePreview - Applies to: S0 and S1 pricing tiers.
// Fetches state tiles in vector format typically to be integrated into indoor maps module of map control or SDK. The map control will call this API after
// user turns on dynamic styling (see Zoom Levels
// and Tile Grid [https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid])
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetMapStateTilePreview(ctx context.Context, zoom int32, xTileIndex int32, yTileIndex int32, statesetID string, options *RenderGetMapStateTilePreviewOptions) (RenderGetMapStateTilePreviewResponse, error) {
	req, err := client.getMapStateTilePreviewCreateRequest(ctx, zoom, xTileIndex, yTileIndex, statesetID, options)
	if err != nil {
		return RenderGetMapStateTilePreviewResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RenderGetMapStateTilePreviewResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RenderGetMapStateTilePreviewResponse{}, client.getMapStateTilePreviewHandleError(resp)
	}
	return client.getMapStateTilePreviewHandleResponse(resp)
}

// getMapStateTilePreviewCreateRequest creates the GetMapStateTilePreview request.
func (client *RenderClient) getMapStateTilePreviewCreateRequest(ctx context.Context, zoom int32, xTileIndex int32, yTileIndex int32, statesetID string, options *RenderGetMapStateTilePreviewOptions) (*azcore.Request, error) {
	urlPath := "/map/statetile"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("zoom", strconv.FormatInt(int64(zoom), 10))
	reqQP.Set("x", strconv.FormatInt(int64(xTileIndex), 10))
	reqQP.Set("y", strconv.FormatInt(int64(yTileIndex), 10))
	reqQP.Set("statesetId", statesetID)
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/vnd.mapbox-vector-tile, application/json")
	return req, nil
}

// getMapStateTilePreviewHandleResponse handles the GetMapStateTilePreview response.
func (client *RenderClient) getMapStateTilePreviewHandleResponse(resp *azcore.Response) (RenderGetMapStateTilePreviewResponse, error) {
	result := RenderGetMapStateTilePreviewResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// getMapStateTilePreviewHandleError handles the GetMapStateTilePreview error response.
func (client *RenderClient) getMapStateTilePreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMapStaticImage - Applies to: S0 and S1 pricing tiers.
// The static image service renders a user-defined, rectangular image containing a map section using a zoom level from 0 to 20. The static image service
// renders a user-defined, rectangular image
// containing a map section using a zoom level from 0 to 20. The supported resolution range for the map image is from 1x1 to 8192x8192. If you are deciding
// when to use the static image service over the
// map tile service, you may want to consider how you would like to interact with the rendered map. If the map contents will be relatively unchanging, a
// static map is a good choice. If you want to
// support a lot of zooming, panning and changing of the map content, the map tile service would be a better choice.
// Service also provides Image Composition functionality to get a static image back with additional data like; pushpins and geometry overlays with following
// S0 and S1 capabilities.
// In S0 you can:
// * Render up to 5 pushpins specified in the request
// * Provide one custom image for the pins referenced in the request
// * Add labels to the pushpins
// In S1 you can:
// * Render pushpins through Azure Maps Data Service [https://aka.ms/AzureMapsMapDataService]
// * Specify multiple pushpin styles
// * Provide custom pushpin images stored in Azure Maps Data Service [https://aka.ms/AzureMapsMapDataService]
// * Render circle, polyline and polygon geometry types.
// * Render of supported GeoJSON geometry types uploaded through Azure Maps Data Service [https://aka.ms/AzureMapsMapDataService]
// Please see How-to-Guide [https://aka.ms/AzureMapsHowToGuideImageCompositor] for detailed examples.
// Note : Either center or bbox parameter must be supplied to the API.
// The supported Lat and Lon ranges when using the bbox parameter, are as follows:
// ZOOM LEVEL MAX LON RANGE MAX LAT RANGE
// 0 360.0 170.0
// 1 360.0 170.0
// 2 360.0 170.0
// 3 360.0 170.0
// 4 360.0 170.0
// 5 180.0 85.0
// 6 90.0 42.5
// 7 45.0 21.25
// 8 22.5 10.625
// 9 11.25 5.3125
// 10 5.625 2.62625
// 11 2.8125 1.328125
// 12 1.40625 0.6640625
// 13 0.703125 0.33203125
// 14 0.3515625 0.166015625
// 15 0.17578125 0.0830078125
// 16 0.087890625 0.0415039063
// 17 0.0439453125 0.0207519531
// 18 0.0219726563 0.0103759766
// 19 0.0109863281 0.0051879883
// 20 0.0054931641 0.0025939941
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetMapStaticImage(ctx context.Context, formatParam RasterTileFormat, options *RenderGetMapStaticImageOptions) (RenderGetMapStaticImageResponse, error) {
	req, err := client.getMapStaticImageCreateRequest(ctx, formatParam, options)
	if err != nil {
		return RenderGetMapStaticImageResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RenderGetMapStaticImageResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RenderGetMapStaticImageResponse{}, client.getMapStaticImageHandleError(resp)
	}
	return client.getMapStaticImageHandleResponse(resp)
}

// getMapStaticImageCreateRequest creates the GetMapStaticImage request.
func (client *RenderClient) getMapStaticImageCreateRequest(ctx context.Context, formatParam RasterTileFormat, options *RenderGetMapStaticImageOptions) (*azcore.Request, error) {
	urlPath := "/map/static/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	if options != nil && options.Layer != nil {
		reqQP.Set("layer", string(*options.Layer))
	}
	if options != nil && options.Style != nil {
		reqQP.Set("style", string(*options.Style))
	}
	if options != nil && options.Zoom != nil {
		reqQP.Set("zoom", strconv.FormatInt(int64(*options.Zoom), 10))
	}
	if options != nil && options.Center != nil {
		reqQP.Set("center", *options.Center)
	}
	if options != nil && options.Bbox != nil {
		reqQP.Set("bbox", *options.Bbox)
	}
	if options != nil && options.Height != nil {
		reqQP.Set("height", strconv.FormatInt(int64(*options.Height), 10))
	}
	if options != nil && options.Width != nil {
		reqQP.Set("width", strconv.FormatInt(int64(*options.Width), 10))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	if options != nil && options.Pins != nil {
		for _, qv := range options.Pins {
			reqQP.Add("pins", qv)
		}
	}
	if options != nil && options.Path != nil {
		for _, qv := range options.Path {
			reqQP.Add("path", qv)
		}
	}
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile")
	return req, nil
}

// getMapStaticImageHandleResponse handles the GetMapStaticImage response.
func (client *RenderClient) getMapStaticImageHandleResponse(resp *azcore.Response) (RenderGetMapStaticImageResponse, error) {
	result := RenderGetMapStaticImageResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// getMapStaticImageHandleError handles the GetMapStaticImage error response.
func (client *RenderClient) getMapStaticImageHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

// GetMapTile - Applies to: S0 and S1 pricing tiers.
// Fetches map tiles in vector or raster format typically to be integrated into a new map control or SDK. By default, Azure uses vector map tiles for its
// web map control (see Zoom Levels and Tile Grid
// [https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid])
// Note: Weather tiles are only available via Get Map Tile V2 API [https://aka.ms/AzureMapsWeatherTiles]. We recommend to start to use the new Get Map Tile
// V2 API [https://aka.ms/GetMapTileV2].
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderClient) GetMapTile(ctx context.Context, formatParam TileFormat, layer MapTileLayer, style MapTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderGetMapTileOptions) (RenderGetMapTileResponse, error) {
	req, err := client.getMapTileCreateRequest(ctx, formatParam, layer, style, zoom, xTileIndex, yTileIndex, options)
	if err != nil {
		return RenderGetMapTileResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RenderGetMapTileResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RenderGetMapTileResponse{}, client.getMapTileHandleError(resp)
	}
	return client.getMapTileHandleResponse(resp)
}

// getMapTileCreateRequest creates the GetMapTile request.
func (client *RenderClient) getMapTileCreateRequest(ctx context.Context, formatParam TileFormat, layer MapTileLayer, style MapTileStyle, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderGetMapTileOptions) (*azcore.Request, error) {
	urlPath := "/map/tile/{format}"
	if formatParam == "" {
		return nil, errors.New("parameter formatParam cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{format}", url.PathEscape(string(formatParam)))
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "1.0")
	reqQP.Set("layer", string(layer))
	reqQP.Set("style", string(style))
	reqQP.Set("zoom", strconv.FormatInt(int64(zoom), 10))
	reqQP.Set("x", strconv.FormatInt(int64(xTileIndex), 10))
	reqQP.Set("y", strconv.FormatInt(int64(yTileIndex), 10))
	if options != nil && options.TileSize != nil {
		reqQP.Set("tileSize", string(*options.TileSize))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile")
	return req, nil
}

// getMapTileHandleResponse handles the GetMapTile response.
func (client *RenderClient) getMapTileHandleResponse(resp *azcore.Response) (RenderGetMapTileResponse, error) {
	result := RenderGetMapTileResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// getMapTileHandleError handles the GetMapTile error response.
func (client *RenderClient) getMapTileHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
	errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}
