// +build go1.13

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package render

import (
	"context"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
	"strconv"
)

// RenderV2Client contains the methods for the RenderV2 group.
// Don't use this type directly, use NewRenderV2Client() instead.
type RenderV2Client struct {
	con *Connection
	xmsClientID *string
}

// NewRenderV2Client creates a new instance of RenderV2Client with the specified values.
func NewRenderV2Client(con *Connection, xmsClientID *string) *RenderV2Client {
	return &RenderV2Client{con: con, xmsClientID: xmsClientID}
}

// GetMapTilePreview - Applies to: S0 and S1 pricing tiers.
// The Get Map Tiles API allows users to request map tiles in vector or raster formats typically to be integrated into a map control or SDK. Some example
// tiles that can be requested are Azure Maps road
// tiles, real-time Weather Radar tiles or the map tiles created using Azure Maps Creator [https://aka.ms/amcreator]. By default, Azure Maps uses vector
// tiles for its web map control (Web SDK) and
// Android SDK.
// If the operation fails it returns the *ErrorResponse error type.
func (client *RenderV2Client) GetMapTilePreview(ctx context.Context, tilesetID TilesetID, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderV2GetMapTilePreviewOptions) (RenderV2GetMapTilePreviewResponse, error) {
	req, err := client.getMapTilePreviewCreateRequest(ctx, tilesetID, zoom, xTileIndex, yTileIndex, options)
	if err != nil {
		return RenderV2GetMapTilePreviewResponse{}, err
	}
	resp, err := client.con.Pipeline().Do(req)
	if err != nil {
		return RenderV2GetMapTilePreviewResponse{}, err
	}
	if !resp.HasStatusCode(http.StatusOK) {
		return RenderV2GetMapTilePreviewResponse{}, client.getMapTilePreviewHandleError(resp)
	}
	return client.getMapTilePreviewHandleResponse(resp)
}

// getMapTilePreviewCreateRequest creates the GetMapTilePreview request.
func (client *RenderV2Client) getMapTilePreviewCreateRequest(ctx context.Context, tilesetID TilesetID, zoom int32, xTileIndex int32, yTileIndex int32, options *RenderV2GetMapTilePreviewOptions) (*azcore.Request, error) {
	urlPath := "/map/tile"
	req, err := azcore.NewRequest(ctx, http.MethodGet, azcore.JoinPaths(client.con.Endpoint(), urlPath))
	if err != nil {
		return nil, err
	}
	req.Telemetry(telemetryInfo)
	reqQP := req.URL.Query()
	reqQP.Set("api-version", "2.0")
	reqQP.Set("tilesetId", string(tilesetID))
	reqQP.Set("zoom", strconv.FormatInt(int64(zoom), 10))
	reqQP.Set("x", strconv.FormatInt(int64(xTileIndex), 10))
	reqQP.Set("y", strconv.FormatInt(int64(yTileIndex), 10))
	if options != nil && options.TimeStamp != nil {
		reqQP.Set("timeStamp", *options.TimeStamp)
	}
	if options != nil && options.TileSize != nil {
		reqQP.Set("tileSize", string(*options.TileSize))
	}
	if options != nil && options.Language != nil {
		reqQP.Set("language", *options.Language)
	}
	if options != nil && options.View != nil {
		reqQP.Set("view", *options.View)
	}
	req.URL.RawQuery = reqQP.Encode()
	req.SkipBodyDownload()
	if client.xmsClientID != nil {
		req.Header.Set("x-ms-client-id", *client.xmsClientID)
	}
	req.Header.Set("Accept", "application/json, image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile")
	return req, nil
}

// getMapTilePreviewHandleResponse handles the GetMapTilePreview response.
func (client *RenderV2Client) getMapTilePreviewHandleResponse(resp *azcore.Response) (RenderV2GetMapTilePreviewResponse, error) {
	result := RenderV2GetMapTilePreviewResponse{RawResponse: resp.Response}
	if val := resp.Header.Get("Content-Type"); val != "" {
		result.ContentType = &val
	}
	return result, nil
}

// getMapTilePreviewHandleError handles the GetMapTilePreview error response.
func (client *RenderV2Client) getMapTilePreviewHandleError(resp *azcore.Response) error {
	body, err := resp.Payload()
	if err != nil {
		return azcore.NewResponseError(err, resp.Response)
	}
		errType := ErrorResponse{raw: string(body)}
	if err := resp.UnmarshalAsJSON(&errType); err != nil {
		return azcore.NewResponseError(fmt.Errorf("%s\n%s", string(body), err), resp.Response)
	}
	return azcore.NewResponseError(&errType, resp.Response)
}

