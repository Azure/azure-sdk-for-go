package operationalinsights

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/operationalinsights/mgmt/2019-08-01-preview/operationalinsights"

// Cluster the top level Log Analytics cluster resource container.
type Cluster struct {
	autorest.Response `json:"-"`
	// Identity - The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`
	// Sku - The sku properties.
	Sku *Sku `json:"sku,omitempty"`
	// ClusterProperties - Log Analytics cluster properties.
	*ClusterProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.Identity != nil {
		objectMap["identity"] = c.Identity
	}
	if c.Sku != nil {
		objectMap["sku"] = c.Sku
	}
	if c.ClusterProperties != nil {
		objectMap["properties"] = c.ClusterProperties
	}
	if c.Location != nil {
		objectMap["location"] = c.Location
	}
	if c.Tags != nil {
		objectMap["tags"] = c.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Cluster struct.
func (c *Cluster) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity Identity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				c.Identity = &identity
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				c.Sku = &sku
			}
		case "properties":
			if v != nil {
				var clusterProperties ClusterProperties
				err = json.Unmarshal(*v, &clusterProperties)
				if err != nil {
					return err
				}
				c.ClusterProperties = &clusterProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				c.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				c.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				c.Type = &typeVar
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				c.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				c.Tags = tags
			}
		}
	}

	return nil
}

// ClusterListResult the list clusters operation response.
type ClusterListResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link used to get the next page of recommendations.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - A list of Log Analytics clusters.
	Value *[]Cluster `json:"value,omitempty"`
}

// ClusterListResultIterator provides access to a complete listing of Cluster values.
type ClusterListResultIterator struct {
	i    int
	page ClusterListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ClusterListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ClusterListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ClusterListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ClusterListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ClusterListResultIterator) Response() ClusterListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ClusterListResultIterator) Value() Cluster {
	if !iter.page.NotDone() {
		return Cluster{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ClusterListResultIterator type.
func NewClusterListResultIterator(page ClusterListResultPage) ClusterListResultIterator {
	return ClusterListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (clr ClusterListResult) IsEmpty() bool {
	return clr.Value == nil || len(*clr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (clr ClusterListResult) hasNextLink() bool {
	return clr.NextLink != nil && len(*clr.NextLink) != 0
}

// clusterListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (clr ClusterListResult) clusterListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !clr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(clr.NextLink)))
}

// ClusterListResultPage contains a page of Cluster values.
type ClusterListResultPage struct {
	fn  func(context.Context, ClusterListResult) (ClusterListResult, error)
	clr ClusterListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ClusterListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ClusterListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.clr)
		if err != nil {
			return err
		}
		page.clr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ClusterListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ClusterListResultPage) NotDone() bool {
	return !page.clr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ClusterListResultPage) Response() ClusterListResult {
	return page.clr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ClusterListResultPage) Values() []Cluster {
	if page.clr.IsEmpty() {
		return nil
	}
	return *page.clr.Value
}

// Creates a new instance of the ClusterListResultPage type.
func NewClusterListResultPage(cur ClusterListResult, getNextPage func(context.Context, ClusterListResult) (ClusterListResult, error)) ClusterListResultPage {
	return ClusterListResultPage{
		fn:  getNextPage,
		clr: cur,
	}
}

// ClusterPatch the top level Log Analytics cluster resource container.
type ClusterPatch struct {
	// ClusterPatchProperties - Log Analytics cluster properties.
	*ClusterPatchProperties `json:"properties,omitempty"`
	// Sku - The sku properties.
	Sku *Sku `json:"sku,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ClusterPatch.
func (cp ClusterPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.ClusterPatchProperties != nil {
		objectMap["properties"] = cp.ClusterPatchProperties
	}
	if cp.Sku != nil {
		objectMap["sku"] = cp.Sku
	}
	if cp.Tags != nil {
		objectMap["tags"] = cp.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ClusterPatch struct.
func (cp *ClusterPatch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var clusterPatchProperties ClusterPatchProperties
				err = json.Unmarshal(*v, &clusterPatchProperties)
				if err != nil {
					return err
				}
				cp.ClusterPatchProperties = &clusterPatchProperties
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				cp.Sku = &sku
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cp.Tags = tags
			}
		}
	}

	return nil
}

// ClusterPatchProperties log Analytics cluster patch properties.
type ClusterPatchProperties struct {
	// KeyVaultProperties - The associated key properties.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

// ClusterProperties cluster properties.
type ClusterProperties struct {
	// NextLink - The link used to get the next page of recommendations.
	NextLink *string `json:"nextLink,omitempty"`
	// ClusterID - READ-ONLY; The ID associated with the cluster.
	ClusterID *string `json:"clusterId,omitempty"`
	// ProvisioningState - READ-ONLY; The provisioning state of the cluster. Possible values include: 'Creating', 'Succeeded', 'Failed', 'Canceled', 'Deleting', 'ProvisioningAccount'
	ProvisioningState EntityStatus `json:"provisioningState,omitempty"`
	// KeyVaultProperties - The associated key properties.
	KeyVaultProperties *KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

// MarshalJSON is the custom marshaler for ClusterProperties.
func (cp ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.NextLink != nil {
		objectMap["nextLink"] = cp.NextLink
	}
	if cp.KeyVaultProperties != nil {
		objectMap["keyVaultProperties"] = cp.KeyVaultProperties
	}
	return json.Marshal(objectMap)
}

// ClustersCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ClustersCreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ClustersCreateOrUpdateFuture) Result(client ClustersClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "operationalinsights.ClustersCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("operationalinsights.ClustersCreateOrUpdateFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DataExport the top level data export resource container.
type DataExport struct {
	autorest.Response `json:"-"`
	// DataExportProperties - data export properties.
	*DataExportProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExport.
func (de DataExport) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if de.DataExportProperties != nil {
		objectMap["properties"] = de.DataExportProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataExport struct.
func (de *DataExport) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var dataExportProperties DataExportProperties
				err = json.Unmarshal(*v, &dataExportProperties)
				if err != nil {
					return err
				}
				de.DataExportProperties = &dataExportProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				de.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				de.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				de.Type = &typeVar
			}
		}
	}

	return nil
}

// DataExportCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DataExportCreateOrUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *DataExportCreateOrUpdateFuture) Result(client DataExportClient) (de DataExport, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "operationalinsights.DataExportCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("operationalinsights.DataExportCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if de.Response.Response, err = future.GetResult(sender); err == nil && de.Response.Response.StatusCode != http.StatusNoContent {
		de, err = client.CreateOrUpdateResponder(de.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "operationalinsights.DataExportCreateOrUpdateFuture", "Result", de.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DataExportListResult result of the request to list data exports.
type DataExportListResult struct {
	autorest.Response `json:"-"`
	// Value - List of data export instances within a workspace..
	Value *[]DataExport `json:"value,omitempty"`
}

// DataExportListResultIterator provides access to a complete listing of DataExport values.
type DataExportListResultIterator struct {
	i    int
	page DataExportListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DataExportListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataExportListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DataExportListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DataExportListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DataExportListResultIterator) Response() DataExportListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DataExportListResultIterator) Value() DataExport {
	if !iter.page.NotDone() {
		return DataExport{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DataExportListResultIterator type.
func NewDataExportListResultIterator(page DataExportListResultPage) DataExportListResultIterator {
	return DataExportListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (delr DataExportListResult) IsEmpty() bool {
	return delr.Value == nil || len(*delr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (delr DataExportListResult) hasNextLink() bool {
	return delr.NextLink != nil && len(*delr.NextLink) != 0
}

// dataExportListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (delr DataExportListResult) dataExportListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !delr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(delr.NextLink)))
}

// DataExportListResultPage contains a page of DataExport values.
type DataExportListResultPage struct {
	fn   func(context.Context, DataExportListResult) (DataExportListResult, error)
	delr DataExportListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DataExportListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DataExportListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.delr)
		if err != nil {
			return err
		}
		page.delr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DataExportListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DataExportListResultPage) NotDone() bool {
	return !page.delr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DataExportListResultPage) Response() DataExportListResult {
	return page.delr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DataExportListResultPage) Values() []DataExport {
	if page.delr.IsEmpty() {
		return nil
	}
	return *page.delr.Value
}

// Creates a new instance of the DataExportListResultPage type.
func NewDataExportListResultPage(cur DataExportListResult, getNextPage func(context.Context, DataExportListResult) (DataExportListResult, error)) DataExportListResultPage {
	return DataExportListResultPage{
		fn:   getNextPage,
		delr: cur,
	}
}

// DataExportProperties data Export properties.
type DataExportProperties struct {
	// DataExportID - The data export rule ID.
	DataExportID *string `json:"dataExportId,omitempty"`
	// TableNames - An array of tables to export, for example: [“Heartbeat, SecurityEvent”].
	TableNames *[]string `json:"tableNames,omitempty"`
	// Destination - destination properties.
	*Destination `json:"destination,omitempty"`
	// Enable - Active when enabled.
	Enable *bool `json:"enable,omitempty"`
	// CreatedDate - The latest data export rule modification time.
	CreatedDate *string `json:"createdDate,omitempty"`
	// LastModifiedDate - Date and time when the export was last modified.
	LastModifiedDate *string `json:"lastModifiedDate,omitempty"`
}

// MarshalJSON is the custom marshaler for DataExportProperties.
func (dep DataExportProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dep.DataExportID != nil {
		objectMap["dataExportId"] = dep.DataExportID
	}
	if dep.TableNames != nil {
		objectMap["tableNames"] = dep.TableNames
	}
	if dep.Destination != nil {
		objectMap["destination"] = dep.Destination
	}
	if dep.Enable != nil {
		objectMap["enable"] = dep.Enable
	}
	if dep.CreatedDate != nil {
		objectMap["createdDate"] = dep.CreatedDate
	}
	if dep.LastModifiedDate != nil {
		objectMap["lastModifiedDate"] = dep.LastModifiedDate
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for DataExportProperties struct.
func (dep *DataExportProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "dataExportId":
			if v != nil {
				var dataExportID string
				err = json.Unmarshal(*v, &dataExportID)
				if err != nil {
					return err
				}
				dep.DataExportID = &dataExportID
			}
		case "tableNames":
			if v != nil {
				var tableNames []string
				err = json.Unmarshal(*v, &tableNames)
				if err != nil {
					return err
				}
				dep.TableNames = &tableNames
			}
		case "destination":
			if v != nil {
				var destination Destination
				err = json.Unmarshal(*v, &destination)
				if err != nil {
					return err
				}
				dep.Destination = &destination
			}
		case "enable":
			if v != nil {
				var enable bool
				err = json.Unmarshal(*v, &enable)
				if err != nil {
					return err
				}
				dep.Enable = &enable
			}
		case "createdDate":
			if v != nil {
				var createdDate string
				err = json.Unmarshal(*v, &createdDate)
				if err != nil {
					return err
				}
				dep.CreatedDate = &createdDate
			}
		case "lastModifiedDate":
			if v != nil {
				var lastModifiedDate string
				err = json.Unmarshal(*v, &lastModifiedDate)
				if err != nil {
					return err
				}
				dep.LastModifiedDate = &lastModifiedDate
			}
		}
	}

	return nil
}

// Destination destination properties.
type Destination struct {
	// ResourceID - The destination resource ID. This can be copied from the Properties entry of the destination resource in Azure.
	ResourceID *string `json:"resourceId,omitempty"`
	// Type - READ-ONLY; The type of the destination resource. Possible values include: 'StorageAccount', 'EventHub'
	Type Type `json:"type,omitempty"`
	// DestinationMetaData - destination meta data.
	*DestinationMetaData `json:"metaData,omitempty"`
}

// MarshalJSON is the custom marshaler for Destination.
func (d Destination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if d.ResourceID != nil {
		objectMap["resourceId"] = d.ResourceID
	}
	if d.DestinationMetaData != nil {
		objectMap["metaData"] = d.DestinationMetaData
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Destination struct.
func (d *Destination) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "resourceId":
			if v != nil {
				var resourceID string
				err = json.Unmarshal(*v, &resourceID)
				if err != nil {
					return err
				}
				d.ResourceID = &resourceID
			}
		case "type":
			if v != nil {
				var typeVar Type
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				d.Type = typeVar
			}
		case "metaData":
			if v != nil {
				var destinationMetaData DestinationMetaData
				err = json.Unmarshal(*v, &destinationMetaData)
				if err != nil {
					return err
				}
				d.DestinationMetaData = &destinationMetaData
			}
		}
	}

	return nil
}

// DestinationMetaData destination meta data.
type DestinationMetaData struct {
	// EventHubName - Optional. Allows to define an Event Hub name. Not applicable when destination is Storage Account.
	EventHubName *string `json:"eventHubName,omitempty"`
}

// ErrorDetails the details of the error.
type ErrorDetails struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// ErrorResponse error response indicates that the service is not able to process the incoming request. The
// reason is provided in the error message.
type ErrorResponse struct {
	// Error - The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned', 'None'
	Type IdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// KeyVaultProperties ...
type KeyVaultProperties struct {
	// KeyVaultURI - The Key Vault uri which holds they key associated with the Log Analytics cluster.
	KeyVaultURI *string `json:"keyVaultUri,omitempty"`
	// KeyName - The name of the key associated with the Log Analytics cluster.
	KeyName *string `json:"keyName,omitempty"`
	// KeyVersion - The version of the key associated with the Log Analytics cluster.
	KeyVersion *string `json:"keyVersion,omitempty"`
}

// LinkedService the top level Linked service resource container.
type LinkedService struct {
	autorest.Response `json:"-"`
	// LinkedServiceProperties - The properties of the linked service.
	*LinkedServiceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedService.
func (ls LinkedService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ls.LinkedServiceProperties != nil {
		objectMap["properties"] = ls.LinkedServiceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LinkedService struct.
func (ls *LinkedService) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var linkedServiceProperties LinkedServiceProperties
				err = json.Unmarshal(*v, &linkedServiceProperties)
				if err != nil {
					return err
				}
				ls.LinkedServiceProperties = &linkedServiceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ls.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ls.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ls.Type = &typeVar
			}
		}
	}

	return nil
}

// LinkedServiceListResult the list linked service operation response.
type LinkedServiceListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of linked service instances
	Value *[]LinkedService `json:"value,omitempty"`
}

// LinkedServiceProperties linked service properties.
type LinkedServiceProperties struct {
	// ResourceID - The resource id of the resource that will be linked to the workspace. This should be used for linking resources which require read access
	ResourceID *string `json:"resourceId,omitempty"`
	// WriteAccessResourceID - The resource id of the resource that will be linked to the workspace. This should be used for linking resources which require write access
	WriteAccessResourceID *string `json:"writeAccessResourceId,omitempty"`
}

// LinkedStorageAccounts linked storage accounts top level resource container.
type LinkedStorageAccounts struct {
	autorest.Response `json:"-"`
	// LinkedStorageAccountsProperties - Linked storage accounts properties.
	*LinkedStorageAccountsProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedStorageAccounts.
func (lsa LinkedStorageAccounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lsa.LinkedStorageAccountsProperties != nil {
		objectMap["properties"] = lsa.LinkedStorageAccountsProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for LinkedStorageAccounts struct.
func (lsa *LinkedStorageAccounts) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var linkedStorageAccountsProperties LinkedStorageAccountsProperties
				err = json.Unmarshal(*v, &linkedStorageAccountsProperties)
				if err != nil {
					return err
				}
				lsa.LinkedStorageAccountsProperties = &linkedStorageAccountsProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				lsa.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				lsa.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				lsa.Type = &typeVar
			}
		}
	}

	return nil
}

// LinkedStorageAccountsListResult the list linked storage accounts service operation response.
type LinkedStorageAccountsListResult struct {
	autorest.Response `json:"-"`
	// Value - A list of linked storage accounts instances.
	Value *[]LinkedStorageAccounts `json:"value,omitempty"`
}

// LinkedStorageAccountsProperties linked storage accounts properties.
type LinkedStorageAccountsProperties struct {
	// DataSourceType - READ-ONLY; Linked storage accounts type. Possible values include: 'CustomLogs', 'AzureWatson'
	DataSourceType DataSourceType `json:"dataSourceType,omitempty"`
	// StorageAccountIds - Linked storage accounts resources ids.
	StorageAccountIds *[]string `json:"storageAccountIds,omitempty"`
}

// MarshalJSON is the custom marshaler for LinkedStorageAccountsProperties.
func (lsap LinkedStorageAccountsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lsap.StorageAccountIds != nil {
		objectMap["storageAccountIds"] = lsap.StorageAccountIds
	}
	return json.Marshal(objectMap)
}

// ProxyResource common properties of proxy resource.
type ProxyResource struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// Resource the resource definition.
type Resource struct {
	// ID - READ-ONLY; Resource Id
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// Location - Resource location
	Location *string `json:"location,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Location != nil {
		objectMap["location"] = r.Location
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	return json.Marshal(objectMap)
}

// Sku ...
type Sku struct {
	// Capacity - The capacity value
	Capacity *int64 `json:"capacity,omitempty"`
	// Name - The name of the SKU. Possible values include: 'CapacityReservation'
	Name SkuNameEnum `json:"name,omitempty"`
}
