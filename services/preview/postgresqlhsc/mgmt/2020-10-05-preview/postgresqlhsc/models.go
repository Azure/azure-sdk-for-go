package postgresqlhsc

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/postgresqlhsc/mgmt/2020-10-05-preview/postgresqlhsc"

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CloudError an error response from the Batch service.
type CloudError struct {
	// Error - The error.
	Error *CloudErrorBody `json:"error,omitempty"`
}

// CloudErrorBody an error response from the Batch service.
type CloudErrorBody struct {
	// Code - An identifier for the error. Codes are invariant and are intended to be consumed programmatically.
	Code *string `json:"code,omitempty"`
	// Message - A message describing the error, intended to be suitable for display in a user interface.
	Message *string `json:"message,omitempty"`
	// Target - The target of the particular error. For example, the name of the property in error.
	Target *string `json:"target,omitempty"`
	// Details - A list of additional details about the error.
	Details *[]CloudErrorBody `json:"details,omitempty"`
}

// ConfigurationsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ConfigurationsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ConfigurationsClient) (ServerGroupConfiguration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ConfigurationsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ConfigurationsUpdateFuture.Result.
func (future *ConfigurationsUpdateFuture) result(client ConfigurationsClient) (sgc ServerGroupConfiguration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ConfigurationsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sgc.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ConfigurationsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sgc.Response.Response, err = future.GetResult(sender); err == nil && sgc.Response.Response.StatusCode != http.StatusNoContent {
		sgc, err = client.UpdateResponder(sgc.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ConfigurationsUpdateFuture", "Result", sgc.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FirewallRule represents a server group firewall rule.
type FirewallRule struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// FirewallRuleProperties - The properties of a firewall rule.
	*FirewallRuleProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FirewallRule.
func (fr FirewallRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fr.SystemData != nil {
		objectMap["systemData"] = fr.SystemData
	}
	if fr.FirewallRuleProperties != nil {
		objectMap["properties"] = fr.FirewallRuleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FirewallRule struct.
func (fr *FirewallRule) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				fr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var firewallRuleProperties FirewallRuleProperties
				err = json.Unmarshal(*v, &firewallRuleProperties)
				if err != nil {
					return err
				}
				fr.FirewallRuleProperties = &firewallRuleProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fr.Type = &typeVar
			}
		}
	}

	return nil
}

// FirewallRuleListResult a list of firewall rules.
type FirewallRuleListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of firewall rules in a server group.
	Value *[]FirewallRule `json:"value,omitempty"`
}

// FirewallRuleProperties the properties of a server group firewall rule.
type FirewallRuleProperties struct {
	// StartIPAddress - The start IP address of the server group firewall rule. Must be IPv4 format.
	StartIPAddress *string `json:"startIpAddress,omitempty"`
	// EndIPAddress - The end IP address of the server group firewall rule. Must be IPv4 format.
	EndIPAddress *string `json:"endIpAddress,omitempty"`
}

// FirewallRulesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type FirewallRulesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FirewallRulesClient) (FirewallRule, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FirewallRulesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FirewallRulesCreateOrUpdateFuture.Result.
func (future *FirewallRulesCreateOrUpdateFuture) result(client FirewallRulesClient) (fr FirewallRule, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.FirewallRulesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		fr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.FirewallRulesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if fr.Response.Response, err = future.GetResult(sender); err == nil && fr.Response.Response.StatusCode != http.StatusNoContent {
		fr, err = client.CreateOrUpdateResponder(fr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.FirewallRulesCreateOrUpdateFuture", "Result", fr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// FirewallRulesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type FirewallRulesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(FirewallRulesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *FirewallRulesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for FirewallRulesDeleteFuture.Result.
func (future *FirewallRulesDeleteFuture) result(client FirewallRulesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.FirewallRulesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.FirewallRulesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// MaintenanceWindow maintenance window of a server group.
type MaintenanceWindow struct {
	// CustomWindow - indicates whether custom window is enabled or disabled
	CustomWindow *string `json:"customWindow,omitempty"`
	// StartHour - start hour for maintenance window
	StartHour *int32 `json:"startHour,omitempty"`
	// StartMinute - start minute for maintenance window
	StartMinute *int32 `json:"startMinute,omitempty"`
	// DayOfWeek - day of week for maintenance window
	DayOfWeek *int32 `json:"dayOfWeek,omitempty"`
}

// NameAvailability represents a resource name availability.
type NameAvailability struct {
	autorest.Response `json:"-"`
	// Message - Error Message.
	Message *string `json:"message,omitempty"`
	// NameAvailable - Indicates whether the resource name is available.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Name - name of the PostgreSQL server.
	Name *string `json:"name,omitempty"`
	// Type - type of the server
	Type *string `json:"type,omitempty"`
}

// NameAvailabilityRequest request from client to check resource name availability.
type NameAvailabilityRequest struct {
	// Name - Resource name to verify.
	Name *string `json:"name,omitempty"`
	// Type - Resource type used for verification.
	Type *string `json:"type,omitempty"`
}

// Operation REST API operation definition.
type Operation struct {
	// Name - READ-ONLY; The name of the operation being performed on this particular object.
	Name *string `json:"name,omitempty"`
	// Display - READ-ONLY; The localized display information for this particular operation or action.
	Display *OperationDisplay `json:"display,omitempty"`
	// IsDataAction - Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation. Possible values include: 'OperationOriginNotSpecified', 'OperationOriginUser', 'OperationOriginSystem'
	Origin OperationOrigin `json:"origin,omitempty"`
	// Properties - READ-ONLY; Additional descriptions for the operation.
	Properties map[string]interface{} `json:"properties"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.IsDataAction != nil {
		objectMap["isDataAction"] = o.IsDataAction
	}
	return json.Marshal(objectMap)
}

// OperationDisplay display metadata associated with the operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; Operation resource provider name.
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; Localized friendly name for the operation.
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; Operation description.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (od OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult a list of resource provider operations.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - Collection of available operation details
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL client should use to fetch the next page (per server side paging).
	// It's null for now, added for future use.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if olr.Value != nil {
		objectMap["value"] = olr.Value
	}
	return json.Marshal(objectMap)
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Role represents a server group role.
type Role struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// RoleProperties - The properties of a role.
	*RoleProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Role.
func (r Role) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.SystemData != nil {
		objectMap["systemData"] = r.SystemData
	}
	if r.RoleProperties != nil {
		objectMap["properties"] = r.RoleProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Role struct.
func (r *Role) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				r.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var roleProperties RoleProperties
				err = json.Unmarshal(*v, &roleProperties)
				if err != nil {
					return err
				}
				r.RoleProperties = &roleProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				r.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				r.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				r.Type = &typeVar
			}
		}
	}

	return nil
}

// RoleListResult a list of roles.
type RoleListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of roles in a server group.
	Value *[]Role `json:"value,omitempty"`
}

// RoleProperties the properties of a server group role.
type RoleProperties struct {
	// Password - The password of the server group role.
	Password *string `json:"password,omitempty"`
}

// RolesCreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type RolesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RolesClient) (Role, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RolesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RolesCreateFuture.Result.
func (future *RolesCreateFuture) result(client RolesClient) (r Role, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.RolesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		r.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.RolesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if r.Response.Response, err = future.GetResult(sender); err == nil && r.Response.Response.StatusCode != http.StatusNoContent {
		r, err = client.CreateResponder(r.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.RolesCreateFuture", "Result", r.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RolesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type RolesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(RolesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *RolesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for RolesDeleteFuture.Result.
func (future *RolesDeleteFuture) result(client RolesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.RolesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.RolesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerConfiguration represents a configuration.
type ServerConfiguration struct {
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// ServerConfigurationProperties - The properties of a configuration.
	*ServerConfigurationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerConfiguration.
func (sc ServerConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sc.SystemData != nil {
		objectMap["systemData"] = sc.SystemData
	}
	if sc.ServerConfigurationProperties != nil {
		objectMap["properties"] = sc.ServerConfigurationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerConfiguration struct.
func (sc *ServerConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sc.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var serverConfigurationProperties ServerConfigurationProperties
				err = json.Unmarshal(*v, &serverConfigurationProperties)
				if err != nil {
					return err
				}
				sc.ServerConfigurationProperties = &serverConfigurationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sc.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerConfigurationListResult a list of server configurations.
type ServerConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of server configurations.
	Value *[]ServerConfiguration `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerConfigurationListResult.
func (sclr ServerConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sclr.Value != nil {
		objectMap["value"] = sclr.Value
	}
	return json.Marshal(objectMap)
}

// ServerConfigurationListResultIterator provides access to a complete listing of ServerConfiguration
// values.
type ServerConfigurationListResultIterator struct {
	i    int
	page ServerConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServerConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServerConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServerConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServerConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServerConfigurationListResultIterator) Response() ServerConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServerConfigurationListResultIterator) Value() ServerConfiguration {
	if !iter.page.NotDone() {
		return ServerConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServerConfigurationListResultIterator type.
func NewServerConfigurationListResultIterator(page ServerConfigurationListResultPage) ServerConfigurationListResultIterator {
	return ServerConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sclr ServerConfigurationListResult) IsEmpty() bool {
	return sclr.Value == nil || len(*sclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sclr ServerConfigurationListResult) hasNextLink() bool {
	return sclr.NextLink != nil && len(*sclr.NextLink) != 0
}

// serverConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sclr ServerConfigurationListResult) serverConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !sclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sclr.NextLink)))
}

// ServerConfigurationListResultPage contains a page of ServerConfiguration values.
type ServerConfigurationListResultPage struct {
	fn   func(context.Context, ServerConfigurationListResult) (ServerConfigurationListResult, error)
	sclr ServerConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServerConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServerConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sclr)
		if err != nil {
			return err
		}
		page.sclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServerConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServerConfigurationListResultPage) NotDone() bool {
	return !page.sclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServerConfigurationListResultPage) Response() ServerConfigurationListResult {
	return page.sclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServerConfigurationListResultPage) Values() []ServerConfiguration {
	if page.sclr.IsEmpty() {
		return nil
	}
	return *page.sclr.Value
}

// Creates a new instance of the ServerConfigurationListResultPage type.
func NewServerConfigurationListResultPage(cur ServerConfigurationListResult, getNextPage func(context.Context, ServerConfigurationListResult) (ServerConfigurationListResult, error)) ServerConfigurationListResultPage {
	return ServerConfigurationListResultPage{
		fn:   getNextPage,
		sclr: cur,
	}
}

// ServerConfigurationProperties the properties of a configuration.
type ServerConfigurationProperties struct {
	// Value - Value of the configuration.
	Value *string `json:"value,omitempty"`
	// Source - READ-ONLY; Source of the configuration.
	Source *string `json:"source,omitempty"`
	// Description - READ-ONLY; Description of the configuration.
	Description *string `json:"description,omitempty"`
	// DefaultValue - READ-ONLY; Default value of the configuration.
	DefaultValue *string `json:"defaultValue,omitempty"`
	// DataType - READ-ONLY; Data type of the configuration. Possible values include: 'Boolean', 'Numeric', 'Integer', 'Enumeration'
	DataType ConfigurationDataType `json:"dataType,omitempty"`
	// AllowedValues - READ-ONLY; Allowed values of the configuration.
	AllowedValues *string `json:"allowedValues,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerConfigurationProperties.
func (scp ServerConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scp.Value != nil {
		objectMap["value"] = scp.Value
	}
	return json.Marshal(objectMap)
}

// ServerGroup represents a server group for create.
type ServerGroup struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// ServerGroupProperties - Properties of the server group create.
	*ServerGroupProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroup.
func (sg ServerGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sg.SystemData != nil {
		objectMap["systemData"] = sg.SystemData
	}
	if sg.ServerGroupProperties != nil {
		objectMap["properties"] = sg.ServerGroupProperties
	}
	if sg.Tags != nil {
		objectMap["tags"] = sg.Tags
	}
	if sg.Location != nil {
		objectMap["location"] = sg.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroup struct.
func (sg *ServerGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sg.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var serverGroupProperties ServerGroupProperties
				err = json.Unmarshal(*v, &serverGroupProperties)
				if err != nil {
					return err
				}
				sg.ServerGroupProperties = &serverGroupProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sg.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sg.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sg.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerGroupConfiguration represents the configuration list of server role groups in a server group.
type ServerGroupConfiguration struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// ServerGroupConfigurationProperties - The properties of server group configuration.
	*ServerGroupConfigurationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupConfiguration.
func (sgc ServerGroupConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgc.SystemData != nil {
		objectMap["systemData"] = sgc.SystemData
	}
	if sgc.ServerGroupConfigurationProperties != nil {
		objectMap["properties"] = sgc.ServerGroupConfigurationProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroupConfiguration struct.
func (sgc *ServerGroupConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sgc.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var serverGroupConfigurationProperties ServerGroupConfigurationProperties
				err = json.Unmarshal(*v, &serverGroupConfigurationProperties)
				if err != nil {
					return err
				}
				sgc.ServerGroupConfigurationProperties = &serverGroupConfigurationProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sgc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sgc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sgc.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerGroupConfigurationListResult a list of server group configurations.
type ServerGroupConfigurationListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of server group configurations.
	Value *[]ServerGroupConfiguration `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to retrieve next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupConfigurationListResult.
func (sgclr ServerGroupConfigurationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgclr.Value != nil {
		objectMap["value"] = sgclr.Value
	}
	return json.Marshal(objectMap)
}

// ServerGroupConfigurationListResultIterator provides access to a complete listing of
// ServerGroupConfiguration values.
type ServerGroupConfigurationListResultIterator struct {
	i    int
	page ServerGroupConfigurationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServerGroupConfigurationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServerGroupConfigurationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServerGroupConfigurationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServerGroupConfigurationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServerGroupConfigurationListResultIterator) Response() ServerGroupConfigurationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServerGroupConfigurationListResultIterator) Value() ServerGroupConfiguration {
	if !iter.page.NotDone() {
		return ServerGroupConfiguration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServerGroupConfigurationListResultIterator type.
func NewServerGroupConfigurationListResultIterator(page ServerGroupConfigurationListResultPage) ServerGroupConfigurationListResultIterator {
	return ServerGroupConfigurationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sgclr ServerGroupConfigurationListResult) IsEmpty() bool {
	return sgclr.Value == nil || len(*sgclr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sgclr ServerGroupConfigurationListResult) hasNextLink() bool {
	return sgclr.NextLink != nil && len(*sgclr.NextLink) != 0
}

// serverGroupConfigurationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sgclr ServerGroupConfigurationListResult) serverGroupConfigurationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !sgclr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sgclr.NextLink)))
}

// ServerGroupConfigurationListResultPage contains a page of ServerGroupConfiguration values.
type ServerGroupConfigurationListResultPage struct {
	fn    func(context.Context, ServerGroupConfigurationListResult) (ServerGroupConfigurationListResult, error)
	sgclr ServerGroupConfigurationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServerGroupConfigurationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServerGroupConfigurationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sgclr)
		if err != nil {
			return err
		}
		page.sgclr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServerGroupConfigurationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServerGroupConfigurationListResultPage) NotDone() bool {
	return !page.sgclr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServerGroupConfigurationListResultPage) Response() ServerGroupConfigurationListResult {
	return page.sgclr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServerGroupConfigurationListResultPage) Values() []ServerGroupConfiguration {
	if page.sgclr.IsEmpty() {
		return nil
	}
	return *page.sgclr.Value
}

// Creates a new instance of the ServerGroupConfigurationListResultPage type.
func NewServerGroupConfigurationListResultPage(cur ServerGroupConfigurationListResult, getNextPage func(context.Context, ServerGroupConfigurationListResult) (ServerGroupConfigurationListResult, error)) ServerGroupConfigurationListResultPage {
	return ServerGroupConfigurationListResultPage{
		fn:    getNextPage,
		sgclr: cur,
	}
}

// ServerGroupConfigurationProperties the properties of server group configuration.
type ServerGroupConfigurationProperties struct {
	// Description - READ-ONLY; Description of the configuration.
	Description *string `json:"description,omitempty"`
	// DataType - READ-ONLY; Data type of the configuration. Possible values include: 'Boolean', 'Numeric', 'Integer', 'Enumeration'
	DataType ConfigurationDataType `json:"dataType,omitempty"`
	// AllowedValues - READ-ONLY; Allowed values of the configuration.
	AllowedValues *string `json:"allowedValues,omitempty"`
	// ServerRoleGroupConfigurations - The list of server role group configuration values.
	ServerRoleGroupConfigurations *[]ServerRoleGroupConfiguration `json:"serverRoleGroupConfigurations,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupConfigurationProperties.
func (sgcp ServerGroupConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgcp.ServerRoleGroupConfigurations != nil {
		objectMap["serverRoleGroupConfigurations"] = sgcp.ServerRoleGroupConfigurations
	}
	return json.Marshal(objectMap)
}

// ServerGroupForUpdate represents a server group for update.
type ServerGroupForUpdate struct {
	// Location - The location the resource resides in.
	Location *string `json:"location,omitempty"`
	// ServerGroupPropertiesForUpdate - Properties of the server group.
	*ServerGroupPropertiesForUpdate `json:"properties,omitempty"`
	// Tags - Application-specific metadata in the form of key-value pairs.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ServerGroupForUpdate.
func (sgfu ServerGroupForUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgfu.Location != nil {
		objectMap["location"] = sgfu.Location
	}
	if sgfu.ServerGroupPropertiesForUpdate != nil {
		objectMap["properties"] = sgfu.ServerGroupPropertiesForUpdate
	}
	if sgfu.Tags != nil {
		objectMap["tags"] = sgfu.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroupForUpdate struct.
func (sgfu *ServerGroupForUpdate) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sgfu.Location = &location
			}
		case "properties":
			if v != nil {
				var serverGroupPropertiesForUpdate ServerGroupPropertiesForUpdate
				err = json.Unmarshal(*v, &serverGroupPropertiesForUpdate)
				if err != nil {
					return err
				}
				sgfu.ServerGroupPropertiesForUpdate = &serverGroupPropertiesForUpdate
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sgfu.Tags = tags
			}
		}
	}

	return nil
}

// ServerGroupListResult a list of server groups.
type ServerGroupListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of server groups
	Value *[]ServerGroup `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link used to get the next page of operations.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupListResult.
func (sglr ServerGroupListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sglr.Value != nil {
		objectMap["value"] = sglr.Value
	}
	return json.Marshal(objectMap)
}

// ServerGroupListResultIterator provides access to a complete listing of ServerGroup values.
type ServerGroupListResultIterator struct {
	i    int
	page ServerGroupListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ServerGroupListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServerGroupListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ServerGroupListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ServerGroupListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ServerGroupListResultIterator) Response() ServerGroupListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ServerGroupListResultIterator) Value() ServerGroup {
	if !iter.page.NotDone() {
		return ServerGroup{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ServerGroupListResultIterator type.
func NewServerGroupListResultIterator(page ServerGroupListResultPage) ServerGroupListResultIterator {
	return ServerGroupListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sglr ServerGroupListResult) IsEmpty() bool {
	return sglr.Value == nil || len(*sglr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sglr ServerGroupListResult) hasNextLink() bool {
	return sglr.NextLink != nil && len(*sglr.NextLink) != 0
}

// serverGroupListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sglr ServerGroupListResult) serverGroupListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !sglr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sglr.NextLink)))
}

// ServerGroupListResultPage contains a page of ServerGroup values.
type ServerGroupListResultPage struct {
	fn   func(context.Context, ServerGroupListResult) (ServerGroupListResult, error)
	sglr ServerGroupListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ServerGroupListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ServerGroupListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sglr)
		if err != nil {
			return err
		}
		page.sglr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ServerGroupListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ServerGroupListResultPage) NotDone() bool {
	return !page.sglr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ServerGroupListResultPage) Response() ServerGroupListResult {
	return page.sglr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ServerGroupListResultPage) Values() []ServerGroup {
	if page.sglr.IsEmpty() {
		return nil
	}
	return *page.sglr.Value
}

// Creates a new instance of the ServerGroupListResultPage type.
func NewServerGroupListResultPage(cur ServerGroupListResult, getNextPage func(context.Context, ServerGroupListResult) (ServerGroupListResult, error)) ServerGroupListResultPage {
	return ServerGroupListResultPage{
		fn:   getNextPage,
		sglr: cur,
	}
}

// ServerGroupProperties the properties used to create a new server group.
type ServerGroupProperties struct {
	// CreateMode - The mode to create a new server group. Possible values include: 'Default', 'PointInTimeRestore', 'ReadReplica'
	CreateMode CreateMode `json:"createMode,omitempty"`
	// AdministratorLogin - The administrator's login name of servers in server group. Can only be specified when the server is being created (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// AdministratorLoginPassword - The password of the administrator login.
	AdministratorLoginPassword *string `json:"administratorLoginPassword,omitempty"`
	// BackupRetentionDays - The backup retention days for server group.
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// PostgresqlVersion - The PostgreSQL version of server group. Possible values include: 'OneOne', 'OneTwo'
	PostgresqlVersion PostgreSQLVersion `json:"postgresqlVersion,omitempty"`
	// CitusVersion - The Citus version of server group. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion CitusVersion `json:"citusVersion,omitempty"`
	// EnableMx - If Citus MX is enabled or not for the server group.
	EnableMx *bool `json:"enableMx,omitempty"`
	// EnableZfs - If ZFS compression is enabled or not for the server group.
	EnableZfs *bool `json:"enableZfs,omitempty"`
	// EnableShardsOnCoordinator - If shards on coordinator is enabled or not for the server group.
	EnableShardsOnCoordinator *bool `json:"enableShardsOnCoordinator,omitempty"`
	// State - A state of a server group that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating', 'Provisioning'
	State ServerState `json:"state,omitempty"`
	// EarliestRestoreTime - READ-ONLY; The earliest restore point time (ISO8601 format) for server group.
	EarliestRestoreTime *date.Time `json:"earliestRestoreTime,omitempty"`
	// ResourceProviderType - READ-ONLY; The resource provider type of server group. Possible values include: 'Meru', 'Marlin'
	ResourceProviderType ResourceProviderType `json:"resourceProviderType,omitempty"`
	// ServerRoleGroups - The list of server role groups.
	ServerRoleGroups *[]ServerRoleGroup `json:"serverRoleGroups,omitempty"`
	// MaintenanceWindow - Maintenance window of a server group.
	MaintenanceWindow *MaintenanceWindow `json:"maintenanceWindow,omitempty"`
	// AvailabilityZone - Availability Zone information of the server group.
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
	// StandbyAvailabilityZone - Standby Availability Zone information of the server group.
	StandbyAvailabilityZone *string `json:"standbyAvailabilityZone,omitempty"`
	// DelegatedSubnetArguments - The delegated subnet arguments for a server group.
	DelegatedSubnetArguments *ServerGroupPropertiesDelegatedSubnetArguments `json:"delegatedSubnetArguments,omitempty"`
	// PrivateDNSZoneArguments - The private dns zone arguments for a server group.
	PrivateDNSZoneArguments *ServerGroupPropertiesPrivateDNSZoneArguments `json:"privateDnsZoneArguments,omitempty"`
	// ReadReplicas - READ-ONLY; The array of read replica server groups.
	ReadReplicas *[]string `json:"readReplicas,omitempty"`
	// SourceServerGroup - READ-ONLY; The source server group id for read replica server groups.
	SourceServerGroup *string `json:"sourceServerGroup,omitempty"`
	// SourceSubscriptionID - The source subscription id to restore from. It's required when 'createMode' is 'PointInTimeRestore' or 'ReadReplica'
	SourceSubscriptionID *string `json:"sourceSubscriptionId,omitempty"`
	// SourceResourceGroupName - The source resource group name to restore from. It's required when 'createMode' is 'PointInTimeRestore' or 'ReadReplica'
	SourceResourceGroupName *string `json:"sourceResourceGroupName,omitempty"`
	// SourceServerGroupName - The source server group name to restore from. It's required when 'createMode' is 'PointInTimeRestore' or 'ReadReplica'
	SourceServerGroupName *string `json:"sourceServerGroupName,omitempty"`
	// SourceLocation - The source server group location to restore from. It's required when 'createMode' is 'PointInTimeRestore' or 'ReadReplica'
	SourceLocation *string `json:"sourceLocation,omitempty"`
	// PointInTimeUTC - Restore point creation time (ISO8601 format), specifying the time to restore from. It's required when 'createMode' is 'PointInTimeRestore'
	PointInTimeUTC *date.Time `json:"pointInTimeUTC,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupProperties.
func (sgp ServerGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgp.CreateMode != "" {
		objectMap["createMode"] = sgp.CreateMode
	}
	if sgp.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgp.AdministratorLogin
	}
	if sgp.AdministratorLoginPassword != nil {
		objectMap["administratorLoginPassword"] = sgp.AdministratorLoginPassword
	}
	if sgp.BackupRetentionDays != nil {
		objectMap["backupRetentionDays"] = sgp.BackupRetentionDays
	}
	if sgp.PostgresqlVersion != "" {
		objectMap["postgresqlVersion"] = sgp.PostgresqlVersion
	}
	if sgp.CitusVersion != "" {
		objectMap["citusVersion"] = sgp.CitusVersion
	}
	if sgp.EnableMx != nil {
		objectMap["enableMx"] = sgp.EnableMx
	}
	if sgp.EnableZfs != nil {
		objectMap["enableZfs"] = sgp.EnableZfs
	}
	if sgp.EnableShardsOnCoordinator != nil {
		objectMap["enableShardsOnCoordinator"] = sgp.EnableShardsOnCoordinator
	}
	if sgp.State != "" {
		objectMap["state"] = sgp.State
	}
	if sgp.ServerRoleGroups != nil {
		objectMap["serverRoleGroups"] = sgp.ServerRoleGroups
	}
	if sgp.MaintenanceWindow != nil {
		objectMap["maintenanceWindow"] = sgp.MaintenanceWindow
	}
	if sgp.AvailabilityZone != nil {
		objectMap["availabilityZone"] = sgp.AvailabilityZone
	}
	if sgp.StandbyAvailabilityZone != nil {
		objectMap["standbyAvailabilityZone"] = sgp.StandbyAvailabilityZone
	}
	if sgp.DelegatedSubnetArguments != nil {
		objectMap["delegatedSubnetArguments"] = sgp.DelegatedSubnetArguments
	}
	if sgp.PrivateDNSZoneArguments != nil {
		objectMap["privateDnsZoneArguments"] = sgp.PrivateDNSZoneArguments
	}
	if sgp.SourceSubscriptionID != nil {
		objectMap["sourceSubscriptionId"] = sgp.SourceSubscriptionID
	}
	if sgp.SourceResourceGroupName != nil {
		objectMap["sourceResourceGroupName"] = sgp.SourceResourceGroupName
	}
	if sgp.SourceServerGroupName != nil {
		objectMap["sourceServerGroupName"] = sgp.SourceServerGroupName
	}
	if sgp.SourceLocation != nil {
		objectMap["sourceLocation"] = sgp.SourceLocation
	}
	if sgp.PointInTimeUTC != nil {
		objectMap["pointInTimeUTC"] = sgp.PointInTimeUTC
	}
	return json.Marshal(objectMap)
}

// ServerGroupPropertiesDelegatedSubnetArguments the delegated subnet arguments for a server group.
type ServerGroupPropertiesDelegatedSubnetArguments struct {
	// SubnetArmResourceID - delegated subnet arm resource id.
	SubnetArmResourceID *string `json:"subnetArmResourceId,omitempty"`
}

// ServerGroupPropertiesForUpdate the properties used to update a server group.
type ServerGroupPropertiesForUpdate struct {
	// AdministratorLoginPassword - The password of the administrator login.
	AdministratorLoginPassword *string `json:"administratorLoginPassword,omitempty"`
	// BackupRetentionDays - The backup retention days for server group.
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// PostgresqlVersion - The PostgreSQL version of server group. Possible values include: 'OneOne', 'OneTwo'
	PostgresqlVersion PostgreSQLVersion `json:"postgresqlVersion,omitempty"`
	// CitusVersion - The Citus version of server group. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion CitusVersion `json:"citusVersion,omitempty"`
	// EnableShardsOnCoordinator - If shards on coordinator is enabled or not for the server group.
	EnableShardsOnCoordinator *bool `json:"enableShardsOnCoordinator,omitempty"`
	// ServerRoleGroups - The list of server role groups.
	ServerRoleGroups *[]ServerRoleGroup `json:"serverRoleGroups,omitempty"`
	// MaintenanceWindow - Maintenance window of a server group.
	MaintenanceWindow *MaintenanceWindow `json:"maintenanceWindow,omitempty"`
	// AvailabilityZone - Availability Zone information of the server group.
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
	// StandbyAvailabilityZone - Standby Availability Zone information of the server group.
	StandbyAvailabilityZone *string `json:"standbyAvailabilityZone,omitempty"`
}

// ServerGroupPropertiesPrivateDNSZoneArguments the private dns zone arguments for a server group.
type ServerGroupPropertiesPrivateDNSZoneArguments struct {
	// PrivateDNSZoneArmResourceID - private dns zone arm resource id.
	PrivateDNSZoneArmResourceID *string `json:"privateDnsZoneArmResourceId,omitempty"`
}

// ServerGroupsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ServerGroupsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServerGroupsClient) (ServerGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServerGroupsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServerGroupsCreateOrUpdateFuture.Result.
func (future *ServerGroupsCreateOrUpdateFuture) result(client ServerGroupsClient) (sg ServerGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sg.Response.Response, err = future.GetResult(sender); err == nil && sg.Response.Response.StatusCode != http.StatusNoContent {
		sg, err = client.CreateOrUpdateResponder(sg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsCreateOrUpdateFuture", "Result", sg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServerGroupsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServerGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServerGroupsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServerGroupsDeleteFuture.Result.
func (future *ServerGroupsDeleteFuture) result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupServer represents a server in a server group.
type ServerGroupServer struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// ServerGroupServerProperties - The properties of a server in a server group.
	*ServerGroupServerProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupServer.
func (sgs ServerGroupServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgs.SystemData != nil {
		objectMap["systemData"] = sgs.SystemData
	}
	if sgs.ServerGroupServerProperties != nil {
		objectMap["properties"] = sgs.ServerGroupServerProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerGroupServer struct.
func (sgs *ServerGroupServer) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sgs.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var serverGroupServerProperties ServerGroupServerProperties
				err = json.Unmarshal(*v, &serverGroupServerProperties)
				if err != nil {
					return err
				}
				sgs.ServerGroupServerProperties = &serverGroupServerProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sgs.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sgs.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sgs.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerGroupServerListResult a list of servers in a server group.
type ServerGroupServerListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of servers in a server group.
	Value *[]ServerGroupServer `json:"value,omitempty"`
}

// ServerGroupServerProperties the properties of a server in server group.
type ServerGroupServerProperties struct {
	// FullyQualifiedDomainName - The fully qualified domain name of a server.
	FullyQualifiedDomainName *string `json:"fullyQualifiedDomainName,omitempty"`
	// Role - The role of server in the server group. Possible values include: 'Coordinator', 'Worker'
	Role ServerRole `json:"role,omitempty"`
	// State - A state of a server that is visible to user. Possible values include: 'Ready', 'Dropping', 'Disabled', 'Starting', 'Stopping', 'Stopped', 'Updating', 'Provisioning'
	State ServerState `json:"state,omitempty"`
	// HaState - A state of a server group that is visible to user for HA feature. Possible values include: 'NotEnabled', 'CreatingStandby', 'ReplicatingData', 'FailingOver', 'Healthy', 'RemovingStandby', 'NotSync'
	HaState ServerHaState `json:"haState,omitempty"`
	// AdministratorLogin - The administrator's login name of a servers in server group.
	AdministratorLogin *string `json:"administratorLogin,omitempty"`
	// PostgresqlVersion - The PostgreSQL version of server. Possible values include: 'OneOne', 'OneTwo'
	PostgresqlVersion PostgreSQLVersion `json:"postgresqlVersion,omitempty"`
	// CitusVersion - The Citus version of server. Possible values include: 'EightFullStopThree', 'NineFullStopZero', 'NineFullStopOne', 'NineFullStopTwo', 'NineFullStopThree', 'NineFullStopFour', 'NineFullStopFive'
	CitusVersion CitusVersion `json:"citusVersion,omitempty"`
	// AvailabilityZone - Availability Zone information of the server group.
	AvailabilityZone *string `json:"availabilityZone,omitempty"`
	// StandbyAvailabilityZone - Standby Availability Zone information of the server group.
	StandbyAvailabilityZone *string `json:"standbyAvailabilityZone,omitempty"`
	// ServerEdition - The edition of a server (default: GeneralPurpose). Possible values include: 'GeneralPurpose', 'MemoryOptimized'
	ServerEdition ServerEdition `json:"serverEdition,omitempty"`
	// StorageQuotaInMb - The storage of a server in MB (max: 2097152 = 2TiB).
	StorageQuotaInMb *int64 `json:"storageQuotaInMb,omitempty"`
	// VCores - The vCores count of a server (max: 64).
	VCores *int64 `json:"vCores,omitempty"`
	// EnableHa - If high availability is enabled or not for the server.
	EnableHa *bool `json:"enableHa,omitempty"`
	// EnablePublicIP - READ-ONLY; If public IP is requested or not for a server.
	EnablePublicIP *bool `json:"enablePublicIp,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerGroupServerProperties.
func (sgsp ServerGroupServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgsp.FullyQualifiedDomainName != nil {
		objectMap["fullyQualifiedDomainName"] = sgsp.FullyQualifiedDomainName
	}
	if sgsp.Role != "" {
		objectMap["role"] = sgsp.Role
	}
	if sgsp.State != "" {
		objectMap["state"] = sgsp.State
	}
	if sgsp.HaState != "" {
		objectMap["haState"] = sgsp.HaState
	}
	if sgsp.AdministratorLogin != nil {
		objectMap["administratorLogin"] = sgsp.AdministratorLogin
	}
	if sgsp.PostgresqlVersion != "" {
		objectMap["postgresqlVersion"] = sgsp.PostgresqlVersion
	}
	if sgsp.CitusVersion != "" {
		objectMap["citusVersion"] = sgsp.CitusVersion
	}
	if sgsp.AvailabilityZone != nil {
		objectMap["availabilityZone"] = sgsp.AvailabilityZone
	}
	if sgsp.StandbyAvailabilityZone != nil {
		objectMap["standbyAvailabilityZone"] = sgsp.StandbyAvailabilityZone
	}
	if sgsp.ServerEdition != "" {
		objectMap["serverEdition"] = sgsp.ServerEdition
	}
	if sgsp.StorageQuotaInMb != nil {
		objectMap["storageQuotaInMb"] = sgsp.StorageQuotaInMb
	}
	if sgsp.VCores != nil {
		objectMap["vCores"] = sgsp.VCores
	}
	if sgsp.EnableHa != nil {
		objectMap["enableHa"] = sgsp.EnableHa
	}
	return json.Marshal(objectMap)
}

// ServerGroupsRestartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsRestartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServerGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServerGroupsRestartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServerGroupsRestartFuture.Result.
func (future *ServerGroupsRestartFuture) result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsRestartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsRestartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupsStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServerGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServerGroupsStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServerGroupsStartFuture.Result.
func (future *ServerGroupsStartFuture) result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupsStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServerGroupsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServerGroupsStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServerGroupsStopFuture.Result.
func (future *ServerGroupsStopFuture) result(client ServerGroupsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerGroupsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerGroupsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ServerGroupsClient) (ServerGroup, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ServerGroupsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ServerGroupsUpdateFuture.Result.
func (future *ServerGroupsUpdateFuture) result(client ServerGroupsClient) (sg ServerGroup, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sg.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("postgresqlhsc.ServerGroupsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sg.Response.Response, err = future.GetResult(sender); err == nil && sg.Response.Response.StatusCode != http.StatusNoContent {
		sg, err = client.UpdateResponder(sg.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "postgresqlhsc.ServerGroupsUpdateFuture", "Result", sg.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServerNameItem the name object for a server.
type ServerNameItem struct {
	// Name - The name of a server.
	Name *string `json:"name,omitempty"`
	// FullyQualifiedDomainName - The fully qualified domain name of a server.
	FullyQualifiedDomainName *string `json:"fullyQualifiedDomainName,omitempty"`
}

// ServerProperties the properties of a server.
type ServerProperties struct {
	// ServerEdition - The edition of a server (default: GeneralPurpose). Possible values include: 'GeneralPurpose', 'MemoryOptimized'
	ServerEdition ServerEdition `json:"serverEdition,omitempty"`
	// StorageQuotaInMb - The storage of a server in MB (max: 2097152 = 2TiB).
	StorageQuotaInMb *int64 `json:"storageQuotaInMb,omitempty"`
	// VCores - The vCores count of a server (max: 64).
	VCores *int64 `json:"vCores,omitempty"`
	// EnableHa - If high availability is enabled or not for the server.
	EnableHa *bool `json:"enableHa,omitempty"`
	// EnablePublicIP - READ-ONLY; If public IP is requested or not for a server.
	EnablePublicIP *bool `json:"enablePublicIp,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerProperties.
func (sp ServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.ServerEdition != "" {
		objectMap["serverEdition"] = sp.ServerEdition
	}
	if sp.StorageQuotaInMb != nil {
		objectMap["storageQuotaInMb"] = sp.StorageQuotaInMb
	}
	if sp.VCores != nil {
		objectMap["vCores"] = sp.VCores
	}
	if sp.EnableHa != nil {
		objectMap["enableHa"] = sp.EnableHa
	}
	return json.Marshal(objectMap)
}

// ServerRoleGroup represents a server role group.
type ServerRoleGroup struct {
	// Name - The name of the server role group.
	Name *string `json:"name,omitempty"`
	// Role - The role of servers in the server role group. Possible values include: 'Coordinator', 'Worker'
	Role ServerRole `json:"role,omitempty"`
	// ServerCount - The number of servers in the server role group.
	ServerCount *int32 `json:"serverCount,omitempty"`
	// ServerNames - READ-ONLY; The list of server names in the server role group.
	ServerNames *[]ServerNameItem `json:"serverNames,omitempty"`
	// ServerEdition - The edition of a server (default: GeneralPurpose). Possible values include: 'GeneralPurpose', 'MemoryOptimized'
	ServerEdition ServerEdition `json:"serverEdition,omitempty"`
	// StorageQuotaInMb - The storage of a server in MB (max: 2097152 = 2TiB).
	StorageQuotaInMb *int64 `json:"storageQuotaInMb,omitempty"`
	// VCores - The vCores count of a server (max: 64).
	VCores *int64 `json:"vCores,omitempty"`
	// EnableHa - If high availability is enabled or not for the server.
	EnableHa *bool `json:"enableHa,omitempty"`
	// EnablePublicIP - READ-ONLY; If public IP is requested or not for a server.
	EnablePublicIP *bool `json:"enablePublicIp,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerRoleGroup.
func (srg ServerRoleGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srg.Name != nil {
		objectMap["name"] = srg.Name
	}
	if srg.Role != "" {
		objectMap["role"] = srg.Role
	}
	if srg.ServerCount != nil {
		objectMap["serverCount"] = srg.ServerCount
	}
	if srg.ServerEdition != "" {
		objectMap["serverEdition"] = srg.ServerEdition
	}
	if srg.StorageQuotaInMb != nil {
		objectMap["storageQuotaInMb"] = srg.StorageQuotaInMb
	}
	if srg.VCores != nil {
		objectMap["vCores"] = srg.VCores
	}
	if srg.EnableHa != nil {
		objectMap["enableHa"] = srg.EnableHa
	}
	return json.Marshal(objectMap)
}

// ServerRoleGroupConfiguration represents server role group configuration value.
type ServerRoleGroupConfiguration struct {
	// Role - The role of servers in the server role group. Possible values include: 'Coordinator', 'Worker'
	Role ServerRole `json:"role,omitempty"`
	// Value - Value of the configuration.
	Value *string `json:"value,omitempty"`
	// DefaultValue - READ-ONLY; Default value of the configuration.
	DefaultValue *string `json:"defaultValue,omitempty"`
	// Source - READ-ONLY; Source of the configuration.
	Source *string `json:"source,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerRoleGroupConfiguration.
func (srgc ServerRoleGroupConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if srgc.Role != "" {
		objectMap["role"] = srgc.Role
	}
	if srgc.Value != nil {
		objectMap["value"] = srgc.Value
	}
	return json.Marshal(objectMap)
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}
