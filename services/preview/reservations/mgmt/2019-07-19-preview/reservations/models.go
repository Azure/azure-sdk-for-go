package reservations

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/reservations/mgmt/2019-07-19-preview/reservations"

// AppliedScopeType enumerates the values for applied scope type.
type AppliedScopeType string

const (
	// Shared ...
	Shared AppliedScopeType = "Shared"
	// Single ...
	Single AppliedScopeType = "Single"
)

// PossibleAppliedScopeTypeValues returns an array of possible values for the AppliedScopeType const type.
func PossibleAppliedScopeTypeValues() []AppliedScopeType {
	return []AppliedScopeType{Shared, Single}
}

// ErrorResponseCode enumerates the values for error response code.
type ErrorResponseCode string

const (
	// ActivateQuoteFailed ...
	ActivateQuoteFailed ErrorResponseCode = "ActivateQuoteFailed"
	// AppliedScopesNotAssociatedWithCommerceAccount ...
	AppliedScopesNotAssociatedWithCommerceAccount ErrorResponseCode = "AppliedScopesNotAssociatedWithCommerceAccount"
	// AuthorizationFailed ...
	AuthorizationFailed ErrorResponseCode = "AuthorizationFailed"
	// BadRequest ...
	BadRequest ErrorResponseCode = "BadRequest"
	// BillingCustomerInputError ...
	BillingCustomerInputError ErrorResponseCode = "BillingCustomerInputError"
	// BillingError ...
	BillingError ErrorResponseCode = "BillingError"
	// BillingPaymentInstrumentHardError ...
	BillingPaymentInstrumentHardError ErrorResponseCode = "BillingPaymentInstrumentHardError"
	// BillingPaymentInstrumentSoftError ...
	BillingPaymentInstrumentSoftError ErrorResponseCode = "BillingPaymentInstrumentSoftError"
	// BillingScopeIDCannotBeChanged ...
	BillingScopeIDCannotBeChanged ErrorResponseCode = "BillingScopeIdCannotBeChanged"
	// BillingTransientError ...
	BillingTransientError ErrorResponseCode = "BillingTransientError"
	// CalculatePriceFailed ...
	CalculatePriceFailed ErrorResponseCode = "CalculatePriceFailed"
	// CapacityUpdateScopesFailed ...
	CapacityUpdateScopesFailed ErrorResponseCode = "CapacityUpdateScopesFailed"
	// ClientCertificateThumbprintNotSet ...
	ClientCertificateThumbprintNotSet ErrorResponseCode = "ClientCertificateThumbprintNotSet"
	// CreateQuoteFailed ...
	CreateQuoteFailed ErrorResponseCode = "CreateQuoteFailed"
	// Forbidden ...
	Forbidden ErrorResponseCode = "Forbidden"
	// FulfillmentConfigurationError ...
	FulfillmentConfigurationError ErrorResponseCode = "FulfillmentConfigurationError"
	// FulfillmentError ...
	FulfillmentError ErrorResponseCode = "FulfillmentError"
	// FulfillmentOutOfStockError ...
	FulfillmentOutOfStockError ErrorResponseCode = "FulfillmentOutOfStockError"
	// FulfillmentTransientError ...
	FulfillmentTransientError ErrorResponseCode = "FulfillmentTransientError"
	// HTTPMethodNotSupported ...
	HTTPMethodNotSupported ErrorResponseCode = "HttpMethodNotSupported"
	// InternalServerError ...
	InternalServerError ErrorResponseCode = "InternalServerError"
	// InvalidAccessToken ...
	InvalidAccessToken ErrorResponseCode = "InvalidAccessToken"
	// InvalidFulfillmentRequestParameters ...
	InvalidFulfillmentRequestParameters ErrorResponseCode = "InvalidFulfillmentRequestParameters"
	// InvalidHealthCheckType ...
	InvalidHealthCheckType ErrorResponseCode = "InvalidHealthCheckType"
	// InvalidLocationID ...
	InvalidLocationID ErrorResponseCode = "InvalidLocationId"
	// InvalidRefundQuantity ...
	InvalidRefundQuantity ErrorResponseCode = "InvalidRefundQuantity"
	// InvalidRequestContent ...
	InvalidRequestContent ErrorResponseCode = "InvalidRequestContent"
	// InvalidRequestURI ...
	InvalidRequestURI ErrorResponseCode = "InvalidRequestUri"
	// InvalidReservationID ...
	InvalidReservationID ErrorResponseCode = "InvalidReservationId"
	// InvalidReservationOrderID ...
	InvalidReservationOrderID ErrorResponseCode = "InvalidReservationOrderId"
	// InvalidSingleAppliedScopesCount ...
	InvalidSingleAppliedScopesCount ErrorResponseCode = "InvalidSingleAppliedScopesCount"
	// InvalidSubscriptionID ...
	InvalidSubscriptionID ErrorResponseCode = "InvalidSubscriptionId"
	// InvalidTenantID ...
	InvalidTenantID ErrorResponseCode = "InvalidTenantId"
	// MissingAppliedScopesForSingle ...
	MissingAppliedScopesForSingle ErrorResponseCode = "MissingAppliedScopesForSingle"
	// MissingTenantID ...
	MissingTenantID ErrorResponseCode = "MissingTenantId"
	// NonsupportedAccountID ...
	NonsupportedAccountID ErrorResponseCode = "NonsupportedAccountId"
	// NotSpecified ...
	NotSpecified ErrorResponseCode = "NotSpecified"
	// NotSupportedCountry ...
	NotSupportedCountry ErrorResponseCode = "NotSupportedCountry"
	// NoValidReservationsToReRate ...
	NoValidReservationsToReRate ErrorResponseCode = "NoValidReservationsToReRate"
	// OperationCannotBePerformedInCurrentState ...
	OperationCannotBePerformedInCurrentState ErrorResponseCode = "OperationCannotBePerformedInCurrentState"
	// OperationFailed ...
	OperationFailed ErrorResponseCode = "OperationFailed"
	// PatchValuesSameAsExisting ...
	PatchValuesSameAsExisting ErrorResponseCode = "PatchValuesSameAsExisting"
	// PaymentInstrumentNotFound ...
	PaymentInstrumentNotFound ErrorResponseCode = "PaymentInstrumentNotFound"
	// PurchaseError ...
	PurchaseError ErrorResponseCode = "PurchaseError"
	// ReRateOnlyAllowedForEA ...
	ReRateOnlyAllowedForEA ErrorResponseCode = "ReRateOnlyAllowedForEA"
	// ReservationIDNotInReservationOrder ...
	ReservationIDNotInReservationOrder ErrorResponseCode = "ReservationIdNotInReservationOrder"
	// ReservationOrderCreationFailed ...
	ReservationOrderCreationFailed ErrorResponseCode = "ReservationOrderCreationFailed"
	// ReservationOrderIDAlreadyExists ...
	ReservationOrderIDAlreadyExists ErrorResponseCode = "ReservationOrderIdAlreadyExists"
	// ReservationOrderNotEnabled ...
	ReservationOrderNotEnabled ErrorResponseCode = "ReservationOrderNotEnabled"
	// ReservationOrderNotFound ...
	ReservationOrderNotFound ErrorResponseCode = "ReservationOrderNotFound"
	// RiskCheckFailed ...
	RiskCheckFailed ErrorResponseCode = "RiskCheckFailed"
	// RoleAssignmentCreationFailed ...
	RoleAssignmentCreationFailed ErrorResponseCode = "RoleAssignmentCreationFailed"
	// ServerTimeout ...
	ServerTimeout ErrorResponseCode = "ServerTimeout"
	// UnauthenticatedRequestsThrottled ...
	UnauthenticatedRequestsThrottled ErrorResponseCode = "UnauthenticatedRequestsThrottled"
	// UnsupportedReservationTerm ...
	UnsupportedReservationTerm ErrorResponseCode = "UnsupportedReservationTerm"
)

// PossibleErrorResponseCodeValues returns an array of possible values for the ErrorResponseCode const type.
func PossibleErrorResponseCodeValues() []ErrorResponseCode {
	return []ErrorResponseCode{ActivateQuoteFailed, AppliedScopesNotAssociatedWithCommerceAccount, AuthorizationFailed, BadRequest, BillingCustomerInputError, BillingError, BillingPaymentInstrumentHardError, BillingPaymentInstrumentSoftError, BillingScopeIDCannotBeChanged, BillingTransientError, CalculatePriceFailed, CapacityUpdateScopesFailed, ClientCertificateThumbprintNotSet, CreateQuoteFailed, Forbidden, FulfillmentConfigurationError, FulfillmentError, FulfillmentOutOfStockError, FulfillmentTransientError, HTTPMethodNotSupported, InternalServerError, InvalidAccessToken, InvalidFulfillmentRequestParameters, InvalidHealthCheckType, InvalidLocationID, InvalidRefundQuantity, InvalidRequestContent, InvalidRequestURI, InvalidReservationID, InvalidReservationOrderID, InvalidSingleAppliedScopesCount, InvalidSubscriptionID, InvalidTenantID, MissingAppliedScopesForSingle, MissingTenantID, NonsupportedAccountID, NotSpecified, NotSupportedCountry, NoValidReservationsToReRate, OperationCannotBePerformedInCurrentState, OperationFailed, PatchValuesSameAsExisting, PaymentInstrumentNotFound, PurchaseError, ReRateOnlyAllowedForEA, ReservationIDNotInReservationOrder, ReservationOrderCreationFailed, ReservationOrderIDAlreadyExists, ReservationOrderNotEnabled, ReservationOrderNotFound, RiskCheckFailed, RoleAssignmentCreationFailed, ServerTimeout, UnauthenticatedRequestsThrottled, UnsupportedReservationTerm}
}

// InstanceFlexibility enumerates the values for instance flexibility.
type InstanceFlexibility string

const (
	// Off ...
	Off InstanceFlexibility = "Off"
	// On ...
	On InstanceFlexibility = "On"
)

// PossibleInstanceFlexibilityValues returns an array of possible values for the InstanceFlexibility const type.
func PossibleInstanceFlexibilityValues() []InstanceFlexibility {
	return []InstanceFlexibility{Off, On}
}

// PaymentStatus enumerates the values for payment status.
type PaymentStatus string

const (
	// Cancelled ...
	Cancelled PaymentStatus = "Cancelled"
	// Failed ...
	Failed PaymentStatus = "Failed"
	// Scheduled ...
	Scheduled PaymentStatus = "Scheduled"
	// Succeeded ...
	Succeeded PaymentStatus = "Succeeded"
)

// PossiblePaymentStatusValues returns an array of possible values for the PaymentStatus const type.
func PossiblePaymentStatusValues() []PaymentStatus {
	return []PaymentStatus{Cancelled, Failed, Scheduled, Succeeded}
}

// ReservationBillingPlan enumerates the values for reservation billing plan.
type ReservationBillingPlan string

const (
	// Monthly ...
	Monthly ReservationBillingPlan = "Monthly"
	// Upfront ...
	Upfront ReservationBillingPlan = "Upfront"
)

// PossibleReservationBillingPlanValues returns an array of possible values for the ReservationBillingPlan const type.
func PossibleReservationBillingPlanValues() []ReservationBillingPlan {
	return []ReservationBillingPlan{Monthly, Upfront}
}

// ReservationTerm enumerates the values for reservation term.
type ReservationTerm string

const (
	// P1Y ...
	P1Y ReservationTerm = "P1Y"
	// P3Y ...
	P3Y ReservationTerm = "P3Y"
)

// PossibleReservationTermValues returns an array of possible values for the ReservationTerm const type.
func PossibleReservationTermValues() []ReservationTerm {
	return []ReservationTerm{P1Y, P3Y}
}

// ReservedResourceType enumerates the values for reserved resource type.
type ReservedResourceType string

const (
	// CosmosDb ...
	CosmosDb ReservedResourceType = "CosmosDb"
	// RedHat ...
	RedHat ReservedResourceType = "RedHat"
	// RedHatOsa ...
	RedHatOsa ReservedResourceType = "RedHatOsa"
	// SQLDatabases ...
	SQLDatabases ReservedResourceType = "SqlDatabases"
	// SQLDataWarehouse ...
	SQLDataWarehouse ReservedResourceType = "SqlDataWarehouse"
	// SuseLinux ...
	SuseLinux ReservedResourceType = "SuseLinux"
	// VirtualMachines ...
	VirtualMachines ReservedResourceType = "VirtualMachines"
	// VMwareCloudSimple ...
	VMwareCloudSimple ReservedResourceType = "VMwareCloudSimple"
)

// PossibleReservedResourceTypeValues returns an array of possible values for the ReservedResourceType const type.
func PossibleReservedResourceTypeValues() []ReservedResourceType {
	return []ReservedResourceType{CosmosDb, RedHat, RedHatOsa, SQLDatabases, SQLDataWarehouse, SuseLinux, VirtualMachines, VMwareCloudSimple}
}

// StatusCode enumerates the values for status code.
type StatusCode string

const (
	// StatusCodeActive ...
	StatusCodeActive StatusCode = "Active"
	// StatusCodeExpired ...
	StatusCodeExpired StatusCode = "Expired"
	// StatusCodeMerged ...
	StatusCodeMerged StatusCode = "Merged"
	// StatusCodeNone ...
	StatusCodeNone StatusCode = "None"
	// StatusCodePaymentInstrumentError ...
	StatusCodePaymentInstrumentError StatusCode = "PaymentInstrumentError"
	// StatusCodePending ...
	StatusCodePending StatusCode = "Pending"
	// StatusCodePurchaseError ...
	StatusCodePurchaseError StatusCode = "PurchaseError"
	// StatusCodeSplit ...
	StatusCodeSplit StatusCode = "Split"
	// StatusCodeSucceeded ...
	StatusCodeSucceeded StatusCode = "Succeeded"
)

// PossibleStatusCodeValues returns an array of possible values for the StatusCode const type.
func PossibleStatusCodeValues() []StatusCode {
	return []StatusCode{StatusCodeActive, StatusCodeExpired, StatusCodeMerged, StatusCodeNone, StatusCodePaymentInstrumentError, StatusCodePending, StatusCodePurchaseError, StatusCodeSplit, StatusCodeSucceeded}
}

// AppliedReservationList ...
type AppliedReservationList struct {
	Value *[]string `json:"value,omitempty"`
	// NextLink - Url to get the next page of reservations
	NextLink *string `json:"nextLink,omitempty"`
}

// AppliedReservations ...
type AppliedReservations struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Identifier of the applied reservations
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/AppliedReservations"
	Type                           *string `json:"type,omitempty"`
	*AppliedReservationsProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AppliedReservations.
func (ar AppliedReservations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ar.AppliedReservationsProperties != nil {
		objectMap["properties"] = ar.AppliedReservationsProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppliedReservations struct.
func (ar *AppliedReservations) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ar.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var appliedReservationsProperties AppliedReservationsProperties
				err = json.Unmarshal(*v, &appliedReservationsProperties)
				if err != nil {
					return err
				}
				ar.AppliedReservationsProperties = &appliedReservationsProperties
			}
		}
	}

	return nil
}

// AppliedReservationsProperties ...
type AppliedReservationsProperties struct {
	ReservationOrderIds *AppliedReservationList `json:"reservationOrderIds,omitempty"`
}

// AqiSettings settings for auto quota increase.
type AqiSettings struct {
	// AutoQuotaIncreaseState - If the subscription has enabled automatic quota increase.
	AutoQuotaIncreaseState interface{} `json:"autoQuotaIncreaseState,omitempty"`
}

// AutoQuotaIncreaseDetail auto Quota Increase settings.
type AutoQuotaIncreaseDetail struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The subscription Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the auto quota increase.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource
	Type *string `json:"type,omitempty"`
	// AutoQuotaIncreaseSettings - Actions for auto quota increase.
	*AutoQuotaIncreaseSettings `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AutoQuotaIncreaseDetail.
func (aqid AutoQuotaIncreaseDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aqid.AutoQuotaIncreaseSettings != nil {
		objectMap["properties"] = aqid.AutoQuotaIncreaseSettings
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AutoQuotaIncreaseDetail struct.
func (aqid *AutoQuotaIncreaseDetail) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				aqid.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				aqid.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				aqid.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var autoQuotaIncreaseSettings AutoQuotaIncreaseSettings
				err = json.Unmarshal(*v, &autoQuotaIncreaseSettings)
				if err != nil {
					return err
				}
				aqid.AutoQuotaIncreaseSettings = &autoQuotaIncreaseSettings
			}
		}
	}

	return nil
}

// AutoQuotaIncreaseSettings actions for auto quota increase.
type AutoQuotaIncreaseSettings struct {
	// Settings - Settings for automatic quota increase.
	Settings *AqiSettings `json:"settings,omitempty"`
	// OnFailure - The on failure Actions.
	OnFailure *OnFailure `json:"onFailure,omitempty"`
	// OnSuccess - The on success Actions.
	OnSuccess *OnFailure `json:"onSuccess,omitempty"`
	// SupportTicketAction - The support ticket action.
	SupportTicketAction *SupportRequestAction `json:"supportTicketAction,omitempty"`
}

// CalculatePriceResponse ...
type CalculatePriceResponse struct {
	autorest.Response `json:"-"`
	Properties        *CalculatePriceResponseProperties `json:"properties,omitempty"`
}

// CalculatePriceResponseProperties ...
type CalculatePriceResponseProperties struct {
	// BillingCurrencyTotal - Currency and amount that customer will be charged in customer's local currency. Tax is not included.
	BillingCurrencyTotal *CalculatePriceResponsePropertiesBillingCurrencyTotal `json:"billingCurrencyTotal,omitempty"`
	// IsBillingPartnerManaged - True if billing is managed by Microsoft Partner. Used only for CSP accounts.
	IsBillingPartnerManaged *bool `json:"isBillingPartnerManaged,omitempty"`
	// ReservationOrderID - GUID that represents reservation order that can be placed after calculating price.
	ReservationOrderID *string `json:"reservationOrderId,omitempty"`
	// SkuTitle - Title of SKU that is being purchased.
	SkuTitle *string `json:"skuTitle,omitempty"`
	// SkuDescription - Description of SKU that is being purchased.
	SkuDescription *string `json:"skuDescription,omitempty"`
	// PricingCurrencyTotal - Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included.
	PricingCurrencyTotal *CalculatePriceResponsePropertiesPricingCurrencyTotal `json:"pricingCurrencyTotal,omitempty"`
	PaymentSchedule      *[]PaymentDetail                                      `json:"paymentSchedule,omitempty"`
}

// CalculatePriceResponsePropertiesBillingCurrencyTotal currency and amount that customer will be charged
// in customer's local currency. Tax is not included.
type CalculatePriceResponsePropertiesBillingCurrencyTotal struct {
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// CalculatePriceResponsePropertiesPricingCurrencyTotal amount that Microsoft uses for record. Used during
// refund for calculating refund limit. Tax is not included.
type CalculatePriceResponsePropertiesPricingCurrencyTotal struct {
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// Catalog ...
type Catalog struct {
	// ResourceType - READ-ONLY; The type of resource the SKU applies to.
	ResourceType *string `json:"resourceType,omitempty"`
	// Name - READ-ONLY; The name of SKU
	Name *string `json:"name,omitempty"`
	// BillingPlans - The billing plan options available for this SKU.
	BillingPlans map[string][]ReservationBillingPlan `json:"billingPlans"`
	// Terms - READ-ONLY; Available reservation terms for this resource
	Terms *[]ReservationTerm `json:"terms,omitempty"`
	// Locations - READ-ONLY
	Locations *[]string `json:"locations,omitempty"`
	// SkuProperties - READ-ONLY
	SkuProperties *[]SkuProperty `json:"skuProperties,omitempty"`
	// Restrictions - READ-ONLY
	Restrictions *[]SkuRestriction `json:"restrictions,omitempty"`
}

// MarshalJSON is the custom marshaler for Catalog.
func (c Catalog) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.BillingPlans != nil {
		objectMap["billingPlans"] = c.BillingPlans
	}
	return json.Marshal(objectMap)
}

// CreateGenericQuotaRequestParameters quota change requests information.
type CreateGenericQuotaRequestParameters struct {
	// Value - Quota change requests.
	Value *[]CurrentQuotaLimitBase `json:"value,omitempty"`
}

// CurrentQuotaLimit quota limits.
type CurrentQuotaLimit struct {
	// CurrentQuotaLimitBase - Quota information detail.
	*CurrentQuotaLimitBase `json:"quotaInformation,omitempty"`
	// QuotaRequestStatusDetails - Addition properties for the quota request status for the resource.
	*QuotaRequestStatusDetails `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CurrentQuotaLimit.
func (cql CurrentQuotaLimit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cql.CurrentQuotaLimitBase != nil {
		objectMap["quotaInformation"] = cql.CurrentQuotaLimitBase
	}
	if cql.QuotaRequestStatusDetails != nil {
		objectMap["properties"] = cql.QuotaRequestStatusDetails
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CurrentQuotaLimit struct.
func (cql *CurrentQuotaLimit) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "quotaInformation":
			if v != nil {
				var currentQuotaLimitBase CurrentQuotaLimitBase
				err = json.Unmarshal(*v, &currentQuotaLimitBase)
				if err != nil {
					return err
				}
				cql.CurrentQuotaLimitBase = &currentQuotaLimitBase
			}
		case "properties":
			if v != nil {
				var quotaRequestStatusDetails QuotaRequestStatusDetails
				err = json.Unmarshal(*v, &quotaRequestStatusDetails)
				if err != nil {
					return err
				}
				cql.QuotaRequestStatusDetails = &quotaRequestStatusDetails
			}
		}
	}

	return nil
}

// CurrentQuotaLimitBase quota limits.
type CurrentQuotaLimitBase struct {
	autorest.Response `json:"-"`
	// Properties - Quota properties for the resource.
	Properties *QuotaProperties `json:"properties,omitempty"`
}

// EmailAction email Action.
type EmailAction struct {
	// EmailAddress - The email address for the action.
	EmailAddress *string `json:"emailAddress,omitempty"`
}

// EmailActions the email actions.
type EmailActions struct {
	// Value - The list of email actions based on the success or failure of automatic quota increase action.
	Value *[]EmailAction `json:"value,omitempty"`
}

// Error ...
type Error struct {
	Error *ExtendedErrorInfo `json:"error,omitempty"`
}

// ExceptionResponse the api error.
type ExceptionResponse struct {
	// Error - The api error details.
	Error *ServiceError `json:"error,omitempty"`
}

// ExtendedErrorInfo ...
type ExtendedErrorInfo struct {
	// Code - Possible values include: 'NotSpecified', 'InternalServerError', 'ServerTimeout', 'AuthorizationFailed', 'BadRequest', 'ClientCertificateThumbprintNotSet', 'InvalidRequestContent', 'OperationFailed', 'HTTPMethodNotSupported', 'InvalidRequestURI', 'MissingTenantID', 'InvalidTenantID', 'InvalidReservationOrderID', 'InvalidReservationID', 'ReservationIDNotInReservationOrder', 'ReservationOrderNotFound', 'InvalidSubscriptionID', 'InvalidAccessToken', 'InvalidLocationID', 'UnauthenticatedRequestsThrottled', 'InvalidHealthCheckType', 'Forbidden', 'BillingScopeIDCannotBeChanged', 'AppliedScopesNotAssociatedWithCommerceAccount', 'PatchValuesSameAsExisting', 'RoleAssignmentCreationFailed', 'ReservationOrderCreationFailed', 'ReservationOrderNotEnabled', 'CapacityUpdateScopesFailed', 'UnsupportedReservationTerm', 'ReservationOrderIDAlreadyExists', 'RiskCheckFailed', 'CreateQuoteFailed', 'ActivateQuoteFailed', 'NonsupportedAccountID', 'PaymentInstrumentNotFound', 'MissingAppliedScopesForSingle', 'NoValidReservationsToReRate', 'ReRateOnlyAllowedForEA', 'OperationCannotBePerformedInCurrentState', 'InvalidSingleAppliedScopesCount', 'InvalidFulfillmentRequestParameters', 'NotSupportedCountry', 'InvalidRefundQuantity', 'PurchaseError', 'BillingCustomerInputError', 'BillingPaymentInstrumentSoftError', 'BillingPaymentInstrumentHardError', 'BillingTransientError', 'BillingError', 'FulfillmentConfigurationError', 'FulfillmentOutOfStockError', 'FulfillmentTransientError', 'FulfillmentError', 'CalculatePriceFailed'
	Code    ErrorResponseCode `json:"code,omitempty"`
	Message *string           `json:"message,omitempty"`
}

// ExtendedStatusInfo ...
type ExtendedStatusInfo struct {
	// StatusCode - Possible values include: 'StatusCodeNone', 'StatusCodePending', 'StatusCodeActive', 'StatusCodePurchaseError', 'StatusCodePaymentInstrumentError', 'StatusCodeSplit', 'StatusCodeMerged', 'StatusCodeExpired', 'StatusCodeSucceeded'
	StatusCode StatusCode `json:"statusCode,omitempty"`
	// Message - The message giving detailed information about the status code.
	Message *string `json:"message,omitempty"`
}

// List ...
type List struct {
	autorest.Response `json:"-"`
	Value             *[]Response `json:"value,omitempty"`
	// NextLink - Url to get the next page of reservations.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListCatalog ...
type ListCatalog struct {
	autorest.Response `json:"-"`
	Value             *[]Catalog `json:"value,omitempty"`
}

// ListIterator provides access to a complete listing of Response values.
type ListIterator struct {
	i    int
	page ListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListIterator) Response() List {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListIterator) Value() Response {
	if !iter.page.NotDone() {
		return Response{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListIterator type.
func NewListIterator(page ListPage) ListIterator {
	return ListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (l List) IsEmpty() bool {
	return l.Value == nil || len(*l.Value) == 0
}

// listPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (l List) listPreparer(ctx context.Context) (*http.Request, error) {
	if l.NextLink == nil || len(to.String(l.NextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(l.NextLink)))
}

// ListPage contains a page of Response values.
type ListPage struct {
	fn func(context.Context, List) (List, error)
	l  List
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.l)
	if err != nil {
		return err
	}
	page.l = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListPage) NotDone() bool {
	return !page.l.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListPage) Response() List {
	return page.l
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListPage) Values() []Response {
	if page.l.IsEmpty() {
		return nil
	}
	return *page.l.Value
}

// Creates a new instance of the ListPage type.
func NewListPage(getNextPage func(context.Context, List) (List, error)) ListPage {
	return ListPage{fn: getNextPage}
}

// ListResponse ...
type ListResponse struct {
	autorest.Response `json:"-"`
	Value             *[]Response `json:"value,omitempty"`
}

// MergeProperties ...
type MergeProperties struct {
	// Sources - Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	Sources *[]string `json:"sources,omitempty"`
}

// MergePropertiesType ...
type MergePropertiesType struct {
	// MergeDestination - Reservation Resource Id Created due to the merge. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	MergeDestination *string `json:"mergeDestination,omitempty"`
	// MergeSources - Resource Ids of the Source Reservation's merged to form this Reservation. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	MergeSources *[]string `json:"mergeSources,omitempty"`
}

// MergeRequest ...
type MergeRequest struct {
	*MergeProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for MergeRequest.
func (mr MergeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mr.MergeProperties != nil {
		objectMap["properties"] = mr.MergeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MergeRequest struct.
func (mr *MergeRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var mergeProperties MergeProperties
				err = json.Unmarshal(*v, &mergeProperties)
				if err != nil {
					return err
				}
				mr.MergeProperties = &mergeProperties
			}
		}
	}

	return nil
}

// OnFailure the actions for auto quota increase.
type OnFailure struct {
	// EmailActions - The email actions for auto quota increase.
	EmailActions *OnFailureEmailActions `json:"emailActions,omitempty"`
	// PhoneActions - The phone actions for auto quota increase.
	PhoneActions *OnFailurePhoneActions `json:"phoneActions,omitempty"`
}

// OnFailureEmailActions the email actions for auto quota increase.
type OnFailureEmailActions struct {
	// Value - The list of email actions.
	Value *[]EmailAction `json:"value,omitempty"`
}

// OnFailurePhoneActions the phone actions for auto quota increase.
type OnFailurePhoneActions struct {
	// Value - The list of phone actions.
	Value *[]PhoneAction `json:"value,omitempty"`
}

// OperationDisplay ...
type OperationDisplay struct {
	Provider    *string `json:"provider,omitempty"`
	Resource    *string `json:"resource,omitempty"`
	Operation   *string `json:"operation,omitempty"`
	Description *string `json:"description,omitempty"`
}

// OperationList ...
type OperationList struct {
	autorest.Response `json:"-"`
	Value             *[]OperationResponse `json:"value,omitempty"`
	// NextLink - Url to get the next page of items.
	NextLink *string `json:"nextLink,omitempty"`
}

// OperationListIterator provides access to a complete listing of OperationResponse values.
type OperationListIterator struct {
	i    int
	page OperationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListIterator) Response() OperationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListIterator) Value() OperationResponse {
	if !iter.page.NotDone() {
		return OperationResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListIterator type.
func NewOperationListIterator(page OperationListPage) OperationListIterator {
	return OperationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// operationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationList) operationListPreparer(ctx context.Context) (*http.Request, error) {
	if ol.NextLink == nil || len(to.String(ol.NextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationListPage contains a page of OperationResponse values.
type OperationListPage struct {
	fn func(context.Context, OperationList) (OperationList, error)
	ol OperationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.ol)
	if err != nil {
		return err
	}
	page.ol = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListPage) Response() OperationList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListPage) Values() []OperationResponse {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationListPage type.
func NewOperationListPage(getNextPage func(context.Context, OperationList) (OperationList, error)) OperationListPage {
	return OperationListPage{fn: getNextPage}
}

// OperationResponse ...
type OperationResponse struct {
	Name    *string           `json:"name,omitempty"`
	Display *OperationDisplay `json:"display,omitempty"`
	Origin  *string           `json:"origin,omitempty"`
}

// OrderBillingPlanInformation information describing the type of billing plan for this reservation.
type OrderBillingPlanInformation struct {
	// PricingCurrencyTotal - Amount of money to be paid for the Order. Tax is not included.
	PricingCurrencyTotal *Price `json:"pricingCurrencyTotal,omitempty"`
	// StartDate - Date when the billing plan has started.
	StartDate *date.Date `json:"startDate,omitempty"`
	// NextPaymentDueDate - For recurring billing plans, indicates the date when next payment will be processed. Null when total is paid off.
	NextPaymentDueDate *date.Date       `json:"nextPaymentDueDate,omitempty"`
	Transactions       *[]PaymentDetail `json:"transactions,omitempty"`
}

// OrderList ...
type OrderList struct {
	autorest.Response `json:"-"`
	Value             *[]OrderResponse `json:"value,omitempty"`
	// NextLink - Url to get the next page of reservationOrders.
	NextLink *string `json:"nextLink,omitempty"`
}

// OrderListIterator provides access to a complete listing of OrderResponse values.
type OrderListIterator struct {
	i    int
	page OrderListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OrderListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OrderListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OrderListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OrderListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OrderListIterator) Response() OrderList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OrderListIterator) Value() OrderResponse {
	if !iter.page.NotDone() {
		return OrderResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OrderListIterator type.
func NewOrderListIterator(page OrderListPage) OrderListIterator {
	return OrderListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OrderList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// orderListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OrderList) orderListPreparer(ctx context.Context) (*http.Request, error) {
	if ol.NextLink == nil || len(to.String(ol.NextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OrderListPage contains a page of OrderResponse values.
type OrderListPage struct {
	fn func(context.Context, OrderList) (OrderList, error)
	ol OrderList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OrderListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OrderListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.ol)
	if err != nil {
		return err
	}
	page.ol = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OrderListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OrderListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OrderListPage) Response() OrderList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OrderListPage) Values() []OrderResponse {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OrderListPage type.
func NewOrderListPage(getNextPage func(context.Context, OrderList) (OrderList, error)) OrderListPage {
	return OrderListPage{fn: getNextPage}
}

// OrderProperties ...
type OrderProperties struct {
	// DisplayName - Friendly name for user to easily identified the reservation.
	DisplayName *string `json:"displayName,omitempty"`
	// RequestDateTime - This is the DateTime when the reservation was initially requested for purchase.
	RequestDateTime *date.Time `json:"requestDateTime,omitempty"`
	// CreatedDateTime - This is the DateTime when the reservation was created.
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// ExpiryDate - This is the date when the Reservation will expire.
	ExpiryDate       *date.Date `json:"expiryDate,omitempty"`
	OriginalQuantity *int32     `json:"originalQuantity,omitempty"`
	// Term - Possible values include: 'P1Y', 'P3Y'
	Term ReservationTerm `json:"term,omitempty"`
	// ProvisioningState - Current state of the reservation.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// BillingPlan - Possible values include: 'Upfront', 'Monthly'
	BillingPlan          ReservationBillingPlan       `json:"billingPlan,omitempty"`
	PlanInformation      *OrderBillingPlanInformation `json:"planInformation,omitempty"`
	ReservationsProperty *[]Response                  `json:"reservations,omitempty"`
}

// OrderPurchaseFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type OrderPurchaseFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *OrderPurchaseFuture) Result(client OrderClient) (or OrderResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.OrderPurchaseFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.OrderPurchaseFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.PurchaseResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.OrderPurchaseFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OrderResponse ...
type OrderResponse struct {
	autorest.Response `json:"-"`
	Etag              *int32 `json:"etag,omitempty"`
	// ID - READ-ONLY; Identifier of the reservation
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the reservation
	Name             *string `json:"name,omitempty"`
	*OrderProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/reservations"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for OrderResponse.
func (or OrderResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if or.Etag != nil {
		objectMap["etag"] = or.Etag
	}
	if or.OrderProperties != nil {
		objectMap["properties"] = or.OrderProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OrderResponse struct.
func (or *OrderResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "etag":
			if v != nil {
				var etag int32
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				or.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				or.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				or.Name = &name
			}
		case "properties":
			if v != nil {
				var orderProperties OrderProperties
				err = json.Unmarshal(*v, &orderProperties)
				if err != nil {
					return err
				}
				or.OrderProperties = &orderProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				or.Type = &typeVar
			}
		}
	}

	return nil
}

// Patch ...
type Patch struct {
	*PatchProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Patch.
func (p Patch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PatchProperties != nil {
		objectMap["properties"] = p.PatchProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Patch struct.
func (p *Patch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var patchProperties PatchProperties
				err = json.Unmarshal(*v, &patchProperties)
				if err != nil {
					return err
				}
				p.PatchProperties = &patchProperties
			}
		}
	}

	return nil
}

// PatchProperties ...
type PatchProperties struct {
	// AppliedScopeType - Possible values include: 'Single', 'Shared'
	AppliedScopeType AppliedScopeType `json:"appliedScopeType,omitempty"`
	AppliedScopes    *[]string        `json:"appliedScopes,omitempty"`
	// InstanceFlexibility - Possible values include: 'On', 'Off'
	InstanceFlexibility InstanceFlexibility `json:"instanceFlexibility,omitempty"`
	// Name - Name of the Reservation
	Name            *string                         `json:"name,omitempty"`
	Renew           *bool                           `json:"renew,omitempty"`
	RenewProperties *PatchPropertiesRenewProperties `json:"renewProperties,omitempty"`
}

// PatchPropertiesRenewProperties ...
type PatchPropertiesRenewProperties struct {
	PurchaseProperties *PurchaseRequest `json:"purchaseProperties,omitempty"`
}

// PaymentDetail information about payment related to a reservation order.
type PaymentDetail struct {
	// DueDate - Date when the payment needs to be done.
	DueDate *date.Date `json:"dueDate,omitempty"`
	// PaymentDate - Date when the transaction is completed. Is null when it is scheduled.
	PaymentDate *date.Date `json:"paymentDate,omitempty"`
	// PricingCurrencyTotal - Amount in pricing currency. Tax not included.
	PricingCurrencyTotal *Price `json:"pricingCurrencyTotal,omitempty"`
	// BillingCurrencyTotal - Amount charged in Billing currency. Tax not included. Is null for future payments
	BillingCurrencyTotal *Price `json:"billingCurrencyTotal,omitempty"`
	// BillingAccount - Shows the Account that is charged for this payment.
	BillingAccount *string `json:"billingAccount,omitempty"`
	// Status - Possible values include: 'Succeeded', 'Failed', 'Scheduled', 'Cancelled'
	Status             PaymentStatus       `json:"status,omitempty"`
	ExtendedStatusInfo *ExtendedStatusInfo `json:"extendedStatusInfo,omitempty"`
}

// PhoneAction phone Action.
type PhoneAction struct {
	// PhoneNumber - The phone number for the action.
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// PreferredChannel - The preferred communication channel.
	PreferredChannel interface{} `json:"preferredChannel,omitempty"`
}

// Price ...
type Price struct {
	// CurrencyCode - The ISO 4217 3-letter currency code for the currency used by this purchase record.
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// Properties ...
type Properties struct {
	autorest.Response `json:"-"`
	Properties        *SubscriptionScopeProperties `json:"properties,omitempty"`
}

// PropertiesType ...
type PropertiesType struct {
	// ReservedResourceType - Possible values include: 'VirtualMachines', 'SQLDatabases', 'SuseLinux', 'CosmosDb', 'RedHat', 'SQLDataWarehouse', 'VMwareCloudSimple', 'RedHatOsa'
	ReservedResourceType ReservedResourceType `json:"reservedResourceType,omitempty"`
	// InstanceFlexibility - Possible values include: 'On', 'Off'
	InstanceFlexibility InstanceFlexibility `json:"instanceFlexibility,omitempty"`
	// DisplayName - Friendly name for user to easily identify the reservation
	DisplayName   *string   `json:"displayName,omitempty"`
	AppliedScopes *[]string `json:"appliedScopes,omitempty"`
	// AppliedScopeType - Possible values include: 'Single', 'Shared'
	AppliedScopeType AppliedScopeType `json:"appliedScopeType,omitempty"`
	Quantity         *int32           `json:"quantity,omitempty"`
	// ProvisioningState - Current state of the reservation.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// EffectiveDateTime - DateTime of the Reservation starting when this version is effective from.
	EffectiveDateTime *date.Time `json:"effectiveDateTime,omitempty"`
	// LastUpdatedDateTime - READ-ONLY; DateTime of the last time the Reservation was updated.
	LastUpdatedDateTime *date.Time `json:"lastUpdatedDateTime,omitempty"`
	// ExpiryDate - This is the date when the Reservation will expire.
	ExpiryDate *date.Date `json:"expiryDate,omitempty"`
	// SkuDescription - Description of the SKU in english.
	SkuDescription     *string             `json:"skuDescription,omitempty"`
	ExtendedStatusInfo *ExtendedStatusInfo `json:"extendedStatusInfo,omitempty"`
	// BillingPlan - Possible values include: 'Upfront', 'Monthly'
	BillingPlan     ReservationBillingPlan `json:"billingPlan,omitempty"`
	SplitProperties *SplitPropertiesType   `json:"splitProperties,omitempty"`
	MergeProperties *MergePropertiesType   `json:"mergeProperties,omitempty"`
	BillingScopeID  *string                `json:"billingScopeId,omitempty"`
	Renew           *bool                  `json:"renew,omitempty"`
	// RenewSource - Reservation Id of the reservation from which this reservation is renewed. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}.
	RenewSource *string `json:"renewSource,omitempty"`
	// RenewDestination - Reservation Id of the reservation which is purchased because of renew. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}.
	RenewDestination *string                  `json:"renewDestination,omitempty"`
	RenewProperties  *RenewPropertiesResponse `json:"renewProperties,omitempty"`
	// Term - Possible values include: 'P1Y', 'P3Y'
	Term ReservationTerm `json:"term,omitempty"`
}

// PurchaseRequest ...
type PurchaseRequest struct {
	Sku *SkuName `json:"sku,omitempty"`
	// Location - The Azure Region where the reserved resource lives.
	Location                   *string `json:"location,omitempty"`
	*PurchaseRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PurchaseRequest.
func (pr PurchaseRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.Sku != nil {
		objectMap["sku"] = pr.Sku
	}
	if pr.Location != nil {
		objectMap["location"] = pr.Location
	}
	if pr.PurchaseRequestProperties != nil {
		objectMap["properties"] = pr.PurchaseRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PurchaseRequest struct.
func (pr *PurchaseRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "sku":
			if v != nil {
				var sku SkuName
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				pr.Sku = &sku
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pr.Location = &location
			}
		case "properties":
			if v != nil {
				var purchaseRequestProperties PurchaseRequestProperties
				err = json.Unmarshal(*v, &purchaseRequestProperties)
				if err != nil {
					return err
				}
				pr.PurchaseRequestProperties = &purchaseRequestProperties
			}
		}
	}

	return nil
}

// PurchaseRequestProperties ...
type PurchaseRequestProperties struct {
	// ReservedResourceType - Possible values include: 'VirtualMachines', 'SQLDatabases', 'SuseLinux', 'CosmosDb', 'RedHat', 'SQLDataWarehouse', 'VMwareCloudSimple', 'RedHatOsa'
	ReservedResourceType ReservedResourceType `json:"reservedResourceType,omitempty"`
	BillingScopeID       *string              `json:"billingScopeId,omitempty"`
	// Term - Possible values include: 'P1Y', 'P3Y'
	Term ReservationTerm `json:"term,omitempty"`
	// BillingPlan - Possible values include: 'Upfront', 'Monthly'
	BillingPlan ReservationBillingPlan `json:"billingPlan,omitempty"`
	Quantity    *int32                 `json:"quantity,omitempty"`
	// DisplayName - Friendly name of the Reservation
	DisplayName *string `json:"displayName,omitempty"`
	// AppliedScopeType - Possible values include: 'Single', 'Shared'
	AppliedScopeType AppliedScopeType `json:"appliedScopeType,omitempty"`
	AppliedScopes    *[]string        `json:"appliedScopes,omitempty"`
	Renew            *bool            `json:"renew,omitempty"`
	// ReservedResourceProperties - Properties specific to each reserved resource type. Not required if not applicable.
	ReservedResourceProperties *PurchaseRequestPropertiesReservedResourceProperties `json:"reservedResourceProperties,omitempty"`
}

// PurchaseRequestPropertiesReservedResourceProperties properties specific to each reserved resource type.
// Not required if not applicable.
type PurchaseRequestPropertiesReservedResourceProperties struct {
	// InstanceFlexibility - Possible values include: 'On', 'Off'
	InstanceFlexibility InstanceFlexibility `json:"instanceFlexibility,omitempty"`
}

// QuotaLimits quota limits.
type QuotaLimits struct {
	autorest.Response `json:"-"`
	// Value - List of Quota limits.
	Value *[]CurrentQuotaLimitBase `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// QuotaLimitsIterator provides access to a complete listing of CurrentQuotaLimitBase values.
type QuotaLimitsIterator struct {
	i    int
	page QuotaLimitsPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *QuotaLimitsIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaLimitsIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *QuotaLimitsIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter QuotaLimitsIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter QuotaLimitsIterator) Response() QuotaLimits {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter QuotaLimitsIterator) Value() CurrentQuotaLimitBase {
	if !iter.page.NotDone() {
		return CurrentQuotaLimitBase{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the QuotaLimitsIterator type.
func NewQuotaLimitsIterator(page QuotaLimitsPage) QuotaLimitsIterator {
	return QuotaLimitsIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ql QuotaLimits) IsEmpty() bool {
	return ql.Value == nil || len(*ql.Value) == 0
}

// quotaLimitsPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ql QuotaLimits) quotaLimitsPreparer(ctx context.Context) (*http.Request, error) {
	if ql.NextLink == nil || len(to.String(ql.NextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ql.NextLink)))
}

// QuotaLimitsPage contains a page of CurrentQuotaLimitBase values.
type QuotaLimitsPage struct {
	fn func(context.Context, QuotaLimits) (QuotaLimits, error)
	ql QuotaLimits
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *QuotaLimitsPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaLimitsPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.ql)
	if err != nil {
		return err
	}
	page.ql = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *QuotaLimitsPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page QuotaLimitsPage) NotDone() bool {
	return !page.ql.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page QuotaLimitsPage) Response() QuotaLimits {
	return page.ql
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page QuotaLimitsPage) Values() []CurrentQuotaLimitBase {
	if page.ql.IsEmpty() {
		return nil
	}
	return *page.ql.Value
}

// Creates a new instance of the QuotaLimitsPage type.
func NewQuotaLimitsPage(getNextPage func(context.Context, QuotaLimits) (QuotaLimits, error)) QuotaLimitsPage {
	return QuotaLimitsPage{fn: getNextPage}
}

// QuotaLimitsResponse quota limits request response.
type QuotaLimitsResponse struct {
	// Value - List of Quota limits with the quota request status.
	Value *[]CurrentQuotaLimit `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// QuotaProperties resource quota properties.
type QuotaProperties struct {
	// Limit - The quota limit.
	Limit *int32 `json:"limit,omitempty"`
	// CurrentValue - READ-ONLY; The current resource usages information.
	CurrentValue *int32 `json:"currentValue,omitempty"`
	// Unit -  The units of the limit, such as - Count, Bytes, etc. Use the unit field provided in the Get quota response.
	Unit *string `json:"unit,omitempty"`
	// Name - Name of the resource provide by the resource Provider. Please use this name property for quotaRequests.
	Name *ResourceName `json:"name,omitempty"`
	// ResourceType - The Resource Type Name.
	ResourceType interface{} `json:"resourceType,omitempty"`
	// QuotaPeriod - READ-ONLY; The quota period over which the usage values are summarized, such as - P1D (Per one day), PT1M (Per one minute), PT1S (Per one second). This parameter is optional because, for some resources like compute, the period doesn’t matter.
	QuotaPeriod *string `json:"quotaPeriod,omitempty"`
	// Properties - Additional properties for the specific resource provider.
	Properties interface{} `json:"properties,omitempty"`
}

// QuotaRequestCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type QuotaRequestCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *QuotaRequestCreateFuture) Result(client QuotaRequestClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.QuotaRequestCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.QuotaRequestCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.CreateResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.QuotaRequestCreateFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// QuotaRequestDetails the details of the quota Request.
type QuotaRequestDetails struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The quota request Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// QuotaRequestProperties - The quota request details.
	*QuotaRequestProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/ServiceLimits"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestDetails.
func (qrd QuotaRequestDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrd.QuotaRequestProperties != nil {
		objectMap["properties"] = qrd.QuotaRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestDetails struct.
func (qrd *QuotaRequestDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				qrd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				qrd.Name = &name
			}
		case "properties":
			if v != nil {
				var quotaRequestProperties QuotaRequestProperties
				err = json.Unmarshal(*v, &quotaRequestProperties)
				if err != nil {
					return err
				}
				qrd.QuotaRequestProperties = &quotaRequestProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				qrd.Type = &typeVar
			}
		}
	}

	return nil
}

// QuotaRequestDetailsList quota requests information.
type QuotaRequestDetailsList struct {
	autorest.Response `json:"-"`
	// Value - The quota Requests.
	Value *[]QuotaRequestDetails `json:"value,omitempty"`
	// NextLink - The uri to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// QuotaRequestDetailsListIterator provides access to a complete listing of QuotaRequestDetails values.
type QuotaRequestDetailsListIterator struct {
	i    int
	page QuotaRequestDetailsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *QuotaRequestDetailsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaRequestDetailsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *QuotaRequestDetailsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter QuotaRequestDetailsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter QuotaRequestDetailsListIterator) Response() QuotaRequestDetailsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter QuotaRequestDetailsListIterator) Value() QuotaRequestDetails {
	if !iter.page.NotDone() {
		return QuotaRequestDetails{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the QuotaRequestDetailsListIterator type.
func NewQuotaRequestDetailsListIterator(page QuotaRequestDetailsListPage) QuotaRequestDetailsListIterator {
	return QuotaRequestDetailsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (qrdl QuotaRequestDetailsList) IsEmpty() bool {
	return qrdl.Value == nil || len(*qrdl.Value) == 0
}

// quotaRequestDetailsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (qrdl QuotaRequestDetailsList) quotaRequestDetailsListPreparer(ctx context.Context) (*http.Request, error) {
	if qrdl.NextLink == nil || len(to.String(qrdl.NextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(qrdl.NextLink)))
}

// QuotaRequestDetailsListPage contains a page of QuotaRequestDetails values.
type QuotaRequestDetailsListPage struct {
	fn   func(context.Context, QuotaRequestDetailsList) (QuotaRequestDetailsList, error)
	qrdl QuotaRequestDetailsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *QuotaRequestDetailsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaRequestDetailsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	next, err := page.fn(ctx, page.qrdl)
	if err != nil {
		return err
	}
	page.qrdl = next
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *QuotaRequestDetailsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page QuotaRequestDetailsListPage) NotDone() bool {
	return !page.qrdl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page QuotaRequestDetailsListPage) Response() QuotaRequestDetailsList {
	return page.qrdl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page QuotaRequestDetailsListPage) Values() []QuotaRequestDetails {
	if page.qrdl.IsEmpty() {
		return nil
	}
	return *page.qrdl.Value
}

// Creates a new instance of the QuotaRequestDetailsListPage type.
func NewQuotaRequestDetailsListPage(getNextPage func(context.Context, QuotaRequestDetailsList) (QuotaRequestDetailsList, error)) QuotaRequestDetailsListPage {
	return QuotaRequestDetailsListPage{fn: getNextPage}
}

// QuotaRequestOneResourceProperties the details of quota request.
type QuotaRequestOneResourceProperties struct {
	// ProvisioningState - READ-ONLY; The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// RequestSubmitTime - READ-ONLY; The quota request submit time. The date conforms to the following format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
	RequestSubmitTime *date.Time `json:"requestSubmitTime,omitempty"`
	// CurrentQuotaLimitBase - The quota request addition properties.
	*CurrentQuotaLimitBase `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestOneResourceProperties.
func (qrorp QuotaRequestOneResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrorp.CurrentQuotaLimitBase != nil {
		objectMap["properties"] = qrorp.CurrentQuotaLimitBase
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestOneResourceProperties struct.
func (qrorp *QuotaRequestOneResourceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "provisioningState":
			if v != nil {
				var provisioningState interface{}
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				qrorp.ProvisioningState = provisioningState
			}
		case "message":
			if v != nil {
				var message string
				err = json.Unmarshal(*v, &message)
				if err != nil {
					return err
				}
				qrorp.Message = &message
			}
		case "requestSubmitTime":
			if v != nil {
				var requestSubmitTime date.Time
				err = json.Unmarshal(*v, &requestSubmitTime)
				if err != nil {
					return err
				}
				qrorp.RequestSubmitTime = &requestSubmitTime
			}
		case "properties":
			if v != nil {
				var currentQuotaLimitBase CurrentQuotaLimitBase
				err = json.Unmarshal(*v, &currentQuotaLimitBase)
				if err != nil {
					return err
				}
				qrorp.CurrentQuotaLimitBase = &currentQuotaLimitBase
			}
		}
	}

	return nil
}

// QuotaRequestOneResourceSubmitResponse quota submit request response
type QuotaRequestOneResourceSubmitResponse struct {
	// ID - READ-ONLY; The quota request Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/ServiceLimits"
	Type *string `json:"type,omitempty"`
	// QuotaRequestOneResourceProperties - The quota request details.
	*QuotaRequestOneResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestOneResourceSubmitResponse.
func (qrorsr QuotaRequestOneResourceSubmitResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrorsr.QuotaRequestOneResourceProperties != nil {
		objectMap["properties"] = qrorsr.QuotaRequestOneResourceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestOneResourceSubmitResponse struct.
func (qrorsr *QuotaRequestOneResourceSubmitResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				qrorsr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				qrorsr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				qrorsr.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var quotaRequestOneResourceProperties QuotaRequestOneResourceProperties
				err = json.Unmarshal(*v, &quotaRequestOneResourceProperties)
				if err != nil {
					return err
				}
				qrorsr.QuotaRequestOneResourceProperties = &quotaRequestOneResourceProperties
			}
		}
	}

	return nil
}

// QuotaRequestProperties the details of quota request.
type QuotaRequestProperties struct {
	// ProvisioningState - The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// RequestSubmitTime - READ-ONLY; The quota request submit time. The date conforms to the following format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
	RequestSubmitTime *date.Time `json:"requestSubmitTime,omitempty"`
	// Value - The quotaRequests.
	Value *[]SubRequest `json:"value,omitempty"`
}

// QuotaRequestStatusDetails the quota request status details.
type QuotaRequestStatusDetails struct {
	// ProvisioningState - READ-ONLY; The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; A user friendly message.
	Message *string `json:"message,omitempty"`
}

// QuotaRequestSubmitResponse quota submit request response
type QuotaRequestSubmitResponse struct {
	// ID - READ-ONLY; The quota request Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Properties - The quota request details.
	Properties *QuotaRequestProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/serviceLimits"
	Type *string `json:"type,omitempty"`
}

// QuotaRequestSubmitResponse201 the quota request submit response with request id.
type QuotaRequestSubmitResponse201 struct {
	// ID - READ-ONLY; The quota request id. Please use the requestId to check the request status.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The operation Id
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The resource type
	Type *string `json:"type,omitempty"`
	// QuotaRequestStatusDetails - The quota request status.
	*QuotaRequestStatusDetails `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestSubmitResponse201.
func (qrsr2 QuotaRequestSubmitResponse201) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrsr2.QuotaRequestStatusDetails != nil {
		objectMap["properties"] = qrsr2.QuotaRequestStatusDetails
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestSubmitResponse201 struct.
func (qrsr2 *QuotaRequestSubmitResponse201) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				qrsr2.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				qrsr2.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				qrsr2.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var quotaRequestStatusDetails QuotaRequestStatusDetails
				err = json.Unmarshal(*v, &quotaRequestStatusDetails)
				if err != nil {
					return err
				}
				qrsr2.QuotaRequestStatusDetails = &quotaRequestStatusDetails
			}
		}
	}

	return nil
}

// QuotaRequestUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type QuotaRequestUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *QuotaRequestUpdateFuture) Result(client QuotaRequestClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.QuotaRequestUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.QuotaRequestUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.UpdateResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.QuotaRequestUpdateFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RenewPropertiesResponse ...
type RenewPropertiesResponse struct {
	PurchaseProperties *PurchaseRequest `json:"purchaseProperties,omitempty"`
	// PricingCurrencyTotal - Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included. This is locked price 30 days before expiry.
	PricingCurrencyTotal *RenewPropertiesResponsePricingCurrencyTotal `json:"pricingCurrencyTotal,omitempty"`
	// BillingCurrencyTotal - Currency and amount that customer will be charged in customer's local currency for renewal purchase. Tax is not included.
	BillingCurrencyTotal *RenewPropertiesResponseBillingCurrencyTotal `json:"billingCurrencyTotal,omitempty"`
}

// RenewPropertiesResponseBillingCurrencyTotal currency and amount that customer will be charged in
// customer's local currency for renewal purchase. Tax is not included.
type RenewPropertiesResponseBillingCurrencyTotal struct {
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// RenewPropertiesResponsePricingCurrencyTotal amount that Microsoft uses for record. Used during refund
// for calculating refund limit. Tax is not included. This is locked price 30 days before expiry.
type RenewPropertiesResponsePricingCurrencyTotal struct {
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// ReservationAvailableScopesFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ReservationAvailableScopesFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ReservationAvailableScopesFuture) Result(client Client) (p Properties, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ReservationAvailableScopesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.ReservationAvailableScopesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if p.Response.Response, err = future.GetResult(sender); err == nil && p.Response.Response.StatusCode != http.StatusNoContent {
		p, err = client.AvailableScopesResponder(p.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ReservationAvailableScopesFuture", "Result", p.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ReservationMergeFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ReservationMergeFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ReservationMergeFuture) Result(client Client) (lr ListResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ReservationMergeFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.ReservationMergeFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lr.Response.Response, err = future.GetResult(sender); err == nil && lr.Response.Response.StatusCode != http.StatusNoContent {
		lr, err = client.MergeResponder(lr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ReservationMergeFuture", "Result", lr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ReservationUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ReservationUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ReservationUpdateFuture) Result(client Client) (r Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ReservationUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.ReservationUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if r.Response.Response, err = future.GetResult(sender); err == nil && r.Response.Response.StatusCode != http.StatusNoContent {
		r, err = client.UpdateResponder(r.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ReservationUpdateFuture", "Result", r.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ResourceName name of the resource provide by the resource Provider. Please use this name property for
// quotaRequests.
type ResourceName struct {
	// Value - Resource name.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - READ-ONLY; Resource display name.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// Response ...
type Response struct {
	autorest.Response `json:"-"`
	// Location - READ-ONLY; The Azure Region where the reserved resource lives.
	Location *string `json:"location,omitempty"`
	Etag     *int32  `json:"etag,omitempty"`
	// ID - READ-ONLY; Identifier of the reservation
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the reservation
	Name       *string         `json:"name,omitempty"`
	Sku        *SkuName        `json:"sku,omitempty"`
	Properties *PropertiesType `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/reservationOrders/reservations"
	Type *string `json:"type,omitempty"`
}

// ScopeProperties ...
type ScopeProperties struct {
	Scope *string `json:"scope,omitempty"`
	Valid *bool   `json:"valid,omitempty"`
}

// ServiceError the api error details.
type ServiceError struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; The list of error details.
	Details *[]ServiceErrorDetail `json:"details,omitempty"`
}

// ServiceErrorDetail the error details.
type ServiceErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
}

// SetObject ...
type SetObject struct {
	autorest.Response `json:"-"`
	Value             interface{} `json:"value,omitempty"`
}

// SkuName ...
type SkuName struct {
	Name *string `json:"name,omitempty"`
}

// SkuProperty ...
type SkuProperty struct {
	// Name - An invariant to describe the feature.
	Name *string `json:"name,omitempty"`
	// Value - An invariant if the feature is measured by quantity.
	Value *string `json:"value,omitempty"`
}

// SkuRestriction ...
type SkuRestriction struct {
	// Type - The type of restrictions.
	Type *string `json:"type,omitempty"`
	// Values - The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
	Values *[]string `json:"values,omitempty"`
	// ReasonCode - The reason for restriction.
	ReasonCode *string `json:"reasonCode,omitempty"`
}

// SplitFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type SplitFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *SplitFuture) Result(client Client) (lr ListResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.SplitFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("reservations.SplitFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lr.Response.Response, err = future.GetResult(sender); err == nil && lr.Response.Response.StatusCode != http.StatusNoContent {
		lr, err = client.SplitResponder(lr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.SplitFuture", "Result", lr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SplitProperties ...
type SplitProperties struct {
	// Quantities - List of the quantities in the new reservations to create.
	Quantities *[]int32 `json:"quantities,omitempty"`
	// ReservationID - Resource id of the reservation to be split. Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	ReservationID *string `json:"reservationId,omitempty"`
}

// SplitPropertiesType ...
type SplitPropertiesType struct {
	// SplitDestinations - List of destination Resource Id that are created due to split. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	SplitDestinations *[]string `json:"splitDestinations,omitempty"`
	// SplitSource - Resource Id of the Reservation from which this is split. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	SplitSource *string `json:"splitSource,omitempty"`
}

// SplitRequest ...
type SplitRequest struct {
	*SplitProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SplitRequest.
func (sr SplitRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.SplitProperties != nil {
		objectMap["properties"] = sr.SplitProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SplitRequest struct.
func (sr *SplitRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var splitProperties SplitProperties
				err = json.Unmarshal(*v, &splitProperties)
				if err != nil {
					return err
				}
				sr.SplitProperties = &splitProperties
			}
		}
	}

	return nil
}

// SubRequest the sub-request submitted with the quota request.
type SubRequest struct {
	// Limit - READ-ONLY; The Resource limit.
	Limit *int32 `json:"limit,omitempty"`
	// Name - The Resource name.
	Name *ResourceName `json:"name,omitempty"`
	// ResourceType - READ-ONLY; Resource type for which the quota check was made.
	ResourceType *string `json:"resourceType,omitempty"`
	// Unit -  The units of the limit, such as - Count, Bytes, etc. Use the unit field provided in the Get quota response.
	Unit *string `json:"unit,omitempty"`
	// ProvisioningState - The quota request status.
	ProvisioningState interface{} `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// SubRequestID - READ-ONLY; Sub request id for individual request.
	SubRequestID *string `json:"subRequestId,omitempty"`
}

// SubscriptionScopeProperties ...
type SubscriptionScopeProperties struct {
	Scopes *[]ScopeProperties `json:"scopes,omitempty"`
}

// SupportRequestAction the SupportRequest action.
type SupportRequestAction struct {
	// AutoQuotaIncreaseState - Is support request action enabled.
	AutoQuotaIncreaseState interface{} `json:"autoQuotaIncreaseState,omitempty"`
	// Severity - The support request severity.
	Severity interface{} `json:"severity,omitempty"`
	// FirstName - The first name of the recipient.
	FirstName *string `json:"firstName,omitempty"`
	// LastName - The last name of the recipient.
	LastName *string `json:"lastName,omitempty"`
	// Country - The country of the recipient.
	Country *string `json:"country,omitempty"`
	// PhoneNumber - The phone number of the recipient.
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	// PrimaryEmailAddress - The primary email addresses of the recipients.
	PrimaryEmailAddress *string `json:"primaryEmailAddress,omitempty"`
	// SupportLanguage - The support language.
	SupportLanguage *string `json:"supportLanguage,omitempty"`
	// PreferredContactMethod - The preferred communication channel.
	PreferredContactMethod interface{} `json:"preferredContactMethod,omitempty"`
	// AlternateEmailAddresses - The alternate email address of the recipient.
	AlternateEmailAddresses *[]string `json:"alternateEmailAddresses,omitempty"`
}
