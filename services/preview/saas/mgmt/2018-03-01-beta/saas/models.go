package saas

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/saas/mgmt/2018-03-01-beta/saas"

// AccessTokenResult the ISV access token result response.
type AccessTokenResult struct {
	autorest.Response `json:"-"`
	// PublisherOfferBaseURI - The Publisher Offer Base Uri
	PublisherOfferBaseURI *string `json:"publisherOfferBaseUri,omitempty"`
	// Token - The generated token
	Token *string `json:"token,omitempty"`
}

// App the saasApp resource.
type App struct {
	// ID - READ-ONLY; the resource Id.
	ID *string `json:"id,omitempty"`
	// Location - the resource location.
	Location *string `json:"location,omitempty"`
	// Name - the resource name.
	Name *string `json:"name,omitempty"`
	// Type - the resource type.
	Type *string `json:"type,omitempty"`
	// Properties - the resource properties.
	Properties *AppProperties `json:"properties,omitempty"`
	// Tags - the resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for App.
func (a App) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if a.Location != nil {
		objectMap["location"] = a.Location
	}
	if a.Name != nil {
		objectMap["name"] = a.Name
	}
	if a.Type != nil {
		objectMap["type"] = a.Type
	}
	if a.Properties != nil {
		objectMap["properties"] = a.Properties
	}
	if a.Tags != nil {
		objectMap["tags"] = a.Tags
	}
	return json.Marshal(objectMap)
}

// AppOperation saas app operations
type AppOperation struct {
	// Name - the operation name
	Name *string `json:"name,omitempty"`
	// Display - the operation display
	Display *AppOperationDisplay `json:"display,omitempty"`
	// Origin - the operation origin
	Origin *string `json:"origin,omitempty"`
	// IsDataAction - whether the operation is a data action or not.
	IsDataAction *bool `json:"isDataAction,omitempty"`
}

// AppOperationDisplay saas app operation display
type AppOperationDisplay struct {
	// Provider - Name of the provider for display purposes
	Provider *string `json:"provider,omitempty"`
	// Resource - Name of the resource type for display purposes
	Resource *string `json:"resource,omitempty"`
	// Operation - Name of the operation for display purposes
	Operation *string `json:"operation,omitempty"`
	// Description - Description of the operation for display purposes
	Description *string `json:"description,omitempty"`
}

// AppOperationsResponseWithContinuation saas app operation response with continuation.
type AppOperationsResponseWithContinuation struct {
	autorest.Response `json:"-"`
	// NextLink - the next link to query to get the remaining results.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - the value of response.
	Value *[]AppOperation `json:"value,omitempty"`
}

// AppOperationsResponseWithContinuationIterator provides access to a complete listing of AppOperation
// values.
type AppOperationsResponseWithContinuationIterator struct {
	i    int
	page AppOperationsResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppOperationsResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppOperationsResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppOperationsResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppOperationsResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppOperationsResponseWithContinuationIterator) Response() AppOperationsResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppOperationsResponseWithContinuationIterator) Value() AppOperation {
	if !iter.page.NotDone() {
		return AppOperation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppOperationsResponseWithContinuationIterator type.
func NewAppOperationsResponseWithContinuationIterator(page AppOperationsResponseWithContinuationPage) AppOperationsResponseWithContinuationIterator {
	return AppOperationsResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aorwc AppOperationsResponseWithContinuation) IsEmpty() bool {
	return aorwc.Value == nil || len(*aorwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aorwc AppOperationsResponseWithContinuation) hasNextLink() bool {
	return aorwc.NextLink != nil && len(*aorwc.NextLink) != 0
}

// appOperationsResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aorwc AppOperationsResponseWithContinuation) appOperationsResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !aorwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aorwc.NextLink)))
}

// AppOperationsResponseWithContinuationPage contains a page of AppOperation values.
type AppOperationsResponseWithContinuationPage struct {
	fn    func(context.Context, AppOperationsResponseWithContinuation) (AppOperationsResponseWithContinuation, error)
	aorwc AppOperationsResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppOperationsResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppOperationsResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aorwc)
		if err != nil {
			return err
		}
		page.aorwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppOperationsResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppOperationsResponseWithContinuationPage) NotDone() bool {
	return !page.aorwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppOperationsResponseWithContinuationPage) Response() AppOperationsResponseWithContinuation {
	return page.aorwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppOperationsResponseWithContinuationPage) Values() []AppOperation {
	if page.aorwc.IsEmpty() {
		return nil
	}
	return *page.aorwc.Value
}

// Creates a new instance of the AppOperationsResponseWithContinuationPage type.
func NewAppOperationsResponseWithContinuationPage(cur AppOperationsResponseWithContinuation, getNextPage func(context.Context, AppOperationsResponseWithContinuation) (AppOperationsResponseWithContinuation, error)) AppOperationsResponseWithContinuationPage {
	return AppOperationsResponseWithContinuationPage{
		fn:    getNextPage,
		aorwc: cur,
	}
}

// AppPlan saas resource plan.
type AppPlan struct {
	// Publisher - the publisher id.
	Publisher *string `json:"publisher,omitempty"`
	// Product - the offer id.
	Product *string `json:"product,omitempty"`
	// Name - the plan id.
	Name *string `json:"name,omitempty"`
}

// AppProperties saas resource properties.
type AppProperties struct {
	// Status - the Saas resource status. Possible values include: 'Pending', 'Subscribed', 'Unsubscribed', 'Suspended', 'Deactivated'
	Status AppStatus `json:"status,omitempty"`
	// SaasAppPlan - the resource plan details.
	SaasAppPlan *AppPlan `json:"saasAppPlan,omitempty"`
}

// AppResponseWithContinuation saas app response with continuation.
type AppResponseWithContinuation struct {
	autorest.Response `json:"-"`
	// NextLink - the next link to query to get the remaining results.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - the value of response.
	Value *[]App `json:"value,omitempty"`
}

// AppResponseWithContinuationIterator provides access to a complete listing of App values.
type AppResponseWithContinuationIterator struct {
	i    int
	page AppResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AppResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AppResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AppResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AppResponseWithContinuationIterator) Response() AppResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AppResponseWithContinuationIterator) Value() App {
	if !iter.page.NotDone() {
		return App{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AppResponseWithContinuationIterator type.
func NewAppResponseWithContinuationIterator(page AppResponseWithContinuationPage) AppResponseWithContinuationIterator {
	return AppResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (arwc AppResponseWithContinuation) IsEmpty() bool {
	return arwc.Value == nil || len(*arwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (arwc AppResponseWithContinuation) hasNextLink() bool {
	return arwc.NextLink != nil && len(*arwc.NextLink) != 0
}

// appResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (arwc AppResponseWithContinuation) appResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !arwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(arwc.NextLink)))
}

// AppResponseWithContinuationPage contains a page of App values.
type AppResponseWithContinuationPage struct {
	fn   func(context.Context, AppResponseWithContinuation) (AppResponseWithContinuation, error)
	arwc AppResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AppResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AppResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.arwc)
		if err != nil {
			return err
		}
		page.arwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AppResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AppResponseWithContinuationPage) NotDone() bool {
	return !page.arwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AppResponseWithContinuationPage) Response() AppResponseWithContinuation {
	return page.arwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AppResponseWithContinuationPage) Values() []App {
	if page.arwc.IsEmpty() {
		return nil
	}
	return *page.arwc.Value
}

// Creates a new instance of the AppResponseWithContinuationPage type.
func NewAppResponseWithContinuationPage(cur AppResponseWithContinuation, getNextPage func(context.Context, AppResponseWithContinuation) (AppResponseWithContinuation, error)) AppResponseWithContinuationPage {
	return AppResponseWithContinuationPage{
		fn:   getNextPage,
		arwc: cur,
	}
}

// CreateResourceFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CreateResourceFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (Resource, error)
}

// CreationProperties properties for creation saas
type CreationProperties struct {
	// OfferID - The offer id.
	OfferID *string `json:"offerId,omitempty"`
	// PublisherID - The publisher id.
	PublisherID *string `json:"publisherId,omitempty"`
	// Quantity - The seat count.
	Quantity *float64 `json:"quantity,omitempty"`
	// SkuID - The plan id.
	SkuID *string `json:"skuId,omitempty"`
	// PaymentChannelType - The Payment channel for the SaasSubscription. Possible values include: 'SubscriptionDelegated', 'CustomerDelegated'
	PaymentChannelType PaymentChannelType `json:"paymentChannelType,omitempty"`
	// PaymentChannelMetadata - The metadata about the SaaS subscription such as the AzureSubscriptionId and ResourceUri.
	PaymentChannelMetadata map[string]*string `json:"paymentChannelMetadata"`
	// SaasResourceName - The SaaS resource name.
	SaasResourceName *string `json:"saasResourceName,omitempty"`
	// TermID - The current Term id.
	TermID *string `json:"termId,omitempty"`
	// AutoRenew - Whether the SaaS subscription will auto renew upon term end.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	// PublisherTestEnvironment - The environment in the publisher side for this resource.
	PublisherTestEnvironment *string `json:"publisherTestEnvironment,omitempty"`
	// SaasSubscriptionID - The saas subscription id used for tenant to subscription level migration request.
	SaasSubscriptionID *string `json:"saasSubscriptionId,omitempty"`
	// SaasSessionID - The saas session id used for dev service migration request.
	SaasSessionID *string `json:"saasSessionId,omitempty"`
}

// MarshalJSON is the custom marshaler for CreationProperties.
func (cp CreationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.OfferID != nil {
		objectMap["offerId"] = cp.OfferID
	}
	if cp.PublisherID != nil {
		objectMap["publisherId"] = cp.PublisherID
	}
	if cp.Quantity != nil {
		objectMap["quantity"] = cp.Quantity
	}
	if cp.SkuID != nil {
		objectMap["skuId"] = cp.SkuID
	}
	if cp.PaymentChannelType != "" {
		objectMap["paymentChannelType"] = cp.PaymentChannelType
	}
	if cp.PaymentChannelMetadata != nil {
		objectMap["paymentChannelMetadata"] = cp.PaymentChannelMetadata
	}
	if cp.SaasResourceName != nil {
		objectMap["saasResourceName"] = cp.SaasResourceName
	}
	if cp.TermID != nil {
		objectMap["termId"] = cp.TermID
	}
	if cp.AutoRenew != nil {
		objectMap["autoRenew"] = cp.AutoRenew
	}
	if cp.PublisherTestEnvironment != nil {
		objectMap["publisherTestEnvironment"] = cp.PublisherTestEnvironment
	}
	if cp.SaasSubscriptionID != nil {
		objectMap["saasSubscriptionId"] = cp.SaasSubscriptionID
	}
	if cp.SaasSessionID != nil {
		objectMap["saasSessionId"] = cp.SaasSessionID
	}
	return json.Marshal(objectMap)
}

// DeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type DeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (autorest.Response, error)
}

// DeleteOptions delete Options
type DeleteOptions struct {
	// UnsubscribeOnly - whether it is unsubscribeOnly
	UnsubscribeOnly *bool `json:"unsubscribeOnly,omitempty"`
	// ReasonCode - The reasonCode
	ReasonCode *float64 `json:"reasonCode,omitempty"`
	// Feedback - the feedback
	Feedback *string `json:"feedback,omitempty"`
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// MoveResource resource Move Options
type MoveResource struct {
	// TargetResourceGroup - The target resource group uri for the move
	TargetResourceGroup *string `json:"targetResourceGroup,omitempty"`
	// Resources - The resource uris to move
	Resources *[]string `json:"resources,omitempty"`
}

// Properties saas resource properties
type Properties struct {
	// Status - The SaaS Subscription Status. Possible values include: 'ResourceStatusNotStarted', 'ResourceStatusPendingFulfillmentStart', 'ResourceStatusSubscribed', 'ResourceStatusUnsubscribed', 'ResourceStatusSuspended'
	Status ResourceStatus `json:"status,omitempty"`
	// Term - The current Term object.
	Term *ResourcePropertiesTerm `json:"term,omitempty"`
	// IsFreeTrial - Whether the current term is a Free Trial term
	IsFreeTrial *bool `json:"isFreeTrial,omitempty"`
	// Created - READ-ONLY; The created date of this resource.
	Created *string `json:"created,omitempty"`
	// LastModified - The last modifier date if this resource.
	LastModified *string `json:"lastModified,omitempty"`
}

// MarshalJSON is the custom marshaler for Properties.
func (p Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.Status != "" {
		objectMap["status"] = p.Status
	}
	if p.Term != nil {
		objectMap["term"] = p.Term
	}
	if p.IsFreeTrial != nil {
		objectMap["isFreeTrial"] = p.IsFreeTrial
	}
	if p.LastModified != nil {
		objectMap["lastModified"] = p.LastModified
	}
	return json.Marshal(objectMap)
}

// Resource saaS REST API resource definition.
type Resource struct {
	autorest.Response `json:"-"`
	// Properties - saas properties
	Properties *ResourceProperties `json:"properties,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// ID - READ-ONLY; The resource uri
	ID *string `json:"id,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - the resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Properties != nil {
		objectMap["properties"] = r.Properties
	}
	if r.Tags != nil {
		objectMap["tags"] = r.Tags
	}
	return json.Marshal(objectMap)
}

// ResourceCreation saaS REST API resource definition for creation.
type ResourceCreation struct {
	// ID - READ-ONLY; The resource uri
	ID *string `json:"id,omitempty"`
	// Name - The resource name
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
	// Tags - the resource tags.
	Tags map[string]*string `json:"tags"`
	// Properties - Properties of the SaaS resource that are relevant for creation.
	Properties *CreationProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceCreation.
func (rc ResourceCreation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rc.Name != nil {
		objectMap["name"] = rc.Name
	}
	if rc.Tags != nil {
		objectMap["tags"] = rc.Tags
	}
	if rc.Properties != nil {
		objectMap["properties"] = rc.Properties
	}
	return json.Marshal(objectMap)
}

// ResourceProperties saas properties
type ResourceProperties struct {
	// Status - The SaaS Subscription Status. Possible values include: 'ResourceStatusNotStarted', 'ResourceStatusPendingFulfillmentStart', 'ResourceStatusSubscribed', 'ResourceStatusUnsubscribed', 'ResourceStatusSuspended'
	Status ResourceStatus `json:"status,omitempty"`
	// Term - The current Term object.
	Term *ResourcePropertiesTerm `json:"term,omitempty"`
	// IsFreeTrial - Whether the current term is a Free Trial term
	IsFreeTrial *bool `json:"isFreeTrial,omitempty"`
	// Created - READ-ONLY; The created date of this resource.
	Created *string `json:"created,omitempty"`
	// LastModified - The last modifier date if this resource.
	LastModified *string `json:"lastModified,omitempty"`
	// OfferID - The offer id.
	OfferID *string `json:"offerId,omitempty"`
	// PublisherID - The publisher id.
	PublisherID *string `json:"publisherId,omitempty"`
	// Quantity - The seat count.
	Quantity *float64 `json:"quantity,omitempty"`
	// SkuID - The plan id.
	SkuID *string `json:"skuId,omitempty"`
	// PaymentChannelType - The Payment channel for the SaasSubscription. Possible values include: 'SubscriptionDelegated', 'CustomerDelegated'
	PaymentChannelType PaymentChannelType `json:"paymentChannelType,omitempty"`
	// PaymentChannelMetadata - The metadata about the SaaS subscription such as the AzureSubscriptionId and ResourceUri.
	PaymentChannelMetadata map[string]*string `json:"paymentChannelMetadata"`
	// SaasResourceName - The SaaS resource name.
	SaasResourceName *string `json:"saasResourceName,omitempty"`
	// TermID - The current Term id.
	TermID *string `json:"termId,omitempty"`
	// AutoRenew - Whether the SaaS subscription will auto renew upon term end.
	AutoRenew *bool `json:"autoRenew,omitempty"`
	// PublisherTestEnvironment - The environment in the publisher side for this resource.
	PublisherTestEnvironment *string `json:"publisherTestEnvironment,omitempty"`
	// SaasSubscriptionID - The saas subscription id used for tenant to subscription level migration request.
	SaasSubscriptionID *string `json:"saasSubscriptionId,omitempty"`
	// SaasSessionID - The saas session id used for dev service migration request.
	SaasSessionID *string `json:"saasSessionId,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceProperties.
func (r ResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Status != "" {
		objectMap["status"] = r.Status
	}
	if r.Term != nil {
		objectMap["term"] = r.Term
	}
	if r.IsFreeTrial != nil {
		objectMap["isFreeTrial"] = r.IsFreeTrial
	}
	if r.LastModified != nil {
		objectMap["lastModified"] = r.LastModified
	}
	if r.OfferID != nil {
		objectMap["offerId"] = r.OfferID
	}
	if r.PublisherID != nil {
		objectMap["publisherId"] = r.PublisherID
	}
	if r.Quantity != nil {
		objectMap["quantity"] = r.Quantity
	}
	if r.SkuID != nil {
		objectMap["skuId"] = r.SkuID
	}
	if r.PaymentChannelType != "" {
		objectMap["paymentChannelType"] = r.PaymentChannelType
	}
	if r.PaymentChannelMetadata != nil {
		objectMap["paymentChannelMetadata"] = r.PaymentChannelMetadata
	}
	if r.SaasResourceName != nil {
		objectMap["saasResourceName"] = r.SaasResourceName
	}
	if r.TermID != nil {
		objectMap["termId"] = r.TermID
	}
	if r.AutoRenew != nil {
		objectMap["autoRenew"] = r.AutoRenew
	}
	if r.PublisherTestEnvironment != nil {
		objectMap["publisherTestEnvironment"] = r.PublisherTestEnvironment
	}
	if r.SaasSubscriptionID != nil {
		objectMap["saasSubscriptionId"] = r.SaasSubscriptionID
	}
	if r.SaasSessionID != nil {
		objectMap["saasSessionId"] = r.SaasSessionID
	}
	return json.Marshal(objectMap)
}

// ResourcePropertiesTerm the current Term object.
type ResourcePropertiesTerm struct {
	// TermUnit - The unit indicating Monthly / Yearly
	TermUnit *string `json:"termUnit,omitempty"`
	// StartDate - The start date of the current term
	StartDate *string `json:"startDate,omitempty"`
	// EndDate - The end date of the current term
	EndDate *string `json:"endDate,omitempty"`
}

// ResourceResponseWithContinuation saas resources response with continuation.
type ResourceResponseWithContinuation struct {
	autorest.Response `json:"-"`
	// NextLink - the next link to query to get the remaining results.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - the value of response.
	Value *[]Resource `json:"value,omitempty"`
}

// ResourceResponseWithContinuationIterator provides access to a complete listing of Resource values.
type ResourceResponseWithContinuationIterator struct {
	i    int
	page ResourceResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourceResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourceResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourceResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourceResponseWithContinuationIterator) Response() ResourceResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourceResponseWithContinuationIterator) Value() Resource {
	if !iter.page.NotDone() {
		return Resource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourceResponseWithContinuationIterator type.
func NewResourceResponseWithContinuationIterator(page ResourceResponseWithContinuationPage) ResourceResponseWithContinuationIterator {
	return ResourceResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rrwc ResourceResponseWithContinuation) IsEmpty() bool {
	return rrwc.Value == nil || len(*rrwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rrwc ResourceResponseWithContinuation) hasNextLink() bool {
	return rrwc.NextLink != nil && len(*rrwc.NextLink) != 0
}

// resourceResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rrwc ResourceResponseWithContinuation) resourceResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !rrwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rrwc.NextLink)))
}

// ResourceResponseWithContinuationPage contains a page of Resource values.
type ResourceResponseWithContinuationPage struct {
	fn   func(context.Context, ResourceResponseWithContinuation) (ResourceResponseWithContinuation, error)
	rrwc ResourceResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourceResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rrwc)
		if err != nil {
			return err
		}
		page.rrwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourceResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourceResponseWithContinuationPage) NotDone() bool {
	return !page.rrwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourceResponseWithContinuationPage) Response() ResourceResponseWithContinuation {
	return page.rrwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourceResponseWithContinuationPage) Values() []Resource {
	if page.rrwc.IsEmpty() {
		return nil
	}
	return *page.rrwc.Value
}

// Creates a new instance of the ResourceResponseWithContinuationPage type.
func NewResourceResponseWithContinuationPage(cur ResourceResponseWithContinuation, getNextPage func(context.Context, ResourceResponseWithContinuation) (ResourceResponseWithContinuation, error)) ResourceResponseWithContinuationPage {
	return ResourceResponseWithContinuationPage{
		fn:   getNextPage,
		rrwc: cur,
	}
}

// Result sample result definition
type Result struct {
	// SampleProperty - Sample property of type string
	SampleProperty *string `json:"sampleProperty,omitempty"`
}

// RpModernEligibility saasRp Modern Eligibility
type RpModernEligibility struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; the azure subscription id
	ID *string `json:"id,omitempty"`
	// IsModern - whether the azure subscription has been converted to modern.
	IsModern *bool `json:"isModern,omitempty"`
}

// MarshalJSON is the custom marshaler for RpModernEligibility.
func (rme RpModernEligibility) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rme.IsModern != nil {
		objectMap["isModern"] = rme.IsModern
	}
	return json.Marshal(objectMap)
}

// SubscriptionLevelCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SubscriptionLevelCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionLevelClient) (Resource, error)
}

// SubscriptionLevelDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionLevelDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionLevelClient) (autorest.Response, error)
}

// SubscriptionLevelMoveResourcesFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SubscriptionLevelMoveResourcesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionLevelClient) (autorest.Response, error)
}

// SubscriptionLevelUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionLevelUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionLevelClient) (Resource, error)
}

// SubscriptionLevelUpdateToUnsubscribedFuture an abstraction for monitoring and retrieving the results of
// a long-running operation.
type SubscriptionLevelUpdateToUnsubscribedFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionLevelClient) (autorest.Response, error)
}

// UpdateResourceFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type UpdateResourceFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (Resource, error)
}
