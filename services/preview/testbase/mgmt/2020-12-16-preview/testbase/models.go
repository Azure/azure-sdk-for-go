package testbase

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/testbase/mgmt/2020-12-16-preview/testbase"

// AccountListResult a list of Test Base Accounts.
type AccountListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Base Accounts.
	Value *[]AccountResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountListResult.
func (alr AccountListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if alr.Value != nil {
		objectMap["value"] = alr.Value
	}
	return json.Marshal(objectMap)
}

// AccountListResultIterator provides access to a complete listing of AccountResource values.
type AccountListResultIterator struct {
	i    int
	page AccountListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccountListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccountListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccountListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccountListResultIterator) Response() AccountListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccountListResultIterator) Value() AccountResource {
	if !iter.page.NotDone() {
		return AccountResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccountListResultIterator type.
func NewAccountListResultIterator(page AccountListResultPage) AccountListResultIterator {
	return AccountListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (alr AccountListResult) IsEmpty() bool {
	return alr.Value == nil || len(*alr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (alr AccountListResult) hasNextLink() bool {
	return alr.NextLink != nil && len(*alr.NextLink) != 0
}

// accountListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (alr AccountListResult) accountListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !alr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(alr.NextLink)))
}

// AccountListResultPage contains a page of AccountResource values.
type AccountListResultPage struct {
	fn  func(context.Context, AccountListResult) (AccountListResult, error)
	alr AccountListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccountListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.alr)
		if err != nil {
			return err
		}
		page.alr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccountListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccountListResultPage) NotDone() bool {
	return !page.alr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccountListResultPage) Response() AccountListResult {
	return page.alr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccountListResultPage) Values() []AccountResource {
	if page.alr.IsEmpty() {
		return nil
	}
	return *page.alr.Value
}

// Creates a new instance of the AccountListResultPage type.
func NewAccountListResultPage(cur AccountListResult, getNextPage func(context.Context, AccountListResult) (AccountListResult, error)) AccountListResultPage {
	return AccountListResultPage{
		fn:  getNextPage,
		alr: cur,
	}
}

// AccountResource the Test Base Account resource.
type AccountResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// AccountResourceProperties - Properties of a Test Base Account.
	*AccountResourceProperties `json:"properties,omitempty"`
	// Tags - The tags of the resource.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountResource.
func (ar AccountResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ar.SystemData != nil {
		objectMap["systemData"] = ar.SystemData
	}
	if ar.AccountResourceProperties != nil {
		objectMap["properties"] = ar.AccountResourceProperties
	}
	if ar.Tags != nil {
		objectMap["tags"] = ar.Tags
	}
	if ar.Location != nil {
		objectMap["location"] = ar.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccountResource struct.
func (ar *AccountResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ar.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var accountResourceProperties AccountResourceProperties
				err = json.Unmarshal(*v, &accountResourceProperties)
				if err != nil {
					return err
				}
				ar.AccountResourceProperties = &accountResourceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				ar.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				ar.Location = &location
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				ar.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ar.Type = &typeVar
			}
		}
	}

	return nil
}

// AccountResourceProperties the properties of a Test Base Account resource.
type AccountResourceProperties struct {
	// ProvisioningState - The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCancelled', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateUpdating'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// Sku - The SKU of the Test Base Account.
	Sku *AccountSKU `json:"sku,omitempty"`
	// AccessLevel - READ-ONLY; The access level of the Test Base Account.
	AccessLevel *string `json:"accessLevel,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountResourceProperties.
func (arp AccountResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arp.ProvisioningState != "" {
		objectMap["provisioningState"] = arp.ProvisioningState
	}
	if arp.Sku != nil {
		objectMap["sku"] = arp.Sku
	}
	return json.Marshal(objectMap)
}

// AccountsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (AccountResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsCreateFuture.Result.
func (future *AccountsCreateFuture) result(client AccountsClient) (ar AccountResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.AccountsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.AccountsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ar.Response.Response, err = future.GetResult(sender); err == nil && ar.Response.Response.StatusCode != http.StatusNoContent {
		ar, err = client.CreateResponder(ar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "testbase.AccountsCreateFuture", "Result", ar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AccountsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsDeleteFuture.Result.
func (future *AccountsDeleteFuture) result(client AccountsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.AccountsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.AccountsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AccountSKU describes a Test Base Account SKU.
type AccountSKU struct {
	// ResourceType - The type of resource the SKU applies to.
	ResourceType *string `json:"resourceType,omitempty"`
	// Name - The name of the SKU. This is typically a letter + number code, such as B0 or S0.
	Name *string `json:"name,omitempty"`
	// Tier - The tier of this particular SKU.
	Tier *string `json:"tier,omitempty"`
	// Capabilities - READ-ONLY; The capabilities of a SKU.
	Capabilities *[]AccountSKUCapability `json:"capabilities,omitempty"`
	// Locations - The locations that the SKU is available.
	Locations *[]string `json:"locations,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountSKU.
func (as AccountSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if as.ResourceType != nil {
		objectMap["resourceType"] = as.ResourceType
	}
	if as.Name != nil {
		objectMap["name"] = as.Name
	}
	if as.Tier != nil {
		objectMap["tier"] = as.Tier
	}
	if as.Locations != nil {
		objectMap["locations"] = as.Locations
	}
	return json.Marshal(objectMap)
}

// AccountSKUCapability properties of the Test Base Account SKU Capability.
type AccountSKUCapability struct {
	// Name - An invariant to describe the feature, such as 'SLA'.
	Name *string `json:"name,omitempty"`
	// Value - An invariant if the feature is measured by quantity, such as 99.9%.
	Value *string `json:"value,omitempty"`
}

// AccountSKUListResult a list of Test Base Account SKUs.
type AccountSKUListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Base Account SKUs.
	Value *[]AccountSKU `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountSKUListResult.
func (aslr AccountSKUListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aslr.Value != nil {
		objectMap["value"] = aslr.Value
	}
	return json.Marshal(objectMap)
}

// AccountSKUListResultIterator provides access to a complete listing of AccountSKU values.
type AccountSKUListResultIterator struct {
	i    int
	page AccountSKUListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccountSKUListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountSKUListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccountSKUListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccountSKUListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccountSKUListResultIterator) Response() AccountSKUListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccountSKUListResultIterator) Value() AccountSKU {
	if !iter.page.NotDone() {
		return AccountSKU{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccountSKUListResultIterator type.
func NewAccountSKUListResultIterator(page AccountSKUListResultPage) AccountSKUListResultIterator {
	return AccountSKUListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aslr AccountSKUListResult) IsEmpty() bool {
	return aslr.Value == nil || len(*aslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aslr AccountSKUListResult) hasNextLink() bool {
	return aslr.NextLink != nil && len(*aslr.NextLink) != 0
}

// accountSKUListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aslr AccountSKUListResult) accountSKUListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !aslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aslr.NextLink)))
}

// AccountSKUListResultPage contains a page of AccountSKU values.
type AccountSKUListResultPage struct {
	fn   func(context.Context, AccountSKUListResult) (AccountSKUListResult, error)
	aslr AccountSKUListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccountSKUListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountSKUListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aslr)
		if err != nil {
			return err
		}
		page.aslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccountSKUListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccountSKUListResultPage) NotDone() bool {
	return !page.aslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccountSKUListResultPage) Response() AccountSKUListResult {
	return page.aslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccountSKUListResultPage) Values() []AccountSKU {
	if page.aslr.IsEmpty() {
		return nil
	}
	return *page.aslr.Value
}

// Creates a new instance of the AccountSKUListResultPage type.
func NewAccountSKUListResultPage(cur AccountSKUListResult, getNextPage func(context.Context, AccountSKUListResult) (AccountSKUListResult, error)) AccountSKUListResultPage {
	return AccountSKUListResultPage{
		fn:   getNextPage,
		aslr: cur,
	}
}

// AccountsOffboardFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsOffboardFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsOffboardFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsOffboardFuture.Result.
func (future *AccountsOffboardFuture) result(client AccountsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.AccountsOffboardFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.AccountsOffboardFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// AccountsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type AccountsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(AccountsClient) (AccountResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *AccountsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for AccountsUpdateFuture.Result.
func (future *AccountsUpdateFuture) result(client AccountsClient) (ar AccountResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.AccountsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.AccountsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ar.Response.Response, err = future.GetResult(sender); err == nil && ar.Response.Response.StatusCode != http.StatusNoContent {
		ar, err = client.UpdateResponder(ar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "testbase.AccountsUpdateFuture", "Result", ar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// AccountUpdateParameterProperties parameters supplied to update a Test Base Account.
type AccountUpdateParameterProperties struct {
	// Sku - The SKU of the Test Base Account.
	Sku *AccountSKU `json:"sku,omitempty"`
}

// AccountUpdateParameters parameters supplied to update a Test Base Account.
type AccountUpdateParameters struct {
	// AccountUpdateParameterProperties - Test Base Account update parameters.
	*AccountUpdateParameterProperties `json:"properties,omitempty"`
	// Tags - The tags of the Test Base Account.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for AccountUpdateParameters.
func (aup AccountUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aup.AccountUpdateParameterProperties != nil {
		objectMap["properties"] = aup.AccountUpdateParameterProperties
	}
	if aup.Tags != nil {
		objectMap["tags"] = aup.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AccountUpdateParameters struct.
func (aup *AccountUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var accountUpdateParameterProperties AccountUpdateParameterProperties
				err = json.Unmarshal(*v, &accountUpdateParameterProperties)
				if err != nil {
					return err
				}
				aup.AccountUpdateParameterProperties = &accountUpdateParameterProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				aup.Tags = tags
			}
		}
	}

	return nil
}

// AccountUsageData the usage data of a Test Base Account.
type AccountUsageData struct {
	// ID - Fully qualified ARM resource id
	ID *string `json:"id,omitempty"`
	// Name - Localizable String object containing the name and a localized value.
	Name *AccountUsageName `json:"name,omitempty"`
	// Unit - Representing the units of the usage quota. Possible values are: Count, Bytes, Seconds, Percent, CountPerSecond, BytesPerSecond.
	Unit *string `json:"unit,omitempty"`
	// Limit - The maximum permitted value for the usage quota. If there is no limit, this value will be -1.
	Limit *int64 `json:"limit,omitempty"`
	// CurrentValue - Current value for the usage quota.
	CurrentValue *int64 `json:"currentValue,omitempty"`
}

// AccountUsageDataList a list of Test Base Account usage data.
type AccountUsageDataList struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Base Account usage data.
	Value *[]AccountUsageData `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AccountUsageDataList.
func (audl AccountUsageDataList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if audl.Value != nil {
		objectMap["value"] = audl.Value
	}
	return json.Marshal(objectMap)
}

// AccountUsageDataListIterator provides access to a complete listing of AccountUsageData values.
type AccountUsageDataListIterator struct {
	i    int
	page AccountUsageDataListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AccountUsageDataListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountUsageDataListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AccountUsageDataListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AccountUsageDataListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AccountUsageDataListIterator) Response() AccountUsageDataList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AccountUsageDataListIterator) Value() AccountUsageData {
	if !iter.page.NotDone() {
		return AccountUsageData{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AccountUsageDataListIterator type.
func NewAccountUsageDataListIterator(page AccountUsageDataListPage) AccountUsageDataListIterator {
	return AccountUsageDataListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (audl AccountUsageDataList) IsEmpty() bool {
	return audl.Value == nil || len(*audl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (audl AccountUsageDataList) hasNextLink() bool {
	return audl.NextLink != nil && len(*audl.NextLink) != 0
}

// accountUsageDataListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (audl AccountUsageDataList) accountUsageDataListPreparer(ctx context.Context) (*http.Request, error) {
	if !audl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(audl.NextLink)))
}

// AccountUsageDataListPage contains a page of AccountUsageData values.
type AccountUsageDataListPage struct {
	fn   func(context.Context, AccountUsageDataList) (AccountUsageDataList, error)
	audl AccountUsageDataList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AccountUsageDataListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AccountUsageDataListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.audl)
		if err != nil {
			return err
		}
		page.audl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AccountUsageDataListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AccountUsageDataListPage) NotDone() bool {
	return !page.audl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AccountUsageDataListPage) Response() AccountUsageDataList {
	return page.audl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AccountUsageDataListPage) Values() []AccountUsageData {
	if page.audl.IsEmpty() {
		return nil
	}
	return *page.audl.Value
}

// Creates a new instance of the AccountUsageDataListPage type.
func NewAccountUsageDataListPage(cur AccountUsageDataList, getNextPage func(context.Context, AccountUsageDataList) (AccountUsageDataList, error)) AccountUsageDataListPage {
	return AccountUsageDataListPage{
		fn:   getNextPage,
		audl: cur,
	}
}

// AccountUsageName localizable String object containing the name and a localized value.
type AccountUsageName struct {
	// Value - The identifier of the usage.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - Localized name of the usage.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// AnalysisResultListResult a list of Analysis Results. It will only contain one element as all the data
// will be nested in a singleton object.
type AnalysisResultListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Analysis Results.
	Value *[]AnalysisResultSingletonResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AnalysisResultListResult.
func (arlr AnalysisResultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arlr.Value != nil {
		objectMap["value"] = arlr.Value
	}
	return json.Marshal(objectMap)
}

// AnalysisResultSingletonResource the Analysis Result Singleton Resource.
type AnalysisResultSingletonResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// BasicAnalysisResultSingletonResourceProperties - Properties of an Analysis Result.
	BasicAnalysisResultSingletonResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AnalysisResultSingletonResource.
func (arsr AnalysisResultSingletonResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if arsr.SystemData != nil {
		objectMap["systemData"] = arsr.SystemData
	}
	objectMap["properties"] = arsr.BasicAnalysisResultSingletonResourceProperties
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AnalysisResultSingletonResource struct.
func (arsr *AnalysisResultSingletonResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				arsr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				basicAnalysisResultSingletonResourceProperties, err := unmarshalBasicAnalysisResultSingletonResourceProperties(*v)
				if err != nil {
					return err
				}
				arsr.BasicAnalysisResultSingletonResourceProperties = basicAnalysisResultSingletonResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				arsr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				arsr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				arsr.Type = &typeVar
			}
		}
	}

	return nil
}

// BasicAnalysisResultSingletonResourceProperties the properties of Analysis Result resource.
type BasicAnalysisResultSingletonResourceProperties interface {
	AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool)
	AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool)
	AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool)
	AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool)
	AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool)
	AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool)
	AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool)
	AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool)
}

// AnalysisResultSingletonResourceProperties the properties of Analysis Result resource.
type AnalysisResultSingletonResourceProperties struct {
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

func unmarshalBasicAnalysisResultSingletonResourceProperties(body []byte) (BasicAnalysisResultSingletonResourceProperties, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["analysisResultType"] {
	case string(AnalysisResultTypeScriptExecution1):
		var sersrp ScriptExecutionResultSingletonResourceProperties
		err := json.Unmarshal(body, &sersrp)
		return sersrp, err
	case string(AnalysisResultTypeReliability1):
		var rrsrp ReliabilityResultSingletonResourceProperties
		err := json.Unmarshal(body, &rrsrp)
		return rrsrp, err
	case string(AnalysisResultTypeCPUUtilization1):
		var cursrp CPUUtilizationResultSingletonResourceProperties
		err := json.Unmarshal(body, &cursrp)
		return cursrp, err
	case string(AnalysisResultTypeMemoryUtilization1):
		var mursrp MemoryUtilizationResultSingletonResourceProperties
		err := json.Unmarshal(body, &mursrp)
		return mursrp, err
	case string(AnalysisResultTypeCPURegression1):
		var crrsrp CPURegressionResultSingletonResourceProperties
		err := json.Unmarshal(body, &crrsrp)
		return crrsrp, err
	case string(AnalysisResultTypeMemoryRegression1):
		var mrrsrp MemoryRegressionResultSingletonResourceProperties
		err := json.Unmarshal(body, &mrrsrp)
		return mrrsrp, err
	case string(AnalysisResultTypeTestAnalysis1):
		var tarsrp TestAnalysisResultSingletonResourceProperties
		err := json.Unmarshal(body, &tarsrp)
		return tarsrp, err
	default:
		var arsrp AnalysisResultSingletonResourceProperties
		err := json.Unmarshal(body, &arsrp)
		return arsrp, err
	}
}
func unmarshalBasicAnalysisResultSingletonResourcePropertiesArray(body []byte) ([]BasicAnalysisResultSingletonResourceProperties, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	arsrpArray := make([]BasicAnalysisResultSingletonResourceProperties, len(rawMessages))

	for index, rawMessage := range rawMessages {
		arsrp, err := unmarshalBasicAnalysisResultSingletonResourceProperties(*rawMessage)
		if err != nil {
			return nil, err
		}
		arsrpArray[index] = arsrp
	}
	return arsrpArray, nil
}

// MarshalJSON is the custom marshaler for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	arsrp.AnalysisResultType = AnalysisResultTypeAnalysisResultSingletonResourceProperties
	objectMap := make(map[string]interface{})
	if arsrp.Grade != "" {
		objectMap["grade"] = arsrp.Grade
	}
	if arsrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = arsrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return &arsrp, true
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for AnalysisResultSingletonResourceProperties.
func (arsrp AnalysisResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &arsrp, true
}

// AvailableOSListResult a list of available OSs.
type AvailableOSListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of available OSs.
	Value *[]AvailableOSResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailableOSListResult.
func (aolr AvailableOSListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aolr.Value != nil {
		objectMap["value"] = aolr.Value
	}
	return json.Marshal(objectMap)
}

// AvailableOSListResultIterator provides access to a complete listing of AvailableOSResource values.
type AvailableOSListResultIterator struct {
	i    int
	page AvailableOSListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *AvailableOSListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailableOSListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *AvailableOSListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter AvailableOSListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter AvailableOSListResultIterator) Response() AvailableOSListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter AvailableOSListResultIterator) Value() AvailableOSResource {
	if !iter.page.NotDone() {
		return AvailableOSResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the AvailableOSListResultIterator type.
func NewAvailableOSListResultIterator(page AvailableOSListResultPage) AvailableOSListResultIterator {
	return AvailableOSListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (aolr AvailableOSListResult) IsEmpty() bool {
	return aolr.Value == nil || len(*aolr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (aolr AvailableOSListResult) hasNextLink() bool {
	return aolr.NextLink != nil && len(*aolr.NextLink) != 0
}

// availableOSListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (aolr AvailableOSListResult) availableOSListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !aolr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(aolr.NextLink)))
}

// AvailableOSListResultPage contains a page of AvailableOSResource values.
type AvailableOSListResultPage struct {
	fn   func(context.Context, AvailableOSListResult) (AvailableOSListResult, error)
	aolr AvailableOSListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *AvailableOSListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/AvailableOSListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.aolr)
		if err != nil {
			return err
		}
		page.aolr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *AvailableOSListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page AvailableOSListResultPage) NotDone() bool {
	return !page.aolr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page AvailableOSListResultPage) Response() AvailableOSListResult {
	return page.aolr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page AvailableOSListResultPage) Values() []AvailableOSResource {
	if page.aolr.IsEmpty() {
		return nil
	}
	return *page.aolr.Value
}

// Creates a new instance of the AvailableOSListResultPage type.
func NewAvailableOSListResultPage(cur AvailableOSListResult, getNextPage func(context.Context, AvailableOSListResult) (AvailableOSListResult, error)) AvailableOSListResultPage {
	return AvailableOSListResultPage{
		fn:   getNextPage,
		aolr: cur,
	}
}

// AvailableOSProperties the Available OS properties.
type AvailableOSProperties struct {
	// OsID - The Id of an Available OS of a Test Base Account.
	OsID *string `json:"osId,omitempty"`
	// OsName - The name of an Available OS of a Test Base Account.
	OsName *string `json:"osName,omitempty"`
	// OsVersion - The version of an Available OS of a Test Base Account.
	OsVersion *string `json:"osVersion,omitempty"`
	// InsiderChannel - The insider channel of an Available OS of a Test Base Account.
	InsiderChannel *string `json:"insiderChannel,omitempty"`
	// OsUpdateType - The OS update type of an Available OS of a Test Base Account.
	OsUpdateType *string `json:"osUpdateType,omitempty"`
	// OsPlatform - The Platform of an Available OS of a Test Base Account.
	OsPlatform *string `json:"osPlatform,omitempty"`
}

// AvailableOSResource the Available OS resource.
type AvailableOSResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// AvailableOSProperties - Available OS properties.
	*AvailableOSProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AvailableOSResource.
func (aor AvailableOSResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if aor.SystemData != nil {
		objectMap["systemData"] = aor.SystemData
	}
	if aor.AvailableOSProperties != nil {
		objectMap["properties"] = aor.AvailableOSProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AvailableOSResource struct.
func (aor *AvailableOSResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				aor.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var availableOSProperties AvailableOSProperties
				err = json.Unmarshal(*v, &availableOSProperties)
				if err != nil {
					return err
				}
				aor.AvailableOSProperties = &availableOSProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				aor.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				aor.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				aor.Type = &typeVar
			}
		}
	}

	return nil
}

// CheckNameAvailabilityResult description of a Check Name availability response properties.
type CheckNameAvailabilityResult struct {
	autorest.Response `json:"-"`
	// NameAvailable - Value indicating the availability of the name: true if the name is available; otherwise, false.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Reason - The reason for unavailability of a name. Required if nameAvailable == false. Possible values include: 'Invalid', 'AlreadyExists'
	Reason Reason `json:"reason,omitempty"`
	// Message - READ-ONLY; The detailed info regarding the reason associated with the name. Required if nameAvailable == false.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for CheckNameAvailabilityResult.
func (cnar CheckNameAvailabilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cnar.NameAvailable != nil {
		objectMap["nameAvailable"] = cnar.NameAvailable
	}
	if cnar.Reason != "" {
		objectMap["reason"] = cnar.Reason
	}
	return json.Marshal(objectMap)
}

// Command the command used in the test
type Command struct {
	// Name - The name of the command.
	Name *string `json:"name,omitempty"`
	// Action - The action of the command. Possible values include: 'Install', 'Launch', 'Close', 'Uninstall', 'Custom'
	Action Action `json:"action,omitempty"`
	// ContentType - The type of command content. Possible values include: 'Inline', 'File', 'Path'
	ContentType ContentType `json:"contentType,omitempty"`
	// Content - The content of the command. The content depends on source type.
	Content *string `json:"content,omitempty"`
	// RunElevated - Specifies whether to run the command as administrator.
	RunElevated *bool `json:"runElevated,omitempty"`
	// RestartAfter - Specifies whether to restart the VM after the command executed.
	RestartAfter *bool `json:"restartAfter,omitempty"`
	// MaxRunTime - Specifies the max run time of the command.
	MaxRunTime *int32 `json:"maxRunTime,omitempty"`
	// RunAsInteractive - Specifies whether to run the command in interactive mode.
	RunAsInteractive *bool `json:"runAsInteractive,omitempty"`
	// AlwaysRun - Specifies whether to run the command even if a previous command is failed.
	AlwaysRun *bool `json:"alwaysRun,omitempty"`
	// ApplyUpdateBefore - Specifies whether to apply update before the command.
	ApplyUpdateBefore *bool `json:"applyUpdateBefore,omitempty"`
}

// CPURegressionResultSingletonResourceProperties the properties of CPU Regression Result.
type CPURegressionResultSingletonResourceProperties struct {
	// CPURegressionResults - The result array data.
	CPURegressionResults *[]RegressionResult `json:"cpuRegressionResults,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	crrsrp.AnalysisResultType = AnalysisResultTypeCPURegression1
	objectMap := make(map[string]interface{})
	if crrsrp.CPURegressionResults != nil {
		objectMap["cpuRegressionResults"] = crrsrp.CPURegressionResults
	}
	if crrsrp.Grade != "" {
		objectMap["grade"] = crrsrp.Grade
	}
	if crrsrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = crrsrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return &crrsrp, true
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPURegressionResultSingletonResourceProperties.
func (crrsrp CPURegressionResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &crrsrp, true
}

// CPUUtilizationResultSingletonResourceProperties the properties of CPU Utilization Result.
type CPUUtilizationResultSingletonResourceProperties struct {
	// CPUUtilizationResults - The result array data.
	CPUUtilizationResults *[]UtilizationResult `json:"cpuUtilizationResults,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	cursrp.AnalysisResultType = AnalysisResultTypeCPUUtilization1
	objectMap := make(map[string]interface{})
	if cursrp.CPUUtilizationResults != nil {
		objectMap["cpuUtilizationResults"] = cursrp.CPUUtilizationResults
	}
	if cursrp.Grade != "" {
		objectMap["grade"] = cursrp.Grade
	}
	if cursrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = cursrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return &cursrp, true
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for CPUUtilizationResultSingletonResourceProperties.
func (cursrp CPUUtilizationResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &cursrp, true
}

// CustomerEventListResult a list of Test Base Customer Events.
type CustomerEventListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Base Customer Events.
	Value *[]CustomerEventResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomerEventListResult.
func (celr CustomerEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if celr.Value != nil {
		objectMap["value"] = celr.Value
	}
	return json.Marshal(objectMap)
}

// CustomerEventListResultIterator provides access to a complete listing of CustomerEventResource values.
type CustomerEventListResultIterator struct {
	i    int
	page CustomerEventListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CustomerEventListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomerEventListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CustomerEventListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CustomerEventListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CustomerEventListResultIterator) Response() CustomerEventListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CustomerEventListResultIterator) Value() CustomerEventResource {
	if !iter.page.NotDone() {
		return CustomerEventResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CustomerEventListResultIterator type.
func NewCustomerEventListResultIterator(page CustomerEventListResultPage) CustomerEventListResultIterator {
	return CustomerEventListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (celr CustomerEventListResult) IsEmpty() bool {
	return celr.Value == nil || len(*celr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (celr CustomerEventListResult) hasNextLink() bool {
	return celr.NextLink != nil && len(*celr.NextLink) != 0
}

// customerEventListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (celr CustomerEventListResult) customerEventListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !celr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(celr.NextLink)))
}

// CustomerEventListResultPage contains a page of CustomerEventResource values.
type CustomerEventListResultPage struct {
	fn   func(context.Context, CustomerEventListResult) (CustomerEventListResult, error)
	celr CustomerEventListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CustomerEventListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomerEventListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.celr)
		if err != nil {
			return err
		}
		page.celr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CustomerEventListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CustomerEventListResultPage) NotDone() bool {
	return !page.celr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CustomerEventListResultPage) Response() CustomerEventListResult {
	return page.celr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CustomerEventListResultPage) Values() []CustomerEventResource {
	if page.celr.IsEmpty() {
		return nil
	}
	return *page.celr.Value
}

// Creates a new instance of the CustomerEventListResultPage type.
func NewCustomerEventListResultPage(cur CustomerEventListResult, getNextPage func(context.Context, CustomerEventListResult) (CustomerEventListResult, error)) CustomerEventListResultPage {
	return CustomerEventListResultPage{
		fn:   getNextPage,
		celr: cur,
	}
}

// CustomerEventProperties a notification events subscribed to be received by customer.
type CustomerEventProperties struct {
	// EventName - The name of the event subscribed to.
	EventName *string `json:"eventName,omitempty"`
	// Receivers - The notification event receivers.
	Receivers *[]NotificationEventReceiver `json:"receivers,omitempty"`
}

// CustomerEventResource the Customer Notification Event resource.
type CustomerEventResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// CustomerEventProperties - Customer Notification Event properties.
	*CustomerEventProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomerEventResource.
func (cer CustomerEventResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cer.SystemData != nil {
		objectMap["systemData"] = cer.SystemData
	}
	if cer.CustomerEventProperties != nil {
		objectMap["properties"] = cer.CustomerEventProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CustomerEventResource struct.
func (cer *CustomerEventResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				cer.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var customerEventProperties CustomerEventProperties
				err = json.Unmarshal(*v, &customerEventProperties)
				if err != nil {
					return err
				}
				cer.CustomerEventProperties = &customerEventProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				cer.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				cer.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				cer.Type = &typeVar
			}
		}
	}

	return nil
}

// CustomerEventsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CustomerEventsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(CustomerEventsClient) (CustomerEventResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *CustomerEventsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for CustomerEventsCreateFuture.Result.
func (future *CustomerEventsCreateFuture) result(client CustomerEventsClient) (cer CustomerEventResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.CustomerEventsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		cer.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.CustomerEventsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if cer.Response.Response, err = future.GetResult(sender); err == nil && cer.Response.Response.StatusCode != http.StatusNoContent {
		cer, err = client.CreateResponder(cer.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "testbase.CustomerEventsCreateFuture", "Result", cer.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CustomerEventsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CustomerEventsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(CustomerEventsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *CustomerEventsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for CustomerEventsDeleteFuture.Result.
func (future *CustomerEventsDeleteFuture) result(client CustomerEventsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.CustomerEventsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.CustomerEventsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// DistributionGroupListReceiverValue the user object receiver value.
type DistributionGroupListReceiverValue struct {
	// DistributionGroups - The list of distribution groups.
	DistributionGroups *[]string `json:"distributionGroups,omitempty"`
}

// DownloadURLResponse the response of getting a download URL.
type DownloadURLResponse struct {
	autorest.Response `json:"-"`
	// DownloadURL - READ-ONLY; The download URL.
	DownloadURL *string `json:"downloadUrl,omitempty"`
	// ExpirationTime - READ-ONLY; Expiry date of the download URL.
	ExpirationTime *date.Time `json:"expirationTime,omitempty"`
}

// MarshalJSON is the custom marshaler for DownloadURLResponse.
func (dur DownloadURLResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// EmailEventListResult a list of email events.
type EmailEventListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of email events.
	Value *[]EmailEventResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for EmailEventListResult.
func (eelr EmailEventListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if eelr.Value != nil {
		objectMap["value"] = eelr.Value
	}
	return json.Marshal(objectMap)
}

// EmailEventListResultIterator provides access to a complete listing of EmailEventResource values.
type EmailEventListResultIterator struct {
	i    int
	page EmailEventListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *EmailEventListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EmailEventListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *EmailEventListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter EmailEventListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter EmailEventListResultIterator) Response() EmailEventListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter EmailEventListResultIterator) Value() EmailEventResource {
	if !iter.page.NotDone() {
		return EmailEventResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the EmailEventListResultIterator type.
func NewEmailEventListResultIterator(page EmailEventListResultPage) EmailEventListResultIterator {
	return EmailEventListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (eelr EmailEventListResult) IsEmpty() bool {
	return eelr.Value == nil || len(*eelr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (eelr EmailEventListResult) hasNextLink() bool {
	return eelr.NextLink != nil && len(*eelr.NextLink) != 0
}

// emailEventListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (eelr EmailEventListResult) emailEventListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !eelr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(eelr.NextLink)))
}

// EmailEventListResultPage contains a page of EmailEventResource values.
type EmailEventListResultPage struct {
	fn   func(context.Context, EmailEventListResult) (EmailEventListResult, error)
	eelr EmailEventListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *EmailEventListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/EmailEventListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.eelr)
		if err != nil {
			return err
		}
		page.eelr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *EmailEventListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page EmailEventListResultPage) NotDone() bool {
	return !page.eelr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page EmailEventListResultPage) Response() EmailEventListResult {
	return page.eelr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page EmailEventListResultPage) Values() []EmailEventResource {
	if page.eelr.IsEmpty() {
		return nil
	}
	return *page.eelr.Value
}

// Creates a new instance of the EmailEventListResultPage type.
func NewEmailEventListResultPage(cur EmailEventListResult, getNextPage func(context.Context, EmailEventListResult) (EmailEventListResult, error)) EmailEventListResultPage {
	return EmailEventListResultPage{
		fn:   getNextPage,
		eelr: cur,
	}
}

// EmailEventProperties the Email Event properties.
type EmailEventProperties struct {
	// EventID - The identifier of the email event.
	EventID *string `json:"eventId,omitempty"`
	// EventName - The name of the email event.
	EventName *string `json:"eventName,omitempty"`
	// DisplayName - The display name of the email event.
	DisplayName *string `json:"displayName,omitempty"`
}

// EmailEventResource the email event resource.
type EmailEventResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// EmailEventProperties - Email Event properties.
	*EmailEventProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for EmailEventResource.
func (eer EmailEventResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if eer.SystemData != nil {
		objectMap["systemData"] = eer.SystemData
	}
	if eer.EmailEventProperties != nil {
		objectMap["properties"] = eer.EmailEventProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for EmailEventResource struct.
func (eer *EmailEventResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				eer.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var emailEventProperties EmailEventProperties
				err = json.Unmarshal(*v, &emailEventProperties)
				if err != nil {
					return err
				}
				eer.EmailEventProperties = &emailEventProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				eer.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				eer.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				eer.Type = &typeVar
			}
		}
	}

	return nil
}

// ErrorDefinition error definition.
type ErrorDefinition struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDefinition `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDefinition.
func (ed ErrorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse the error response send when an operation fails.
type ErrorResponse struct {
	// Error - The error details.
	Error *ErrorDefinition `json:"error,omitempty"`
}

// FavoriteProcessListResult a list of favorite processes for a package.
type FavoriteProcessListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of favorite processes for a package.
	Value *[]FavoriteProcessResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for FavoriteProcessListResult.
func (fplr FavoriteProcessListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fplr.Value != nil {
		objectMap["value"] = fplr.Value
	}
	return json.Marshal(objectMap)
}

// FavoriteProcessListResultIterator provides access to a complete listing of FavoriteProcessResource
// values.
type FavoriteProcessListResultIterator struct {
	i    int
	page FavoriteProcessListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FavoriteProcessListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FavoriteProcessListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FavoriteProcessListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FavoriteProcessListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FavoriteProcessListResultIterator) Response() FavoriteProcessListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FavoriteProcessListResultIterator) Value() FavoriteProcessResource {
	if !iter.page.NotDone() {
		return FavoriteProcessResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FavoriteProcessListResultIterator type.
func NewFavoriteProcessListResultIterator(page FavoriteProcessListResultPage) FavoriteProcessListResultIterator {
	return FavoriteProcessListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (fplr FavoriteProcessListResult) IsEmpty() bool {
	return fplr.Value == nil || len(*fplr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (fplr FavoriteProcessListResult) hasNextLink() bool {
	return fplr.NextLink != nil && len(*fplr.NextLink) != 0
}

// favoriteProcessListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (fplr FavoriteProcessListResult) favoriteProcessListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !fplr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(fplr.NextLink)))
}

// FavoriteProcessListResultPage contains a page of FavoriteProcessResource values.
type FavoriteProcessListResultPage struct {
	fn   func(context.Context, FavoriteProcessListResult) (FavoriteProcessListResult, error)
	fplr FavoriteProcessListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FavoriteProcessListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FavoriteProcessListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.fplr)
		if err != nil {
			return err
		}
		page.fplr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FavoriteProcessListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FavoriteProcessListResultPage) NotDone() bool {
	return !page.fplr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FavoriteProcessListResultPage) Response() FavoriteProcessListResult {
	return page.fplr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FavoriteProcessListResultPage) Values() []FavoriteProcessResource {
	if page.fplr.IsEmpty() {
		return nil
	}
	return *page.fplr.Value
}

// Creates a new instance of the FavoriteProcessListResultPage type.
func NewFavoriteProcessListResultPage(cur FavoriteProcessListResult, getNextPage func(context.Context, FavoriteProcessListResult) (FavoriteProcessListResult, error)) FavoriteProcessListResultPage {
	return FavoriteProcessListResultPage{
		fn:   getNextPage,
		fplr: cur,
	}
}

// FavoriteProcessProperties properties of a favorite process identifier.
type FavoriteProcessProperties struct {
	// ActualProcessName - The actual name of the favorite process. It will be equal to resource name except for the scenario that the process name contains characters that are not allowed in the resource name.
	ActualProcessName *string `json:"actualProcessName,omitempty"`
}

// FavoriteProcessResource a favorite process identifier.
type FavoriteProcessResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// FavoriteProcessProperties - Properties of a favorite process identifier.
	*FavoriteProcessProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FavoriteProcessResource.
func (fpr FavoriteProcessResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fpr.SystemData != nil {
		objectMap["systemData"] = fpr.SystemData
	}
	if fpr.FavoriteProcessProperties != nil {
		objectMap["properties"] = fpr.FavoriteProcessProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FavoriteProcessResource struct.
func (fpr *FavoriteProcessResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				fpr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var favoriteProcessProperties FavoriteProcessProperties
				err = json.Unmarshal(*v, &favoriteProcessProperties)
				if err != nil {
					return err
				}
				fpr.FavoriteProcessProperties = &favoriteProcessProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				fpr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				fpr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				fpr.Type = &typeVar
			}
		}
	}

	return nil
}

// FileUploadURLResponse the URL response
type FileUploadURLResponse struct {
	autorest.Response `json:"-"`
	// UploadURL - READ-ONLY; The URL used for uploading the package.
	UploadURL *string `json:"uploadUrl,omitempty"`
	// BlobPath - READ-ONLY; The blob path of the uploaded package. It will be used as the 'blobPath' property of PackageResource.
	BlobPath *string `json:"blobPath,omitempty"`
}

// MarshalJSON is the custom marshaler for FileUploadURLResponse.
func (fuur FileUploadURLResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// FlightingRingListResult a list of flighting rings.
type FlightingRingListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of flighting rings.
	Value *[]FlightingRingResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for FlightingRingListResult.
func (frlr FlightingRingListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if frlr.Value != nil {
		objectMap["value"] = frlr.Value
	}
	return json.Marshal(objectMap)
}

// FlightingRingListResultIterator provides access to a complete listing of FlightingRingResource values.
type FlightingRingListResultIterator struct {
	i    int
	page FlightingRingListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *FlightingRingListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FlightingRingListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *FlightingRingListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter FlightingRingListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter FlightingRingListResultIterator) Response() FlightingRingListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter FlightingRingListResultIterator) Value() FlightingRingResource {
	if !iter.page.NotDone() {
		return FlightingRingResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the FlightingRingListResultIterator type.
func NewFlightingRingListResultIterator(page FlightingRingListResultPage) FlightingRingListResultIterator {
	return FlightingRingListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (frlr FlightingRingListResult) IsEmpty() bool {
	return frlr.Value == nil || len(*frlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (frlr FlightingRingListResult) hasNextLink() bool {
	return frlr.NextLink != nil && len(*frlr.NextLink) != 0
}

// flightingRingListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (frlr FlightingRingListResult) flightingRingListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !frlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(frlr.NextLink)))
}

// FlightingRingListResultPage contains a page of FlightingRingResource values.
type FlightingRingListResultPage struct {
	fn   func(context.Context, FlightingRingListResult) (FlightingRingListResult, error)
	frlr FlightingRingListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *FlightingRingListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/FlightingRingListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.frlr)
		if err != nil {
			return err
		}
		page.frlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *FlightingRingListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page FlightingRingListResultPage) NotDone() bool {
	return !page.frlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page FlightingRingListResultPage) Response() FlightingRingListResult {
	return page.frlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page FlightingRingListResultPage) Values() []FlightingRingResource {
	if page.frlr.IsEmpty() {
		return nil
	}
	return *page.frlr.Value
}

// Creates a new instance of the FlightingRingListResultPage type.
func NewFlightingRingListResultPage(cur FlightingRingListResult, getNextPage func(context.Context, FlightingRingListResult) (FlightingRingListResult, error)) FlightingRingListResultPage {
	return FlightingRingListResultPage{
		fn:   getNextPage,
		frlr: cur,
	}
}

// FlightingRingProperties the Flighting Ring properties.
type FlightingRingProperties struct {
	// ActualFlightingRingName - The actual name of a flighting ring of a Test Base Account.
	ActualFlightingRingName *string `json:"actualFlightingRingName,omitempty"`
}

// FlightingRingResource the flighting ring resource.
type FlightingRingResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// FlightingRingProperties - Flighting Ring properties.
	*FlightingRingProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for FlightingRingResource.
func (frr FlightingRingResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if frr.SystemData != nil {
		objectMap["systemData"] = frr.SystemData
	}
	if frr.FlightingRingProperties != nil {
		objectMap["properties"] = frr.FlightingRingProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for FlightingRingResource struct.
func (frr *FlightingRingResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				frr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var flightingRingProperties FlightingRingProperties
				err = json.Unmarshal(*v, &flightingRingProperties)
				if err != nil {
					return err
				}
				frr.FlightingRingProperties = &flightingRingProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				frr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				frr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				frr.Type = &typeVar
			}
		}
	}

	return nil
}

// GetFileUploadURLParameters the parameters supplied to the Test Base Account GetFileUploadURL action.
type GetFileUploadURLParameters struct {
	// BlobName - The custom file name of the uploaded blob.
	BlobName *string `json:"blobName,omitempty"`
}

// IdentifiedFailure the failure identified.
type IdentifiedFailure struct {
	// FailureID - The Failure Id.
	FailureID *string `json:"failureId,omitempty"`
	// Category - The category of the failure. Possible values include: 'CategoryNone', 'CategoryUnidentified', 'CategoryPackage', 'CategoryOSUpdate', 'CategoryInfrastructure'
	Category Category `json:"category,omitempty"`
	// ErrorMessage - Message that shows information about the failure.
	ErrorMessage *string `json:"errorMessage,omitempty"`
	// Guidance - Guidance that shows what the customer needs to do for this failure.
	Guidance *string `json:"guidance,omitempty"`
}

// MemoryRegressionResultSingletonResourceProperties the properties of Memory Regression Result.
type MemoryRegressionResultSingletonResourceProperties struct {
	// MemoryRegressionResults - The result array data.
	MemoryRegressionResults *[]RegressionResult `json:"memoryRegressionResults,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	mrrsrp.AnalysisResultType = AnalysisResultTypeMemoryRegression1
	objectMap := make(map[string]interface{})
	if mrrsrp.MemoryRegressionResults != nil {
		objectMap["memoryRegressionResults"] = mrrsrp.MemoryRegressionResults
	}
	if mrrsrp.Grade != "" {
		objectMap["grade"] = mrrsrp.Grade
	}
	if mrrsrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = mrrsrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return &mrrsrp, true
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryRegressionResultSingletonResourceProperties.
func (mrrsrp MemoryRegressionResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &mrrsrp, true
}

// MemoryUtilizationResultSingletonResourceProperties the properties of Memory Utilization Result.
type MemoryUtilizationResultSingletonResourceProperties struct {
	// MemoryUtilizationResults - The result array data.
	MemoryUtilizationResults *[]UtilizationResult `json:"memoryUtilizationResults,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	mursrp.AnalysisResultType = AnalysisResultTypeMemoryUtilization1
	objectMap := make(map[string]interface{})
	if mursrp.MemoryUtilizationResults != nil {
		objectMap["memoryUtilizationResults"] = mursrp.MemoryUtilizationResults
	}
	if mursrp.Grade != "" {
		objectMap["grade"] = mursrp.Grade
	}
	if mursrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = mursrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return &mursrp, true
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for MemoryUtilizationResultSingletonResourceProperties.
func (mursrp MemoryUtilizationResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &mursrp, true
}

// NotificationEventReceiver a notification event receivers.
type NotificationEventReceiver struct {
	// ReceiverType - The type of the notification event receiver.
	ReceiverType *string `json:"receiverType,omitempty"`
	// ReceiverValue - The notification event receiver value.
	ReceiverValue *NotificationReceiverValue `json:"receiverValue,omitempty"`
}

// NotificationReceiverValue a notification event receiver value.
type NotificationReceiverValue struct {
	// UserObjectReceiverValue - The user object receiver value.
	UserObjectReceiverValue *UserObjectReceiverValue `json:"userObjectReceiverValue,omitempty"`
	// SubscriptionReceiverValue - The user object receiver value.
	SubscriptionReceiverValue *SubscriptionReceiverValue `json:"subscriptionReceiverValue,omitempty"`
	// DistributionGroupListReceiverValue - The user object receiver value.
	DistributionGroupListReceiverValue *DistributionGroupListReceiverValue `json:"distributionGroupListReceiverValue,omitempty"`
}

// Operation REST API operation
type Operation struct {
	// Name - READ-ONLY; Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`
	// IsDataAction - READ-ONLY; Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Origin - READ-ONLY; Origin of the operation
	Origin *string `json:"origin,omitempty"`
	// Display - The object that describes the operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Properties - Extra properties of the operation.
	Properties interface{} `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	if o.Properties != nil {
		objectMap["properties"] = o.Properties
	}
	return json.Marshal(objectMap)
}

// OperationDisplay the object that describes the operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; The resource provider name: Microsoft.TestBase.
	Provider *string `json:"provider,omitempty"`
	// Operation - READ-ONLY; Operation type: read, write, delete, listPackages, etc.
	Operation *string `json:"operation,omitempty"`
	// Resource - READ-ONLY; Resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Description - READ-ONLY; Friendly name of the operation.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult a list of operations supported by the resource provider.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - List of operations supported by the Test Base resource provider.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if olr.Value != nil {
		objectMap["value"] = olr.Value
	}
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// OSUpdateListResult a list of OS Updates.
type OSUpdateListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of OS Updates.
	Value *[]OSUpdateResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OSUpdateListResult.
func (oulr OSUpdateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oulr.Value != nil {
		objectMap["value"] = oulr.Value
	}
	return json.Marshal(objectMap)
}

// OSUpdateListResultIterator provides access to a complete listing of OSUpdateResource values.
type OSUpdateListResultIterator struct {
	i    int
	page OSUpdateListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OSUpdateListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OSUpdateListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OSUpdateListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OSUpdateListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OSUpdateListResultIterator) Response() OSUpdateListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OSUpdateListResultIterator) Value() OSUpdateResource {
	if !iter.page.NotDone() {
		return OSUpdateResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OSUpdateListResultIterator type.
func NewOSUpdateListResultIterator(page OSUpdateListResultPage) OSUpdateListResultIterator {
	return OSUpdateListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (oulr OSUpdateListResult) IsEmpty() bool {
	return oulr.Value == nil || len(*oulr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (oulr OSUpdateListResult) hasNextLink() bool {
	return oulr.NextLink != nil && len(*oulr.NextLink) != 0
}

// oSUpdateListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (oulr OSUpdateListResult) oSUpdateListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !oulr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(oulr.NextLink)))
}

// OSUpdateListResultPage contains a page of OSUpdateResource values.
type OSUpdateListResultPage struct {
	fn   func(context.Context, OSUpdateListResult) (OSUpdateListResult, error)
	oulr OSUpdateListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OSUpdateListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OSUpdateListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.oulr)
		if err != nil {
			return err
		}
		page.oulr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OSUpdateListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OSUpdateListResultPage) NotDone() bool {
	return !page.oulr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OSUpdateListResultPage) Response() OSUpdateListResult {
	return page.oulr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OSUpdateListResultPage) Values() []OSUpdateResource {
	if page.oulr.IsEmpty() {
		return nil
	}
	return *page.oulr.Value
}

// Creates a new instance of the OSUpdateListResultPage type.
func NewOSUpdateListResultPage(cur OSUpdateListResult, getNextPage func(context.Context, OSUpdateListResult) (OSUpdateListResult, error)) OSUpdateListResultPage {
	return OSUpdateListResultPage{
		fn:   getNextPage,
		oulr: cur,
	}
}

// OSUpdateProperties properties of an OS Update.
type OSUpdateProperties struct {
	// OsName - The name of the OS.
	OsName *string `json:"osName,omitempty"`
	// Release - The name of tested release.
	Release *string `json:"release,omitempty"`
	// FlightingRing - The flighting ring, only for release of feature updates.
	FlightingRing *string `json:"flightingRing,omitempty"`
	// BuildVersion - The build version of the tested release (OS update).
	BuildVersion *string `json:"buildVersion,omitempty"`
	// BuildRevision - The build revision of the tested release (OS update)
	BuildRevision *string `json:"buildRevision,omitempty"`
	// Type - The type of this release (OS update). Possible values include: 'TypeSecurityUpdate', 'TypeFeatureUpdate'
	Type Type `json:"type,omitempty"`
	// ReleaseVersionDate - The release version date the tested release (OS update)
	ReleaseVersionDate *date.Time `json:"releaseVersionDate,omitempty"`
}

// OSUpdateResource an OS Update.
type OSUpdateResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// OSUpdateProperties - Properties of an OS Update.
	*OSUpdateProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for OSUpdateResource.
func (our OSUpdateResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if our.SystemData != nil {
		objectMap["systemData"] = our.SystemData
	}
	if our.OSUpdateProperties != nil {
		objectMap["properties"] = our.OSUpdateProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OSUpdateResource struct.
func (our *OSUpdateResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				our.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var oSUpdateProperties OSUpdateProperties
				err = json.Unmarshal(*v, &oSUpdateProperties)
				if err != nil {
					return err
				}
				our.OSUpdateProperties = &oSUpdateProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				our.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				our.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				our.Type = &typeVar
			}
		}
	}

	return nil
}

// OSUpdatesTestSummary the summary of some tests.
type OSUpdatesTestSummary struct {
	// ExecutionStatus - The status of the last test. Possible values include: 'ExecutionStatusNone', 'ExecutionStatusInProgress', 'ExecutionStatusProcessing', 'ExecutionStatusCompleted', 'ExecutionStatusNotExecuted', 'ExecutionStatusIncomplete', 'ExecutionStatusFailed', 'ExecutionStatusSucceeded'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// TestStatus - The status of last test. Possible values include: 'TestStatusNone', 'TestStatusTestExecutionInProgress', 'TestStatusDataProcessing', 'TestStatusTestFailure', 'TestStatusUpdateFailure', 'TestStatusTestAndUpdateFailure', 'TestStatusInfrastructureFailure', 'TestStatusCompleted'
	TestStatus TestStatus `json:"testStatus,omitempty"`
	// Grade - The grade of last test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// TestRunTime - The run time of the last test.
	TestRunTime *string `json:"testRunTime,omitempty"`
	// OsUpdateTestSummaries - Detailed summary for each OS update
	OsUpdateTestSummaries *[]OSUpdateTestSummary `json:"osUpdateTestSummaries,omitempty"`
}

// OSUpdateTestSummary the summary of a test.
type OSUpdateTestSummary struct {
	// OsName - The operating system name. e.g. Windows 10 1809.
	OsName *string `json:"osName,omitempty"`
	// ReleaseName - The name of the tested release (OS update).
	ReleaseName *string `json:"releaseName,omitempty"`
	// BuildVersion - The build version of the tested release (OS update)
	BuildVersion *string `json:"buildVersion,omitempty"`
	// BuildRevision - The build revision of the tested release (OS update)
	BuildRevision *string `json:"buildRevision,omitempty"`
	// ReleaseVersionDate - The release version date.
	ReleaseVersionDate *date.Time `json:"releaseVersionDate,omitempty"`
	// FlightingRing - The flighting ring, only for release of feature updates.
	FlightingRing *string `json:"flightingRing,omitempty"`
	// ExecutionStatus - The execution status of the test. Possible values include: 'ExecutionStatusNone', 'ExecutionStatusInProgress', 'ExecutionStatusProcessing', 'ExecutionStatusCompleted', 'ExecutionStatusNotExecuted', 'ExecutionStatusIncomplete', 'ExecutionStatusFailed', 'ExecutionStatusSucceeded'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// TestStatus - The status of the test. Possible values include: 'TestStatusNone', 'TestStatusTestExecutionInProgress', 'TestStatusDataProcessing', 'TestStatusTestFailure', 'TestStatusUpdateFailure', 'TestStatusTestAndUpdateFailure', 'TestStatusInfrastructureFailure', 'TestStatusCompleted'
	TestStatus TestStatus `json:"testStatus,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// TestRunTime - The run time of the test.
	TestRunTime *string `json:"testRunTime,omitempty"`
	// TestType - The test type of the package
	TestType *string `json:"testType,omitempty"`
}

// PackageCheckNameAvailabilityParameters parameters body to pass for Test Base Package name availability
// check.
type PackageCheckNameAvailabilityParameters struct {
	// Name - Resource name to verify.
	Name *string `json:"name,omitempty"`
	// ApplicationName - Application name to verify.
	ApplicationName *string `json:"applicationName,omitempty"`
	// Version - Version name to verify.
	Version *string `json:"version,omitempty"`
	// Type - fully qualified resource type which includes provider namespace.
	Type *string `json:"type,omitempty"`
}

// PackageListResult a list of Test Base Packages.
type PackageListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Base Packages.
	Value *[]PackageResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PackageListResult.
func (plr PackageListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if plr.Value != nil {
		objectMap["value"] = plr.Value
	}
	return json.Marshal(objectMap)
}

// PackageListResultIterator provides access to a complete listing of PackageResource values.
type PackageListResultIterator struct {
	i    int
	page PackageListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PackageListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PackageListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PackageListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PackageListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PackageListResultIterator) Response() PackageListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PackageListResultIterator) Value() PackageResource {
	if !iter.page.NotDone() {
		return PackageResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PackageListResultIterator type.
func NewPackageListResultIterator(page PackageListResultPage) PackageListResultIterator {
	return PackageListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (plr PackageListResult) IsEmpty() bool {
	return plr.Value == nil || len(*plr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (plr PackageListResult) hasNextLink() bool {
	return plr.NextLink != nil && len(*plr.NextLink) != 0
}

// packageListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (plr PackageListResult) packageListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !plr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(plr.NextLink)))
}

// PackageListResultPage contains a page of PackageResource values.
type PackageListResultPage struct {
	fn  func(context.Context, PackageListResult) (PackageListResult, error)
	plr PackageListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PackageListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PackageListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.plr)
		if err != nil {
			return err
		}
		page.plr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PackageListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PackageListResultPage) NotDone() bool {
	return !page.plr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PackageListResultPage) Response() PackageListResult {
	return page.plr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PackageListResultPage) Values() []PackageResource {
	if page.plr.IsEmpty() {
		return nil
	}
	return *page.plr.Value
}

// Creates a new instance of the PackageListResultPage type.
func NewPackageListResultPage(cur PackageListResult, getNextPage func(context.Context, PackageListResult) (PackageListResult, error)) PackageListResultPage {
	return PackageListResultPage{
		fn:  getNextPage,
		plr: cur,
	}
}

// PackageProperties the properties of the Test Base Package.
type PackageProperties struct {
	// ProvisioningState - The provisioning state of the resource. Possible values include: 'ProvisioningStateSucceeded', 'ProvisioningStateFailed', 'ProvisioningStateCancelled', 'ProvisioningStateCreating', 'ProvisioningStateDeleting', 'ProvisioningStateUpdating'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// ApplicationName - Application name
	ApplicationName *string `json:"applicationName,omitempty"`
	// Version - Application version
	Version *string `json:"version,omitempty"`
	// TestTypes - READ-ONLY; OOB, functional or both. Mapped to the data in 'tests' property.
	TestTypes *[]TestType `json:"testTypes,omitempty"`
	// TargetOSList - Specifies the target OSs of specific OS Update types.
	TargetOSList *[]TargetOSInfo `json:"targetOSList,omitempty"`
	// PackageStatus - READ-ONLY; The status of the package. Possible values include: 'Unknown', 'Registered', 'Ready', 'Error', 'ValidatingPackage', 'PreValidationCheckPass', 'Deleted', 'ValidationLongerThanUsual', 'VerifyingPackage'
	PackageStatus PackageStatus `json:"packageStatus,omitempty"`
	// LastModifiedTime - READ-ONLY; The UTC timestamp when the package was last modified.
	LastModifiedTime *date.Time `json:"lastModifiedTime,omitempty"`
	// FlightingRing - The flighting ring for feature update.
	FlightingRing *string `json:"flightingRing,omitempty"`
	// IsEnabled - READ-ONLY; Flag showing that whether the package is enabled. It doesn't schedule test for package which is not enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// BlobPath - The file path of the package.
	BlobPath *string `json:"blobPath,omitempty"`
	// ValidationResults - READ-ONLY; The validation results. There's validation on package when it's created or updated.
	ValidationResults *[]PackageValidationResult `json:"validationResults,omitempty"`
	// Tests - The detailed test information.
	Tests *[]Test `json:"tests,omitempty"`
}

// MarshalJSON is the custom marshaler for PackageProperties.
func (pp PackageProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pp.ProvisioningState != "" {
		objectMap["provisioningState"] = pp.ProvisioningState
	}
	if pp.ApplicationName != nil {
		objectMap["applicationName"] = pp.ApplicationName
	}
	if pp.Version != nil {
		objectMap["version"] = pp.Version
	}
	if pp.TargetOSList != nil {
		objectMap["targetOSList"] = pp.TargetOSList
	}
	if pp.FlightingRing != nil {
		objectMap["flightingRing"] = pp.FlightingRing
	}
	if pp.BlobPath != nil {
		objectMap["blobPath"] = pp.BlobPath
	}
	if pp.Tests != nil {
		objectMap["tests"] = pp.Tests
	}
	return json.Marshal(objectMap)
}

// PackageResource the Test Base Package resource.
type PackageResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// PackageProperties - Test Base Package properties.
	*PackageProperties `json:"properties,omitempty"`
	// Tags - The tags of the resource.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PackageResource.
func (pr PackageResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.SystemData != nil {
		objectMap["systemData"] = pr.SystemData
	}
	if pr.PackageProperties != nil {
		objectMap["properties"] = pr.PackageProperties
	}
	if pr.Tags != nil {
		objectMap["tags"] = pr.Tags
	}
	if pr.Location != nil {
		objectMap["location"] = pr.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PackageResource struct.
func (pr *PackageResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var packageProperties PackageProperties
				err = json.Unmarshal(*v, &packageProperties)
				if err != nil {
					return err
				}
				pr.PackageProperties = &packageProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pr.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pr.Location = &location
			}
		case "etag":
			if v != nil {
				var etag string
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				pr.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pr.Type = &typeVar
			}
		}
	}

	return nil
}

// PackagesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PackagesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PackagesClient) (PackageResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PackagesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PackagesCreateFuture.Result.
func (future *PackagesCreateFuture) result(client PackagesClient) (pr PackageResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.PackagesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.PackagesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pr.Response.Response, err = future.GetResult(sender); err == nil && pr.Response.Response.StatusCode != http.StatusNoContent {
		pr, err = client.CreateResponder(pr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "testbase.PackagesCreateFuture", "Result", pr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PackagesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PackagesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PackagesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PackagesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PackagesDeleteFuture.Result.
func (future *PackagesDeleteFuture) result(client PackagesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.PackagesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.PackagesDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PackagesHardDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PackagesHardDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PackagesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PackagesHardDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PackagesHardDeleteFuture.Result.
func (future *PackagesHardDeleteFuture) result(client PackagesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.PackagesHardDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.PackagesHardDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PackagesUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PackagesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PackagesClient) (PackageResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PackagesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PackagesUpdateFuture.Result.
func (future *PackagesUpdateFuture) result(client PackagesClient) (pr PackageResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "testbase.PackagesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("testbase.PackagesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pr.Response.Response, err = future.GetResult(sender); err == nil && pr.Response.Response.StatusCode != http.StatusNoContent {
		pr, err = client.UpdateResponder(pr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "testbase.PackagesUpdateFuture", "Result", pr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PackageUpdateParameterProperties parameters supplied to update a Test Base Package.
type PackageUpdateParameterProperties struct {
	// TargetOSList - Specifies the target OSs of specific OS Update types.
	TargetOSList *[]TargetOSInfo `json:"targetOSList,omitempty"`
	// FlightingRing - The flighting ring for feature update.
	FlightingRing *string `json:"flightingRing,omitempty"`
	// IsEnabled - Specifies whether the package is enabled. It doesn't schedule test for package which is not enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`
	// BlobPath - The file name of the package.
	BlobPath *string `json:"blobPath,omitempty"`
	// Tests - The detailed test information.
	Tests *[]Test `json:"tests,omitempty"`
}

// PackageUpdateParameters parameters supplied to update a Test Base Package.
type PackageUpdateParameters struct {
	// PackageUpdateParameterProperties - Test Base Package update parameters.
	*PackageUpdateParameterProperties `json:"properties,omitempty"`
	// Tags - The tags of the Package.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for PackageUpdateParameters.
func (pup PackageUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pup.PackageUpdateParameterProperties != nil {
		objectMap["properties"] = pup.PackageUpdateParameterProperties
	}
	if pup.Tags != nil {
		objectMap["tags"] = pup.Tags
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PackageUpdateParameters struct.
func (pup *PackageUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var packageUpdateParameterProperties PackageUpdateParameterProperties
				err = json.Unmarshal(*v, &packageUpdateParameterProperties)
				if err != nil {
					return err
				}
				pup.PackageUpdateParameterProperties = &packageUpdateParameterProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pup.Tags = tags
			}
		}
	}

	return nil
}

// PackageValidationResult the validation results. There's validation on package when it's created or
// updated.
type PackageValidationResult struct {
	// ValidationName - READ-ONLY; Validation name.
	ValidationName *string `json:"validationName,omitempty"`
	// IsValid - READ-ONLY; Indicates whether the package passed the validation.
	IsValid *bool `json:"isValid,omitempty"`
	// Errors - READ-ONLY; Error information.
	Errors *[]string `json:"errors,omitempty"`
}

// MarshalJSON is the custom marshaler for PackageValidationResult.
func (pvr PackageValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ProxyResource the resource model definition for an ARM proxy resource. It will have everything other
// than required location and tags
type ProxyResource struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RegressionResult the regression result.
type RegressionResult struct {
	// FileName - FileName of the binary being analyzed.
	FileName *string `json:"fileName,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// Details - Message that facilitates debugging a particular regression, if any was inferred.
	Details *string `json:"details,omitempty"`
	// Diff - Difference between the two datasets being analyzed.
	Diff *float64 `json:"diff,omitempty"`
	// IsRegressed - Indicates if a regression was inferred.
	IsRegressed *bool `json:"isRegressed,omitempty"`
}

// RegressionTestDetails the details of a regression test.
type RegressionTestDetails struct {
	// Diff - Difference between the two datasets being analyzed.
	Diff *float64 `json:"diff,omitempty"`
	// IsRegressed - Indicates if a regression was inferred.
	IsRegressed *bool `json:"isRegressed,omitempty"`
}

// ReliabilityResult the Reliability Result.
type ReliabilityResult struct {
	// FileName - File name.
	FileName *string `json:"fileName,omitempty"`
	// LaunchCount - Count of number of launches.
	LaunchCount *int32 `json:"launchCount,omitempty"`
	// CrashCount - Count of number of crashes.
	CrashCount *int32 `json:"crashCount,omitempty"`
	// HangCount - Count of number of hangs.
	HangCount *int32 `json:"hangCount,omitempty"`
	// RegressionGrade - The regression grade. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	RegressionGrade Grade `json:"regressionGrade,omitempty"`
	// CrashRegressionGrade - The statistic regression grade for crash signal. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	CrashRegressionGrade Grade `json:"crashRegressionGrade,omitempty"`
	// CrashRegressionTestDetails - Details related to the crash regression analysis.
	CrashRegressionTestDetails *RegressionTestDetails `json:"crashRegressionTestDetails,omitempty"`
	// HangRegressionGrade - The statistic regression grade for hang signal. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	HangRegressionGrade Grade `json:"hangRegressionGrade,omitempty"`
	// HangRegressionTestDetails - Details related to the hang regression analysis.
	HangRegressionTestDetails *RegressionTestDetails `json:"hangRegressionTestDetails,omitempty"`
}

// ReliabilityResultSingletonResourceProperties the properties of Reliability Result.
type ReliabilityResultSingletonResourceProperties struct {
	// ReliabilityResults - The result array data.
	ReliabilityResults *[]ReliabilityResult `json:"reliabilityResults,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	rrsrp.AnalysisResultType = AnalysisResultTypeReliability1
	objectMap := make(map[string]interface{})
	if rrsrp.ReliabilityResults != nil {
		objectMap["reliabilityResults"] = rrsrp.ReliabilityResults
	}
	if rrsrp.Grade != "" {
		objectMap["grade"] = rrsrp.Grade
	}
	if rrsrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = rrsrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return &rrsrp, true
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ReliabilityResultSingletonResourceProperties.
func (rrsrp ReliabilityResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &rrsrp, true
}

// Resource the Resource definition.
type Resource struct {
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ScriptExecutionResult the Script Execution Result.
type ScriptExecutionResult struct {
	// ScriptName - Name of script.
	ScriptName *string `json:"scriptName,omitempty"`
	// StartTime - Start time of script execution.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - End time of script execution.
	EndTime *date.Time `json:"endTime,omitempty"`
	// ExitCode - Exit code.
	ExitCode *int32 `json:"exitCode,omitempty"`
	// TimedOut - Whether the script execution is timed out.
	TimedOut *bool `json:"timedOut,omitempty"`
}

// ScriptExecutionResultSingletonResourceProperties the properties of Script Execution Result.
type ScriptExecutionResultSingletonResourceProperties struct {
	// ScriptExecutionResults - The result array data.
	ScriptExecutionResults *[]ScriptExecutionResult `json:"scriptExecutionResults,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	sersrp.AnalysisResultType = AnalysisResultTypeScriptExecution1
	objectMap := make(map[string]interface{})
	if sersrp.ScriptExecutionResults != nil {
		objectMap["scriptExecutionResults"] = sersrp.ScriptExecutionResults
	}
	if sersrp.Grade != "" {
		objectMap["grade"] = sersrp.Grade
	}
	if sersrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = sersrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return &sersrp, true
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for ScriptExecutionResultSingletonResourceProperties.
func (sersrp ScriptExecutionResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &sersrp, true
}

// SubscriptionReceiverValue the subscription role receiver value.
type SubscriptionReceiverValue struct {
	// SubscriptionID - The subscription id of the notification receiver.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// SubscriptionName - The subscription name of the notification receiver.
	SubscriptionName *string `json:"subscriptionName,omitempty"`
	// Role - The role of the notification receiver.
	Role *string `json:"role,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The type of identity that last modified the resource.
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TargetOSInfo the information of the target OS to be tested.
type TargetOSInfo struct {
	// OsUpdateType - Specifies the OS update type to test against, e.g., 'Security updates' or 'Feature updates'.
	OsUpdateType *string `json:"osUpdateType,omitempty"`
	// TargetOSs - Specifies the target OSs to be tested.
	TargetOSs *[]string `json:"targetOSs,omitempty"`
}

// Test the definition of a Test.
type Test struct {
	// TestType - The type of the test. Possible values include: 'OutOfBoxTest', 'FunctionalTest'
	TestType TestType `json:"testType,omitempty"`
	// ValidationRunStatus - READ-ONLY; The status of the validation run of the package. Possible values include: 'ValidationRunStatusUnknown', 'ValidationRunStatusPending', 'ValidationRunStatusPassed', 'ValidationRunStatusFailed'
	ValidationRunStatus ValidationRunStatus `json:"validationRunStatus,omitempty"`
	// IsActive - Indicates if this test is active.It doesn't schedule test for not active Test.
	IsActive *bool `json:"isActive,omitempty"`
	// Commands - The commands used in the test.
	Commands *[]Command `json:"commands,omitempty"`
}

// MarshalJSON is the custom marshaler for Test.
func (t Test) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.TestType != "" {
		objectMap["testType"] = t.TestType
	}
	if t.IsActive != nil {
		objectMap["isActive"] = t.IsActive
	}
	if t.Commands != nil {
		objectMap["commands"] = t.Commands
	}
	return json.Marshal(objectMap)
}

// TestAnalysisResult the test analysis result.
type TestAnalysisResult struct {
	// BlobData - The data to provide more failure analysis information.
	BlobData *string `json:"blobData,omitempty"`
	// TestAnalysisStatus - The status of the analysis. Possible values include: 'TestAnalysisStatusNone', 'TestAnalysisStatusAnalyzing', 'TestAnalysisStatusCompleted', 'TestAnalysisStatusFailed'
	TestAnalysisStatus TestAnalysisStatus `json:"testAnalysisStatus,omitempty"`
	// IdentifiedFailures - The array of identified failures.
	IdentifiedFailures *[]IdentifiedFailure `json:"identifiedFailures,omitempty"`
}

// TestAnalysisResultSingletonResourceProperties the properties of Test Analysis Result.
type TestAnalysisResultSingletonResourceProperties struct {
	// TestAnalysisResult - The result of test analysis.
	TestAnalysisResult *TestAnalysisResult `json:"testAnalysisResult,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// AnalysisResultType - Possible values include: 'AnalysisResultTypeAnalysisResultSingletonResourceProperties', 'AnalysisResultTypeScriptExecution1', 'AnalysisResultTypeReliability1', 'AnalysisResultTypeCPUUtilization1', 'AnalysisResultTypeMemoryUtilization1', 'AnalysisResultTypeCPURegression1', 'AnalysisResultTypeMemoryRegression1', 'AnalysisResultTypeTestAnalysis1'
	AnalysisResultType AnalysisResultTypeBasicAnalysisResultSingletonResourceProperties `json:"analysisResultType,omitempty"`
}

// MarshalJSON is the custom marshaler for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) MarshalJSON() ([]byte, error) {
	tarsrp.AnalysisResultType = AnalysisResultTypeTestAnalysis1
	objectMap := make(map[string]interface{})
	if tarsrp.TestAnalysisResult != nil {
		objectMap["testAnalysisResult"] = tarsrp.TestAnalysisResult
	}
	if tarsrp.Grade != "" {
		objectMap["grade"] = tarsrp.Grade
	}
	if tarsrp.AnalysisResultType != "" {
		objectMap["analysisResultType"] = tarsrp.AnalysisResultType
	}
	return json.Marshal(objectMap)
}

// AsScriptExecutionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsScriptExecutionResultSingletonResourceProperties() (*ScriptExecutionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsReliabilityResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsReliabilityResultSingletonResourceProperties() (*ReliabilityResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPUUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsCPUUtilizationResultSingletonResourceProperties() (*CPUUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryUtilizationResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsMemoryUtilizationResultSingletonResourceProperties() (*MemoryUtilizationResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsCPURegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsCPURegressionResultSingletonResourceProperties() (*CPURegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsMemoryRegressionResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsMemoryRegressionResultSingletonResourceProperties() (*MemoryRegressionResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsTestAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsTestAnalysisResultSingletonResourceProperties() (*TestAnalysisResultSingletonResourceProperties, bool) {
	return &tarsrp, true
}

// AsAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsAnalysisResultSingletonResourceProperties() (*AnalysisResultSingletonResourceProperties, bool) {
	return nil, false
}

// AsBasicAnalysisResultSingletonResourceProperties is the BasicAnalysisResultSingletonResourceProperties implementation for TestAnalysisResultSingletonResourceProperties.
func (tarsrp TestAnalysisResultSingletonResourceProperties) AsBasicAnalysisResultSingletonResourceProperties() (BasicAnalysisResultSingletonResourceProperties, bool) {
	return &tarsrp, true
}

// TestResultAnalysisSummary the summary of a Test Analysis Result.
type TestResultAnalysisSummary struct {
	// Name - Metric name
	Name *string `json:"name,omitempty"`
	// AnalysisStatus - The analysis status. Possible values include: 'None', 'Completed', 'InProgress', 'Failed', 'Succeeded', 'Available', 'NotAvailable'
	AnalysisStatus AnalysisStatus `json:"analysisStatus,omitempty"`
	// Grade - The grade of the test result. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
}

// TestResultListResult a list of Test Results.
type TestResultListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Results.
	Value *[]TestResultResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TestResultListResult.
func (trlr TestResultListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if trlr.Value != nil {
		objectMap["value"] = trlr.Value
	}
	return json.Marshal(objectMap)
}

// TestResultListResultIterator provides access to a complete listing of TestResultResource values.
type TestResultListResultIterator struct {
	i    int
	page TestResultListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TestResultListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TestResultListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TestResultListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TestResultListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TestResultListResultIterator) Response() TestResultListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TestResultListResultIterator) Value() TestResultResource {
	if !iter.page.NotDone() {
		return TestResultResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TestResultListResultIterator type.
func NewTestResultListResultIterator(page TestResultListResultPage) TestResultListResultIterator {
	return TestResultListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (trlr TestResultListResult) IsEmpty() bool {
	return trlr.Value == nil || len(*trlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (trlr TestResultListResult) hasNextLink() bool {
	return trlr.NextLink != nil && len(*trlr.NextLink) != 0
}

// testResultListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (trlr TestResultListResult) testResultListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !trlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(trlr.NextLink)))
}

// TestResultListResultPage contains a page of TestResultResource values.
type TestResultListResultPage struct {
	fn   func(context.Context, TestResultListResult) (TestResultListResult, error)
	trlr TestResultListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TestResultListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TestResultListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.trlr)
		if err != nil {
			return err
		}
		page.trlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TestResultListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TestResultListResultPage) NotDone() bool {
	return !page.trlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TestResultListResultPage) Response() TestResultListResult {
	return page.trlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TestResultListResultPage) Values() []TestResultResource {
	if page.trlr.IsEmpty() {
		return nil
	}
	return *page.trlr.Value
}

// Creates a new instance of the TestResultListResultPage type.
func NewTestResultListResultPage(cur TestResultListResult, getNextPage func(context.Context, TestResultListResult) (TestResultListResult, error)) TestResultListResultPage {
	return TestResultListResultPage{
		fn:   getNextPage,
		trlr: cur,
	}
}

// TestResultProperties the properties of a Test Result.
type TestResultProperties struct {
	// BaselineTestResultID - Azure Id of the baseline test result.
	BaselineTestResultID *string `json:"baselineTestResultId,omitempty"`
	// PackageID - Resource Id of the package.
	PackageID *string `json:"packageId,omitempty"`
	// ApplicationName - Application name.
	ApplicationName *string `json:"applicationName,omitempty"`
	// ApplicationVersion - Application version.
	ApplicationVersion *string `json:"applicationVersion,omitempty"`
	// OsName - The operating system name, e.g. Windows 10 1809.
	OsName *string `json:"osName,omitempty"`
	// ReleaseName - The name of the tested release (OS update).
	ReleaseName *string `json:"releaseName,omitempty"`
	// ReleaseVersionDate - The release version date of the tested release.
	ReleaseVersionDate *date.Time `json:"releaseVersionDate,omitempty"`
	// FlightingRing - The flighting ring, only for release of feature updates.
	FlightingRing *string `json:"flightingRing,omitempty"`
	// BuildVersion - The build version of the tested release (OS update).
	BuildVersion *string `json:"buildVersion,omitempty"`
	// BuildRevision - The build revision of the tested release (OS update).
	BuildRevision *string `json:"buildRevision,omitempty"`
	// TestType - Test type. E.g. 'Out of box test' or 'Functional test'.
	TestType *string `json:"testType,omitempty"`
	// TestRunTime - The run time of the test.
	TestRunTime *string `json:"testRunTime,omitempty"`
	// IsDownloadDataAvailable - Whether download data is available.
	IsDownloadDataAvailable *bool `json:"isDownloadDataAvailable,omitempty"`
	// IsVideoAvailable - Whether video data is available.
	IsVideoAvailable *bool `json:"isVideoAvailable,omitempty"`
	// ExecutionStatus - The execution status of the test. Possible values include: 'ExecutionStatusNone', 'ExecutionStatusInProgress', 'ExecutionStatusProcessing', 'ExecutionStatusCompleted', 'ExecutionStatusNotExecuted', 'ExecutionStatusIncomplete', 'ExecutionStatusFailed', 'ExecutionStatusSucceeded'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// TestStatus - The status of the test. Possible values include: 'TestStatusNone', 'TestStatusTestExecutionInProgress', 'TestStatusDataProcessing', 'TestStatusTestFailure', 'TestStatusUpdateFailure', 'TestStatusTestAndUpdateFailure', 'TestStatusInfrastructureFailure', 'TestStatusCompleted'
	TestStatus TestStatus `json:"testStatus,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// KbNumber - KB number.
	KbNumber *string `json:"kbNumber,omitempty"`
	// PackageVersion - The version of the Windows update package.
	PackageVersion *string `json:"packageVersion,omitempty"`
	// AnalysisSummaries - List of analysis summaries.
	AnalysisSummaries *[]TestResultAnalysisSummary `json:"analysisSummaries,omitempty"`
}

// TestResultResource the Test Result Resource.
type TestResultResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// TestResultProperties - The properties of a Test Result.
	*TestResultProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TestResultResource.
func (trr TestResultResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if trr.SystemData != nil {
		objectMap["systemData"] = trr.SystemData
	}
	if trr.TestResultProperties != nil {
		objectMap["properties"] = trr.TestResultProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TestResultResource struct.
func (trr *TestResultResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				trr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var testResultProperties TestResultProperties
				err = json.Unmarshal(*v, &testResultProperties)
				if err != nil {
					return err
				}
				trr.TestResultProperties = &testResultProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				trr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				trr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				trr.Type = &typeVar
			}
		}
	}

	return nil
}

// TestSummaryListResult a list of Test Summaries.
type TestSummaryListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of Test Summaries.
	Value *[]TestSummaryResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TestSummaryListResult.
func (tslr TestSummaryListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tslr.Value != nil {
		objectMap["value"] = tslr.Value
	}
	return json.Marshal(objectMap)
}

// TestSummaryListResultIterator provides access to a complete listing of TestSummaryResource values.
type TestSummaryListResultIterator struct {
	i    int
	page TestSummaryListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TestSummaryListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TestSummaryListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TestSummaryListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TestSummaryListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TestSummaryListResultIterator) Response() TestSummaryListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TestSummaryListResultIterator) Value() TestSummaryResource {
	if !iter.page.NotDone() {
		return TestSummaryResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TestSummaryListResultIterator type.
func NewTestSummaryListResultIterator(page TestSummaryListResultPage) TestSummaryListResultIterator {
	return TestSummaryListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (tslr TestSummaryListResult) IsEmpty() bool {
	return tslr.Value == nil || len(*tslr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (tslr TestSummaryListResult) hasNextLink() bool {
	return tslr.NextLink != nil && len(*tslr.NextLink) != 0
}

// testSummaryListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (tslr TestSummaryListResult) testSummaryListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !tslr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(tslr.NextLink)))
}

// TestSummaryListResultPage contains a page of TestSummaryResource values.
type TestSummaryListResultPage struct {
	fn   func(context.Context, TestSummaryListResult) (TestSummaryListResult, error)
	tslr TestSummaryListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TestSummaryListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TestSummaryListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.tslr)
		if err != nil {
			return err
		}
		page.tslr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TestSummaryListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TestSummaryListResultPage) NotDone() bool {
	return !page.tslr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TestSummaryListResultPage) Response() TestSummaryListResult {
	return page.tslr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TestSummaryListResultPage) Values() []TestSummaryResource {
	if page.tslr.IsEmpty() {
		return nil
	}
	return *page.tslr.Value
}

// Creates a new instance of the TestSummaryListResultPage type.
func NewTestSummaryListResultPage(cur TestSummaryListResult, getNextPage func(context.Context, TestSummaryListResult) (TestSummaryListResult, error)) TestSummaryListResultPage {
	return TestSummaryListResultPage{
		fn:   getNextPage,
		tslr: cur,
	}
}

// TestSummaryProperties properties of a Test Summary.
type TestSummaryProperties struct {
	// TestSummaryID - The Id of the current Test Summary.
	TestSummaryID *string `json:"testSummaryId,omitempty"`
	// PackageID - The Azure resource Id of package.
	PackageID *string `json:"packageId,omitempty"`
	// ApplicationName - Application name.
	ApplicationName *string `json:"applicationName,omitempty"`
	// ApplicationVersion - Application version.
	ApplicationVersion *string `json:"applicationVersion,omitempty"`
	// ExecutionStatus - The execution status of last test. Possible values include: 'ExecutionStatusNone', 'ExecutionStatusInProgress', 'ExecutionStatusProcessing', 'ExecutionStatusCompleted', 'ExecutionStatusNotExecuted', 'ExecutionStatusIncomplete', 'ExecutionStatusFailed', 'ExecutionStatusSucceeded'
	ExecutionStatus ExecutionStatus `json:"executionStatus,omitempty"`
	// TestStatus - The status of last test. Possible values include: 'TestStatusNone', 'TestStatusTestExecutionInProgress', 'TestStatusDataProcessing', 'TestStatusTestFailure', 'TestStatusUpdateFailure', 'TestStatusTestAndUpdateFailure', 'TestStatusInfrastructureFailure', 'TestStatusCompleted'
	TestStatus TestStatus `json:"testStatus,omitempty"`
	// Grade - The grade of the test. Possible values include: 'GradeNone', 'GradeNotAvailable', 'GradePass', 'GradeFail'
	Grade Grade `json:"grade,omitempty"`
	// TestRunTime - The run time of the last test.
	TestRunTime *string `json:"testRunTime,omitempty"`
	// FeatureUpdatesTestSummary - The result summary of tests triggered by feature updates
	FeatureUpdatesTestSummary *OSUpdatesTestSummary `json:"featureUpdatesTestSummary,omitempty"`
	// SecurityUpdatesTestSummary - The result summary of tests triggered by security updates
	SecurityUpdatesTestSummary *OSUpdatesTestSummary `json:"securityUpdatesTestSummary,omitempty"`
}

// TestSummaryResource summary of a Test.
type TestSummaryResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// TestSummaryProperties - Properties of a Test Summary.
	*TestSummaryProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TestSummaryResource.
func (tsr TestSummaryResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tsr.SystemData != nil {
		objectMap["systemData"] = tsr.SystemData
	}
	if tsr.TestSummaryProperties != nil {
		objectMap["properties"] = tsr.TestSummaryProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TestSummaryResource struct.
func (tsr *TestSummaryResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				tsr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var testSummaryProperties TestSummaryProperties
				err = json.Unmarshal(*v, &testSummaryProperties)
				if err != nil {
					return err
				}
				tsr.TestSummaryProperties = &testSummaryProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				tsr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				tsr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				tsr.Type = &typeVar
			}
		}
	}

	return nil
}

// TestTypeListResult a list of test types.
type TestTypeListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of test types.
	Value *[]TestTypeResource `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results. Not empty if value contains incomplete list of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for TestTypeListResult.
func (ttlr TestTypeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ttlr.Value != nil {
		objectMap["value"] = ttlr.Value
	}
	return json.Marshal(objectMap)
}

// TestTypeListResultIterator provides access to a complete listing of TestTypeResource values.
type TestTypeListResultIterator struct {
	i    int
	page TestTypeListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *TestTypeListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TestTypeListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *TestTypeListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter TestTypeListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter TestTypeListResultIterator) Response() TestTypeListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter TestTypeListResultIterator) Value() TestTypeResource {
	if !iter.page.NotDone() {
		return TestTypeResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the TestTypeListResultIterator type.
func NewTestTypeListResultIterator(page TestTypeListResultPage) TestTypeListResultIterator {
	return TestTypeListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ttlr TestTypeListResult) IsEmpty() bool {
	return ttlr.Value == nil || len(*ttlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ttlr TestTypeListResult) hasNextLink() bool {
	return ttlr.NextLink != nil && len(*ttlr.NextLink) != 0
}

// testTypeListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ttlr TestTypeListResult) testTypeListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !ttlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ttlr.NextLink)))
}

// TestTypeListResultPage contains a page of TestTypeResource values.
type TestTypeListResultPage struct {
	fn   func(context.Context, TestTypeListResult) (TestTypeListResult, error)
	ttlr TestTypeListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *TestTypeListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/TestTypeListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ttlr)
		if err != nil {
			return err
		}
		page.ttlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *TestTypeListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page TestTypeListResultPage) NotDone() bool {
	return !page.ttlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page TestTypeListResultPage) Response() TestTypeListResult {
	return page.ttlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page TestTypeListResultPage) Values() []TestTypeResource {
	if page.ttlr.IsEmpty() {
		return nil
	}
	return *page.ttlr.Value
}

// Creates a new instance of the TestTypeListResultPage type.
func NewTestTypeListResultPage(cur TestTypeListResult, getNextPage func(context.Context, TestTypeListResult) (TestTypeListResult, error)) TestTypeListResultPage {
	return TestTypeListResultPage{
		fn:   getNextPage,
		ttlr: cur,
	}
}

// TestTypeProperties the Test Type properties.
type TestTypeProperties struct {
	// ActualTestTypeName - The actual name of a test type of a Test Base Account.
	ActualTestTypeName *string `json:"actualTestTypeName,omitempty"`
}

// TestTypeResource the test type resource.
type TestTypeResource struct {
	autorest.Response `json:"-"`
	// SystemData - The system metadata relating to this resource
	SystemData *SystemData `json:"systemData,omitempty"`
	// TestTypeProperties - Test Type properties.
	*TestTypeProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TestTypeResource.
func (ttr TestTypeResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ttr.SystemData != nil {
		objectMap["systemData"] = ttr.SystemData
	}
	if ttr.TestTypeProperties != nil {
		objectMap["properties"] = ttr.TestTypeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for TestTypeResource struct.
func (ttr *TestTypeResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				ttr.SystemData = &systemData
			}
		case "properties":
			if v != nil {
				var testTypeProperties TestTypeProperties
				err = json.Unmarshal(*v, &testTypeProperties)
				if err != nil {
					return err
				}
				ttr.TestTypeProperties = &testTypeProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ttr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ttr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ttr.Type = &typeVar
			}
		}
	}

	return nil
}

// TrackedResource the resource model definition for an ARM tracked top level resource
type TrackedResource struct {
	// Tags - The tags of the resource.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// UserObjectReceiverValue the user object receiver value.
type UserObjectReceiverValue struct {
	// UserObjectIds - user object ids.
	UserObjectIds *[]string `json:"userObjectIds,omitempty"`
}

// UtilizationBound the bound of a utilization result.
type UtilizationBound struct {
	// Percentile - The percentile of the bound.
	Percentile *float64 `json:"percentile,omitempty"`
	// Value - The value of the bound.
	Value *float64 `json:"value,omitempty"`
}

// UtilizationEntry the utilization entry.
type UtilizationEntry struct {
	// Timestamp - The timestamp.
	Timestamp *date.Time `json:"timestamp,omitempty"`
	// Value - The value.
	Value *float64 `json:"value,omitempty"`
}

// UtilizationResult the Utilization Result.
type UtilizationResult struct {
	// Process - Process name, or '_total' for all processes
	Process *string `json:"process,omitempty"`
	// UpperBound - Upper bound
	UpperBound *UtilizationBound `json:"upperBound,omitempty"`
	// LowerBound - Lower bound
	LowerBound *UtilizationBound `json:"lowerBound,omitempty"`
	// Utilization - Utilization data
	Utilization *[]UtilizationEntry `json:"utilization,omitempty"`
}
