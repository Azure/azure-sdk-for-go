package providerhub

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/providerhub/mgmt/2020-11-20/providerhub"

// AuthorizationActionMapping ...
type AuthorizationActionMapping struct {
	Original *string `json:"original,omitempty"`
	Desired  *string `json:"desired,omitempty"`
}

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// CanaryTrafficRegionRolloutConfiguration ...
type CanaryTrafficRegionRolloutConfiguration struct {
	SkipRegions *[]string `json:"skipRegions,omitempty"`
	Regions     *[]string `json:"regions,omitempty"`
}

// CheckinManifestInfo ...
type CheckinManifestInfo struct {
	autorest.Response `json:"-"`
	IsCheckedIn       *bool   `json:"isCheckedIn,omitempty"`
	StatusMessage     *string `json:"statusMessage,omitempty"`
	PullRequest       *string `json:"pullRequest,omitempty"`
	CommitID          *string `json:"commitId,omitempty"`
}

// CheckinManifestParams ...
type CheckinManifestParams struct {
	// Environment - The environment supplied to the checkin manifest operation.
	Environment *string `json:"environment,omitempty"`
	// BaselineArmManifestLocation - The baseline ARM manifest location supplied to the checkin manifest operation.
	BaselineArmManifestLocation *string `json:"baselineArmManifestLocation,omitempty"`
}

// CheckNameAvailabilitySpecifications ...
type CheckNameAvailabilitySpecifications struct {
	EnableDefaultValidation           *bool     `json:"enableDefaultValidation,omitempty"`
	ResourceTypesWithCustomValidation *[]string `json:"resourceTypesWithCustomValidation,omitempty"`
}

// CustomRollout rollout details.
type CustomRollout struct {
	autorest.Response `json:"-"`
	// Properties - Properties of the rollout.
	Properties *CustomRolloutPropertiesModel `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomRollout.
func (cr CustomRollout) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cr.Properties != nil {
		objectMap["properties"] = cr.Properties
	}
	return json.Marshal(objectMap)
}

// CustomRolloutArrayResponseWithContinuation ...
type CustomRolloutArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]CustomRollout `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// CustomRolloutArrayResponseWithContinuationIterator provides access to a complete listing of
// CustomRollout values.
type CustomRolloutArrayResponseWithContinuationIterator struct {
	i    int
	page CustomRolloutArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *CustomRolloutArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomRolloutArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *CustomRolloutArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter CustomRolloutArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter CustomRolloutArrayResponseWithContinuationIterator) Response() CustomRolloutArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter CustomRolloutArrayResponseWithContinuationIterator) Value() CustomRollout {
	if !iter.page.NotDone() {
		return CustomRollout{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the CustomRolloutArrayResponseWithContinuationIterator type.
func NewCustomRolloutArrayResponseWithContinuationIterator(page CustomRolloutArrayResponseWithContinuationPage) CustomRolloutArrayResponseWithContinuationIterator {
	return CustomRolloutArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (crarwc CustomRolloutArrayResponseWithContinuation) IsEmpty() bool {
	return crarwc.Value == nil || len(*crarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (crarwc CustomRolloutArrayResponseWithContinuation) hasNextLink() bool {
	return crarwc.NextLink != nil && len(*crarwc.NextLink) != 0
}

// customRolloutArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (crarwc CustomRolloutArrayResponseWithContinuation) customRolloutArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !crarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(crarwc.NextLink)))
}

// CustomRolloutArrayResponseWithContinuationPage contains a page of CustomRollout values.
type CustomRolloutArrayResponseWithContinuationPage struct {
	fn     func(context.Context, CustomRolloutArrayResponseWithContinuation) (CustomRolloutArrayResponseWithContinuation, error)
	crarwc CustomRolloutArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *CustomRolloutArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/CustomRolloutArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.crarwc)
		if err != nil {
			return err
		}
		page.crarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *CustomRolloutArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page CustomRolloutArrayResponseWithContinuationPage) NotDone() bool {
	return !page.crarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page CustomRolloutArrayResponseWithContinuationPage) Response() CustomRolloutArrayResponseWithContinuation {
	return page.crarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page CustomRolloutArrayResponseWithContinuationPage) Values() []CustomRollout {
	if page.crarwc.IsEmpty() {
		return nil
	}
	return *page.crarwc.Value
}

// Creates a new instance of the CustomRolloutArrayResponseWithContinuationPage type.
func NewCustomRolloutArrayResponseWithContinuationPage(cur CustomRolloutArrayResponseWithContinuation, getNextPage func(context.Context, CustomRolloutArrayResponseWithContinuation) (CustomRolloutArrayResponseWithContinuation, error)) CustomRolloutArrayResponseWithContinuationPage {
	return CustomRolloutArrayResponseWithContinuationPage{
		fn:     getNextPage,
		crarwc: cur,
	}
}

// CustomRolloutProperties ...
type CustomRolloutProperties struct {
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState                     `json:"provisioningState,omitempty"`
	Specification     *CustomRolloutPropertiesSpecification `json:"specification,omitempty"`
	Status            *CustomRolloutPropertiesStatus        `json:"status,omitempty"`
}

// CustomRolloutPropertiesModel properties of the rollout.
type CustomRolloutPropertiesModel struct {
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState                     `json:"provisioningState,omitempty"`
	Specification     *CustomRolloutPropertiesSpecification `json:"specification,omitempty"`
	Status            *CustomRolloutPropertiesStatus        `json:"status,omitempty"`
}

// CustomRolloutPropertiesSpecification ...
type CustomRolloutPropertiesSpecification struct {
	Canary                    *CustomRolloutSpecificationCanary               `json:"canary,omitempty"`
	ProviderRegistration      *CustomRolloutSpecificationProviderRegistration `json:"providerRegistration,omitempty"`
	ResourceTypeRegistrations *[]ResourceTypeRegistration                     `json:"resourceTypeRegistrations,omitempty"`
}

// CustomRolloutPropertiesStatus ...
type CustomRolloutPropertiesStatus struct {
	CompletedRegions       *[]string                     `json:"completedRegions,omitempty"`
	FailedOrSkippedRegions map[string]*ExtendedErrorInfo `json:"failedOrSkippedRegions"`
}

// MarshalJSON is the custom marshaler for CustomRolloutPropertiesStatus.
func (crp CustomRolloutPropertiesStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if crp.CompletedRegions != nil {
		objectMap["completedRegions"] = crp.CompletedRegions
	}
	if crp.FailedOrSkippedRegions != nil {
		objectMap["failedOrSkippedRegions"] = crp.FailedOrSkippedRegions
	}
	return json.Marshal(objectMap)
}

// CustomRolloutSpecification ...
type CustomRolloutSpecification struct {
	Canary                    *CustomRolloutSpecificationCanary               `json:"canary,omitempty"`
	ProviderRegistration      *CustomRolloutSpecificationProviderRegistration `json:"providerRegistration,omitempty"`
	ResourceTypeRegistrations *[]ResourceTypeRegistration                     `json:"resourceTypeRegistrations,omitempty"`
}

// CustomRolloutSpecificationCanary ...
type CustomRolloutSpecificationCanary struct {
	Regions *[]string `json:"regions,omitempty"`
}

// CustomRolloutSpecificationProviderRegistration ...
type CustomRolloutSpecificationProviderRegistration struct {
	Properties *ProviderRegistrationPropertiesModel `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CustomRolloutSpecificationProviderRegistration.
func (crsR CustomRolloutSpecificationProviderRegistration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if crsR.Properties != nil {
		objectMap["properties"] = crsR.Properties
	}
	return json.Marshal(objectMap)
}

// CustomRolloutStatus ...
type CustomRolloutStatus struct {
	CompletedRegions       *[]string                     `json:"completedRegions,omitempty"`
	FailedOrSkippedRegions map[string]*ExtendedErrorInfo `json:"failedOrSkippedRegions"`
}

// MarshalJSON is the custom marshaler for CustomRolloutStatus.
func (crs CustomRolloutStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if crs.CompletedRegions != nil {
		objectMap["completedRegions"] = crs.CompletedRegions
	}
	if crs.FailedOrSkippedRegions != nil {
		objectMap["failedOrSkippedRegions"] = crs.FailedOrSkippedRegions
	}
	return json.Marshal(objectMap)
}

// DefaultRollout default rollout definition.
type DefaultRollout struct {
	autorest.Response `json:"-"`
	// Properties - Properties of the rollout.
	Properties *DefaultRolloutPropertiesModel `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultRollout.
func (dr DefaultRollout) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dr.Properties != nil {
		objectMap["properties"] = dr.Properties
	}
	return json.Marshal(objectMap)
}

// DefaultRolloutArrayResponseWithContinuation ...
type DefaultRolloutArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]DefaultRollout `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// DefaultRolloutArrayResponseWithContinuationIterator provides access to a complete listing of
// DefaultRollout values.
type DefaultRolloutArrayResponseWithContinuationIterator struct {
	i    int
	page DefaultRolloutArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *DefaultRolloutArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DefaultRolloutArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *DefaultRolloutArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter DefaultRolloutArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter DefaultRolloutArrayResponseWithContinuationIterator) Response() DefaultRolloutArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter DefaultRolloutArrayResponseWithContinuationIterator) Value() DefaultRollout {
	if !iter.page.NotDone() {
		return DefaultRollout{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the DefaultRolloutArrayResponseWithContinuationIterator type.
func NewDefaultRolloutArrayResponseWithContinuationIterator(page DefaultRolloutArrayResponseWithContinuationPage) DefaultRolloutArrayResponseWithContinuationIterator {
	return DefaultRolloutArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (drarwc DefaultRolloutArrayResponseWithContinuation) IsEmpty() bool {
	return drarwc.Value == nil || len(*drarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (drarwc DefaultRolloutArrayResponseWithContinuation) hasNextLink() bool {
	return drarwc.NextLink != nil && len(*drarwc.NextLink) != 0
}

// defaultRolloutArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (drarwc DefaultRolloutArrayResponseWithContinuation) defaultRolloutArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !drarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(drarwc.NextLink)))
}

// DefaultRolloutArrayResponseWithContinuationPage contains a page of DefaultRollout values.
type DefaultRolloutArrayResponseWithContinuationPage struct {
	fn     func(context.Context, DefaultRolloutArrayResponseWithContinuation) (DefaultRolloutArrayResponseWithContinuation, error)
	drarwc DefaultRolloutArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *DefaultRolloutArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/DefaultRolloutArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.drarwc)
		if err != nil {
			return err
		}
		page.drarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *DefaultRolloutArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page DefaultRolloutArrayResponseWithContinuationPage) NotDone() bool {
	return !page.drarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page DefaultRolloutArrayResponseWithContinuationPage) Response() DefaultRolloutArrayResponseWithContinuation {
	return page.drarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page DefaultRolloutArrayResponseWithContinuationPage) Values() []DefaultRollout {
	if page.drarwc.IsEmpty() {
		return nil
	}
	return *page.drarwc.Value
}

// Creates a new instance of the DefaultRolloutArrayResponseWithContinuationPage type.
func NewDefaultRolloutArrayResponseWithContinuationPage(cur DefaultRolloutArrayResponseWithContinuation, getNextPage func(context.Context, DefaultRolloutArrayResponseWithContinuation) (DefaultRolloutArrayResponseWithContinuation, error)) DefaultRolloutArrayResponseWithContinuationPage {
	return DefaultRolloutArrayResponseWithContinuationPage{
		fn:     getNextPage,
		drarwc: cur,
	}
}

// DefaultRolloutProperties ...
type DefaultRolloutProperties struct {
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState                      `json:"provisioningState,omitempty"`
	Specification     *DefaultRolloutPropertiesSpecification `json:"specification,omitempty"`
	Status            *DefaultRolloutPropertiesStatus        `json:"status,omitempty"`
}

// DefaultRolloutPropertiesModel properties of the rollout.
type DefaultRolloutPropertiesModel struct {
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState                      `json:"provisioningState,omitempty"`
	Specification     *DefaultRolloutPropertiesSpecification `json:"specification,omitempty"`
	Status            *DefaultRolloutPropertiesStatus        `json:"status,omitempty"`
}

// DefaultRolloutPropertiesSpecification ...
type DefaultRolloutPropertiesSpecification struct {
	Canary                    *DefaultRolloutSpecificationCanary                 `json:"canary,omitempty"`
	LowTraffic                *DefaultRolloutSpecificationLowTraffic             `json:"lowTraffic,omitempty"`
	MediumTraffic             *DefaultRolloutSpecificationMediumTraffic          `json:"mediumTraffic,omitempty"`
	HighTraffic               *DefaultRolloutSpecificationHighTraffic            `json:"highTraffic,omitempty"`
	RestOfTheWorldGroupOne    *DefaultRolloutSpecificationRestOfTheWorldGroupOne `json:"restOfTheWorldGroupOne,omitempty"`
	RestOfTheWorldGroupTwo    *DefaultRolloutSpecificationRestOfTheWorldGroupTwo `json:"restOfTheWorldGroupTwo,omitempty"`
	ProviderRegistration      *DefaultRolloutSpecificationProviderRegistration   `json:"providerRegistration,omitempty"`
	ResourceTypeRegistrations *[]ResourceTypeRegistration                        `json:"resourceTypeRegistrations,omitempty"`
}

// DefaultRolloutPropertiesStatus ...
type DefaultRolloutPropertiesStatus struct {
	// NextTrafficRegion - Possible values include: 'TrafficRegionCategoryNotSpecified', 'TrafficRegionCategoryCanary', 'TrafficRegionCategoryLowTraffic', 'TrafficRegionCategoryMediumTraffic', 'TrafficRegionCategoryHighTraffic', 'TrafficRegionCategoryNone', 'TrafficRegionCategoryRestOfTheWorldGroupOne', 'TrafficRegionCategoryRestOfTheWorldGroupTwo'
	NextTrafficRegion              TrafficRegionCategory `json:"nextTrafficRegion,omitempty"`
	NextTrafficRegionScheduledTime *date.Time            `json:"nextTrafficRegionScheduledTime,omitempty"`
	// SubscriptionReregistrationResult - Possible values include: 'NotApplicable', 'ConditionalUpdate', 'ForcedUpdate', 'Failed'
	SubscriptionReregistrationResult SubscriptionReregistrationResult `json:"subscriptionReregistrationResult,omitempty"`
	CompletedRegions                 *[]string                        `json:"completedRegions,omitempty"`
	FailedOrSkippedRegions           map[string]*ExtendedErrorInfo    `json:"failedOrSkippedRegions"`
}

// MarshalJSON is the custom marshaler for DefaultRolloutPropertiesStatus.
func (drp DefaultRolloutPropertiesStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if drp.NextTrafficRegion != "" {
		objectMap["nextTrafficRegion"] = drp.NextTrafficRegion
	}
	if drp.NextTrafficRegionScheduledTime != nil {
		objectMap["nextTrafficRegionScheduledTime"] = drp.NextTrafficRegionScheduledTime
	}
	if drp.SubscriptionReregistrationResult != "" {
		objectMap["subscriptionReregistrationResult"] = drp.SubscriptionReregistrationResult
	}
	if drp.CompletedRegions != nil {
		objectMap["completedRegions"] = drp.CompletedRegions
	}
	if drp.FailedOrSkippedRegions != nil {
		objectMap["failedOrSkippedRegions"] = drp.FailedOrSkippedRegions
	}
	return json.Marshal(objectMap)
}

// DefaultRolloutsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type DefaultRolloutsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(DefaultRolloutsClient) (DefaultRollout, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *DefaultRolloutsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for DefaultRolloutsCreateOrUpdateFuture.Result.
func (future *DefaultRolloutsCreateOrUpdateFuture) result(client DefaultRolloutsClient) (dr DefaultRollout, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "providerhub.DefaultRolloutsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		dr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("providerhub.DefaultRolloutsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if dr.Response.Response, err = future.GetResult(sender); err == nil && dr.Response.Response.StatusCode != http.StatusNoContent {
		dr, err = client.CreateOrUpdateResponder(dr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "providerhub.DefaultRolloutsCreateOrUpdateFuture", "Result", dr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// DefaultRolloutSpecification ...
type DefaultRolloutSpecification struct {
	Canary                    *DefaultRolloutSpecificationCanary                 `json:"canary,omitempty"`
	LowTraffic                *DefaultRolloutSpecificationLowTraffic             `json:"lowTraffic,omitempty"`
	MediumTraffic             *DefaultRolloutSpecificationMediumTraffic          `json:"mediumTraffic,omitempty"`
	HighTraffic               *DefaultRolloutSpecificationHighTraffic            `json:"highTraffic,omitempty"`
	RestOfTheWorldGroupOne    *DefaultRolloutSpecificationRestOfTheWorldGroupOne `json:"restOfTheWorldGroupOne,omitempty"`
	RestOfTheWorldGroupTwo    *DefaultRolloutSpecificationRestOfTheWorldGroupTwo `json:"restOfTheWorldGroupTwo,omitempty"`
	ProviderRegistration      *DefaultRolloutSpecificationProviderRegistration   `json:"providerRegistration,omitempty"`
	ResourceTypeRegistrations *[]ResourceTypeRegistration                        `json:"resourceTypeRegistrations,omitempty"`
}

// DefaultRolloutSpecificationCanary ...
type DefaultRolloutSpecificationCanary struct {
	SkipRegions *[]string `json:"skipRegions,omitempty"`
	Regions     *[]string `json:"regions,omitempty"`
}

// DefaultRolloutSpecificationHighTraffic ...
type DefaultRolloutSpecificationHighTraffic struct {
	WaitDuration *string   `json:"waitDuration,omitempty"`
	Regions      *[]string `json:"regions,omitempty"`
}

// DefaultRolloutSpecificationLowTraffic ...
type DefaultRolloutSpecificationLowTraffic struct {
	WaitDuration *string   `json:"waitDuration,omitempty"`
	Regions      *[]string `json:"regions,omitempty"`
}

// DefaultRolloutSpecificationMediumTraffic ...
type DefaultRolloutSpecificationMediumTraffic struct {
	WaitDuration *string   `json:"waitDuration,omitempty"`
	Regions      *[]string `json:"regions,omitempty"`
}

// DefaultRolloutSpecificationProviderRegistration ...
type DefaultRolloutSpecificationProviderRegistration struct {
	Properties *ProviderRegistrationPropertiesModel `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for DefaultRolloutSpecificationProviderRegistration.
func (drsR DefaultRolloutSpecificationProviderRegistration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if drsR.Properties != nil {
		objectMap["properties"] = drsR.Properties
	}
	return json.Marshal(objectMap)
}

// DefaultRolloutSpecificationRestOfTheWorldGroupOne ...
type DefaultRolloutSpecificationRestOfTheWorldGroupOne struct {
	WaitDuration *string   `json:"waitDuration,omitempty"`
	Regions      *[]string `json:"regions,omitempty"`
}

// DefaultRolloutSpecificationRestOfTheWorldGroupTwo ...
type DefaultRolloutSpecificationRestOfTheWorldGroupTwo struct {
	WaitDuration *string   `json:"waitDuration,omitempty"`
	Regions      *[]string `json:"regions,omitempty"`
}

// DefaultRolloutStatus ...
type DefaultRolloutStatus struct {
	// NextTrafficRegion - Possible values include: 'TrafficRegionCategoryNotSpecified', 'TrafficRegionCategoryCanary', 'TrafficRegionCategoryLowTraffic', 'TrafficRegionCategoryMediumTraffic', 'TrafficRegionCategoryHighTraffic', 'TrafficRegionCategoryNone', 'TrafficRegionCategoryRestOfTheWorldGroupOne', 'TrafficRegionCategoryRestOfTheWorldGroupTwo'
	NextTrafficRegion              TrafficRegionCategory `json:"nextTrafficRegion,omitempty"`
	NextTrafficRegionScheduledTime *date.Time            `json:"nextTrafficRegionScheduledTime,omitempty"`
	// SubscriptionReregistrationResult - Possible values include: 'NotApplicable', 'ConditionalUpdate', 'ForcedUpdate', 'Failed'
	SubscriptionReregistrationResult SubscriptionReregistrationResult `json:"subscriptionReregistrationResult,omitempty"`
	CompletedRegions                 *[]string                        `json:"completedRegions,omitempty"`
	FailedOrSkippedRegions           map[string]*ExtendedErrorInfo    `json:"failedOrSkippedRegions"`
}

// MarshalJSON is the custom marshaler for DefaultRolloutStatus.
func (drs DefaultRolloutStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if drs.NextTrafficRegion != "" {
		objectMap["nextTrafficRegion"] = drs.NextTrafficRegion
	}
	if drs.NextTrafficRegionScheduledTime != nil {
		objectMap["nextTrafficRegionScheduledTime"] = drs.NextTrafficRegionScheduledTime
	}
	if drs.SubscriptionReregistrationResult != "" {
		objectMap["subscriptionReregistrationResult"] = drs.SubscriptionReregistrationResult
	}
	if drs.CompletedRegions != nil {
		objectMap["completedRegions"] = drs.CompletedRegions
	}
	if drs.FailedOrSkippedRegions != nil {
		objectMap["failedOrSkippedRegions"] = drs.FailedOrSkippedRegions
	}
	return json.Marshal(objectMap)
}

// Error standard error object.
type Error struct {
	// Code - READ-ONLY; Server-defined set of error codes.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Human-readable representation of the error.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Target of the error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; Array of details about specific errors that led to this reported error.
	Details *[]Error `json:"details,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than  the current object about the error.
	InnerError *ErrorInnerError `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorInnerError object containing more specific information than  the current object about the error.
type ErrorInnerError struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Code - READ-ONLY; Specific error code than was provided by the containing error.
	Code *string `json:"code,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than the current object about the error.
	InnerError interface{} `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorInnerError.
func (eE ErrorInnerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	for k, v := range eE.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ErrorInnerError struct.
func (eE *ErrorInnerError) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if eE.AdditionalProperties == nil {
					eE.AdditionalProperties = make(map[string]interface{})
				}
				eE.AdditionalProperties[k] = additionalProperties
			}
		case "code":
			if v != nil {
				var code string
				err = json.Unmarshal(*v, &code)
				if err != nil {
					return err
				}
				eE.Code = &code
			}
		case "innerError":
			if v != nil {
				var innerError interface{}
				err = json.Unmarshal(*v, &innerError)
				if err != nil {
					return err
				}
				eE.InnerError = innerError
			}
		}
	}

	return nil
}

// ErrorResponse standard error response.
type ErrorResponse struct {
	// Error - Standard error object.
	Error *ErrorResponseError `json:"error,omitempty"`
}

// ErrorResponseError standard error object.
type ErrorResponseError struct {
	// Code - READ-ONLY; Server-defined set of error codes.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Human-readable representation of the error.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Target of the error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; Array of details about specific errors that led to this reported error.
	Details *[]Error `json:"details,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than  the current object about the error.
	InnerError *ErrorInnerError `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorResponseError.
func (er ErrorResponseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ExtendedErrorInfo ...
type ExtendedErrorInfo struct {
	Code           *string              `json:"code,omitempty"`
	Target         *string              `json:"target,omitempty"`
	Message        *string              `json:"message,omitempty"`
	Details        *[]ExtendedErrorInfo `json:"details,omitempty"`
	AdditionalInfo *[]TypedErrorInfo    `json:"additionalInfo,omitempty"`
}

// ExtendedLocationOptions ...
type ExtendedLocationOptions struct {
	Type            *string `json:"type,omitempty"`
	SupportedPolicy *string `json:"supportedPolicy,omitempty"`
}

// ExtensionOptions ...
type ExtensionOptions struct {
	Request  *[]ExtensionOptionType `json:"request,omitempty"`
	Response *[]ExtensionOptionType `json:"response,omitempty"`
}

// FeaturesRule ...
type FeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// IdentityManagement ...
type IdentityManagement struct {
	// Type - Possible values include: 'IdentityManagementTypesNotSpecified', 'IdentityManagementTypesSystemAssigned', 'IdentityManagementTypesUserAssigned', 'IdentityManagementTypesActor', 'IdentityManagementTypesDelegatedResourceIdentity'
	Type IdentityManagementTypes `json:"type,omitempty"`
}

// IdentityManagementProperties ...
type IdentityManagementProperties struct {
	// Type - Possible values include: 'IdentityManagementTypesNotSpecified', 'IdentityManagementTypesSystemAssigned', 'IdentityManagementTypesUserAssigned', 'IdentityManagementTypesActor', 'IdentityManagementTypesDelegatedResourceIdentity'
	Type          IdentityManagementTypes `json:"type,omitempty"`
	ApplicationID *string                 `json:"applicationId,omitempty"`
}

// InnerError inner error containing list of errors.
type InnerError struct {
	// AdditionalProperties - Unmatched properties from the message are deserialized this collection
	AdditionalProperties map[string]interface{} `json:""`
	// Code - READ-ONLY; Specific error code than was provided by the containing error.
	Code *string `json:"code,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than the current object about the error.
	InnerError interface{} `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for InnerError.
func (ie InnerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	for k, v := range ie.AdditionalProperties {
		objectMap[k] = v
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for InnerError struct.
func (ie *InnerError) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		default:
			if v != nil {
				var additionalProperties interface{}
				err = json.Unmarshal(*v, &additionalProperties)
				if err != nil {
					return err
				}
				if ie.AdditionalProperties == nil {
					ie.AdditionalProperties = make(map[string]interface{})
				}
				ie.AdditionalProperties[k] = additionalProperties
			}
		case "code":
			if v != nil {
				var code string
				err = json.Unmarshal(*v, &code)
				if err != nil {
					return err
				}
				ie.Code = &code
			}
		case "innerError":
			if v != nil {
				var innerError interface{}
				err = json.Unmarshal(*v, &innerError)
				if err != nil {
					return err
				}
				ie.InnerError = innerError
			}
		}
	}

	return nil
}

// LightHouseAuthorization ...
type LightHouseAuthorization struct {
	PrincipalID      *string `json:"principalId,omitempty"`
	RoleDefinitionID *string `json:"roleDefinitionId,omitempty"`
}

// LinkedAccessCheck ...
type LinkedAccessCheck struct {
	ActionName       *string `json:"actionName,omitempty"`
	LinkedProperty   *string `json:"linkedProperty,omitempty"`
	LinkedAction     *string `json:"linkedAction,omitempty"`
	LinkedActionVerb *string `json:"linkedActionVerb,omitempty"`
	LinkedType       *string `json:"linkedType,omitempty"`
}

// LinkedOperationRule ...
type LinkedOperationRule struct {
	// LinkedOperation - Possible values include: 'None', 'CrossResourceGroupResourceMove', 'CrossSubscriptionResourceMove'
	LinkedOperation LinkedOperation `json:"linkedOperation,omitempty"`
	// LinkedAction - Possible values include: 'LinkedActionNotSpecified', 'LinkedActionBlocked', 'LinkedActionValidate', 'LinkedActionEnabled'
	LinkedAction LinkedAction `json:"linkedAction,omitempty"`
}

// ListOperationsDefinition ...
type ListOperationsDefinition struct {
	autorest.Response `json:"-"`
	Value             *[]OperationsDefinition `json:"value,omitempty"`
}

// LoggingHiddenPropertyPath ...
type LoggingHiddenPropertyPath struct {
	HiddenPathsOnRequest  *[]string `json:"hiddenPathsOnRequest,omitempty"`
	HiddenPathsOnResponse *[]string `json:"hiddenPathsOnResponse,omitempty"`
}

// LoggingRule ...
type LoggingRule struct {
	Action *string `json:"action,omitempty"`
	// Direction - Possible values include: 'LoggingDirectionsNone', 'LoggingDirectionsRequest', 'LoggingDirectionsResponse'
	Direction LoggingDirections `json:"direction,omitempty"`
	// DetailLevel - Possible values include: 'LoggingDetailsNone', 'LoggingDetailsBody'
	DetailLevel         LoggingDetails                  `json:"detailLevel,omitempty"`
	HiddenPropertyPaths *LoggingRuleHiddenPropertyPaths `json:"hiddenPropertyPaths,omitempty"`
}

// LoggingRuleHiddenPropertyPaths ...
type LoggingRuleHiddenPropertyPaths struct {
	HiddenPathsOnRequest  *[]string `json:"hiddenPathsOnRequest,omitempty"`
	HiddenPathsOnResponse *[]string `json:"hiddenPathsOnResponse,omitempty"`
}

// Metadata ...
type Metadata struct {
	ProviderAuthorizations          *[]ResourceProviderAuthorization         `json:"providerAuthorizations,omitempty"`
	ProviderAuthentication          *MetadataProviderAuthentication          `json:"providerAuthentication,omitempty"`
	ThirdPartyProviderAuthorization *MetadataThirdPartyProviderAuthorization `json:"thirdPartyProviderAuthorization,omitempty"`
}

// MetadataProviderAuthentication ...
type MetadataProviderAuthentication struct {
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
}

// MetadataThirdPartyProviderAuthorization ...
type MetadataThirdPartyProviderAuthorization struct {
	Authorizations    *[]LightHouseAuthorization `json:"authorizations,omitempty"`
	ManagedByTenantID *string                    `json:"managedByTenantId,omitempty"`
}

// NotificationEndpoint ...
type NotificationEndpoint struct {
	NotificationDestination *string   `json:"notificationDestination,omitempty"`
	Locations               *[]string `json:"locations,omitempty"`
}

// NotificationRegistration the notification registration definition.
type NotificationRegistration struct {
	autorest.Response `json:"-"`
	Properties        *NotificationRegistrationPropertiesModel `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for NotificationRegistration.
func (nr NotificationRegistration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if nr.Properties != nil {
		objectMap["properties"] = nr.Properties
	}
	return json.Marshal(objectMap)
}

// NotificationRegistrationArrayResponseWithContinuation ...
type NotificationRegistrationArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]NotificationRegistration `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// NotificationRegistrationArrayResponseWithContinuationIterator provides access to a complete listing of
// NotificationRegistration values.
type NotificationRegistrationArrayResponseWithContinuationIterator struct {
	i    int
	page NotificationRegistrationArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *NotificationRegistrationArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NotificationRegistrationArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *NotificationRegistrationArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter NotificationRegistrationArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter NotificationRegistrationArrayResponseWithContinuationIterator) Response() NotificationRegistrationArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter NotificationRegistrationArrayResponseWithContinuationIterator) Value() NotificationRegistration {
	if !iter.page.NotDone() {
		return NotificationRegistration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the NotificationRegistrationArrayResponseWithContinuationIterator type.
func NewNotificationRegistrationArrayResponseWithContinuationIterator(page NotificationRegistrationArrayResponseWithContinuationPage) NotificationRegistrationArrayResponseWithContinuationIterator {
	return NotificationRegistrationArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (nrarwc NotificationRegistrationArrayResponseWithContinuation) IsEmpty() bool {
	return nrarwc.Value == nil || len(*nrarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (nrarwc NotificationRegistrationArrayResponseWithContinuation) hasNextLink() bool {
	return nrarwc.NextLink != nil && len(*nrarwc.NextLink) != 0
}

// notificationRegistrationArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (nrarwc NotificationRegistrationArrayResponseWithContinuation) notificationRegistrationArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !nrarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(nrarwc.NextLink)))
}

// NotificationRegistrationArrayResponseWithContinuationPage contains a page of NotificationRegistration
// values.
type NotificationRegistrationArrayResponseWithContinuationPage struct {
	fn     func(context.Context, NotificationRegistrationArrayResponseWithContinuation) (NotificationRegistrationArrayResponseWithContinuation, error)
	nrarwc NotificationRegistrationArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *NotificationRegistrationArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NotificationRegistrationArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.nrarwc)
		if err != nil {
			return err
		}
		page.nrarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *NotificationRegistrationArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page NotificationRegistrationArrayResponseWithContinuationPage) NotDone() bool {
	return !page.nrarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page NotificationRegistrationArrayResponseWithContinuationPage) Response() NotificationRegistrationArrayResponseWithContinuation {
	return page.nrarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page NotificationRegistrationArrayResponseWithContinuationPage) Values() []NotificationRegistration {
	if page.nrarwc.IsEmpty() {
		return nil
	}
	return *page.nrarwc.Value
}

// Creates a new instance of the NotificationRegistrationArrayResponseWithContinuationPage type.
func NewNotificationRegistrationArrayResponseWithContinuationPage(cur NotificationRegistrationArrayResponseWithContinuation, getNextPage func(context.Context, NotificationRegistrationArrayResponseWithContinuation) (NotificationRegistrationArrayResponseWithContinuation, error)) NotificationRegistrationArrayResponseWithContinuationPage {
	return NotificationRegistrationArrayResponseWithContinuationPage{
		fn:     getNextPage,
		nrarwc: cur,
	}
}

// NotificationRegistrationProperties ...
type NotificationRegistrationProperties struct {
	// NotificationMode - Possible values include: 'NotificationModeNotSpecified', 'NotificationModeEventHub', 'NotificationModeWebHook'
	NotificationMode NotificationMode `json:"notificationMode,omitempty"`
	// MessageScope - Possible values include: 'MessageScopeNotSpecified', 'MessageScopeRegisteredSubscriptions'
	MessageScope          MessageScope            `json:"messageScope,omitempty"`
	IncludedEvents        *[]string               `json:"includedEvents,omitempty"`
	NotificationEndpoints *[]NotificationEndpoint `json:"notificationEndpoints,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// NotificationRegistrationPropertiesModel ...
type NotificationRegistrationPropertiesModel struct {
	// NotificationMode - Possible values include: 'NotificationModeNotSpecified', 'NotificationModeEventHub', 'NotificationModeWebHook'
	NotificationMode NotificationMode `json:"notificationMode,omitempty"`
	// MessageScope - Possible values include: 'MessageScopeNotSpecified', 'MessageScopeRegisteredSubscriptions'
	MessageScope          MessageScope            `json:"messageScope,omitempty"`
	IncludedEvents        *[]string               `json:"includedEvents,omitempty"`
	NotificationEndpoints *[]NotificationEndpoint `json:"notificationEndpoints,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// OperationsContent ...
type OperationsContent struct {
	autorest.Response `json:"-"`
	// OperationsDefinition - Operations content.
	*OperationsDefinition `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationsContent.
func (oc OperationsContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oc.OperationsDefinition != nil {
		objectMap["properties"] = oc.OperationsDefinition
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OperationsContent struct.
func (oc *OperationsContent) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var operationsDefinition OperationsDefinition
				err = json.Unmarshal(*v, &operationsDefinition)
				if err != nil {
					return err
				}
				oc.OperationsDefinition = &operationsDefinition
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				oc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				oc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				oc.Type = &typeVar
			}
		}
	}

	return nil
}

// OperationsDefinition properties of an Operation.
type OperationsDefinition struct {
	// Name - Name of the operation.
	Name *string `json:"name,omitempty"`
	// IsDataAction - Indicates whether the operation applies to data-plane.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Origin - Possible values include: 'OriginNotSpecified', 'OriginUser', 'OriginSystem'
	Origin Origin `json:"origin,omitempty"`
	// Display - Display information of the operation.
	Display *OperationsDefinitionDisplay `json:"display,omitempty"`
	// ActionType - Possible values include: 'NotSpecified', 'Internal'
	ActionType ActionType  `json:"actionType,omitempty"`
	Properties interface{} `json:"properties,omitempty"`
}

// OperationsDefinitionArrayResponseWithContinuation ...
type OperationsDefinitionArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]OperationsDefinition `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// OperationsDefinitionArrayResponseWithContinuationIterator provides access to a complete listing of
// OperationsDefinition values.
type OperationsDefinitionArrayResponseWithContinuationIterator struct {
	i    int
	page OperationsDefinitionArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationsDefinitionArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsDefinitionArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationsDefinitionArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationsDefinitionArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationsDefinitionArrayResponseWithContinuationIterator) Response() OperationsDefinitionArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationsDefinitionArrayResponseWithContinuationIterator) Value() OperationsDefinition {
	if !iter.page.NotDone() {
		return OperationsDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationsDefinitionArrayResponseWithContinuationIterator type.
func NewOperationsDefinitionArrayResponseWithContinuationIterator(page OperationsDefinitionArrayResponseWithContinuationPage) OperationsDefinitionArrayResponseWithContinuationIterator {
	return OperationsDefinitionArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (odarwc OperationsDefinitionArrayResponseWithContinuation) IsEmpty() bool {
	return odarwc.Value == nil || len(*odarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (odarwc OperationsDefinitionArrayResponseWithContinuation) hasNextLink() bool {
	return odarwc.NextLink != nil && len(*odarwc.NextLink) != 0
}

// operationsDefinitionArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (odarwc OperationsDefinitionArrayResponseWithContinuation) operationsDefinitionArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !odarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(odarwc.NextLink)))
}

// OperationsDefinitionArrayResponseWithContinuationPage contains a page of OperationsDefinition values.
type OperationsDefinitionArrayResponseWithContinuationPage struct {
	fn     func(context.Context, OperationsDefinitionArrayResponseWithContinuation) (OperationsDefinitionArrayResponseWithContinuation, error)
	odarwc OperationsDefinitionArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationsDefinitionArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationsDefinitionArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.odarwc)
		if err != nil {
			return err
		}
		page.odarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationsDefinitionArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationsDefinitionArrayResponseWithContinuationPage) NotDone() bool {
	return !page.odarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationsDefinitionArrayResponseWithContinuationPage) Response() OperationsDefinitionArrayResponseWithContinuation {
	return page.odarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationsDefinitionArrayResponseWithContinuationPage) Values() []OperationsDefinition {
	if page.odarwc.IsEmpty() {
		return nil
	}
	return *page.odarwc.Value
}

// Creates a new instance of the OperationsDefinitionArrayResponseWithContinuationPage type.
func NewOperationsDefinitionArrayResponseWithContinuationPage(cur OperationsDefinitionArrayResponseWithContinuation, getNextPage func(context.Context, OperationsDefinitionArrayResponseWithContinuation) (OperationsDefinitionArrayResponseWithContinuation, error)) OperationsDefinitionArrayResponseWithContinuationPage {
	return OperationsDefinitionArrayResponseWithContinuationPage{
		fn:     getNextPage,
		odarwc: cur,
	}
}

// OperationsDefinitionDisplay display information of the operation.
type OperationsDefinitionDisplay struct {
	Provider    *string `json:"provider,omitempty"`
	Resource    *string `json:"resource,omitempty"`
	Operation   *string `json:"operation,omitempty"`
	Description *string `json:"description,omitempty"`
}

// OperationsDisplayDefinition ...
type OperationsDisplayDefinition struct {
	Provider    *string `json:"provider,omitempty"`
	Resource    *string `json:"resource,omitempty"`
	Operation   *string `json:"operation,omitempty"`
	Description *string `json:"description,omitempty"`
}

// OperationsPutContent ...
type OperationsPutContent struct {
	Contents *[]OperationsDefinition `json:"contents,omitempty"`
}

// ProviderRegistration ...
type ProviderRegistration struct {
	autorest.Response `json:"-"`
	Properties        *ProviderRegistrationPropertiesModel `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProviderRegistration.
func (pr ProviderRegistration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.Properties != nil {
		objectMap["properties"] = pr.Properties
	}
	return json.Marshal(objectMap)
}

// ProviderRegistrationArrayResponseWithContinuation ...
type ProviderRegistrationArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]ProviderRegistration `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ProviderRegistrationArrayResponseWithContinuationIterator provides access to a complete listing of
// ProviderRegistration values.
type ProviderRegistrationArrayResponseWithContinuationIterator struct {
	i    int
	page ProviderRegistrationArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProviderRegistrationArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderRegistrationArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProviderRegistrationArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProviderRegistrationArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProviderRegistrationArrayResponseWithContinuationIterator) Response() ProviderRegistrationArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProviderRegistrationArrayResponseWithContinuationIterator) Value() ProviderRegistration {
	if !iter.page.NotDone() {
		return ProviderRegistration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProviderRegistrationArrayResponseWithContinuationIterator type.
func NewProviderRegistrationArrayResponseWithContinuationIterator(page ProviderRegistrationArrayResponseWithContinuationPage) ProviderRegistrationArrayResponseWithContinuationIterator {
	return ProviderRegistrationArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (prarwc ProviderRegistrationArrayResponseWithContinuation) IsEmpty() bool {
	return prarwc.Value == nil || len(*prarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (prarwc ProviderRegistrationArrayResponseWithContinuation) hasNextLink() bool {
	return prarwc.NextLink != nil && len(*prarwc.NextLink) != 0
}

// providerRegistrationArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (prarwc ProviderRegistrationArrayResponseWithContinuation) providerRegistrationArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !prarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(prarwc.NextLink)))
}

// ProviderRegistrationArrayResponseWithContinuationPage contains a page of ProviderRegistration values.
type ProviderRegistrationArrayResponseWithContinuationPage struct {
	fn     func(context.Context, ProviderRegistrationArrayResponseWithContinuation) (ProviderRegistrationArrayResponseWithContinuation, error)
	prarwc ProviderRegistrationArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProviderRegistrationArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderRegistrationArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.prarwc)
		if err != nil {
			return err
		}
		page.prarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProviderRegistrationArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProviderRegistrationArrayResponseWithContinuationPage) NotDone() bool {
	return !page.prarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProviderRegistrationArrayResponseWithContinuationPage) Response() ProviderRegistrationArrayResponseWithContinuation {
	return page.prarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProviderRegistrationArrayResponseWithContinuationPage) Values() []ProviderRegistration {
	if page.prarwc.IsEmpty() {
		return nil
	}
	return *page.prarwc.Value
}

// Creates a new instance of the ProviderRegistrationArrayResponseWithContinuationPage type.
func NewProviderRegistrationArrayResponseWithContinuationPage(cur ProviderRegistrationArrayResponseWithContinuation, getNextPage func(context.Context, ProviderRegistrationArrayResponseWithContinuation) (ProviderRegistrationArrayResponseWithContinuation, error)) ProviderRegistrationArrayResponseWithContinuationPage {
	return ProviderRegistrationArrayResponseWithContinuationPage{
		fn:     getNextPage,
		prarwc: cur,
	}
}

// ProviderRegistrationProperties ...
type ProviderRegistrationProperties struct {
	ProviderHubMetadata *ProviderRegistrationPropertiesProviderHubMetadata `json:"providerHubMetadata,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState                               ProvisioningState                                                              `json:"provisioningState,omitempty"`
	SubscriptionLifecycleNotificationSpecifications *ProviderRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications `json:"subscriptionLifecycleNotificationSpecifications,omitempty"`
	ProviderAuthentication                          *ResourceProviderManifestPropertiesProviderAuthentication                      `json:"providerAuthentication,omitempty"`
	ProviderAuthorizations                          *[]ResourceProviderAuthorization                                               `json:"providerAuthorizations,omitempty"`
	Namespace                                       *string                                                                        `json:"namespace,omitempty"`
	ProviderVersion                                 *string                                                                        `json:"providerVersion,omitempty"`
	// ProviderType - Possible values include: 'ResourceProviderTypeNotSpecified', 'ResourceProviderTypeInternal', 'ResourceProviderTypeExternal', 'ResourceProviderTypeHidden', 'ResourceProviderTypeRegistrationFree', 'ResourceProviderTypeLegacyRegistrationRequired', 'ResourceProviderTypeTenantOnly', 'ResourceProviderTypeAuthorizationFree'
	ProviderType              ResourceProviderType                                         `json:"providerType,omitempty"`
	RequiredFeatures          *[]string                                                    `json:"requiredFeatures,omitempty"`
	FeaturesRule              *ResourceProviderManifestPropertiesFeaturesRule              `json:"featuresRule,omitempty"`
	RequestHeaderOptions      *ResourceProviderManifestPropertiesRequestHeaderOptions      `json:"requestHeaderOptions,omitempty"`
	Management                *ResourceProviderManifestPropertiesManagement                `json:"management,omitempty"`
	Capabilities              *[]ResourceProviderCapabilities                              `json:"capabilities,omitempty"`
	Metadata                  interface{}                                                  `json:"metadata,omitempty"`
	TemplateDeploymentOptions *ResourceProviderManifestPropertiesTemplateDeploymentOptions `json:"templateDeploymentOptions,omitempty"`
}

// ProviderRegistrationPropertiesModel ...
type ProviderRegistrationPropertiesModel struct {
	ProviderHubMetadata *ProviderRegistrationPropertiesProviderHubMetadata `json:"providerHubMetadata,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState                               ProvisioningState                                                              `json:"provisioningState,omitempty"`
	SubscriptionLifecycleNotificationSpecifications *ProviderRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications `json:"subscriptionLifecycleNotificationSpecifications,omitempty"`
	ProviderAuthentication                          *ResourceProviderManifestPropertiesProviderAuthentication                      `json:"providerAuthentication,omitempty"`
	ProviderAuthorizations                          *[]ResourceProviderAuthorization                                               `json:"providerAuthorizations,omitempty"`
	Namespace                                       *string                                                                        `json:"namespace,omitempty"`
	ProviderVersion                                 *string                                                                        `json:"providerVersion,omitempty"`
	// ProviderType - Possible values include: 'ResourceProviderTypeNotSpecified', 'ResourceProviderTypeInternal', 'ResourceProviderTypeExternal', 'ResourceProviderTypeHidden', 'ResourceProviderTypeRegistrationFree', 'ResourceProviderTypeLegacyRegistrationRequired', 'ResourceProviderTypeTenantOnly', 'ResourceProviderTypeAuthorizationFree'
	ProviderType              ResourceProviderType                                         `json:"providerType,omitempty"`
	RequiredFeatures          *[]string                                                    `json:"requiredFeatures,omitempty"`
	FeaturesRule              *ResourceProviderManifestPropertiesFeaturesRule              `json:"featuresRule,omitempty"`
	RequestHeaderOptions      *ResourceProviderManifestPropertiesRequestHeaderOptions      `json:"requestHeaderOptions,omitempty"`
	Management                *ResourceProviderManifestPropertiesManagement                `json:"management,omitempty"`
	Capabilities              *[]ResourceProviderCapabilities                              `json:"capabilities,omitempty"`
	Metadata                  interface{}                                                  `json:"metadata,omitempty"`
	TemplateDeploymentOptions *ResourceProviderManifestPropertiesTemplateDeploymentOptions `json:"templateDeploymentOptions,omitempty"`
}

// ProviderRegistrationPropertiesProviderHubMetadata ...
type ProviderRegistrationPropertiesProviderHubMetadata struct {
	ProviderAuthorizations          *[]ResourceProviderAuthorization         `json:"providerAuthorizations,omitempty"`
	ProviderAuthentication          *MetadataProviderAuthentication          `json:"providerAuthentication,omitempty"`
	ThirdPartyProviderAuthorization *MetadataThirdPartyProviderAuthorization `json:"thirdPartyProviderAuthorization,omitempty"`
}

// ProviderRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications ...
type ProviderRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications struct {
	SubscriptionStateOverrideActions *[]SubscriptionStateOverrideAction `json:"subscriptionStateOverrideActions,omitempty"`
	SoftDeleteTTL                    *string                            `json:"softDeleteTTL,omitempty"`
}

// ProviderRegistrationsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ProviderRegistrationsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProviderRegistrationsClient) (ProviderRegistration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProviderRegistrationsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProviderRegistrationsCreateOrUpdateFuture.Result.
func (future *ProviderRegistrationsCreateOrUpdateFuture) result(client ProviderRegistrationsClient) (pr ProviderRegistration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "providerhub.ProviderRegistrationsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("providerhub.ProviderRegistrationsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pr.Response.Response, err = future.GetResult(sender); err == nil && pr.Response.Response.StatusCode != http.StatusNoContent {
		pr, err = client.CreateOrUpdateResponder(pr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "providerhub.ProviderRegistrationsCreateOrUpdateFuture", "Result", pr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// RequestHeaderOptions ...
type RequestHeaderOptions struct {
	// OptInHeaders - Possible values include: 'OptInHeaderTypeNotSpecified', 'OptInHeaderTypeSignedUserToken', 'OptInHeaderTypeClientGroupMembership', 'OptInHeaderTypeSignedAuxiliaryTokens', 'OptInHeaderTypeUnboundedClientGroupMembership'
	OptInHeaders OptInHeaderType `json:"optInHeaders,omitempty"`
}

// ReRegisterSubscriptionMetadata ...
type ReRegisterSubscriptionMetadata struct {
	Enabled          *bool  `json:"enabled,omitempty"`
	ConcurrencyLimit *int32 `json:"concurrencyLimit,omitempty"`
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceMovePolicy ...
type ResourceMovePolicy struct {
	ValidationRequired            *bool `json:"validationRequired,omitempty"`
	CrossResourceGroupMoveEnabled *bool `json:"crossResourceGroupMoveEnabled,omitempty"`
	CrossSubscriptionMoveEnabled  *bool `json:"crossSubscriptionMoveEnabled,omitempty"`
}

// ResourceProviderAuthentication ...
type ResourceProviderAuthentication struct {
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
}

// ResourceProviderAuthorization ...
type ResourceProviderAuthorization struct {
	ApplicationID             *string `json:"applicationId,omitempty"`
	RoleDefinitionID          *string `json:"roleDefinitionId,omitempty"`
	ManagedByRoleDefinitionID *string `json:"managedByRoleDefinitionId,omitempty"`
}

// ResourceProviderCapabilities ...
type ResourceProviderCapabilities struct {
	QuotaID *string `json:"quotaId,omitempty"`
	// Effect - Possible values include: 'ResourceProviderCapabilitiesEffectNotSpecified', 'ResourceProviderCapabilitiesEffectAllow', 'ResourceProviderCapabilitiesEffectDisallow'
	Effect           ResourceProviderCapabilitiesEffect `json:"effect,omitempty"`
	RequiredFeatures *[]string                          `json:"requiredFeatures,omitempty"`
}

// ResourceProviderEndpoint ...
type ResourceProviderEndpoint struct {
	Enabled          *bool                                 `json:"enabled,omitempty"`
	APIVersions      *[]string                             `json:"apiVersions,omitempty"`
	EndpointURI      *string                               `json:"endpointUri,omitempty"`
	Locations        *[]string                             `json:"locations,omitempty"`
	RequiredFeatures *[]string                             `json:"requiredFeatures,omitempty"`
	FeaturesRule     *ResourceProviderEndpointFeaturesRule `json:"featuresRule,omitempty"`
	Timeout          *string                               `json:"timeout,omitempty"`
}

// ResourceProviderEndpointFeaturesRule ...
type ResourceProviderEndpointFeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// ResourceProviderManagement ...
type ResourceProviderManagement struct {
	SchemaOwners           *[]string          `json:"schemaOwners,omitempty"`
	ManifestOwners         *[]string          `json:"manifestOwners,omitempty"`
	IncidentRoutingService *string            `json:"incidentRoutingService,omitempty"`
	IncidentRoutingTeam    *string            `json:"incidentRoutingTeam,omitempty"`
	IncidentContactEmail   *string            `json:"incidentContactEmail,omitempty"`
	ServiceTreeInfos       *[]ServiceTreeInfo `json:"serviceTreeInfos,omitempty"`
	// ResourceAccessPolicy - Possible values include: 'ResourceAccessPolicyNotSpecified', 'ResourceAccessPolicyAcisReadAllowed', 'ResourceAccessPolicyAcisActionAllowed'
	ResourceAccessPolicy ResourceAccessPolicy `json:"resourceAccessPolicy,omitempty"`
	ResourceAccessRoles  *[]interface{}       `json:"resourceAccessRoles,omitempty"`
}

// ResourceProviderManifest ...
type ResourceProviderManifest struct {
	autorest.Response      `json:"-"`
	ProviderAuthentication *ResourceProviderManifestProviderAuthentication `json:"providerAuthentication,omitempty"`
	ProviderAuthorizations *[]ResourceProviderAuthorization                `json:"providerAuthorizations,omitempty"`
	Namespace              *string                                         `json:"namespace,omitempty"`
	ProviderVersion        *string                                         `json:"providerVersion,omitempty"`
	// ProviderType - Possible values include: 'ResourceProviderTypeNotSpecified', 'ResourceProviderTypeInternal', 'ResourceProviderTypeExternal', 'ResourceProviderTypeHidden', 'ResourceProviderTypeRegistrationFree', 'ResourceProviderTypeLegacyRegistrationRequired', 'ResourceProviderTypeTenantOnly', 'ResourceProviderTypeAuthorizationFree'
	ProviderType                   ResourceProviderType                                    `json:"providerType,omitempty"`
	RequiredFeatures               *[]string                                               `json:"requiredFeatures,omitempty"`
	FeaturesRule                   *ResourceProviderManifestFeaturesRule                   `json:"featuresRule,omitempty"`
	RequestHeaderOptions           *ResourceProviderManifestRequestHeaderOptions           `json:"requestHeaderOptions,omitempty"`
	ResourceTypes                  *[]ResourceType                                         `json:"resourceTypes,omitempty"`
	Management                     *ResourceProviderManifestManagement                     `json:"management,omitempty"`
	Capabilities                   *[]ResourceProviderCapabilities                         `json:"capabilities,omitempty"`
	Metadata                       interface{}                                             `json:"metadata,omitempty"`
	GlobalNotificationEndpoints    *[]ResourceProviderEndpoint                             `json:"globalNotificationEndpoints,omitempty"`
	ReRegisterSubscriptionMetadata *ResourceProviderManifestReRegisterSubscriptionMetadata `json:"reRegisterSubscriptionMetadata,omitempty"`
}

// ResourceProviderManifestFeaturesRule ...
type ResourceProviderManifestFeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// ResourceProviderManifestManagement ...
type ResourceProviderManifestManagement struct {
	SchemaOwners           *[]string          `json:"schemaOwners,omitempty"`
	ManifestOwners         *[]string          `json:"manifestOwners,omitempty"`
	IncidentRoutingService *string            `json:"incidentRoutingService,omitempty"`
	IncidentRoutingTeam    *string            `json:"incidentRoutingTeam,omitempty"`
	IncidentContactEmail   *string            `json:"incidentContactEmail,omitempty"`
	ServiceTreeInfos       *[]ServiceTreeInfo `json:"serviceTreeInfos,omitempty"`
	// ResourceAccessPolicy - Possible values include: 'ResourceAccessPolicyNotSpecified', 'ResourceAccessPolicyAcisReadAllowed', 'ResourceAccessPolicyAcisActionAllowed'
	ResourceAccessPolicy ResourceAccessPolicy `json:"resourceAccessPolicy,omitempty"`
	ResourceAccessRoles  *[]interface{}       `json:"resourceAccessRoles,omitempty"`
}

// ResourceProviderManifestProperties ...
type ResourceProviderManifestProperties struct {
	ProviderAuthentication *ResourceProviderManifestPropertiesProviderAuthentication `json:"providerAuthentication,omitempty"`
	ProviderAuthorizations *[]ResourceProviderAuthorization                          `json:"providerAuthorizations,omitempty"`
	Namespace              *string                                                   `json:"namespace,omitempty"`
	ProviderVersion        *string                                                   `json:"providerVersion,omitempty"`
	// ProviderType - Possible values include: 'ResourceProviderTypeNotSpecified', 'ResourceProviderTypeInternal', 'ResourceProviderTypeExternal', 'ResourceProviderTypeHidden', 'ResourceProviderTypeRegistrationFree', 'ResourceProviderTypeLegacyRegistrationRequired', 'ResourceProviderTypeTenantOnly', 'ResourceProviderTypeAuthorizationFree'
	ProviderType              ResourceProviderType                                         `json:"providerType,omitempty"`
	RequiredFeatures          *[]string                                                    `json:"requiredFeatures,omitempty"`
	FeaturesRule              *ResourceProviderManifestPropertiesFeaturesRule              `json:"featuresRule,omitempty"`
	RequestHeaderOptions      *ResourceProviderManifestPropertiesRequestHeaderOptions      `json:"requestHeaderOptions,omitempty"`
	Management                *ResourceProviderManifestPropertiesManagement                `json:"management,omitempty"`
	Capabilities              *[]ResourceProviderCapabilities                              `json:"capabilities,omitempty"`
	Metadata                  interface{}                                                  `json:"metadata,omitempty"`
	TemplateDeploymentOptions *ResourceProviderManifestPropertiesTemplateDeploymentOptions `json:"templateDeploymentOptions,omitempty"`
}

// ResourceProviderManifestPropertiesFeaturesRule ...
type ResourceProviderManifestPropertiesFeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// ResourceProviderManifestPropertiesManagement ...
type ResourceProviderManifestPropertiesManagement struct {
	SchemaOwners           *[]string          `json:"schemaOwners,omitempty"`
	ManifestOwners         *[]string          `json:"manifestOwners,omitempty"`
	IncidentRoutingService *string            `json:"incidentRoutingService,omitempty"`
	IncidentRoutingTeam    *string            `json:"incidentRoutingTeam,omitempty"`
	IncidentContactEmail   *string            `json:"incidentContactEmail,omitempty"`
	ServiceTreeInfos       *[]ServiceTreeInfo `json:"serviceTreeInfos,omitempty"`
	// ResourceAccessPolicy - Possible values include: 'ResourceAccessPolicyNotSpecified', 'ResourceAccessPolicyAcisReadAllowed', 'ResourceAccessPolicyAcisActionAllowed'
	ResourceAccessPolicy ResourceAccessPolicy `json:"resourceAccessPolicy,omitempty"`
	ResourceAccessRoles  *[]interface{}       `json:"resourceAccessRoles,omitempty"`
}

// ResourceProviderManifestPropertiesProviderAuthentication ...
type ResourceProviderManifestPropertiesProviderAuthentication struct {
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
}

// ResourceProviderManifestPropertiesRequestHeaderOptions ...
type ResourceProviderManifestPropertiesRequestHeaderOptions struct {
	// OptInHeaders - Possible values include: 'OptInHeaderTypeNotSpecified', 'OptInHeaderTypeSignedUserToken', 'OptInHeaderTypeClientGroupMembership', 'OptInHeaderTypeSignedAuxiliaryTokens', 'OptInHeaderTypeUnboundedClientGroupMembership'
	OptInHeaders OptInHeaderType `json:"optInHeaders,omitempty"`
}

// ResourceProviderManifestPropertiesTemplateDeploymentOptions ...
type ResourceProviderManifestPropertiesTemplateDeploymentOptions struct {
	PreflightSupported *bool              `json:"preflightSupported,omitempty"`
	PreflightOptions   *[]PreflightOption `json:"preflightOptions,omitempty"`
}

// ResourceProviderManifestProviderAuthentication ...
type ResourceProviderManifestProviderAuthentication struct {
	AllowedAudiences *[]string `json:"allowedAudiences,omitempty"`
}

// ResourceProviderManifestRequestHeaderOptions ...
type ResourceProviderManifestRequestHeaderOptions struct {
	// OptInHeaders - Possible values include: 'OptInHeaderTypeNotSpecified', 'OptInHeaderTypeSignedUserToken', 'OptInHeaderTypeClientGroupMembership', 'OptInHeaderTypeSignedAuxiliaryTokens', 'OptInHeaderTypeUnboundedClientGroupMembership'
	OptInHeaders OptInHeaderType `json:"optInHeaders,omitempty"`
}

// ResourceProviderManifestReRegisterSubscriptionMetadata ...
type ResourceProviderManifestReRegisterSubscriptionMetadata struct {
	Enabled          *bool  `json:"enabled,omitempty"`
	ConcurrencyLimit *int32 `json:"concurrencyLimit,omitempty"`
}

// ResourceType ...
type ResourceType struct {
	Name *string `json:"name,omitempty"`
	// RoutingType - Possible values include: 'Default', 'ProxyOnly', 'HostBased', 'Extension', 'Tenant', 'Fanout', 'LocationBased', 'Failover', 'CascadeExtension'
	RoutingType RoutingType `json:"routingType,omitempty"`
	// ResourceValidation - Possible values include: 'ResourceValidationNotSpecified', 'ResourceValidationReservedWords', 'ResourceValidationProfaneWords'
	ResourceValidation          ResourceValidation            `json:"resourceValidation,omitempty"`
	AllowedUnauthorizedActions  *[]string                     `json:"allowedUnauthorizedActions,omitempty"`
	AuthorizationActionMappings *[]AuthorizationActionMapping `json:"authorizationActionMappings,omitempty"`
	LinkedAccessChecks          *[]LinkedAccessCheck          `json:"linkedAccessChecks,omitempty"`
	DefaultAPIVersion           *string                       `json:"defaultApiVersion,omitempty"`
	LoggingRules                *[]LoggingRule                `json:"loggingRules,omitempty"`
	ThrottlingRules             *[]ThrottlingRule             `json:"throttlingRules,omitempty"`
	Endpoints                   *[]ResourceProviderEndpoint   `json:"endpoints,omitempty"`
	// MarketplaceType - Possible values include: 'MarketplaceTypeNotSpecified', 'MarketplaceTypeAddOn', 'MarketplaceTypeBypass', 'MarketplaceTypeStore'
	MarketplaceType          MarketplaceType                       `json:"marketplaceType,omitempty"`
	IdentityManagement       *ResourceTypeIdentityManagement       `json:"identityManagement,omitempty"`
	Metadata                 interface{}                           `json:"metadata,omitempty"`
	RequiredFeatures         *[]string                             `json:"requiredFeatures,omitempty"`
	FeaturesRule             *ResourceTypeFeaturesRule             `json:"featuresRule,omitempty"`
	SubscriptionStateRules   *[]SubscriptionStateRule              `json:"subscriptionStateRules,omitempty"`
	ServiceTreeInfos         *[]ServiceTreeInfo                    `json:"serviceTreeInfos,omitempty"`
	RequestHeaderOptions     *ResourceTypeRequestHeaderOptions     `json:"requestHeaderOptions,omitempty"`
	SkuLink                  *string                               `json:"skuLink,omitempty"`
	DisallowedActionVerbs    *[]string                             `json:"disallowedActionVerbs,omitempty"`
	TemplateDeploymentPolicy *ResourceTypeTemplateDeploymentPolicy `json:"templateDeploymentPolicy,omitempty"`
	ExtendedLocations        *[]ExtendedLocationOptions            `json:"extendedLocations,omitempty"`
	LinkedOperationRules     *[]LinkedOperationRule                `json:"linkedOperationRules,omitempty"`
	// ResourceDeletionPolicy - Possible values include: 'ManifestResourceDeletionPolicyNotSpecified', 'ManifestResourceDeletionPolicyCascade', 'ManifestResourceDeletionPolicyForce'
	ResourceDeletionPolicy ManifestResourceDeletionPolicy `json:"resourceDeletionPolicy,omitempty"`
}

// ResourceTypeEndpoint ...
type ResourceTypeEndpoint struct {
	Enabled          *bool                             `json:"enabled,omitempty"`
	APIVersions      *[]string                         `json:"apiVersions,omitempty"`
	Locations        *[]string                         `json:"locations,omitempty"`
	RequiredFeatures *[]string                         `json:"requiredFeatures,omitempty"`
	FeaturesRule     *ResourceTypeEndpointFeaturesRule `json:"featuresRule,omitempty"`
	Extensions       *[]ResourceTypeExtension          `json:"extensions,omitempty"`
	Timeout          *string                           `json:"timeout,omitempty"`
}

// ResourceTypeEndpointFeaturesRule ...
type ResourceTypeEndpointFeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// ResourceTypeExtension ...
type ResourceTypeExtension struct {
	EndpointURI         *string              `json:"endpointUri,omitempty"`
	ExtensionCategories *[]ExtensionCategory `json:"extensionCategories,omitempty"`
	Timeout             *string              `json:"timeout,omitempty"`
}

// ResourceTypeExtensionOptions ...
type ResourceTypeExtensionOptions struct {
	ResourceCreationBegin *ResourceTypeExtensionOptionsResourceCreationBegin `json:"resourceCreationBegin,omitempty"`
}

// ResourceTypeExtensionOptionsResourceCreationBegin ...
type ResourceTypeExtensionOptionsResourceCreationBegin struct {
	Request  *[]ExtensionOptionType `json:"request,omitempty"`
	Response *[]ExtensionOptionType `json:"response,omitempty"`
}

// ResourceTypeFeaturesRule ...
type ResourceTypeFeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// ResourceTypeIdentityManagement ...
type ResourceTypeIdentityManagement struct {
	// Type - Possible values include: 'IdentityManagementTypesNotSpecified', 'IdentityManagementTypesSystemAssigned', 'IdentityManagementTypesUserAssigned', 'IdentityManagementTypesActor', 'IdentityManagementTypesDelegatedResourceIdentity'
	Type IdentityManagementTypes `json:"type,omitempty"`
}

// ResourceTypeRegistration ...
type ResourceTypeRegistration struct {
	autorest.Response `json:"-"`
	Properties        *ResourceTypeRegistrationProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceTypeRegistration.
func (rtr ResourceTypeRegistration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rtr.Properties != nil {
		objectMap["properties"] = rtr.Properties
	}
	return json.Marshal(objectMap)
}

// ResourceTypeRegistrationArrayResponseWithContinuation ...
type ResourceTypeRegistrationArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]ResourceTypeRegistration `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// ResourceTypeRegistrationArrayResponseWithContinuationIterator provides access to a complete listing of
// ResourceTypeRegistration values.
type ResourceTypeRegistrationArrayResponseWithContinuationIterator struct {
	i    int
	page ResourceTypeRegistrationArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ResourceTypeRegistrationArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceTypeRegistrationArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ResourceTypeRegistrationArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ResourceTypeRegistrationArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ResourceTypeRegistrationArrayResponseWithContinuationIterator) Response() ResourceTypeRegistrationArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ResourceTypeRegistrationArrayResponseWithContinuationIterator) Value() ResourceTypeRegistration {
	if !iter.page.NotDone() {
		return ResourceTypeRegistration{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ResourceTypeRegistrationArrayResponseWithContinuationIterator type.
func NewResourceTypeRegistrationArrayResponseWithContinuationIterator(page ResourceTypeRegistrationArrayResponseWithContinuationPage) ResourceTypeRegistrationArrayResponseWithContinuationIterator {
	return ResourceTypeRegistrationArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (rtrarwc ResourceTypeRegistrationArrayResponseWithContinuation) IsEmpty() bool {
	return rtrarwc.Value == nil || len(*rtrarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (rtrarwc ResourceTypeRegistrationArrayResponseWithContinuation) hasNextLink() bool {
	return rtrarwc.NextLink != nil && len(*rtrarwc.NextLink) != 0
}

// resourceTypeRegistrationArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (rtrarwc ResourceTypeRegistrationArrayResponseWithContinuation) resourceTypeRegistrationArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !rtrarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(rtrarwc.NextLink)))
}

// ResourceTypeRegistrationArrayResponseWithContinuationPage contains a page of ResourceTypeRegistration
// values.
type ResourceTypeRegistrationArrayResponseWithContinuationPage struct {
	fn      func(context.Context, ResourceTypeRegistrationArrayResponseWithContinuation) (ResourceTypeRegistrationArrayResponseWithContinuation, error)
	rtrarwc ResourceTypeRegistrationArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ResourceTypeRegistrationArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ResourceTypeRegistrationArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.rtrarwc)
		if err != nil {
			return err
		}
		page.rtrarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ResourceTypeRegistrationArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ResourceTypeRegistrationArrayResponseWithContinuationPage) NotDone() bool {
	return !page.rtrarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ResourceTypeRegistrationArrayResponseWithContinuationPage) Response() ResourceTypeRegistrationArrayResponseWithContinuation {
	return page.rtrarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ResourceTypeRegistrationArrayResponseWithContinuationPage) Values() []ResourceTypeRegistration {
	if page.rtrarwc.IsEmpty() {
		return nil
	}
	return *page.rtrarwc.Value
}

// Creates a new instance of the ResourceTypeRegistrationArrayResponseWithContinuationPage type.
func NewResourceTypeRegistrationArrayResponseWithContinuationPage(cur ResourceTypeRegistrationArrayResponseWithContinuation, getNextPage func(context.Context, ResourceTypeRegistrationArrayResponseWithContinuation) (ResourceTypeRegistrationArrayResponseWithContinuation, error)) ResourceTypeRegistrationArrayResponseWithContinuationPage {
	return ResourceTypeRegistrationArrayResponseWithContinuationPage{
		fn:      getNextPage,
		rtrarwc: cur,
	}
}

// ResourceTypeRegistrationProperties ...
type ResourceTypeRegistrationProperties struct {
	// RoutingType - Possible values include: 'Default', 'ProxyOnly', 'HostBased', 'Extension', 'Tenant', 'Fanout', 'LocationBased', 'Failover', 'CascadeExtension'
	RoutingType RoutingType `json:"routingType,omitempty"`
	// Regionality - Possible values include: 'RegionalityNotSpecified', 'RegionalityGlobal', 'RegionalityRegional'
	Regionality      Regionality                                         `json:"regionality,omitempty"`
	Endpoints        *[]ResourceTypeEndpoint                             `json:"endpoints,omitempty"`
	ExtensionOptions *ResourceTypeRegistrationPropertiesExtensionOptions `json:"extensionOptions,omitempty"`
	// MarketplaceType - Possible values include: 'MarketplaceType1NotSpecified', 'MarketplaceType1AddOn', 'MarketplaceType1Bypass', 'MarketplaceType1Store'
	MarketplaceType             MarketplaceType1                                `json:"marketplaceType,omitempty"`
	SwaggerSpecifications       *[]SwaggerSpecification                         `json:"swaggerSpecifications,omitempty"`
	AllowedUnauthorizedActions  *[]string                                       `json:"allowedUnauthorizedActions,omitempty"`
	AuthorizationActionMappings *[]AuthorizationActionMapping                   `json:"authorizationActionMappings,omitempty"`
	LinkedAccessChecks          *[]LinkedAccessCheck                            `json:"linkedAccessChecks,omitempty"`
	DefaultAPIVersion           *string                                         `json:"defaultApiVersion,omitempty"`
	LoggingRules                *[]LoggingRule                                  `json:"loggingRules,omitempty"`
	ThrottlingRules             *[]ThrottlingRule                               `json:"throttlingRules,omitempty"`
	RequiredFeatures            *[]string                                       `json:"requiredFeatures,omitempty"`
	FeaturesRule                *ResourceTypeRegistrationPropertiesFeaturesRule `json:"featuresRule,omitempty"`
	EnableAsyncOperation        *bool                                           `json:"enableAsyncOperation,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState                               ProvisioningState                                                                  `json:"provisioningState,omitempty"`
	EnableThirdPartyS2S                             *bool                                                                              `json:"enableThirdPartyS2S,omitempty"`
	SubscriptionLifecycleNotificationSpecifications *ResourceTypeRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications `json:"subscriptionLifecycleNotificationSpecifications,omitempty"`
	IsPureProxy                                     *bool                                                                              `json:"isPureProxy,omitempty"`
	IdentityManagement                              *ResourceTypeRegistrationPropertiesIdentityManagement                              `json:"identityManagement,omitempty"`
	CheckNameAvailabilitySpecifications             *ResourceTypeRegistrationPropertiesCheckNameAvailabilitySpecifications             `json:"checkNameAvailabilitySpecifications,omitempty"`
	DisallowedActionVerbs                           *[]string                                                                          `json:"disallowedActionVerbs,omitempty"`
	ServiceTreeInfos                                *[]ServiceTreeInfo                                                                 `json:"serviceTreeInfos,omitempty"`
	RequestHeaderOptions                            *ResourceTypeRegistrationPropertiesRequestHeaderOptions                            `json:"requestHeaderOptions,omitempty"`
	SubscriptionStateRules                          *[]SubscriptionStateRule                                                           `json:"subscriptionStateRules,omitempty"`
	TemplateDeploymentOptions                       *ResourceTypeRegistrationPropertiesTemplateDeploymentOptions                       `json:"templateDeploymentOptions,omitempty"`
	ExtendedLocations                               *[]ExtendedLocationOptions                                                         `json:"extendedLocations,omitempty"`
	ResourceMovePolicy                              *ResourceTypeRegistrationPropertiesResourceMovePolicy                              `json:"resourceMovePolicy,omitempty"`
	// ResourceDeletionPolicy - Possible values include: 'ResourceDeletionPolicyNotSpecified', 'ResourceDeletionPolicyCascadeDeleteAll', 'ResourceDeletionPolicyCascadeDeleteProxyOnlyChildren'
	ResourceDeletionPolicy ResourceDeletionPolicy `json:"resourceDeletionPolicy,omitempty"`
}

// ResourceTypeRegistrationPropertiesCheckNameAvailabilitySpecifications ...
type ResourceTypeRegistrationPropertiesCheckNameAvailabilitySpecifications struct {
	EnableDefaultValidation           *bool     `json:"enableDefaultValidation,omitempty"`
	ResourceTypesWithCustomValidation *[]string `json:"resourceTypesWithCustomValidation,omitempty"`
}

// ResourceTypeRegistrationPropertiesExtensionOptions ...
type ResourceTypeRegistrationPropertiesExtensionOptions struct {
	ResourceCreationBegin *ResourceTypeExtensionOptionsResourceCreationBegin `json:"resourceCreationBegin,omitempty"`
}

// ResourceTypeRegistrationPropertiesFeaturesRule ...
type ResourceTypeRegistrationPropertiesFeaturesRule struct {
	// RequiredFeaturesPolicy - Possible values include: 'Any', 'All'
	RequiredFeaturesPolicy FeaturesPolicy `json:"requiredFeaturesPolicy,omitempty"`
}

// ResourceTypeRegistrationPropertiesIdentityManagement ...
type ResourceTypeRegistrationPropertiesIdentityManagement struct {
	// Type - Possible values include: 'IdentityManagementTypesNotSpecified', 'IdentityManagementTypesSystemAssigned', 'IdentityManagementTypesUserAssigned', 'IdentityManagementTypesActor', 'IdentityManagementTypesDelegatedResourceIdentity'
	Type          IdentityManagementTypes `json:"type,omitempty"`
	ApplicationID *string                 `json:"applicationId,omitempty"`
}

// ResourceTypeRegistrationPropertiesModel ...
type ResourceTypeRegistrationPropertiesModel struct {
	// RoutingType - Possible values include: 'Default', 'ProxyOnly', 'HostBased', 'Extension', 'Tenant', 'Fanout', 'LocationBased', 'Failover', 'CascadeExtension'
	RoutingType RoutingType `json:"routingType,omitempty"`
	// Regionality - Possible values include: 'RegionalityNotSpecified', 'RegionalityGlobal', 'RegionalityRegional'
	Regionality      Regionality                                         `json:"regionality,omitempty"`
	Endpoints        *[]ResourceTypeEndpoint                             `json:"endpoints,omitempty"`
	ExtensionOptions *ResourceTypeRegistrationPropertiesExtensionOptions `json:"extensionOptions,omitempty"`
	// MarketplaceType - Possible values include: 'MarketplaceType1NotSpecified', 'MarketplaceType1AddOn', 'MarketplaceType1Bypass', 'MarketplaceType1Store'
	MarketplaceType             MarketplaceType1                                `json:"marketplaceType,omitempty"`
	SwaggerSpecifications       *[]SwaggerSpecification                         `json:"swaggerSpecifications,omitempty"`
	AllowedUnauthorizedActions  *[]string                                       `json:"allowedUnauthorizedActions,omitempty"`
	AuthorizationActionMappings *[]AuthorizationActionMapping                   `json:"authorizationActionMappings,omitempty"`
	LinkedAccessChecks          *[]LinkedAccessCheck                            `json:"linkedAccessChecks,omitempty"`
	DefaultAPIVersion           *string                                         `json:"defaultApiVersion,omitempty"`
	LoggingRules                *[]LoggingRule                                  `json:"loggingRules,omitempty"`
	ThrottlingRules             *[]ThrottlingRule                               `json:"throttlingRules,omitempty"`
	RequiredFeatures            *[]string                                       `json:"requiredFeatures,omitempty"`
	FeaturesRule                *ResourceTypeRegistrationPropertiesFeaturesRule `json:"featuresRule,omitempty"`
	EnableAsyncOperation        *bool                                           `json:"enableAsyncOperation,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState                               ProvisioningState                                                                  `json:"provisioningState,omitempty"`
	EnableThirdPartyS2S                             *bool                                                                              `json:"enableThirdPartyS2S,omitempty"`
	SubscriptionLifecycleNotificationSpecifications *ResourceTypeRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications `json:"subscriptionLifecycleNotificationSpecifications,omitempty"`
	IsPureProxy                                     *bool                                                                              `json:"isPureProxy,omitempty"`
	IdentityManagement                              *ResourceTypeRegistrationPropertiesIdentityManagement                              `json:"identityManagement,omitempty"`
	CheckNameAvailabilitySpecifications             *ResourceTypeRegistrationPropertiesCheckNameAvailabilitySpecifications             `json:"checkNameAvailabilitySpecifications,omitempty"`
	DisallowedActionVerbs                           *[]string                                                                          `json:"disallowedActionVerbs,omitempty"`
	ServiceTreeInfos                                *[]ServiceTreeInfo                                                                 `json:"serviceTreeInfos,omitempty"`
	RequestHeaderOptions                            *ResourceTypeRegistrationPropertiesRequestHeaderOptions                            `json:"requestHeaderOptions,omitempty"`
	SubscriptionStateRules                          *[]SubscriptionStateRule                                                           `json:"subscriptionStateRules,omitempty"`
	TemplateDeploymentOptions                       *ResourceTypeRegistrationPropertiesTemplateDeploymentOptions                       `json:"templateDeploymentOptions,omitempty"`
	ExtendedLocations                               *[]ExtendedLocationOptions                                                         `json:"extendedLocations,omitempty"`
	ResourceMovePolicy                              *ResourceTypeRegistrationPropertiesResourceMovePolicy                              `json:"resourceMovePolicy,omitempty"`
	// ResourceDeletionPolicy - Possible values include: 'ResourceDeletionPolicyNotSpecified', 'ResourceDeletionPolicyCascadeDeleteAll', 'ResourceDeletionPolicyCascadeDeleteProxyOnlyChildren'
	ResourceDeletionPolicy ResourceDeletionPolicy `json:"resourceDeletionPolicy,omitempty"`
}

// ResourceTypeRegistrationPropertiesRequestHeaderOptions ...
type ResourceTypeRegistrationPropertiesRequestHeaderOptions struct {
	// OptInHeaders - Possible values include: 'OptInHeaderTypeNotSpecified', 'OptInHeaderTypeSignedUserToken', 'OptInHeaderTypeClientGroupMembership', 'OptInHeaderTypeSignedAuxiliaryTokens', 'OptInHeaderTypeUnboundedClientGroupMembership'
	OptInHeaders OptInHeaderType `json:"optInHeaders,omitempty"`
}

// ResourceTypeRegistrationPropertiesResourceMovePolicy ...
type ResourceTypeRegistrationPropertiesResourceMovePolicy struct {
	ValidationRequired            *bool `json:"validationRequired,omitempty"`
	CrossResourceGroupMoveEnabled *bool `json:"crossResourceGroupMoveEnabled,omitempty"`
	CrossSubscriptionMoveEnabled  *bool `json:"crossSubscriptionMoveEnabled,omitempty"`
}

// ResourceTypeRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications ...
type ResourceTypeRegistrationPropertiesSubscriptionLifecycleNotificationSpecifications struct {
	SubscriptionStateOverrideActions *[]SubscriptionStateOverrideAction `json:"subscriptionStateOverrideActions,omitempty"`
	SoftDeleteTTL                    *string                            `json:"softDeleteTTL,omitempty"`
}

// ResourceTypeRegistrationPropertiesTemplateDeploymentOptions ...
type ResourceTypeRegistrationPropertiesTemplateDeploymentOptions struct {
	PreflightSupported *bool              `json:"preflightSupported,omitempty"`
	PreflightOptions   *[]PreflightOption `json:"preflightOptions,omitempty"`
}

// ResourceTypeRegistrationsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results
// of a long-running operation.
type ResourceTypeRegistrationsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ResourceTypeRegistrationsClient) (ResourceTypeRegistration, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ResourceTypeRegistrationsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ResourceTypeRegistrationsCreateOrUpdateFuture.Result.
func (future *ResourceTypeRegistrationsCreateOrUpdateFuture) result(client ResourceTypeRegistrationsClient) (rtr ResourceTypeRegistration, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "providerhub.ResourceTypeRegistrationsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		rtr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("providerhub.ResourceTypeRegistrationsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rtr.Response.Response, err = future.GetResult(sender); err == nil && rtr.Response.Response.StatusCode != http.StatusNoContent {
		rtr, err = client.CreateOrUpdateResponder(rtr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "providerhub.ResourceTypeRegistrationsCreateOrUpdateFuture", "Result", rtr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ResourceTypeRequestHeaderOptions ...
type ResourceTypeRequestHeaderOptions struct {
	// OptInHeaders - Possible values include: 'OptInHeaderTypeNotSpecified', 'OptInHeaderTypeSignedUserToken', 'OptInHeaderTypeClientGroupMembership', 'OptInHeaderTypeSignedAuxiliaryTokens', 'OptInHeaderTypeUnboundedClientGroupMembership'
	OptInHeaders OptInHeaderType `json:"optInHeaders,omitempty"`
}

// ResourceTypeSku ...
type ResourceTypeSku struct {
	SkuSettings *[]SkuSetting `json:"skuSettings,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// ResourceTypeTemplateDeploymentPolicy ...
type ResourceTypeTemplateDeploymentPolicy struct {
	// Capabilities - Possible values include: 'TemplateDeploymentCapabilitiesDefault', 'TemplateDeploymentCapabilitiesPreflight'
	Capabilities TemplateDeploymentCapabilities `json:"capabilities,omitempty"`
	// PreflightOptions - Possible values include: 'TemplateDeploymentPreflightOptionsNone', 'TemplateDeploymentPreflightOptionsValidationRequests', 'TemplateDeploymentPreflightOptionsDeploymentRequests', 'TemplateDeploymentPreflightOptionsTestOnly', 'TemplateDeploymentPreflightOptionsRegisteredOnly'
	PreflightOptions TemplateDeploymentPreflightOptions `json:"preflightOptions,omitempty"`
}

// RolloutStatusBase ...
type RolloutStatusBase struct {
	CompletedRegions       *[]string                     `json:"completedRegions,omitempty"`
	FailedOrSkippedRegions map[string]*ExtendedErrorInfo `json:"failedOrSkippedRegions"`
}

// MarshalJSON is the custom marshaler for RolloutStatusBase.
func (rsb RolloutStatusBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rsb.CompletedRegions != nil {
		objectMap["completedRegions"] = rsb.CompletedRegions
	}
	if rsb.FailedOrSkippedRegions != nil {
		objectMap["failedOrSkippedRegions"] = rsb.FailedOrSkippedRegions
	}
	return json.Marshal(objectMap)
}

// ServiceTreeInfo ...
type ServiceTreeInfo struct {
	ServiceID   *string `json:"serviceId,omitempty"`
	ComponentID *string `json:"componentId,omitempty"`
}

// SkuCapability ...
type SkuCapability struct {
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

// SkuCapacity ...
type SkuCapacity struct {
	Minimum *int32 `json:"minimum,omitempty"`
	Maximum *int32 `json:"maximum,omitempty"`
	Default *int32 `json:"default,omitempty"`
	// ScaleType - Possible values include: 'SkuScaleTypeNone', 'SkuScaleTypeManual', 'SkuScaleTypeAutomatic'
	ScaleType SkuScaleType `json:"scaleType,omitempty"`
}

// SkuCost ...
type SkuCost struct {
	MeterID      *string `json:"meterId,omitempty"`
	Quantity     *int32  `json:"quantity,omitempty"`
	ExtendedUnit *string `json:"extendedUnit,omitempty"`
}

// SkuLocationInfo ...
type SkuLocationInfo struct {
	Location          *string          `json:"location,omitempty"`
	Zones             *[]string        `json:"zones,omitempty"`
	ZoneDetails       *[]SkuZoneDetail `json:"zoneDetails,omitempty"`
	ExtendedLocations *[]string        `json:"extendedLocations,omitempty"`
	// Type - Possible values include: 'TypeNotSpecified', 'TypeEdgeZone', 'TypeArcZone'
	Type Type `json:"type,omitempty"`
}

// SkuResource ...
type SkuResource struct {
	autorest.Response `json:"-"`
	Properties        *SkuResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SkuResource.
func (sr SkuResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.Properties != nil {
		objectMap["properties"] = sr.Properties
	}
	return json.Marshal(objectMap)
}

// SkuResourceArrayResponseWithContinuation ...
type SkuResourceArrayResponseWithContinuation struct {
	autorest.Response `json:"-"`
	Value             *[]SkuResource `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// SkuResourceArrayResponseWithContinuationIterator provides access to a complete listing of SkuResource
// values.
type SkuResourceArrayResponseWithContinuationIterator struct {
	i    int
	page SkuResourceArrayResponseWithContinuationPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SkuResourceArrayResponseWithContinuationIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkuResourceArrayResponseWithContinuationIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SkuResourceArrayResponseWithContinuationIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SkuResourceArrayResponseWithContinuationIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SkuResourceArrayResponseWithContinuationIterator) Response() SkuResourceArrayResponseWithContinuation {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SkuResourceArrayResponseWithContinuationIterator) Value() SkuResource {
	if !iter.page.NotDone() {
		return SkuResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SkuResourceArrayResponseWithContinuationIterator type.
func NewSkuResourceArrayResponseWithContinuationIterator(page SkuResourceArrayResponseWithContinuationPage) SkuResourceArrayResponseWithContinuationIterator {
	return SkuResourceArrayResponseWithContinuationIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (srarwc SkuResourceArrayResponseWithContinuation) IsEmpty() bool {
	return srarwc.Value == nil || len(*srarwc.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (srarwc SkuResourceArrayResponseWithContinuation) hasNextLink() bool {
	return srarwc.NextLink != nil && len(*srarwc.NextLink) != 0
}

// skuResourceArrayResponseWithContinuationPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (srarwc SkuResourceArrayResponseWithContinuation) skuResourceArrayResponseWithContinuationPreparer(ctx context.Context) (*http.Request, error) {
	if !srarwc.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(srarwc.NextLink)))
}

// SkuResourceArrayResponseWithContinuationPage contains a page of SkuResource values.
type SkuResourceArrayResponseWithContinuationPage struct {
	fn     func(context.Context, SkuResourceArrayResponseWithContinuation) (SkuResourceArrayResponseWithContinuation, error)
	srarwc SkuResourceArrayResponseWithContinuation
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SkuResourceArrayResponseWithContinuationPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkuResourceArrayResponseWithContinuationPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.srarwc)
		if err != nil {
			return err
		}
		page.srarwc = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SkuResourceArrayResponseWithContinuationPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SkuResourceArrayResponseWithContinuationPage) NotDone() bool {
	return !page.srarwc.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SkuResourceArrayResponseWithContinuationPage) Response() SkuResourceArrayResponseWithContinuation {
	return page.srarwc
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SkuResourceArrayResponseWithContinuationPage) Values() []SkuResource {
	if page.srarwc.IsEmpty() {
		return nil
	}
	return *page.srarwc.Value
}

// Creates a new instance of the SkuResourceArrayResponseWithContinuationPage type.
func NewSkuResourceArrayResponseWithContinuationPage(cur SkuResourceArrayResponseWithContinuation, getNextPage func(context.Context, SkuResourceArrayResponseWithContinuation) (SkuResourceArrayResponseWithContinuation, error)) SkuResourceArrayResponseWithContinuationPage {
	return SkuResourceArrayResponseWithContinuationPage{
		fn:     getNextPage,
		srarwc: cur,
	}
}

// SkuResourceProperties ...
type SkuResourceProperties struct {
	SkuSettings *[]SkuSetting `json:"skuSettings,omitempty"`
	// ProvisioningState - Possible values include: 'ProvisioningStateNotSpecified', 'ProvisioningStateAccepted', 'ProvisioningStateRunning', 'ProvisioningStateCreating', 'ProvisioningStateCreated', 'ProvisioningStateDeleting', 'ProvisioningStateDeleted', 'ProvisioningStateCanceled', 'ProvisioningStateFailed', 'ProvisioningStateSucceeded', 'ProvisioningStateMovingResources', 'ProvisioningStateTransientFailure', 'ProvisioningStateRolloutInProgress'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
}

// SkuSetting ...
type SkuSetting struct {
	Name             *string             `json:"name,omitempty"`
	Tier             *string             `json:"tier,omitempty"`
	Size             *string             `json:"size,omitempty"`
	Family           *string             `json:"family,omitempty"`
	Kind             *string             `json:"kind,omitempty"`
	Locations        *[]string           `json:"locations,omitempty"`
	LocationInfo     *[]SkuLocationInfo  `json:"locationInfo,omitempty"`
	RequiredQuotaIds *[]string           `json:"requiredQuotaIds,omitempty"`
	RequiredFeatures *[]string           `json:"requiredFeatures,omitempty"`
	Capacity         *SkuSettingCapacity `json:"capacity,omitempty"`
	Costs            *[]SkuCost          `json:"costs,omitempty"`
	Capabilities     *[]SkuCapability    `json:"capabilities,omitempty"`
}

// SkuSettingCapacity ...
type SkuSettingCapacity struct {
	Minimum *int32 `json:"minimum,omitempty"`
	Maximum *int32 `json:"maximum,omitempty"`
	Default *int32 `json:"default,omitempty"`
	// ScaleType - Possible values include: 'SkuScaleTypeNone', 'SkuScaleTypeManual', 'SkuScaleTypeAutomatic'
	ScaleType SkuScaleType `json:"scaleType,omitempty"`
}

// SkuZoneDetail ...
type SkuZoneDetail struct {
	Name         *[]string        `json:"name,omitempty"`
	Capabilities *[]SkuCapability `json:"capabilities,omitempty"`
}

// SubscriptionLifecycleNotificationSpecifications ...
type SubscriptionLifecycleNotificationSpecifications struct {
	SubscriptionStateOverrideActions *[]SubscriptionStateOverrideAction `json:"subscriptionStateOverrideActions,omitempty"`
	SoftDeleteTTL                    *string                            `json:"softDeleteTTL,omitempty"`
}

// SubscriptionStateOverrideAction ...
type SubscriptionStateOverrideAction struct {
	// State - Possible values include: 'Registered', 'Unregistered', 'Warned', 'Suspended', 'Deleted', 'WarnedToRegistered', 'WarnedToSuspended', 'WarnedToDeleted', 'WarnedToUnregistered', 'SuspendedToRegistered', 'SuspendedToWarned', 'SuspendedToDeleted', 'SuspendedToUnregistered'
	State SubscriptionTransitioningState `json:"state,omitempty"`
	// Action - Possible values include: 'NotDefined', 'DeleteAllResources', 'SoftDeleteAllResources', 'NoOp', 'BillingCancellation', 'UndoSoftDelete'
	Action SubscriptionNotificationOperation `json:"action,omitempty"`
}

// SubscriptionStateRule ...
type SubscriptionStateRule struct {
	// State - Possible values include: 'SubscriptionStateNotDefined', 'SubscriptionStateEnabled', 'SubscriptionStateWarned', 'SubscriptionStatePastDue', 'SubscriptionStateDisabled', 'SubscriptionStateDeleted'
	State          SubscriptionState `json:"state,omitempty"`
	AllowedActions *[]string         `json:"allowedActions,omitempty"`
}

// SwaggerSpecification ...
type SwaggerSpecification struct {
	APIVersions          *[]string `json:"apiVersions,omitempty"`
	SwaggerSpecFolderURI *string   `json:"swaggerSpecFolderUri,omitempty"`
}

// TemplateDeploymentOptions ...
type TemplateDeploymentOptions struct {
	PreflightSupported *bool              `json:"preflightSupported,omitempty"`
	PreflightOptions   *[]PreflightOption `json:"preflightOptions,omitempty"`
}

// TemplateDeploymentPolicy ...
type TemplateDeploymentPolicy struct {
	// Capabilities - Possible values include: 'TemplateDeploymentCapabilitiesDefault', 'TemplateDeploymentCapabilitiesPreflight'
	Capabilities TemplateDeploymentCapabilities `json:"capabilities,omitempty"`
	// PreflightOptions - Possible values include: 'TemplateDeploymentPreflightOptionsNone', 'TemplateDeploymentPreflightOptionsValidationRequests', 'TemplateDeploymentPreflightOptionsDeploymentRequests', 'TemplateDeploymentPreflightOptionsTestOnly', 'TemplateDeploymentPreflightOptionsRegisteredOnly'
	PreflightOptions TemplateDeploymentPreflightOptions `json:"preflightOptions,omitempty"`
}

// ThirdPartyProviderAuthorization ...
type ThirdPartyProviderAuthorization struct {
	Authorizations    *[]LightHouseAuthorization `json:"authorizations,omitempty"`
	ManagedByTenantID *string                    `json:"managedByTenantId,omitempty"`
}

// ThrottlingMetric ...
type ThrottlingMetric struct {
	// Type - Possible values include: 'ThrottlingMetricTypeNotSpecified', 'ThrottlingMetricTypeNumberOfRequests', 'ThrottlingMetricTypeNumberOfResources'
	Type     ThrottlingMetricType `json:"type,omitempty"`
	Limit    *int64               `json:"limit,omitempty"`
	Interval *string              `json:"interval,omitempty"`
}

// ThrottlingRule ...
type ThrottlingRule struct {
	Action           *string             `json:"action,omitempty"`
	Metrics          *[]ThrottlingMetric `json:"metrics,omitempty"`
	RequiredFeatures *[]string           `json:"requiredFeatures,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// TrafficRegionRolloutConfiguration ...
type TrafficRegionRolloutConfiguration struct {
	WaitDuration *string   `json:"waitDuration,omitempty"`
	Regions      *[]string `json:"regions,omitempty"`
}

// TrafficRegions ...
type TrafficRegions struct {
	Regions *[]string `json:"regions,omitempty"`
}

// TypedErrorInfo ...
type TypedErrorInfo struct {
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for TypedErrorInfo.
func (tei TypedErrorInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tei.Type != nil {
		objectMap["type"] = tei.Type
	}
	return json.Marshal(objectMap)
}
