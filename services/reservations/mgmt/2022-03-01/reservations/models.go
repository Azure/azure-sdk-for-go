package reservations

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/reservations/mgmt/2022-03-01/reservations"

// AppliedReservationList ...
type AppliedReservationList struct {
	Value *[]string `json:"value,omitempty"`
	// NextLink - Url to get the next page of reservations
	NextLink *string `json:"nextLink,omitempty"`
}

// AppliedReservations ...
type AppliedReservations struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Identifier of the applied reservations
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/AppliedReservations"
	Type                           *string `json:"type,omitempty"`
	*AppliedReservationsProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for AppliedReservations.
func (ar AppliedReservations) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ar.AppliedReservationsProperties != nil {
		objectMap["properties"] = ar.AppliedReservationsProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for AppliedReservations struct.
func (ar *AppliedReservations) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ar.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var appliedReservationsProperties AppliedReservationsProperties
				err = json.Unmarshal(*v, &appliedReservationsProperties)
				if err != nil {
					return err
				}
				ar.AppliedReservationsProperties = &appliedReservationsProperties
			}
		}
	}

	return nil
}

// AppliedReservationsProperties ...
type AppliedReservationsProperties struct {
	ReservationOrderIds *AppliedReservationList `json:"reservationOrderIds,omitempty"`
}

// AvailableScopeProperties ...
type AvailableScopeProperties struct {
	autorest.Response `json:"-"`
	Properties        *SubscriptionScopeProperties `json:"properties,omitempty"`
}

// AvailableScopeRequest available scope
type AvailableScopeRequest struct {
	Properties *AvailableScopeRequestProperties `json:"properties,omitempty"`
}

// AvailableScopeRequestProperties available scope request properties
type AvailableScopeRequestProperties struct {
	Scopes *[]string `json:"scopes,omitempty"`
}

// BillingInformation billing information
type BillingInformation struct {
	BillingCurrencyTotalPaidAmount           *Price `json:"billingCurrencyTotalPaidAmount,omitempty"`
	BillingCurrencyProratedAmount            *Price `json:"billingCurrencyProratedAmount,omitempty"`
	BillingCurrencyRemainingCommitmentAmount *Price `json:"billingCurrencyRemainingCommitmentAmount,omitempty"`
}

// CalculateExchangeOperationResultResponse calculateExchange operation result
type CalculateExchangeOperationResultResponse struct {
	autorest.Response `json:"-"`
	// ID - It should match what is used to GET the operation result.
	ID *string `json:"id,omitempty"`
	// Name - It must match the last segment of the id field, and will typically be a GUID / system generated value.
	Name *string `json:"name,omitempty"`
	// Status - Status of the operation. Possible values include: 'CalculateExchangeOperationResultStatusSucceeded', 'CalculateExchangeOperationResultStatusFailed', 'CalculateExchangeOperationResultStatusCancelled', 'CalculateExchangeOperationResultStatusPending'
	Status     CalculateExchangeOperationResultStatus `json:"status,omitempty"`
	Properties *CalculateExchangeResponseProperties   `json:"properties,omitempty"`
	Error      *OperationResultError                  `json:"error,omitempty"`
}

// CalculateExchangePostFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CalculateExchangePostFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(CalculateExchangeClient) (CalculateExchangeOperationResultResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *CalculateExchangePostFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for CalculateExchangePostFuture.Result.
func (future *CalculateExchangePostFuture) result(client CalculateExchangeClient) (ceorr CalculateExchangeOperationResultResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.CalculateExchangePostFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ceorr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.CalculateExchangePostFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ceorr.Response.Response, err = future.GetResult(sender); err == nil && ceorr.Response.Response.StatusCode != http.StatusNoContent {
		ceorr, err = client.PostResponder(ceorr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.CalculateExchangePostFuture", "Result", ceorr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CalculateExchangeRequest calculate exchange request
type CalculateExchangeRequest struct {
	Properties *CalculateExchangeRequestProperties `json:"properties,omitempty"`
}

// CalculateExchangeRequestProperties calculate exchange request properties
type CalculateExchangeRequestProperties struct {
	// ReservationsToPurchase - List of reservations that are being purchased in this exchange.
	ReservationsToPurchase *[]PurchaseRequest `json:"reservationsToPurchase,omitempty"`
	// ReservationsToExchange - List of reservations that are being returned in this exchange.
	ReservationsToExchange *[]ToReturn `json:"reservationsToExchange,omitempty"`
}

// CalculateExchangeResponseProperties calculateExchange response properties
type CalculateExchangeResponseProperties struct {
	// SessionID - Exchange session identifier
	SessionID      *string `json:"sessionId,omitempty"`
	NetPayable     *Price  `json:"netPayable,omitempty"`
	RefundsTotal   *Price  `json:"refundsTotal,omitempty"`
	PurchasesTotal *Price  `json:"purchasesTotal,omitempty"`
	// ReservationsToPurchase - Details of the reservations being purchased
	ReservationsToPurchase *[]ToPurchaseCalculateExchange `json:"reservationsToPurchase,omitempty"`
	// ReservationsToExchange - Details of the reservations being returned
	ReservationsToExchange *[]ToExchange         `json:"reservationsToExchange,omitempty"`
	PolicyResult           *ExchangePolicyErrors `json:"policyResult,omitempty"`
}

// CalculatePriceResponse ...
type CalculatePriceResponse struct {
	autorest.Response `json:"-"`
	Properties        *CalculatePriceResponseProperties `json:"properties,omitempty"`
}

// CalculatePriceResponseProperties ...
type CalculatePriceResponseProperties struct {
	// BillingCurrencyTotal - Currency and amount that customer will be charged in customer's local currency. Tax is not included.
	BillingCurrencyTotal *CalculatePriceResponsePropertiesBillingCurrencyTotal `json:"billingCurrencyTotal,omitempty"`
	// NetTotal - Net total amount in pricing currency.
	NetTotal *float64 `json:"netTotal,omitempty"`
	// TaxTotal - Tax amount in pricing currency.
	TaxTotal *float64 `json:"taxTotal,omitempty"`
	// GrandTotal - Total amount in pricing currency.
	GrandTotal *float64 `json:"grandTotal,omitempty"`
	// IsTaxIncluded - Whether or not tax is included in grand total
	IsTaxIncluded *bool `json:"isTaxIncluded,omitempty"`
	// IsBillingPartnerManaged - True if billing is managed by Microsoft Partner. Used only for CSP accounts.
	IsBillingPartnerManaged *bool `json:"isBillingPartnerManaged,omitempty"`
	// ReservationOrderID - GUID that represents reservation order that can be placed after calculating price.
	ReservationOrderID *string `json:"reservationOrderId,omitempty"`
	// SkuTitle - Title of SKU that is being purchased.
	SkuTitle *string `json:"skuTitle,omitempty"`
	// SkuDescription - Description of SKU that is being purchased.
	SkuDescription *string `json:"skuDescription,omitempty"`
	// PricingCurrencyTotal - Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included.
	PricingCurrencyTotal *CalculatePriceResponsePropertiesPricingCurrencyTotal `json:"pricingCurrencyTotal,omitempty"`
	PaymentSchedule      *[]PaymentDetail                                      `json:"paymentSchedule,omitempty"`
}

// CalculatePriceResponsePropertiesBillingCurrencyTotal currency and amount that customer will be charged
// in customer's local currency. Tax is not included.
type CalculatePriceResponsePropertiesBillingCurrencyTotal struct {
	// CurrencyCode - The ISO 4217 3-letter currency code for the currency used by this purchase record.
	CurrencyCode *string `json:"currencyCode,omitempty"`
	// Amount - Amount in pricing currency. Tax is not included.
	Amount *float64 `json:"amount,omitempty"`
}

// CalculatePriceResponsePropertiesPricingCurrencyTotal amount that Microsoft uses for record. Used during
// refund for calculating refund limit. Tax is not included.
type CalculatePriceResponsePropertiesPricingCurrencyTotal struct {
	// CurrencyCode - The ISO 4217 3-letter currency code for the currency used by this purchase record.
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// Catalog ...
type Catalog struct {
	// ResourceType - READ-ONLY; The type of resource the SKU applies to.
	ResourceType *string `json:"resourceType,omitempty"`
	// Name - READ-ONLY; The name of SKU
	Name *string `json:"name,omitempty"`
	// BillingPlans - The billing plan options available for this SKU.
	BillingPlans map[string][]ReservationBillingPlan `json:"billingPlans"`
	// Terms - READ-ONLY; Available reservation terms for this resource
	Terms *[]ReservationTerm `json:"terms,omitempty"`
	// Locations - READ-ONLY
	Locations *[]string `json:"locations,omitempty"`
	// SkuProperties - READ-ONLY
	SkuProperties *[]SkuProperty `json:"skuProperties,omitempty"`
	// Msrp - READ-ONLY; Pricing information about the SKU
	Msrp *CatalogMsrp `json:"msrp,omitempty"`
	// Restrictions - READ-ONLY
	Restrictions *[]SkuRestriction `json:"restrictions,omitempty"`
	// Tier - READ-ONLY; The tier of this SKU
	Tier *string `json:"tier,omitempty"`
	// Size - READ-ONLY; The size of this SKU
	Size *string `json:"size,omitempty"`
	// Capabilities - READ-ONLY
	Capabilities *[]SkuCapability `json:"capabilities,omitempty"`
}

// MarshalJSON is the custom marshaler for Catalog.
func (c Catalog) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if c.BillingPlans != nil {
		objectMap["billingPlans"] = c.BillingPlans
	}
	return json.Marshal(objectMap)
}

// CatalogMsrp pricing information about the SKU
type CatalogMsrp struct {
	// P1Y - Amount in pricing currency. Tax not included.
	P1Y *Price `json:"p1Y,omitempty"`
}

// ChangeDirectoryRequest ...
type ChangeDirectoryRequest struct {
	// DestinationTenantID - Tenant id GUID that reservation order is to be transferred to
	DestinationTenantID *string `json:"destinationTenantId,omitempty"`
}

// ChangeDirectoryResponse change directory response
type ChangeDirectoryResponse struct {
	autorest.Response    `json:"-"`
	ReservationOrder     *ChangeDirectoryResult   `json:"reservationOrder,omitempty"`
	ReservationsProperty *[]ChangeDirectoryResult `json:"reservations,omitempty"`
}

// ChangeDirectoryResult change directory result for reservation order or reservation
type ChangeDirectoryResult struct {
	// ID - Identifier of the reservation order or reservation
	ID *string `json:"id,omitempty"`
	// Name - Name of the reservation order or reservation
	Name *string `json:"name,omitempty"`
	// IsSucceeded - True if change directory operation succeeded on this reservation order or reservation
	IsSucceeded *bool `json:"isSucceeded,omitempty"`
	// Error - Error reason if operation failed. Null otherwise
	Error *string `json:"error,omitempty"`
}

// CreateGenericQuotaRequestParameters quota change requests information.
type CreateGenericQuotaRequestParameters struct {
	// Value - Quota change requests.
	Value *[]CurrentQuotaLimitBase `json:"value,omitempty"`
}

// CurrentQuotaLimit current quota limits.
type CurrentQuotaLimit struct {
	// CurrentQuotaLimitBase - Quota details.
	*CurrentQuotaLimitBase `json:"quotaInformation,omitempty"`
	// QuotaRequestStatusDetails - Additional properties for the quota status for the resource.
	*QuotaRequestStatusDetails `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CurrentQuotaLimit.
func (cql CurrentQuotaLimit) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cql.CurrentQuotaLimitBase != nil {
		objectMap["quotaInformation"] = cql.CurrentQuotaLimitBase
	}
	if cql.QuotaRequestStatusDetails != nil {
		objectMap["properties"] = cql.QuotaRequestStatusDetails
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CurrentQuotaLimit struct.
func (cql *CurrentQuotaLimit) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "quotaInformation":
			if v != nil {
				var currentQuotaLimitBase CurrentQuotaLimitBase
				err = json.Unmarshal(*v, &currentQuotaLimitBase)
				if err != nil {
					return err
				}
				cql.CurrentQuotaLimitBase = &currentQuotaLimitBase
			}
		case "properties":
			if v != nil {
				var quotaRequestStatusDetails QuotaRequestStatusDetails
				err = json.Unmarshal(*v, &quotaRequestStatusDetails)
				if err != nil {
					return err
				}
				cql.QuotaRequestStatusDetails = &quotaRequestStatusDetails
			}
		}
	}

	return nil
}

// CurrentQuotaLimitBase quota properties.
type CurrentQuotaLimitBase struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; The quota request ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/ServiceLimits"
	Type *string `json:"type,omitempty"`
	// Properties - Quota properties for the resource.
	Properties *QuotaProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CurrentQuotaLimitBase.
func (cqlb CurrentQuotaLimitBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cqlb.Properties != nil {
		objectMap["properties"] = cqlb.Properties
	}
	return json.Marshal(objectMap)
}

// Error ...
type Error struct {
	Error *ExtendedErrorInfo `json:"error,omitempty"`
}

// ErrorDetails the details of the error.
type ErrorDetails struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetails.
func (ed ErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse error response indicates that the service is not able to process the incoming request. The
// reason is provided in the error message.
type ErrorResponse struct {
	// Error - The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`
}

// ExceptionResponse the API error.
type ExceptionResponse struct {
	// Error - The API error details.
	Error *ServiceError `json:"error,omitempty"`
}

// ExchangeOperationResultResponse exchange operation result
type ExchangeOperationResultResponse struct {
	autorest.Response `json:"-"`
	// ID - It should match what is used to GET the operation result.
	ID *string `json:"id,omitempty"`
	// Name - It must match the last segment of the id field, and will typically be a GUID / system generated value.
	Name *string `json:"name,omitempty"`
	// Status - Status of the operation. Possible values include: 'ExchangeOperationResultStatusSucceeded', 'ExchangeOperationResultStatusFailed', 'ExchangeOperationResultStatusCancelled', 'ExchangeOperationResultStatusPendingRefunds', 'ExchangeOperationResultStatusPendingPurchases'
	Status     ExchangeOperationResultStatus `json:"status,omitempty"`
	Properties *ExchangeResponseProperties   `json:"properties,omitempty"`
	Error      *OperationResultError         `json:"error,omitempty"`
}

// ExchangePolicyError error details
type ExchangePolicyError struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

// ExchangePolicyErrors exchange policy errors
type ExchangePolicyErrors struct {
	// PolicyErrors - Exchange Policy errors
	PolicyErrors *[]ExchangePolicyError `json:"policyErrors,omitempty"`
}

// ExchangePostFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type ExchangePostFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ExchangeClient) (ExchangeOperationResultResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ExchangePostFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ExchangePostFuture.Result.
func (future *ExchangePostFuture) result(client ExchangeClient) (eorr ExchangeOperationResultResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ExchangePostFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		eorr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.ExchangePostFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if eorr.Response.Response, err = future.GetResult(sender); err == nil && eorr.Response.Response.StatusCode != http.StatusNoContent {
		eorr, err = client.PostResponder(eorr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ExchangePostFuture", "Result", eorr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ExchangeRequest exchange request
type ExchangeRequest struct {
	Properties *ExchangeRequestProperties `json:"properties,omitempty"`
}

// ExchangeRequestProperties exchange request properties
type ExchangeRequestProperties struct {
	// SessionID - SessionId that was returned by CalculateExchange API.
	SessionID *string `json:"sessionId,omitempty"`
}

// ExchangeResponseProperties exchange response properties
type ExchangeResponseProperties struct {
	// SessionID - Exchange session identifier
	SessionID      *string `json:"sessionId,omitempty"`
	NetPayable     *Price  `json:"netPayable,omitempty"`
	RefundsTotal   *Price  `json:"refundsTotal,omitempty"`
	PurchasesTotal *Price  `json:"purchasesTotal,omitempty"`
	// ReservationsToPurchase - Details of the reservations being purchased
	ReservationsToPurchase *[]ToPurchaseExchange `json:"reservationsToPurchase,omitempty"`
	// ReservationsToExchange - Details of the reservations being returned
	ReservationsToExchange *[]ToReturnForExchange `json:"reservationsToExchange,omitempty"`
	PolicyResult           *ExchangePolicyErrors  `json:"policyResult,omitempty"`
}

// ExtendedErrorInfo ...
type ExtendedErrorInfo struct {
	// Code - Possible values include: 'ErrorResponseCodeNotSpecified', 'ErrorResponseCodeInternalServerError', 'ErrorResponseCodeServerTimeout', 'ErrorResponseCodeAuthorizationFailed', 'ErrorResponseCodeBadRequest', 'ErrorResponseCodeClientCertificateThumbprintNotSet', 'ErrorResponseCodeInvalidRequestContent', 'ErrorResponseCodeOperationFailed', 'ErrorResponseCodeHTTPMethodNotSupported', 'ErrorResponseCodeInvalidRequestURI', 'ErrorResponseCodeMissingTenantID', 'ErrorResponseCodeInvalidTenantID', 'ErrorResponseCodeInvalidReservationOrderID', 'ErrorResponseCodeInvalidReservationID', 'ErrorResponseCodeReservationIDNotInReservationOrder', 'ErrorResponseCodeReservationOrderNotFound', 'ErrorResponseCodeInvalidSubscriptionID', 'ErrorResponseCodeInvalidAccessToken', 'ErrorResponseCodeInvalidLocationID', 'ErrorResponseCodeUnauthenticatedRequestsThrottled', 'ErrorResponseCodeInvalidHealthCheckType', 'ErrorResponseCodeForbidden', 'ErrorResponseCodeBillingScopeIDCannotBeChanged', 'ErrorResponseCodeAppliedScopesNotAssociatedWithCommerceAccount', 'ErrorResponseCodePatchValuesSameAsExisting', 'ErrorResponseCodeRoleAssignmentCreationFailed', 'ErrorResponseCodeReservationOrderCreationFailed', 'ErrorResponseCodeReservationOrderNotEnabled', 'ErrorResponseCodeCapacityUpdateScopesFailed', 'ErrorResponseCodeUnsupportedReservationTerm', 'ErrorResponseCodeReservationOrderIDAlreadyExists', 'ErrorResponseCodeRiskCheckFailed', 'ErrorResponseCodeCreateQuoteFailed', 'ErrorResponseCodeActivateQuoteFailed', 'ErrorResponseCodeNonsupportedAccountID', 'ErrorResponseCodePaymentInstrumentNotFound', 'ErrorResponseCodeMissingAppliedScopesForSingle', 'ErrorResponseCodeNoValidReservationsToReRate', 'ErrorResponseCodeReRateOnlyAllowedForEA', 'ErrorResponseCodeOperationCannotBePerformedInCurrentState', 'ErrorResponseCodeInvalidSingleAppliedScopesCount', 'ErrorResponseCodeInvalidFulfillmentRequestParameters', 'ErrorResponseCodeNotSupportedCountry', 'ErrorResponseCodeInvalidRefundQuantity', 'ErrorResponseCodePurchaseError', 'ErrorResponseCodeBillingCustomerInputError', 'ErrorResponseCodeBillingPaymentInstrumentSoftError', 'ErrorResponseCodeBillingPaymentInstrumentHardError', 'ErrorResponseCodeBillingTransientError', 'ErrorResponseCodeBillingError', 'ErrorResponseCodeFulfillmentConfigurationError', 'ErrorResponseCodeFulfillmentOutOfStockError', 'ErrorResponseCodeFulfillmentTransientError', 'ErrorResponseCodeFulfillmentError', 'ErrorResponseCodeCalculatePriceFailed', 'ErrorResponseCodeAppliedScopesSameAsExisting'
	Code    ErrorResponseCode `json:"code,omitempty"`
	Message *string           `json:"message,omitempty"`
}

// ExtendedStatusInfo ...
type ExtendedStatusInfo struct {
	// StatusCode - Possible values include: 'StatusCodeNone', 'StatusCodePending', 'StatusCodeProcessing', 'StatusCodeActive', 'StatusCodePurchaseError', 'StatusCodePaymentInstrumentError', 'StatusCodeSplit', 'StatusCodeMerged', 'StatusCodeExpired', 'StatusCodeSucceeded'
	StatusCode StatusCode `json:"statusCode,omitempty"`
	// Message - The message giving detailed information about the status code.
	Message *string `json:"message,omitempty"`
}

// List ...
type List struct {
	autorest.Response `json:"-"`
	Value             *[]Response `json:"value,omitempty"`
	// NextLink - Url to get the next page of reservations.
	NextLink *string `json:"nextLink,omitempty"`
}

// ListCatalog ...
type ListCatalog struct {
	autorest.Response `json:"-"`
	Value             *[]Catalog `json:"value,omitempty"`
}

// ListIterator provides access to a complete listing of Response values.
type ListIterator struct {
	i    int
	page ListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListIterator) Response() List {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListIterator) Value() Response {
	if !iter.page.NotDone() {
		return Response{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListIterator type.
func NewListIterator(page ListPage) ListIterator {
	return ListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (l List) IsEmpty() bool {
	return l.Value == nil || len(*l.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (l List) hasNextLink() bool {
	return l.NextLink != nil && len(*l.NextLink) != 0
}

// listPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (l List) listPreparer(ctx context.Context) (*http.Request, error) {
	if !l.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(l.NextLink)))
}

// ListPage contains a page of Response values.
type ListPage struct {
	fn func(context.Context, List) (List, error)
	l  List
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.l)
		if err != nil {
			return err
		}
		page.l = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListPage) NotDone() bool {
	return !page.l.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListPage) Response() List {
	return page.l
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListPage) Values() []Response {
	if page.l.IsEmpty() {
		return nil
	}
	return *page.l.Value
}

// Creates a new instance of the ListPage type.
func NewListPage(cur List, getNextPage func(context.Context, List) (List, error)) ListPage {
	return ListPage{
		fn: getNextPage,
		l:  cur,
	}
}

// ListResponse ...
type ListResponse struct {
	autorest.Response `json:"-"`
	Value             *[]Response `json:"value,omitempty"`
}

// ListResult the list of reservations and summary of roll out count of reservations in each state.
type ListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of reservations.
	Value *[]Response `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
	// Summary - The roll out count summary of the reservations
	Summary *Summary `json:"summary,omitempty"`
}

// MarshalJSON is the custom marshaler for ListResult.
func (lr ListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if lr.Summary != nil {
		objectMap["summary"] = lr.Summary
	}
	return json.Marshal(objectMap)
}

// ListResultIterator provides access to a complete listing of Response values.
type ListResultIterator struct {
	i    int
	page ListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ListResultIterator) Response() ListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ListResultIterator) Value() Response {
	if !iter.page.NotDone() {
		return Response{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ListResultIterator type.
func NewListResultIterator(page ListResultPage) ListResultIterator {
	return ListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (lr ListResult) IsEmpty() bool {
	return lr.Value == nil || len(*lr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (lr ListResult) hasNextLink() bool {
	return lr.NextLink != nil && len(*lr.NextLink) != 0
}

// listResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (lr ListResult) listResultPreparer(ctx context.Context) (*http.Request, error) {
	if !lr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(lr.NextLink)))
}

// ListResultPage contains a page of Response values.
type ListResultPage struct {
	fn func(context.Context, ListResult) (ListResult, error)
	lr ListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.lr)
		if err != nil {
			return err
		}
		page.lr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ListResultPage) NotDone() bool {
	return !page.lr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ListResultPage) Response() ListResult {
	return page.lr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ListResultPage) Values() []Response {
	if page.lr.IsEmpty() {
		return nil
	}
	return *page.lr.Value
}

// Creates a new instance of the ListResultPage type.
func NewListResultPage(cur ListResult, getNextPage func(context.Context, ListResult) (ListResult, error)) ListResultPage {
	return ListResultPage{
		fn: getNextPage,
		lr: cur,
	}
}

// MergeProperties ...
type MergeProperties struct {
	// Sources - Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	Sources *[]string `json:"sources,omitempty"`
}

// MergePropertiesType ...
type MergePropertiesType struct {
	// MergeDestination - Reservation Resource Id Created due to the merge. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	MergeDestination *string `json:"mergeDestination,omitempty"`
	// MergeSources - Resource Ids of the Source Reservation's merged to form this Reservation. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	MergeSources *[]string `json:"mergeSources,omitempty"`
}

// MergeRequest ...
type MergeRequest struct {
	*MergeProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for MergeRequest.
func (mr MergeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mr.MergeProperties != nil {
		objectMap["properties"] = mr.MergeProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for MergeRequest struct.
func (mr *MergeRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var mergeProperties MergeProperties
				err = json.Unmarshal(*v, &mergeProperties)
				if err != nil {
					return err
				}
				mr.MergeProperties = &mergeProperties
			}
		}
	}

	return nil
}

// OperationDisplay ...
type OperationDisplay struct {
	Provider    *string `json:"provider,omitempty"`
	Resource    *string `json:"resource,omitempty"`
	Operation   *string `json:"operation,omitempty"`
	Description *string `json:"description,omitempty"`
}

// OperationList ...
type OperationList struct {
	autorest.Response `json:"-"`
	Value             *[]OperationResponse `json:"value,omitempty"`
	// NextLink - Url to get the next page of items.
	NextLink *string `json:"nextLink,omitempty"`
}

// OperationListIterator provides access to a complete listing of OperationResponse values.
type OperationListIterator struct {
	i    int
	page OperationListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListIterator) Response() OperationList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListIterator) Value() OperationResponse {
	if !iter.page.NotDone() {
		return OperationResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListIterator type.
func NewOperationListIterator(page OperationListPage) OperationListIterator {
	return OperationListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OperationList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OperationList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// operationListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OperationList) operationListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OperationListPage contains a page of OperationResponse values.
type OperationListPage struct {
	fn func(context.Context, OperationList) (OperationList, error)
	ol OperationList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListPage) Response() OperationList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListPage) Values() []OperationResponse {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OperationListPage type.
func NewOperationListPage(cur OperationList, getNextPage func(context.Context, OperationList) (OperationList, error)) OperationListPage {
	return OperationListPage{
		fn: getNextPage,
		ol: cur,
	}
}

// OperationResponse ...
type OperationResponse struct {
	// Name - Name of the operation
	Name *string `json:"name,omitempty"`
	// IsDataAction - Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Display of the operation
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - Origin of the operation
	Origin *string `json:"origin,omitempty"`
	// Properties - Properties of the operation
	Properties interface{} `json:"properties,omitempty"`
}

// OperationResultError required if status == failed or status == canceled.
type OperationResultError struct {
	// Code - Required if status == failed or status == cancelled. If status == failed, provide an invariant error code used for error troubleshooting, aggregation, and analysis.
	Code *string `json:"code,omitempty"`
	// Message - Required if status == failed. Localized. If status == failed, provide an actionable error message indicating what error occurred, and what the user can do to address the issue.
	Message *string `json:"message,omitempty"`
}

// OrderBillingPlanInformation information describing the type of billing plan for this reservation.
type OrderBillingPlanInformation struct {
	// PricingCurrencyTotal - Amount of money to be paid for the Order. Tax is not included.
	PricingCurrencyTotal *Price `json:"pricingCurrencyTotal,omitempty"`
	// StartDate - Date when the billing plan has started.
	StartDate *date.Date `json:"startDate,omitempty"`
	// NextPaymentDueDate - For recurring billing plans, indicates the date when next payment will be processed. Null when total is paid off.
	NextPaymentDueDate *date.Date       `json:"nextPaymentDueDate,omitempty"`
	Transactions       *[]PaymentDetail `json:"transactions,omitempty"`
}

// OrderList ...
type OrderList struct {
	autorest.Response `json:"-"`
	Value             *[]OrderResponse `json:"value,omitempty"`
	// NextLink - Url to get the next page of reservationOrders.
	NextLink *string `json:"nextLink,omitempty"`
}

// OrderListIterator provides access to a complete listing of OrderResponse values.
type OrderListIterator struct {
	i    int
	page OrderListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OrderListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OrderListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OrderListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OrderListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OrderListIterator) Response() OrderList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OrderListIterator) Value() OrderResponse {
	if !iter.page.NotDone() {
		return OrderResponse{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OrderListIterator type.
func NewOrderListIterator(page OrderListPage) OrderListIterator {
	return OrderListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ol OrderList) IsEmpty() bool {
	return ol.Value == nil || len(*ol.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ol OrderList) hasNextLink() bool {
	return ol.NextLink != nil && len(*ol.NextLink) != 0
}

// orderListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ol OrderList) orderListPreparer(ctx context.Context) (*http.Request, error) {
	if !ol.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ol.NextLink)))
}

// OrderListPage contains a page of OrderResponse values.
type OrderListPage struct {
	fn func(context.Context, OrderList) (OrderList, error)
	ol OrderList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OrderListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OrderListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ol)
		if err != nil {
			return err
		}
		page.ol = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OrderListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OrderListPage) NotDone() bool {
	return !page.ol.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OrderListPage) Response() OrderList {
	return page.ol
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OrderListPage) Values() []OrderResponse {
	if page.ol.IsEmpty() {
		return nil
	}
	return *page.ol.Value
}

// Creates a new instance of the OrderListPage type.
func NewOrderListPage(cur OrderList, getNextPage func(context.Context, OrderList) (OrderList, error)) OrderListPage {
	return OrderListPage{
		fn: getNextPage,
		ol: cur,
	}
}

// OrderProperties ...
type OrderProperties struct {
	// DisplayName - Friendly name for user to easily identified the reservation.
	DisplayName *string `json:"displayName,omitempty"`
	// RequestDateTime - This is the DateTime when the reservation was initially requested for purchase.
	RequestDateTime *date.Time `json:"requestDateTime,omitempty"`
	// CreatedDateTime - This is the DateTime when the reservation was created.
	CreatedDateTime *date.Time `json:"createdDateTime,omitempty"`
	// ExpiryDate - This is the date when the Reservation will expire.
	ExpiryDate *date.Date `json:"expiryDate,omitempty"`
	// BenefitStartTime - This is the DateTime when the reservation benefit started.
	BenefitStartTime *date.Time `json:"benefitStartTime,omitempty"`
	// OriginalQuantity - Total Quantity of the SKUs purchased in the Reservation.
	OriginalQuantity *int32 `json:"originalQuantity,omitempty"`
	// Term - Possible values include: 'ReservationTermP1Y', 'ReservationTermP3Y', 'ReservationTermP5Y'
	Term ReservationTerm `json:"term,omitempty"`
	// ProvisioningState - Current state of the reservation. Possible values include: 'ProvisioningState1Creating', 'ProvisioningState1PendingResourceHold', 'ProvisioningState1ConfirmedResourceHold', 'ProvisioningState1PendingBilling', 'ProvisioningState1ConfirmedBilling', 'ProvisioningState1Created', 'ProvisioningState1Succeeded', 'ProvisioningState1Cancelled', 'ProvisioningState1Expired', 'ProvisioningState1BillingFailed', 'ProvisioningState1Failed', 'ProvisioningState1Split', 'ProvisioningState1Merged'
	ProvisioningState ProvisioningState1 `json:"provisioningState,omitempty"`
	// BillingPlan - Possible values include: 'ReservationBillingPlanUpfront', 'ReservationBillingPlanMonthly'
	BillingPlan          ReservationBillingPlan       `json:"billingPlan,omitempty"`
	PlanInformation      *OrderBillingPlanInformation `json:"planInformation,omitempty"`
	ReservationsProperty *[]Response                  `json:"reservations,omitempty"`
}

// OrderPurchaseFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type OrderPurchaseFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(OrderClient) (OrderResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *OrderPurchaseFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for OrderPurchaseFuture.Result.
func (future *OrderPurchaseFuture) result(client OrderClient) (or OrderResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.OrderPurchaseFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		or.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.OrderPurchaseFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if or.Response.Response, err = future.GetResult(sender); err == nil && or.Response.Response.StatusCode != http.StatusNoContent {
		or, err = client.PurchaseResponder(or.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.OrderPurchaseFuture", "Result", or.Response.Response, "Failure responding to request")
		}
	}
	return
}

// OrderResponse ...
type OrderResponse struct {
	autorest.Response `json:"-"`
	Etag              *int32 `json:"etag,omitempty"`
	// ID - READ-ONLY; Identifier of the reservation
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the reservation
	Name             *string `json:"name,omitempty"`
	*OrderProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/reservations"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for OrderResponse.
func (or OrderResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if or.Etag != nil {
		objectMap["etag"] = or.Etag
	}
	if or.OrderProperties != nil {
		objectMap["properties"] = or.OrderProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OrderResponse struct.
func (or *OrderResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "etag":
			if v != nil {
				var etag int32
				err = json.Unmarshal(*v, &etag)
				if err != nil {
					return err
				}
				or.Etag = &etag
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				or.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				or.Name = &name
			}
		case "properties":
			if v != nil {
				var orderProperties OrderProperties
				err = json.Unmarshal(*v, &orderProperties)
				if err != nil {
					return err
				}
				or.OrderProperties = &orderProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				or.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				or.SystemData = &systemData
			}
		}
	}

	return nil
}

// Patch ...
type Patch struct {
	*PatchProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for Patch.
func (p Patch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.PatchProperties != nil {
		objectMap["properties"] = p.PatchProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Patch struct.
func (p *Patch) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var patchProperties PatchProperties
				err = json.Unmarshal(*v, &patchProperties)
				if err != nil {
					return err
				}
				p.PatchProperties = &patchProperties
			}
		}
	}

	return nil
}

// PatchProperties ...
type PatchProperties struct {
	// AppliedScopeType - Possible values include: 'AppliedScopeTypeSingle', 'AppliedScopeTypeShared'
	AppliedScopeType AppliedScopeType `json:"appliedScopeType,omitempty"`
	AppliedScopes    *[]string        `json:"appliedScopes,omitempty"`
	// InstanceFlexibility - Possible values include: 'InstanceFlexibilityOn', 'InstanceFlexibilityOff'
	InstanceFlexibility InstanceFlexibility `json:"instanceFlexibility,omitempty"`
	// Name - Name of the Reservation
	Name            *string                         `json:"name,omitempty"`
	Renew           *bool                           `json:"renew,omitempty"`
	RenewProperties *PatchPropertiesRenewProperties `json:"renewProperties,omitempty"`
}

// PatchPropertiesRenewProperties ...
type PatchPropertiesRenewProperties struct {
	PurchaseProperties *PurchaseRequest `json:"purchaseProperties,omitempty"`
}

// PaymentDetail information about payment related to a reservation order.
type PaymentDetail struct {
	// DueDate - Date when the payment needs to be done.
	DueDate *date.Date `json:"dueDate,omitempty"`
	// PaymentDate - Date when the transaction is completed. Is null when it is scheduled.
	PaymentDate *date.Date `json:"paymentDate,omitempty"`
	// PricingCurrencyTotal - Amount in pricing currency. Tax not included.
	PricingCurrencyTotal *Price `json:"pricingCurrencyTotal,omitempty"`
	// BillingCurrencyTotal - Amount charged in Billing currency. Tax not included. Is null for future payments
	BillingCurrencyTotal *Price `json:"billingCurrencyTotal,omitempty"`
	// BillingAccount - Shows the Account that is charged for this payment.
	BillingAccount *string `json:"billingAccount,omitempty"`
	// Status - Possible values include: 'PaymentStatusSucceeded', 'PaymentStatusFailed', 'PaymentStatusScheduled', 'PaymentStatusCancelled'
	Status             PaymentStatus       `json:"status,omitempty"`
	ExtendedStatusInfo *ExtendedStatusInfo `json:"extendedStatusInfo,omitempty"`
}

// Price ...
type Price struct {
	// CurrencyCode - The ISO 4217 3-letter currency code for the currency used by this purchase record.
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// Properties the properties of the reservations
type Properties struct {
	// ReservedResourceType - The type of the resource that is being reserved. Possible values include: 'ReservedResourceTypeVirtualMachines', 'ReservedResourceTypeSQLDatabases', 'ReservedResourceTypeSuseLinux', 'ReservedResourceTypeCosmosDb', 'ReservedResourceTypeRedHat', 'ReservedResourceTypeSQLDataWarehouse', 'ReservedResourceTypeVMwareCloudSimple', 'ReservedResourceTypeRedHatOsa', 'ReservedResourceTypeDatabricks', 'ReservedResourceTypeAppService', 'ReservedResourceTypeManagedDisk', 'ReservedResourceTypeBlockBlob', 'ReservedResourceTypeRedisCache', 'ReservedResourceTypeAzureDataExplorer', 'ReservedResourceTypeMySQL', 'ReservedResourceTypeMariaDb', 'ReservedResourceTypePostgreSQL', 'ReservedResourceTypeDedicatedHost', 'ReservedResourceTypeSapHana', 'ReservedResourceTypeSQLAzureHybridBenefit', 'ReservedResourceTypeAVS', 'ReservedResourceTypeDataFactory', 'ReservedResourceTypeNetAppStorage', 'ReservedResourceTypeAzureFiles', 'ReservedResourceTypeSQLEdge', 'ReservedResourceTypeVirtualMachineSoftware'
	ReservedResourceType ReservedResourceType `json:"reservedResourceType,omitempty"`
	// InstanceFlexibility - Allows reservation discount to be applied across skus within the same Autofit group. Not all skus support instance size flexibility. Possible values include: 'InstanceFlexibilityOn', 'InstanceFlexibilityOff'
	InstanceFlexibility InstanceFlexibility `json:"instanceFlexibility,omitempty"`
	// DisplayName - Friendly name for user to easily identify the reservation
	DisplayName *string `json:"displayName,omitempty"`
	// AppliedScopes - The list of applied scopes
	AppliedScopes *[]string `json:"appliedScopes,omitempty"`
	// AppliedScopeType - The applied scope type. Possible values include: 'AppliedScopeTypeSingle', 'AppliedScopeTypeShared'
	AppliedScopeType AppliedScopeType `json:"appliedScopeType,omitempty"`
	// Archived - Indicates if the reservation is archived
	Archived *bool `json:"archived,omitempty"`
	// Capabilities - Capabilities of the reservation
	Capabilities *string `json:"capabilities,omitempty"`
	// Quantity - Quantity of the SKUs that are part of the Reservation.
	Quantity *int32 `json:"quantity,omitempty"`
	// ProvisioningState - Current state of the reservation. Possible values include: 'ProvisioningStateCreating', 'ProvisioningStatePendingResourceHold', 'ProvisioningStateConfirmedResourceHold', 'ProvisioningStatePendingBilling', 'ProvisioningStateConfirmedBilling', 'ProvisioningStateCreated', 'ProvisioningStateSucceeded', 'ProvisioningStateCancelled', 'ProvisioningStateExpired', 'ProvisioningStateBillingFailed', 'ProvisioningStateFailed', 'ProvisioningStateSplit', 'ProvisioningStateMerged'
	ProvisioningState ProvisioningState `json:"provisioningState,omitempty"`
	// EffectiveDateTime - DateTime of the Reservation starting when this version is effective from.
	EffectiveDateTime *date.Time `json:"effectiveDateTime,omitempty"`
	// BenefitStartTime - This is the DateTime when the reservation benefit started.
	BenefitStartTime *date.Time `json:"benefitStartTime,omitempty"`
	// LastUpdatedDateTime - READ-ONLY; DateTime of the last time the Reservation was updated.
	LastUpdatedDateTime *date.Time `json:"lastUpdatedDateTime,omitempty"`
	// ExpiryDate - This is the date when the Reservation will expire.
	ExpiryDate *date.Date `json:"expiryDate,omitempty"`
	// SkuDescription - Description of the SKU in english.
	SkuDescription *string `json:"skuDescription,omitempty"`
	// ExtendedStatusInfo - The message giving detailed information about the status code.
	ExtendedStatusInfo *ExtendedStatusInfo `json:"extendedStatusInfo,omitempty"`
	// BillingPlan - The billing plan options available for this SKU. Possible values include: 'ReservationBillingPlanUpfront', 'ReservationBillingPlanMonthly'
	BillingPlan ReservationBillingPlan `json:"billingPlan,omitempty"`
	// DisplayProvisioningState - READ-ONLY; The provisioning state of the reservation for display, e.g. Succeeded
	DisplayProvisioningState *string `json:"displayProvisioningState,omitempty"`
	// ProvisioningSubState - READ-ONLY; The provisioning state of the reservation, e.g. Succeeded
	ProvisioningSubState *string `json:"provisioningSubState,omitempty"`
	// PurchaseDate - This is the date when the Reservation was purchased.
	PurchaseDate    *date.Date           `json:"purchaseDate,omitempty"`
	SplitProperties *SplitPropertiesType `json:"splitProperties,omitempty"`
	MergeProperties *MergePropertiesType `json:"mergeProperties,omitempty"`
	BillingScopeID  *string              `json:"billingScopeId,omitempty"`
	// Renew - Setting this to true will automatically purchase a new reservation on the expiration date time.
	Renew *bool `json:"renew,omitempty"`
	// RenewSource - Reservation Id of the reservation from which this reservation is renewed. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}.
	RenewSource *string `json:"renewSource,omitempty"`
	// RenewDestination - Reservation Id of the reservation which is purchased because of renew. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}.
	RenewDestination *string                  `json:"renewDestination,omitempty"`
	RenewProperties  *RenewPropertiesResponse `json:"renewProperties,omitempty"`
	// Term - Represent the term of Reservation. Possible values include: 'ReservationTermP1Y', 'ReservationTermP3Y', 'ReservationTermP5Y'
	Term ReservationTerm `json:"term,omitempty"`
	// UserFriendlyAppliedScopeType - READ-ONLY; The applied scope type of the reservation for display, e.g. Shared
	UserFriendlyAppliedScopeType *string `json:"userFriendlyAppliedScopeType,omitempty"`
	// UserFriendlyRenewState - READ-ONLY; The renew state of the reservation for display, e.g. On
	UserFriendlyRenewState *string `json:"userFriendlyRenewState,omitempty"`
	// Utilization - READ-ONLY; Reservation utilization
	Utilization *PropertiesUtilization `json:"utilization,omitempty"`
}

// MarshalJSON is the custom marshaler for Properties.
func (p Properties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.ReservedResourceType != "" {
		objectMap["reservedResourceType"] = p.ReservedResourceType
	}
	if p.InstanceFlexibility != "" {
		objectMap["instanceFlexibility"] = p.InstanceFlexibility
	}
	if p.DisplayName != nil {
		objectMap["displayName"] = p.DisplayName
	}
	if p.AppliedScopes != nil {
		objectMap["appliedScopes"] = p.AppliedScopes
	}
	if p.AppliedScopeType != "" {
		objectMap["appliedScopeType"] = p.AppliedScopeType
	}
	if p.Archived != nil {
		objectMap["archived"] = p.Archived
	}
	if p.Capabilities != nil {
		objectMap["capabilities"] = p.Capabilities
	}
	if p.Quantity != nil {
		objectMap["quantity"] = p.Quantity
	}
	if p.ProvisioningState != "" {
		objectMap["provisioningState"] = p.ProvisioningState
	}
	if p.EffectiveDateTime != nil {
		objectMap["effectiveDateTime"] = p.EffectiveDateTime
	}
	if p.BenefitStartTime != nil {
		objectMap["benefitStartTime"] = p.BenefitStartTime
	}
	if p.ExpiryDate != nil {
		objectMap["expiryDate"] = p.ExpiryDate
	}
	if p.SkuDescription != nil {
		objectMap["skuDescription"] = p.SkuDescription
	}
	if p.ExtendedStatusInfo != nil {
		objectMap["extendedStatusInfo"] = p.ExtendedStatusInfo
	}
	if p.BillingPlan != "" {
		objectMap["billingPlan"] = p.BillingPlan
	}
	if p.PurchaseDate != nil {
		objectMap["purchaseDate"] = p.PurchaseDate
	}
	if p.SplitProperties != nil {
		objectMap["splitProperties"] = p.SplitProperties
	}
	if p.MergeProperties != nil {
		objectMap["mergeProperties"] = p.MergeProperties
	}
	if p.BillingScopeID != nil {
		objectMap["billingScopeId"] = p.BillingScopeID
	}
	if p.Renew != nil {
		objectMap["renew"] = p.Renew
	}
	if p.RenewSource != nil {
		objectMap["renewSource"] = p.RenewSource
	}
	if p.RenewDestination != nil {
		objectMap["renewDestination"] = p.RenewDestination
	}
	if p.RenewProperties != nil {
		objectMap["renewProperties"] = p.RenewProperties
	}
	if p.Term != "" {
		objectMap["term"] = p.Term
	}
	return json.Marshal(objectMap)
}

// PropertiesUtilization reservation utilization
type PropertiesUtilization struct {
	// Trend - READ-ONLY; The number of days trend for a reservation
	Trend *string `json:"trend,omitempty"`
	// Aggregates - The array of aggregates of a reservation's utilization
	Aggregates *[]UtilizationAggregates `json:"aggregates,omitempty"`
}

// MarshalJSON is the custom marshaler for PropertiesUtilization.
func (p PropertiesUtilization) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if p.Aggregates != nil {
		objectMap["aggregates"] = p.Aggregates
	}
	return json.Marshal(objectMap)
}

// PurchaseRequest ...
type PurchaseRequest struct {
	Sku *SkuName `json:"sku,omitempty"`
	// Location - The Azure Region where the reserved resource lives.
	Location                   *string `json:"location,omitempty"`
	*PurchaseRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PurchaseRequest.
func (pr PurchaseRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pr.Sku != nil {
		objectMap["sku"] = pr.Sku
	}
	if pr.Location != nil {
		objectMap["location"] = pr.Location
	}
	if pr.PurchaseRequestProperties != nil {
		objectMap["properties"] = pr.PurchaseRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PurchaseRequest struct.
func (pr *PurchaseRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "sku":
			if v != nil {
				var sku SkuName
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				pr.Sku = &sku
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pr.Location = &location
			}
		case "properties":
			if v != nil {
				var purchaseRequestProperties PurchaseRequestProperties
				err = json.Unmarshal(*v, &purchaseRequestProperties)
				if err != nil {
					return err
				}
				pr.PurchaseRequestProperties = &purchaseRequestProperties
			}
		}
	}

	return nil
}

// PurchaseRequestProperties ...
type PurchaseRequestProperties struct {
	// ReservedResourceType - Possible values include: 'ReservedResourceTypeVirtualMachines', 'ReservedResourceTypeSQLDatabases', 'ReservedResourceTypeSuseLinux', 'ReservedResourceTypeCosmosDb', 'ReservedResourceTypeRedHat', 'ReservedResourceTypeSQLDataWarehouse', 'ReservedResourceTypeVMwareCloudSimple', 'ReservedResourceTypeRedHatOsa', 'ReservedResourceTypeDatabricks', 'ReservedResourceTypeAppService', 'ReservedResourceTypeManagedDisk', 'ReservedResourceTypeBlockBlob', 'ReservedResourceTypeRedisCache', 'ReservedResourceTypeAzureDataExplorer', 'ReservedResourceTypeMySQL', 'ReservedResourceTypeMariaDb', 'ReservedResourceTypePostgreSQL', 'ReservedResourceTypeDedicatedHost', 'ReservedResourceTypeSapHana', 'ReservedResourceTypeSQLAzureHybridBenefit', 'ReservedResourceTypeAVS', 'ReservedResourceTypeDataFactory', 'ReservedResourceTypeNetAppStorage', 'ReservedResourceTypeAzureFiles', 'ReservedResourceTypeSQLEdge', 'ReservedResourceTypeVirtualMachineSoftware'
	ReservedResourceType ReservedResourceType `json:"reservedResourceType,omitempty"`
	BillingScopeID       *string              `json:"billingScopeId,omitempty"`
	// Term - Possible values include: 'ReservationTermP1Y', 'ReservationTermP3Y', 'ReservationTermP5Y'
	Term ReservationTerm `json:"term,omitempty"`
	// BillingPlan - Possible values include: 'ReservationBillingPlanUpfront', 'ReservationBillingPlanMonthly'
	BillingPlan ReservationBillingPlan `json:"billingPlan,omitempty"`
	// Quantity - Quantity of the SKUs that are part of the Reservation.
	Quantity *int32 `json:"quantity,omitempty"`
	// DisplayName - Friendly name of the Reservation
	DisplayName *string `json:"displayName,omitempty"`
	// AppliedScopeType - Possible values include: 'AppliedScopeTypeSingle', 'AppliedScopeTypeShared'
	AppliedScopeType AppliedScopeType `json:"appliedScopeType,omitempty"`
	AppliedScopes    *[]string        `json:"appliedScopes,omitempty"`
	Renew            *bool            `json:"renew,omitempty"`
	// ReservedResourceProperties - Properties specific to each reserved resource type. Not required if not applicable.
	ReservedResourceProperties *PurchaseRequestPropertiesReservedResourceProperties `json:"reservedResourceProperties,omitempty"`
}

// PurchaseRequestPropertiesReservedResourceProperties properties specific to each reserved resource type.
// Not required if not applicable.
type PurchaseRequestPropertiesReservedResourceProperties struct {
	// InstanceFlexibility - Possible values include: 'InstanceFlexibilityOn', 'InstanceFlexibilityOff'
	InstanceFlexibility InstanceFlexibility `json:"instanceFlexibility,omitempty"`
}

// QuotaCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type QuotaCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(QuotaClient) (SetObject, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *QuotaCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for QuotaCreateOrUpdateFuture.Result.
func (future *QuotaCreateOrUpdateFuture) result(client QuotaClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.QuotaCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		so.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.QuotaCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.CreateOrUpdateResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.QuotaCreateOrUpdateFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// QuotaLimits quota limits.
type QuotaLimits struct {
	autorest.Response `json:"-"`
	// Value - List of quotas (service limits).
	Value *[]CurrentQuotaLimitBase `json:"value,omitempty"`
	// NextLink - The URI for fetching the next page of quotas (service limits). When no more pages exist, the value is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// QuotaLimitsIterator provides access to a complete listing of CurrentQuotaLimitBase values.
type QuotaLimitsIterator struct {
	i    int
	page QuotaLimitsPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *QuotaLimitsIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaLimitsIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *QuotaLimitsIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter QuotaLimitsIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter QuotaLimitsIterator) Response() QuotaLimits {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter QuotaLimitsIterator) Value() CurrentQuotaLimitBase {
	if !iter.page.NotDone() {
		return CurrentQuotaLimitBase{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the QuotaLimitsIterator type.
func NewQuotaLimitsIterator(page QuotaLimitsPage) QuotaLimitsIterator {
	return QuotaLimitsIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (ql QuotaLimits) IsEmpty() bool {
	return ql.Value == nil || len(*ql.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (ql QuotaLimits) hasNextLink() bool {
	return ql.NextLink != nil && len(*ql.NextLink) != 0
}

// quotaLimitsPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (ql QuotaLimits) quotaLimitsPreparer(ctx context.Context) (*http.Request, error) {
	if !ql.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(ql.NextLink)))
}

// QuotaLimitsPage contains a page of CurrentQuotaLimitBase values.
type QuotaLimitsPage struct {
	fn func(context.Context, QuotaLimits) (QuotaLimits, error)
	ql QuotaLimits
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *QuotaLimitsPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaLimitsPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.ql)
		if err != nil {
			return err
		}
		page.ql = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *QuotaLimitsPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page QuotaLimitsPage) NotDone() bool {
	return !page.ql.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page QuotaLimitsPage) Response() QuotaLimits {
	return page.ql
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page QuotaLimitsPage) Values() []CurrentQuotaLimitBase {
	if page.ql.IsEmpty() {
		return nil
	}
	return *page.ql.Value
}

// Creates a new instance of the QuotaLimitsPage type.
func NewQuotaLimitsPage(cur QuotaLimits, getNextPage func(context.Context, QuotaLimits) (QuotaLimits, error)) QuotaLimitsPage {
	return QuotaLimitsPage{
		fn: getNextPage,
		ql: cur,
	}
}

// QuotaLimitsResponse quotas (service limits) in the request response.
type QuotaLimitsResponse struct {
	// Value - List of quotas with the quota request status.
	Value *[]CurrentQuotaLimit `json:"value,omitempty"`
	// NextLink - The URI for fetching the next page of quota limits. When no more pages exist, the value is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// QuotaProperties quota properties for the resource.
type QuotaProperties struct {
	// Limit - Quota properties.
	Limit *int32 `json:"limit,omitempty"`
	// CurrentValue - READ-ONLY; Current usage value for the resource.
	CurrentValue *int32 `json:"currentValue,omitempty"`
	// Unit -  The limit units, such as **count** and **bytes**. Use the unit field provided in the response of the GET quota operation.
	Unit *string `json:"unit,omitempty"`
	// Name - Name of the resource provide by the resource provider. Use this property for quotaRequests resource operations.
	Name *ResourceName `json:"name,omitempty"`
	// ResourceType - The name of the resource type. Possible values include: 'ResourceTypeStandard', 'ResourceTypeDedicated', 'ResourceTypeLowPriority', 'ResourceTypeShared', 'ResourceTypeServiceSpecific'
	ResourceType ResourceType `json:"resourceType,omitempty"`
	// QuotaPeriod - READ-ONLY; The time period over which the quota usage values are summarized. For example, P1D (per one day), PT1M (per one minute), and PT1S (per one second). This parameter is optional because, for some resources such as compute, the time period is irrelevant.
	QuotaPeriod *string `json:"quotaPeriod,omitempty"`
	// Properties - Additional properties for the specified resource provider.
	Properties interface{} `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaProperties.
func (qp QuotaProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qp.Limit != nil {
		objectMap["limit"] = qp.Limit
	}
	if qp.Unit != nil {
		objectMap["unit"] = qp.Unit
	}
	if qp.Name != nil {
		objectMap["name"] = qp.Name
	}
	if qp.ResourceType != "" {
		objectMap["resourceType"] = qp.ResourceType
	}
	if qp.Properties != nil {
		objectMap["properties"] = qp.Properties
	}
	return json.Marshal(objectMap)
}

// QuotaRequestDetails quota request details.
type QuotaRequestDetails struct {
	autorest.Response `json:"-"`
	// ID - READ-ONLY; Quota request ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Quota request name.
	Name *string `json:"name,omitempty"`
	// QuotaRequestProperties - Quota request details.
	*QuotaRequestProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestDetails.
func (qrd QuotaRequestDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrd.QuotaRequestProperties != nil {
		objectMap["properties"] = qrd.QuotaRequestProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestDetails struct.
func (qrd *QuotaRequestDetails) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				qrd.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				qrd.Name = &name
			}
		case "properties":
			if v != nil {
				var quotaRequestProperties QuotaRequestProperties
				err = json.Unmarshal(*v, &quotaRequestProperties)
				if err != nil {
					return err
				}
				qrd.QuotaRequestProperties = &quotaRequestProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				qrd.Type = &typeVar
			}
		}
	}

	return nil
}

// QuotaRequestDetailsList quota request details.
type QuotaRequestDetailsList struct {
	autorest.Response `json:"-"`
	// Value - The quota requests.
	Value *[]QuotaRequestDetails `json:"value,omitempty"`
	// NextLink - The URI to fetch the next page of quota limits. When there are no more pages, this is null.
	NextLink *string `json:"nextLink,omitempty"`
}

// QuotaRequestDetailsListIterator provides access to a complete listing of QuotaRequestDetails values.
type QuotaRequestDetailsListIterator struct {
	i    int
	page QuotaRequestDetailsListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *QuotaRequestDetailsListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaRequestDetailsListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *QuotaRequestDetailsListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter QuotaRequestDetailsListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter QuotaRequestDetailsListIterator) Response() QuotaRequestDetailsList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter QuotaRequestDetailsListIterator) Value() QuotaRequestDetails {
	if !iter.page.NotDone() {
		return QuotaRequestDetails{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the QuotaRequestDetailsListIterator type.
func NewQuotaRequestDetailsListIterator(page QuotaRequestDetailsListPage) QuotaRequestDetailsListIterator {
	return QuotaRequestDetailsListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (qrdl QuotaRequestDetailsList) IsEmpty() bool {
	return qrdl.Value == nil || len(*qrdl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (qrdl QuotaRequestDetailsList) hasNextLink() bool {
	return qrdl.NextLink != nil && len(*qrdl.NextLink) != 0
}

// quotaRequestDetailsListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (qrdl QuotaRequestDetailsList) quotaRequestDetailsListPreparer(ctx context.Context) (*http.Request, error) {
	if !qrdl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(qrdl.NextLink)))
}

// QuotaRequestDetailsListPage contains a page of QuotaRequestDetails values.
type QuotaRequestDetailsListPage struct {
	fn   func(context.Context, QuotaRequestDetailsList) (QuotaRequestDetailsList, error)
	qrdl QuotaRequestDetailsList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *QuotaRequestDetailsListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/QuotaRequestDetailsListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.qrdl)
		if err != nil {
			return err
		}
		page.qrdl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *QuotaRequestDetailsListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page QuotaRequestDetailsListPage) NotDone() bool {
	return !page.qrdl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page QuotaRequestDetailsListPage) Response() QuotaRequestDetailsList {
	return page.qrdl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page QuotaRequestDetailsListPage) Values() []QuotaRequestDetails {
	if page.qrdl.IsEmpty() {
		return nil
	}
	return *page.qrdl.Value
}

// Creates a new instance of the QuotaRequestDetailsListPage type.
func NewQuotaRequestDetailsListPage(cur QuotaRequestDetailsList, getNextPage func(context.Context, QuotaRequestDetailsList) (QuotaRequestDetailsList, error)) QuotaRequestDetailsListPage {
	return QuotaRequestDetailsListPage{
		fn:   getNextPage,
		qrdl: cur,
	}
}

// QuotaRequestOneResourceProperties the details of quota request.
type QuotaRequestOneResourceProperties struct {
	// ProvisioningState - READ-ONLY; The quota request status. Possible values include: 'QuotaRequestStateAccepted', 'QuotaRequestStateInvalid', 'QuotaRequestStateSucceeded', 'QuotaRequestStateFailed', 'QuotaRequestStateInProgress'
	ProvisioningState QuotaRequestState `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// RequestSubmitTime - READ-ONLY; The time when the quota request was submitted using format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
	RequestSubmitTime *date.Time `json:"requestSubmitTime,omitempty"`
	// CurrentQuotaLimitBase - The quota request addition properties.
	*CurrentQuotaLimitBase `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestOneResourceProperties.
func (qrorp QuotaRequestOneResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrorp.CurrentQuotaLimitBase != nil {
		objectMap["properties"] = qrorp.CurrentQuotaLimitBase
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestOneResourceProperties struct.
func (qrorp *QuotaRequestOneResourceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "provisioningState":
			if v != nil {
				var provisioningState QuotaRequestState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				qrorp.ProvisioningState = provisioningState
			}
		case "message":
			if v != nil {
				var message string
				err = json.Unmarshal(*v, &message)
				if err != nil {
					return err
				}
				qrorp.Message = &message
			}
		case "requestSubmitTime":
			if v != nil {
				var requestSubmitTime date.Time
				err = json.Unmarshal(*v, &requestSubmitTime)
				if err != nil {
					return err
				}
				qrorp.RequestSubmitTime = &requestSubmitTime
			}
		case "properties":
			if v != nil {
				var currentQuotaLimitBase CurrentQuotaLimitBase
				err = json.Unmarshal(*v, &currentQuotaLimitBase)
				if err != nil {
					return err
				}
				qrorp.CurrentQuotaLimitBase = &currentQuotaLimitBase
			}
		}
	}

	return nil
}

// QuotaRequestOneResourceSubmitResponse response for the quota submission request.
type QuotaRequestOneResourceSubmitResponse struct {
	// ID - READ-ONLY; The quota request ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/ServiceLimits"
	Type *string `json:"type,omitempty"`
	// QuotaRequestOneResourceProperties - The details for quota request.
	*QuotaRequestOneResourceProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestOneResourceSubmitResponse.
func (qrorsr QuotaRequestOneResourceSubmitResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrorsr.QuotaRequestOneResourceProperties != nil {
		objectMap["properties"] = qrorsr.QuotaRequestOneResourceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestOneResourceSubmitResponse struct.
func (qrorsr *QuotaRequestOneResourceSubmitResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				qrorsr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				qrorsr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				qrorsr.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var quotaRequestOneResourceProperties QuotaRequestOneResourceProperties
				err = json.Unmarshal(*v, &quotaRequestOneResourceProperties)
				if err != nil {
					return err
				}
				qrorsr.QuotaRequestOneResourceProperties = &quotaRequestOneResourceProperties
			}
		}
	}

	return nil
}

// QuotaRequestProperties the details of quota request.
type QuotaRequestProperties struct {
	// ProvisioningState - The quota request status. Possible values include: 'QuotaRequestStateAccepted', 'QuotaRequestStateInvalid', 'QuotaRequestStateSucceeded', 'QuotaRequestStateFailed', 'QuotaRequestStateInProgress'
	ProvisioningState QuotaRequestState `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User friendly status message.
	Message *string `json:"message,omitempty"`
	// RequestSubmitTime - READ-ONLY; The time when the quota request was submitted using format: yyyy-MM-ddTHH:mm:ssZ as specified by the ISO 8601 standard.
	RequestSubmitTime *date.Time `json:"requestSubmitTime,omitempty"`
	// Value - The quotaRequests.
	Value *[]SubRequest `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestProperties.
func (qrp QuotaRequestProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrp.ProvisioningState != "" {
		objectMap["provisioningState"] = qrp.ProvisioningState
	}
	if qrp.Value != nil {
		objectMap["value"] = qrp.Value
	}
	return json.Marshal(objectMap)
}

// QuotaRequestStatusDetails quota request status details.
type QuotaRequestStatusDetails struct {
	// ProvisioningState - READ-ONLY; The details of the quota request status. Possible values include: 'QuotaRequestStateAccepted', 'QuotaRequestStateInvalid', 'QuotaRequestStateSucceeded', 'QuotaRequestStateFailed', 'QuotaRequestStateInProgress'
	ProvisioningState QuotaRequestState `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; A user friendly message.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestStatusDetails.
func (qrsd QuotaRequestStatusDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// QuotaRequestSubmitResponse response for the quota submission request.
type QuotaRequestSubmitResponse struct {
	// ID - READ-ONLY; The quota request ID.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the quota request.
	Name *string `json:"name,omitempty"`
	// Properties - The quota request details.
	Properties *QuotaRequestProperties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/serviceLimits"
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestSubmitResponse.
func (qrsr QuotaRequestSubmitResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrsr.Properties != nil {
		objectMap["properties"] = qrsr.Properties
	}
	return json.Marshal(objectMap)
}

// QuotaRequestSubmitResponse201 response with request ID that the quota request was accepted.
type QuotaRequestSubmitResponse201 struct {
	// ID - READ-ONLY; The quota request ID. Use the requestId parameter to check the request status.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Operation ID
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type
	Type *string `json:"type,omitempty"`
	// QuotaRequestStatusDetails - Quota request status.
	*QuotaRequestStatusDetails `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for QuotaRequestSubmitResponse201.
func (qrsr2 QuotaRequestSubmitResponse201) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if qrsr2.QuotaRequestStatusDetails != nil {
		objectMap["properties"] = qrsr2.QuotaRequestStatusDetails
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for QuotaRequestSubmitResponse201 struct.
func (qrsr2 *QuotaRequestSubmitResponse201) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				qrsr2.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				qrsr2.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				qrsr2.Type = &typeVar
			}
		case "properties":
			if v != nil {
				var quotaRequestStatusDetails QuotaRequestStatusDetails
				err = json.Unmarshal(*v, &quotaRequestStatusDetails)
				if err != nil {
					return err
				}
				qrsr2.QuotaRequestStatusDetails = &quotaRequestStatusDetails
			}
		}
	}

	return nil
}

// QuotaUpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type QuotaUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(QuotaClient) (SetObject, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *QuotaUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for QuotaUpdateFuture.Result.
func (future *QuotaUpdateFuture) result(client QuotaClient) (so SetObject, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.QuotaUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		so.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.QuotaUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if so.Response.Response, err = future.GetResult(sender); err == nil && so.Response.Response.StatusCode != http.StatusNoContent {
		so, err = client.UpdateResponder(so.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.QuotaUpdateFuture", "Result", so.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RenewPropertiesResponse ...
type RenewPropertiesResponse struct {
	PurchaseProperties *PurchaseRequest `json:"purchaseProperties,omitempty"`
	// PricingCurrencyTotal - Amount that Microsoft uses for record. Used during refund for calculating refund limit. Tax is not included. This is locked price 30 days before expiry.
	PricingCurrencyTotal *RenewPropertiesResponsePricingCurrencyTotal `json:"pricingCurrencyTotal,omitempty"`
	// BillingCurrencyTotal - Currency and amount that customer will be charged in customer's local currency for renewal purchase. Tax is not included.
	BillingCurrencyTotal *RenewPropertiesResponseBillingCurrencyTotal `json:"billingCurrencyTotal,omitempty"`
}

// RenewPropertiesResponseBillingCurrencyTotal currency and amount that customer will be charged in
// customer's local currency for renewal purchase. Tax is not included.
type RenewPropertiesResponseBillingCurrencyTotal struct {
	// CurrencyCode - The ISO 4217 3-letter currency code for the currency used by this purchase record.
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// RenewPropertiesResponsePricingCurrencyTotal amount that Microsoft uses for record. Used during refund
// for calculating refund limit. Tax is not included. This is locked price 30 days before expiry.
type RenewPropertiesResponsePricingCurrencyTotal struct {
	// CurrencyCode - The ISO 4217 3-letter currency code for the currency used by this purchase record.
	CurrencyCode *string  `json:"currencyCode,omitempty"`
	Amount       *float64 `json:"amount,omitempty"`
}

// ReservationAvailableScopesFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ReservationAvailableScopesFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (AvailableScopeProperties, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ReservationAvailableScopesFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ReservationAvailableScopesFuture.Result.
func (future *ReservationAvailableScopesFuture) result(client Client) (asp AvailableScopeProperties, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ReservationAvailableScopesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		asp.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.ReservationAvailableScopesFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if asp.Response.Response, err = future.GetResult(sender); err == nil && asp.Response.Response.StatusCode != http.StatusNoContent {
		asp, err = client.AvailableScopesResponder(asp.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ReservationAvailableScopesFuture", "Result", asp.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ReservationMergeFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ReservationMergeFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (ListResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ReservationMergeFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ReservationMergeFuture.Result.
func (future *ReservationMergeFuture) result(client Client) (lr ListResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ReservationMergeFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.ReservationMergeFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lr.Response.Response, err = future.GetResult(sender); err == nil && lr.Response.Response.StatusCode != http.StatusNoContent {
		lr, err = client.MergeResponder(lr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ReservationMergeFuture", "Result", lr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ReservationUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ReservationUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ReservationUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ReservationUpdateFuture.Result.
func (future *ReservationUpdateFuture) result(client Client) (r Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.ReservationUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		r.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.ReservationUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if r.Response.Response, err = future.GetResult(sender); err == nil && r.Response.Response.StatusCode != http.StatusNoContent {
		r, err = client.UpdateResponder(r.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.ReservationUpdateFuture", "Result", r.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ResourceName resource name provided by the resource provider. Use this property for quotaRequest
// parameter.
type ResourceName struct {
	// Value - Resource name.
	Value *string `json:"value,omitempty"`
	// LocalizedValue - READ-ONLY; Resource display localized name.
	LocalizedValue *string `json:"localizedValue,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceName.
func (rn ResourceName) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rn.Value != nil {
		objectMap["value"] = rn.Value
	}
	return json.Marshal(objectMap)
}

// Response the definition of the reservation.
type Response struct {
	autorest.Response `json:"-"`
	// Location - The Azure Region where the reserved resource lives.
	Location *string `json:"location,omitempty"`
	Etag     *int32  `json:"etag,omitempty"`
	// ID - READ-ONLY; Identifier of the reservation
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Name of the reservation
	Name *string `json:"name,omitempty"`
	// Sku - The sku information associated to this reservation
	Sku *SkuName `json:"sku,omitempty"`
	// Properties - The properties associated to this reservation
	Properties *Properties `json:"properties,omitempty"`
	// Type - READ-ONLY; Type of resource. "Microsoft.Capacity/reservationOrders/reservations"
	Type *string `json:"type,omitempty"`
	// Kind - Resource Provider type to be reserved. Possible values include: 'KindMicrosoftCompute'
	Kind Kind `json:"kind,omitempty"`
	// SystemData - READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Response.
func (r Response) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if r.Location != nil {
		objectMap["location"] = r.Location
	}
	if r.Etag != nil {
		objectMap["etag"] = r.Etag
	}
	if r.Sku != nil {
		objectMap["sku"] = r.Sku
	}
	if r.Properties != nil {
		objectMap["properties"] = r.Properties
	}
	if r.Kind != "" {
		objectMap["kind"] = r.Kind
	}
	return json.Marshal(objectMap)
}

// ScopeProperties ...
type ScopeProperties struct {
	Scope *string `json:"scope,omitempty"`
	Valid *bool   `json:"valid,omitempty"`
}

// ServiceError the API error details.
type ServiceError struct {
	// Code - The error code.
	Code *string `json:"code,omitempty"`
	// Message - The error message text.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; The list of error details.
	Details *[]ServiceErrorDetail `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceError.
func (se ServiceError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if se.Code != nil {
		objectMap["code"] = se.Code
	}
	if se.Message != nil {
		objectMap["message"] = se.Message
	}
	return json.Marshal(objectMap)
}

// ServiceErrorDetail the error details.
type ServiceErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceErrorDetail.
func (sed ServiceErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SetObject ...
type SetObject struct {
	autorest.Response `json:"-"`
	Value             interface{} `json:"value,omitempty"`
}

// SkuCapability ...
type SkuCapability struct {
	// Name - An invariant to describe the feature.
	Name *string `json:"name,omitempty"`
	// Value - An invariant if the feature is measured by quantity.
	Value *string `json:"value,omitempty"`
}

// SkuName ...
type SkuName struct {
	Name *string `json:"name,omitempty"`
}

// SkuProperty ...
type SkuProperty struct {
	// Name - An invariant to describe the feature.
	Name *string `json:"name,omitempty"`
	// Value - An invariant if the feature is measured by quantity.
	Value *string `json:"value,omitempty"`
}

// SkuRestriction ...
type SkuRestriction struct {
	// Type - The type of restrictions.
	Type *string `json:"type,omitempty"`
	// Values - The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
	Values *[]string `json:"values,omitempty"`
	// ReasonCode - The reason for restriction.
	ReasonCode *string `json:"reasonCode,omitempty"`
}

// SplitFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type SplitFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(Client) (ListResponse, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SplitFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SplitFuture.Result.
func (future *SplitFuture) result(client Client) (lr ListResponse, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "reservations.SplitFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		lr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("reservations.SplitFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if lr.Response.Response, err = future.GetResult(sender); err == nil && lr.Response.Response.StatusCode != http.StatusNoContent {
		lr, err = client.SplitResponder(lr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "reservations.SplitFuture", "Result", lr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SplitProperties ...
type SplitProperties struct {
	// Quantities - List of the quantities in the new reservations to create.
	Quantities *[]int32 `json:"quantities,omitempty"`
	// ReservationID - Resource id of the reservation to be split. Format of the resource id should be /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	ReservationID *string `json:"reservationId,omitempty"`
}

// SplitPropertiesType ...
type SplitPropertiesType struct {
	// SplitDestinations - List of destination Resource Id that are created due to split. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	SplitDestinations *[]string `json:"splitDestinations,omitempty"`
	// SplitSource - Resource Id of the Reservation from which this is split. Format of the resource Id is /providers/Microsoft.Capacity/reservationOrders/{reservationOrderId}/reservations/{reservationId}
	SplitSource *string `json:"splitSource,omitempty"`
}

// SplitRequest ...
type SplitRequest struct {
	*SplitProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SplitRequest.
func (sr SplitRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.SplitProperties != nil {
		objectMap["properties"] = sr.SplitProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SplitRequest struct.
func (sr *SplitRequest) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var splitProperties SplitProperties
				err = json.Unmarshal(*v, &splitProperties)
				if err != nil {
					return err
				}
				sr.SplitProperties = &splitProperties
			}
		}
	}

	return nil
}

// SubRequest the sub-request submitted with the quota request.
type SubRequest struct {
	// Limit - READ-ONLY; Quota (resource limit).
	Limit *int32 `json:"limit,omitempty"`
	// Name - The resource name.
	Name *ResourceName `json:"name,omitempty"`
	// ResourceType - READ-ONLY; Resource type for which the quota check was made.
	ResourceType *string `json:"resourceType,omitempty"`
	// Unit -  The limit units, such as **count** and **bytes**. Use the unit field provided in the response of the GET quota operation.
	Unit *string `json:"unit,omitempty"`
	// ProvisioningState - The quota request status. Possible values include: 'QuotaRequestStateAccepted', 'QuotaRequestStateInvalid', 'QuotaRequestStateSucceeded', 'QuotaRequestStateFailed', 'QuotaRequestStateInProgress'
	ProvisioningState QuotaRequestState `json:"provisioningState,omitempty"`
	// Message - READ-ONLY; User-friendly status message.
	Message *string `json:"message,omitempty"`
	// SubRequestID - READ-ONLY; Sub request ID for individual request.
	SubRequestID *string `json:"subRequestId,omitempty"`
}

// MarshalJSON is the custom marshaler for SubRequest.
func (sr SubRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sr.Name != nil {
		objectMap["name"] = sr.Name
	}
	if sr.Unit != nil {
		objectMap["unit"] = sr.Unit
	}
	if sr.ProvisioningState != "" {
		objectMap["provisioningState"] = sr.ProvisioningState
	}
	return json.Marshal(objectMap)
}

// SubscriptionScopeProperties ...
type SubscriptionScopeProperties struct {
	Scopes *[]ScopeProperties `json:"scopes,omitempty"`
}

// Summary the roll up count summary of reservations in each state
type Summary struct {
	// SucceededCount - READ-ONLY; The number of reservation in Succeeded state
	SucceededCount *float64 `json:"succeededCount,omitempty"`
	// FailedCount - READ-ONLY; The number of reservation in Failed state
	FailedCount *float64 `json:"failedCount,omitempty"`
	// ExpiringCount - READ-ONLY; The number of reservation in Expiring state
	ExpiringCount *float64 `json:"expiringCount,omitempty"`
	// ExpiredCount - READ-ONLY; The number of reservation in Expired state
	ExpiredCount *float64 `json:"expiredCount,omitempty"`
	// PendingCount - READ-ONLY; The number of reservation in Pending state
	PendingCount *float64 `json:"pendingCount,omitempty"`
	// CancelledCount - READ-ONLY; The number of reservation in Cancelled state
	CancelledCount *float64 `json:"cancelledCount,omitempty"`
	// ProcessingCount - READ-ONLY; The number of reservation in Processing state
	ProcessingCount *float64 `json:"processingCount,omitempty"`
}

// MarshalJSON is the custom marshaler for Summary.
func (s Summary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'CreatedByTypeUser', 'CreatedByTypeApplication', 'CreatedByTypeManagedIdentity', 'CreatedByTypeKey'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// ToExchange reservation refund details
type ToExchange struct {
	// ReservationID - Fully qualified id of the Reservation being returned.
	ReservationID *string `json:"reservationId,omitempty"`
	// Quantity - Quantity to be returned
	Quantity            *int32              `json:"quantity,omitempty"`
	BillingRefundAmount *Price              `json:"billingRefundAmount,omitempty"`
	BillingInformation  *BillingInformation `json:"billingInformation,omitempty"`
}

// ToPurchaseCalculateExchange reservation purchase details
type ToPurchaseCalculateExchange struct {
	Properties           *PurchaseRequest `json:"properties,omitempty"`
	BillingCurrencyTotal *Price           `json:"billingCurrencyTotal,omitempty"`
}

// ToPurchaseExchange reservation purchase details
type ToPurchaseExchange struct {
	// ReservationOrderID - Fully qualified id of the ReservationOrder being purchased
	ReservationOrderID *string `json:"reservationOrderId,omitempty"`
	// ReservationID - Fully qualified id of the Reservation being purchased. This value is only guaranteed to be non-null if the purchase is successful.
	ReservationID        *string          `json:"reservationId,omitempty"`
	Properties           *PurchaseRequest `json:"properties,omitempty"`
	BillingCurrencyTotal *Price           `json:"billingCurrencyTotal,omitempty"`
	// Status - Possible values include: 'OperationStatusSucceeded', 'OperationStatusFailed', 'OperationStatusCancelled', 'OperationStatusPending'
	Status OperationStatus `json:"status,omitempty"`
}

// ToReturn reservation to return
type ToReturn struct {
	// ReservationID - Fully qualified identifier of the Reservation being returned
	ReservationID *string `json:"reservationId,omitempty"`
	// Quantity - Quantity to be returned. Must be greater than zero.
	Quantity *int32 `json:"quantity,omitempty"`
}

// ToReturnForExchange reservation refund details
type ToReturnForExchange struct {
	// ReservationID - Fully qualified id of the Reservation being returned.
	ReservationID *string `json:"reservationId,omitempty"`
	// Quantity - Quantity to be returned
	Quantity            *int32              `json:"quantity,omitempty"`
	BillingRefundAmount *Price              `json:"billingRefundAmount,omitempty"`
	BillingInformation  *BillingInformation `json:"billingInformation,omitempty"`
	// Status - Possible values include: 'OperationStatusSucceeded', 'OperationStatusFailed', 'OperationStatusCancelled', 'OperationStatusPending'
	Status OperationStatus `json:"status,omitempty"`
}

// UtilizationAggregates the aggregate values of reservation utilization
type UtilizationAggregates struct {
	// Grain - READ-ONLY; The grain of the aggregate
	Grain *float64 `json:"grain,omitempty"`
	// GrainUnit - READ-ONLY; The grain unit of the aggregate
	GrainUnit *string `json:"grainUnit,omitempty"`
	// Value - READ-ONLY; The aggregate value
	Value *float64 `json:"value,omitempty"`
	// ValueUnit - READ-ONLY; The aggregate value unit
	ValueUnit *string `json:"valueUnit,omitempty"`
}

// MarshalJSON is the custom marshaler for UtilizationAggregates.
func (ua UtilizationAggregates) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}
