package signalr

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"net/http"
)

// SkuTier enumerates the values for sku tier.
type SkuTier string

const (
	// Basic ...
	Basic SkuTier = "Basic"
	// Free ...
	Free SkuTier = "Free"
	// Premium ...
	Premium SkuTier = "Premium"
)

// PossibleSkuTierValues returns an array of possible values for the SkuTier const type.
func PossibleSkuTierValues() []SkuTier {
	return []SkuTier{Basic, Free, Premium}
}

// CheckNameAvailabilityResponse result of the request to check name availability. It contains a flag and possible
// reason of failure.
type CheckNameAvailabilityResponse struct {
	autorest.Response `json:"-"`
	// NameAvailable - indicates whether the name is available or not.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Reason - The reason of the availability. Required if name is not available.
	Reason *string `json:"reason,omitempty"`
	// Message - The message of the operation.
	Message *string `json:"message,omitempty"`
}

// CreateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type CreateFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future CreateFuture) Result(client Client) (rr ResourceResponse, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.CreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return rr, azure.NewAsyncOpIncompleteError("signalr.CreateFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		rr, err = client.CreateResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.CreateFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.CreateFuture", "Result", resp, "Failure sending request")
		return
	}
	rr, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.CreateFuture", "Result", resp, "Failure responding to request")
	}
	return
}

// CreateSignalRResourceRequest parameters for SignalR service create/update operation
type CreateSignalRResourceRequest struct {
	// Location - The location of the SignalR service.
	Location *string `json:"location,omitempty"`
	// Tags - A list of key value pairs that describe the resource.
	Tags map[string]*string `json:"tags"`
	// Sku - The billing information of the resource.(e.g. basic vs. standard)
	Sku *ResourceSku `json:"sku,omitempty"`
	// Properties - Settings used to provision or configure the resource
	Properties *CreateSignalRResourceRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CreateSignalRResourceRequest.
func (csrrr CreateSignalRResourceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if csrrr.Location != nil {
		objectMap["location"] = csrrr.Location
	}
	if csrrr.Tags != nil {
		objectMap["tags"] = csrrr.Tags
	}
	if csrrr.Sku != nil {
		objectMap["sku"] = csrrr.Sku
	}
	if csrrr.Properties != nil {
		objectMap["properties"] = csrrr.Properties
	}
	return json.Marshal(objectMap)
}

// CreateSignalRResourceRequestProperties settings used to provision or configure the resource.
type CreateSignalRResourceRequestProperties struct {
	// DomainLabel - leaf domain name of SignalR service.
	DomainLabel *string `json:"domainLabel,omitempty"`
}

// DeleteFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type DeleteFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future DeleteFuture) Result(client Client) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.DeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return ar, azure.NewAsyncOpIncompleteError("signalr.DeleteFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		ar, err = client.DeleteResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.DeleteFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.DeleteFuture", "Result", resp, "Failure sending request")
		return
	}
	ar, err = client.DeleteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.DeleteFuture", "Result", resp, "Failure responding to request")
	}
	return
}

// GetResourceAsyncOperationResultFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type GetResourceAsyncOperationResultFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future GetResourceAsyncOperationResultFuture) Result(client Client) (rr ResourceResponse, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.GetResourceAsyncOperationResultFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return rr, azure.NewAsyncOpIncompleteError("signalr.GetResourceAsyncOperationResultFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		rr, err = client.GetResourceAsyncOperationResultResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.GetResourceAsyncOperationResultFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.GetResourceAsyncOperationResultFuture", "Result", resp, "Failure sending request")
		return
	}
	rr, err = client.GetResourceAsyncOperationResultResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.GetResourceAsyncOperationResultFuture", "Result", resp, "Failure responding to request")
	}
	return
}

// GetSubscriptionAsyncOperationResultFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type GetSubscriptionAsyncOperationResultFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future GetSubscriptionAsyncOperationResultFuture) Result(client Client) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.GetSubscriptionAsyncOperationResultFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return ar, azure.NewAsyncOpIncompleteError("signalr.GetSubscriptionAsyncOperationResultFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		ar, err = client.GetSubscriptionAsyncOperationResultResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.GetSubscriptionAsyncOperationResultFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.GetSubscriptionAsyncOperationResultFuture", "Result", resp, "Failure sending request")
		return
	}
	ar, err = client.GetSubscriptionAsyncOperationResultResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.GetSubscriptionAsyncOperationResultFuture", "Result", resp, "Failure responding to request")
	}
	return
}

// KeysResponse a class represents the access keys of SignalR service.
type KeysResponse struct {
	autorest.Response `json:"-"`
	// PrimaryKey - The primary access key.
	PrimaryKey *string `json:"primaryKey,omitempty"`
	// SecondaryKey - The secondary access key.
	SecondaryKey *string `json:"secondaryKey,omitempty"`
}

// MetricSpecification metrics Specification
type MetricSpecification struct {
	// Name - Name of the metric.
	Name *string `json:"name,omitempty"`
	// DisplayName - Friendly display name of the metric.
	DisplayName *string `json:"displayName,omitempty"`
	// DisplayDescription - Friendly description of the metric.
	DisplayDescription *string `json:"displayDescription,omitempty"`
	// Unit - the unit of the metric.
	Unit *string `json:"unit,omitempty"`
	// AggregationType - the aggregation type of the metric.
	AggregationType *string `json:"aggregationType,omitempty"`
	// FillGapWithZero - fill gap with zero.
	FillGapWithZero *string `json:"fillGapWithZero,omitempty"`
	// Category - the category of the metric.
	Category *string `json:"category,omitempty"`
}

// MoveResourcesFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type MoveResourcesFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future MoveResourcesFuture) Result(client Client) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.MoveResourcesFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return ar, azure.NewAsyncOpIncompleteError("signalr.MoveResourcesFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		ar, err = client.MoveResourcesResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.MoveResourcesFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.MoveResourcesFuture", "Result", resp, "Failure sending request")
		return
	}
	ar, err = client.MoveResourcesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.MoveResourcesFuture", "Result", resp, "Failure responding to request")
	}
	return
}

// MoveResourcesRequest a class describes the parameters for resources move operation
type MoveResourcesRequest struct {
	// TargetResourceGroup - The target resourceGroup name.
	TargetResourceGroup *string `json:"targetResourceGroup,omitempty"`
	// Resources - An list of ResourceIds to move.
	Resources *[]string `json:"resources,omitempty"`
}

// NameAvailabilityRequest data POST-ed to the nameAvailability action
type NameAvailabilityRequest struct {
	// Type - The resource type. Should be always "Microsoft.SignalR/SignalR".
	Type *string `json:"type,omitempty"`
	// Name - The SignalR service name to validate. e.g."my-signalR-name-here"
	Name *string `json:"name,omitempty"`
	// LeafDomain - the leaf domain name.
	LeafDomain *string `json:"leafDomain,omitempty"`
}

// Operation REST API operation.
type Operation struct {
	// Name - Operation name: {provider}/{resource}/{operation}
	Name *string `json:"name,omitempty"`
	// Display - The object that describes the operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - Optional. The intended executor of the operation; governs the display of the operation in the RBAC UX and the audit logs UX.
	Origin *string `json:"origin,omitempty"`
	// Properties - Extra properties for the operation.
	Properties *OperationProperties `json:"properties,omitempty"`
}

// OperationDisplay the object that describes a operation.
type OperationDisplay struct {
	// Provider - Friendly name of the resource provider
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource type on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
	// Operation - The localized friendly name for the operation.
	Operation *string `json:"operation,omitempty"`
	// Description - The localized friendly description for the operation
	Description *string `json:"description,omitempty"`
}

// OperationListResponse result of the request to list REST API operations. It contains a list of operations.
type OperationListResponse struct {
	autorest.Response `json:"-"`
	// Value - List of operations supported by the resource provider.
	Value *[]Operation `json:"value,omitempty"`
}

// OperationProperties extra Operation properties.
type OperationProperties struct {
	// ServiceSpecification - The service specifications.
	ServiceSpecification *ServiceSpecification `json:"serviceSpecification,omitempty"`
}

// PatchSignalRResourceRequest parameters for SignalR service update operation
type PatchSignalRResourceRequest struct {
	// Location - The location of the SignalR service.
	Location *string `json:"location,omitempty"`
	// Tags - A list of key value pairs that describe the resource.
	Tags map[string]*string `json:"tags"`
	// Sku - The billing information of the resource.(e.g. basic vs. standard)
	Sku *ResourceSku `json:"sku,omitempty"`
	// Properties - Settings used to provision or configure the resource
	Properties interface{} `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for PatchSignalRResourceRequest.
func (psrrr PatchSignalRResourceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if psrrr.Location != nil {
		objectMap["location"] = psrrr.Location
	}
	if psrrr.Tags != nil {
		objectMap["tags"] = psrrr.Tags
	}
	if psrrr.Sku != nil {
		objectMap["sku"] = psrrr.Sku
	}
	objectMap["properties"] = psrrr.Properties
	return json.Marshal(objectMap)
}

// RegenerateKeyFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type RegenerateKeyFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future RegenerateKeyFuture) Result(client Client) (kr KeysResponse, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.RegenerateKeyFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return kr, azure.NewAsyncOpIncompleteError("signalr.RegenerateKeyFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		kr, err = client.RegenerateKeyResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.RegenerateKeyFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.RegenerateKeyFuture", "Result", resp, "Failure sending request")
		return
	}
	kr, err = client.RegenerateKeyResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.RegenerateKeyFuture", "Result", resp, "Failure responding to request")
	}
	return
}

// ResourceListResponse object that includes an array of SignalR services and a possible link for next set.
type ResourceListResponse struct {
	autorest.Response `json:"-"`
	// Values - List of SignalR services
	Values *[]ResourceResponse `json:"values,omitempty"`
	// NextLink - Link for next set of SignalR services.
	NextLink *string `json:"nextLink,omitempty"`
}

// ResourceResponse a class represent a SignalR service.
type ResourceResponse struct {
	autorest.Response `json:"-"`
	// ID - The unique ResourceId of SignalR
	ID *string `json:"id,omitempty"`
	// Location - the location of the SignalR service.
	Location *string `json:"location,omitempty"`
	// Name - name of the service
	Name *string `json:"name,omitempty"`
	// Type - resource type of service - e.g. "Microsoft.SignalR/SignalR"
	Type *string `json:"type,omitempty"`
	// Tags - Tags of the service.
	Tags map[string]*string `json:"tags"`
	// Sku - SKU of the service.
	Sku *ResourceSku `json:"sku,omitempty"`
	// ResponseProperties - The properties of the service.
	*ResponseProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceResponse.
func (rr ResourceResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rr.ID != nil {
		objectMap["id"] = rr.ID
	}
	if rr.Location != nil {
		objectMap["location"] = rr.Location
	}
	if rr.Name != nil {
		objectMap["name"] = rr.Name
	}
	if rr.Type != nil {
		objectMap["type"] = rr.Type
	}
	if rr.Tags != nil {
		objectMap["tags"] = rr.Tags
	}
	if rr.Sku != nil {
		objectMap["sku"] = rr.Sku
	}
	if rr.ResponseProperties != nil {
		objectMap["properties"] = rr.ResponseProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ResourceResponse struct.
func (rr *ResourceResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rr.ID = &ID
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rr.Location = &location
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rr.Type = &typeVar
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rr.Tags = tags
			}
		case "sku":
			if v != nil {
				var sku ResourceSku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				rr.Sku = &sku
			}
		case "properties":
			if v != nil {
				var responseProperties ResponseProperties
				err = json.Unmarshal(*v, &responseProperties)
				if err != nil {
					return err
				}
				rr.ResponseProperties = &responseProperties
			}
		}
	}

	return nil
}

// ResourceSku the billing information of the resource.(e.g. basic vs. standard)
type ResourceSku struct {
	// Name - The name of the SKU. This is typically a letter + number code, such as A0 or P3.  Required (if sku is specified)
	Name *string `json:"name,omitempty"`
	// Tier - The tier of this particular SKU. Optional. Possible values include: 'Free', 'Basic', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - Optional, string. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - Optional, string. If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - Optional, integer. If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not
	// possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// ResponseProperties a class that describes the properties of the SignalR service.
type ResponseProperties struct {
	// ProvisioningState - Provisioning state of the resource.
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// Status - Running status of the SignalR service.
	Status *string `json:"status,omitempty"`
	// IsSuspended - Whether the service is suspended or not.
	IsSuspended *bool `json:"isSuspended,omitempty"`
	// ExternalIP - The publicly accessible IP of the SignalR service.
	ExternalIP *string `json:"externalIP,omitempty"`
	// Fqdn - FQDN of the SignalR service instance.
	Fqdn *string `json:"fqdn,omitempty"`
	// PublicPort - The publicly accessibly port of the SignalR service which is designed for browser/client side usage.
	PublicPort *int32 `json:"publicPort,omitempty"`
	// ServerPort - The publicly accessibly port of the SignalR service which is designed for customer server side usage.
	ServerPort *int32 `json:"serverPort,omitempty"`
}

// ServiceSpecification an object that describes a specification
type ServiceSpecification struct {
	// MetricSpecifications - Specifications ofr Metrics.
	MetricSpecifications *[]MetricSpecification `json:"metricSpecifications,omitempty"`
}

// UpdateFuture an abstraction for monitoring and retrieving the results of a long-running operation.
type UpdateFuture struct {
	azure.Future
	req *http.Request
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future UpdateFuture) Result(client Client) (rr ResourceResponse, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.UpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		return rr, azure.NewAsyncOpIncompleteError("signalr.UpdateFuture")
	}
	if future.PollingMethod() == azure.PollingLocation {
		rr, err = client.UpdateResponder(future.Response())
		if err != nil {
			err = autorest.NewErrorWithError(err, "signalr.UpdateFuture", "Result", future.Response(), "Failure responding to request")
		}
		return
	}
	var req *http.Request
	var resp *http.Response
	if future.PollingURL() != "" {
		req, err = http.NewRequest(http.MethodGet, future.PollingURL(), nil)
		if err != nil {
			return
		}
	} else {
		req = autorest.ChangeToGet(future.req)
	}
	resp, err = autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.UpdateFuture", "Result", resp, "Failure sending request")
		return
	}
	rr, err = client.UpdateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "signalr.UpdateFuture", "Result", resp, "Failure responding to request")
	}
	return
}
