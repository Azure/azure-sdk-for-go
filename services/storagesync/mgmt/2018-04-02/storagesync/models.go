package storagesync

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/to"
	"net/http"
)

// CloudTiering enumerates the values for cloud tiering.
type CloudTiering string

const (
	// Off ...
	Off CloudTiering = "off"
	// On ...
	On CloudTiering = "on"
)

// PossibleCloudTieringValues returns an array of possible values for the CloudTiering const type.
func PossibleCloudTieringValues() []CloudTiering {
	return []CloudTiering{Off, On}
}

// CloudTiering1 enumerates the values for cloud tiering 1.
type CloudTiering1 string

const (
	// CloudTiering1Off ...
	CloudTiering1Off CloudTiering1 = "off"
	// CloudTiering1On ...
	CloudTiering1On CloudTiering1 = "on"
)

// PossibleCloudTiering1Values returns an array of possible values for the CloudTiering1 const type.
func PossibleCloudTiering1Values() []CloudTiering1 {
	return []CloudTiering1{CloudTiering1Off, CloudTiering1On}
}

// CloudTiering2 enumerates the values for cloud tiering 2.
type CloudTiering2 string

const (
	// CloudTiering2Off ...
	CloudTiering2Off CloudTiering2 = "off"
	// CloudTiering2On ...
	CloudTiering2On CloudTiering2 = "on"
)

// PossibleCloudTiering2Values returns an array of possible values for the CloudTiering2 const type.
func PossibleCloudTiering2Values() []CloudTiering2 {
	return []CloudTiering2{CloudTiering2Off, CloudTiering2On}
}

// NameAvailabilityReason enumerates the values for name availability reason.
type NameAvailabilityReason string

const (
	// AlreadyExists ...
	AlreadyExists NameAvailabilityReason = "AlreadyExists"
	// Invalid ...
	Invalid NameAvailabilityReason = "Invalid"
)

// PossibleNameAvailabilityReasonValues returns an array of possible values for the NameAvailabilityReason const type.
func PossibleNameAvailabilityReasonValues() []NameAvailabilityReason {
	return []NameAvailabilityReason{AlreadyExists, Invalid}
}

// Operation enumerates the values for operation.
type Operation string

const (
	// Cancel ...
	Cancel Operation = "cancel"
	// Do ...
	Do Operation = "do"
	// Undo ...
	Undo Operation = "undo"
)

// PossibleOperationValues returns an array of possible values for the Operation const type.
func PossibleOperationValues() []Operation {
	return []Operation{Cancel, Do, Undo}
}

// Reason enumerates the values for reason.
type Reason string

const (
	// Deleted ...
	Deleted Reason = "Deleted"
	// Registered ...
	Registered Reason = "Registered"
	// Suspended ...
	Suspended Reason = "Suspended"
	// Unregistered ...
	Unregistered Reason = "Unregistered"
	// Warned ...
	Warned Reason = "Warned"
)

// PossibleReasonValues returns an array of possible values for the Reason const type.
func PossibleReasonValues() []Reason {
	return []Reason{Deleted, Registered, Suspended, Unregistered, Warned}
}

// Status enumerates the values for status.
type Status string

const (
	// Aborted ...
	Aborted Status = "aborted"
	// Active ...
	Active Status = "active"
	// Expired ...
	Expired Status = "expired"
	// Failed ...
	Failed Status = "failed"
	// Succeeded ...
	Succeeded Status = "succeeded"
)

// PossibleStatusValues returns an array of possible values for the Status const type.
func PossibleStatusValues() []Status {
	return []Status{Aborted, Active, Expired, Failed, Succeeded}
}

// APIError error type
type APIError struct {
	// Code - Error code of the given entry.
	Code *string `json:"code,omitempty"`
	// Message - Error message of the given entry.
	Message *string `json:"message,omitempty"`
	// Target - Target of the given error entry.
	Target *string `json:"target,omitempty"`
	// Details - Error details of the given entry.
	Details *ErrorDetails `json:"details,omitempty"`
}

// AzureEntityResource the resource model definition for a Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// BackupRequest backup request
type BackupRequest struct {
	// AzureFileShare - Azure File Share.
	AzureFileShare *string `json:"azureFileShare,omitempty"`
}

// CheckNameAvailabilityParameters parameters for a check name availability request.
type CheckNameAvailabilityParameters struct {
	// Name - The name to check for availability
	Name *string `json:"name,omitempty"`
	// Type - The resource type. Must be set to Microsoft.StorageSync/storageSyncServices
	Type *string `json:"type,omitempty"`
}

// CheckNameAvailabilityResult the CheckNameAvailability operation response.
type CheckNameAvailabilityResult struct {
	autorest.Response `json:"-"`
	// NameAvailable - Gets a boolean value that indicates whether the name is available for you to use. If true, the name is available. If false, the name has already been taken or invalid and cannot be used.
	NameAvailable *bool `json:"nameAvailable,omitempty"`
	// Reason - Gets the reason that a Storage Sync Service name could not be used. The Reason element is only returned if NameAvailable is false. Possible values include: 'Invalid', 'AlreadyExists'
	Reason NameAvailabilityReason `json:"reason,omitempty"`
	// Message - Gets an error message explaining the Reason value in more detail.
	Message *string `json:"message,omitempty"`
}

// CloudEndpoint cloud Endpoint object.
type CloudEndpoint struct {
	autorest.Response `json:"-"`
	// CloudEndpointProperties - Cloud Endpoint properties.
	*CloudEndpointProperties `json:"properties,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for CloudEndpoint.
func (ce CloudEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ce.CloudEndpointProperties != nil {
		objectMap["properties"] = ce.CloudEndpointProperties
	}
	if ce.ID != nil {
		objectMap["id"] = ce.ID
	}
	if ce.Name != nil {
		objectMap["name"] = ce.Name
	}
	if ce.Type != nil {
		objectMap["type"] = ce.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CloudEndpoint struct.
func (ce *CloudEndpoint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var cloudEndpointProperties CloudEndpointProperties
				err = json.Unmarshal(*v, &cloudEndpointProperties)
				if err != nil {
					return err
				}
				ce.CloudEndpointProperties = &cloudEndpointProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				ce.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				ce.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				ce.Type = &typeVar
			}
		}
	}

	return nil
}

// CloudEndpointArray array of CloudEndpoint
type CloudEndpointArray struct {
	autorest.Response `json:"-"`
	// Value - Collection of CloudEndpoint.
	Value *[]CloudEndpoint `json:"value,omitempty"`
}

// CloudEndpointCreateParameters the parameters used when creating a storage sync service.
type CloudEndpointCreateParameters struct {
	// Location - Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
	Tags map[string]*string `json:"tags"`
	// CloudEndpointCreateParametersProperties - The parameters used to create the storage sync service.
	*CloudEndpointCreateParametersProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for CloudEndpointCreateParameters.
func (cecp CloudEndpointCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cecp.Location != nil {
		objectMap["location"] = cecp.Location
	}
	if cecp.Tags != nil {
		objectMap["tags"] = cecp.Tags
	}
	if cecp.CloudEndpointCreateParametersProperties != nil {
		objectMap["properties"] = cecp.CloudEndpointCreateParametersProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for CloudEndpointCreateParameters struct.
func (cecp *CloudEndpointCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				cecp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				cecp.Tags = tags
			}
		case "properties":
			if v != nil {
				var cloudEndpointCreateParametersProperties CloudEndpointCreateParametersProperties
				err = json.Unmarshal(*v, &cloudEndpointCreateParametersProperties)
				if err != nil {
					return err
				}
				cecp.CloudEndpointCreateParametersProperties = &cloudEndpointCreateParametersProperties
			}
		}
	}

	return nil
}

// CloudEndpointCreateParametersProperties cloudEndpoint Properties object.
type CloudEndpointCreateParametersProperties struct {
	// StorageAccountResourceID - Storage Account Resource Id
	StorageAccountResourceID *string `json:"storageAccountResourceId,omitempty"`
	// StorageAccountShareName - Storage Account Share name
	StorageAccountShareName *string `json:"storageAccountShareName,omitempty"`
	// StorageAccountTenantID - Storage Account Tenant Id
	StorageAccountTenantID *string `json:"storageAccountTenantId,omitempty"`
}

// CloudEndpointProperties cloudEndpoint Properties object.
type CloudEndpointProperties struct {
	// StorageAccountResourceID - Storage Account Resource Id
	StorageAccountResourceID *string `json:"storageAccountResourceId,omitempty"`
	// StorageAccountShareName - Storage Account Share name
	StorageAccountShareName *string `json:"storageAccountShareName,omitempty"`
	// StorageAccountTenantID - Storage Account Tenant Id
	StorageAccountTenantID *string `json:"storageAccountTenantId,omitempty"`
	// PartnershipID - Partnership Id
	PartnershipID *string `json:"partnershipId,omitempty"`
	// FriendlyName - Friendly Name
	FriendlyName *string `json:"friendlyName,omitempty"`
	// BackupEnabled - Backup Enabled
	BackupEnabled *bool `json:"backupEnabled,omitempty"`
	// ProvisioningState - CloudEndpoint Provisioning State
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// LastWorkflowID - CloudEndpoint lastWorkflowId
	LastWorkflowID *string `json:"lastWorkflowId,omitempty"`
	// LastOperationName - Resource Last Operation Name
	LastOperationName *string `json:"lastOperationName,omitempty"`
}

// CloudEndpointsGroupCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CloudEndpointsGroupCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CloudEndpointsGroupCreateFuture) Result(client CloudEndpointsGroupClient) (ce CloudEndpoint, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.CloudEndpointsGroupCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if ce.Response.Response, err = future.GetResult(sender); err == nil && ce.Response.Response.StatusCode != http.StatusNoContent {
		ce, err = client.CreateResponder(ce.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupCreateFuture", "Result", ce.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CloudEndpointsGroupDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CloudEndpointsGroupDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CloudEndpointsGroupDeleteFuture) Result(client CloudEndpointsGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.CloudEndpointsGroupDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// CloudEndpointsGroupPostBackupFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CloudEndpointsGroupPostBackupFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CloudEndpointsGroupPostBackupFuture) Result(client CloudEndpointsGroupClient) (pbr PostBackupResponse, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupPostBackupFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.CloudEndpointsGroupPostBackupFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pbr.Response.Response, err = future.GetResult(sender); err == nil && pbr.Response.Response.StatusCode != http.StatusNoContent {
		pbr, err = client.PostBackupResponder(pbr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupPostBackupFuture", "Result", pbr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// CloudEndpointsGroupPostRestoreFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CloudEndpointsGroupPostRestoreFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CloudEndpointsGroupPostRestoreFuture) Result(client CloudEndpointsGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupPostRestoreFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.CloudEndpointsGroupPostRestoreFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// CloudEndpointsGroupPreBackupFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CloudEndpointsGroupPreBackupFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CloudEndpointsGroupPreBackupFuture) Result(client CloudEndpointsGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupPreBackupFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.CloudEndpointsGroupPreBackupFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// CloudEndpointsGroupPreRestoreFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type CloudEndpointsGroupPreRestoreFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *CloudEndpointsGroupPreRestoreFuture) Result(client CloudEndpointsGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.CloudEndpointsGroupPreRestoreFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.CloudEndpointsGroupPreRestoreFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Error error type
type Error struct {
	// Error - Error details of the given entry.
	Error *APIError `json:"error,omitempty"`
	// Innererror - Error details of the given entry.
	Innererror *APIError `json:"innererror,omitempty"`
}

// ErrorDetails error Details object.
type ErrorDetails struct {
	// Code - Error code of the given entry.
	Code *string `json:"code,omitempty"`
	// Message - Error message of the given entry.
	Message *string `json:"message,omitempty"`
	// Target - Target of the given entry.
	Target *string `json:"target,omitempty"`
}

// OperationDisplayInfo the operation supported by storage sync.
type OperationDisplayInfo struct {
	// Description - The description of the operation.
	Description *string `json:"description,omitempty"`
	// Operation - The action that users can perform, based on their permission level.
	Operation *string `json:"operation,omitempty"`
	// Provider - Service provider: Microsoft StorageSync.
	Provider *string `json:"provider,omitempty"`
	// Resource - Resource on which the operation is performed.
	Resource *string `json:"resource,omitempty"`
}

// OperationDisplayResource operation Display Resource object.
type OperationDisplayResource struct {
	// Provider - Operation Display Resource Provider.
	Provider *string `json:"provider,omitempty"`
	// Resource - Operation Display Resource.
	Resource *string `json:"resource,omitempty"`
	// Operation - Operation Display Resource Operation.
	Operation *string `json:"operation,omitempty"`
	// Description - Operation Display Resource Description.
	Description *string `json:"description,omitempty"`
}

// OperationEntity the operation supported by storage sync.
type OperationEntity struct {
	// Name - Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`
	// Display - The operation supported by storage sync.
	Display *OperationDisplayInfo `json:"display,omitempty"`
	// Origin - The origin.
	Origin *string `json:"origin,omitempty"`
}

// OperationEntityListResult the list of storage sync operations.
type OperationEntityListResult struct {
	autorest.Response `json:"-"`
	// NextLink - The link used to get the next page of operations.
	NextLink *string `json:"nextLink,omitempty"`
	// Value - The list of operations.
	Value *[]OperationEntity `json:"value,omitempty"`
}

// OperationEntityListResultIterator provides access to a complete listing of OperationEntity values.
type OperationEntityListResultIterator struct {
	i    int
	page OperationEntityListResultPage
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationEntityListResultIterator) Next() error {
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err := iter.page.Next()
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationEntityListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationEntityListResultIterator) Response() OperationEntityListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationEntityListResultIterator) Value() OperationEntity {
	if !iter.page.NotDone() {
		return OperationEntity{}
	}
	return iter.page.Values()[iter.i]
}

// IsEmpty returns true if the ListResult contains no values.
func (oelr OperationEntityListResult) IsEmpty() bool {
	return oelr.Value == nil || len(*oelr.Value) == 0
}

// operationEntityListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (oelr OperationEntityListResult) operationEntityListResultPreparer() (*http.Request, error) {
	if oelr.NextLink == nil || len(to.String(oelr.NextLink)) < 1 {
		return nil, nil
	}
	return autorest.Prepare(&http.Request{},
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(oelr.NextLink)))
}

// OperationEntityListResultPage contains a page of OperationEntity values.
type OperationEntityListResultPage struct {
	fn   func(OperationEntityListResult) (OperationEntityListResult, error)
	oelr OperationEntityListResult
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationEntityListResultPage) Next() error {
	next, err := page.fn(page.oelr)
	if err != nil {
		return err
	}
	page.oelr = next
	return nil
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationEntityListResultPage) NotDone() bool {
	return !page.oelr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationEntityListResultPage) Response() OperationEntityListResult {
	return page.oelr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationEntityListResultPage) Values() []OperationEntity {
	if page.oelr.IsEmpty() {
		return nil
	}
	return *page.oelr.Value
}

// PostBackupResponse post Backup Response
type PostBackupResponse struct {
	autorest.Response `json:"-"`
	// PostBackupResponseProperties - Post Backup Response Properties
	*PostBackupResponseProperties `json:"backupMetadata,omitempty"`
}

// MarshalJSON is the custom marshaler for PostBackupResponse.
func (pbr PostBackupResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pbr.PostBackupResponseProperties != nil {
		objectMap["backupMetadata"] = pbr.PostBackupResponseProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PostBackupResponse struct.
func (pbr *PostBackupResponse) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "backupMetadata":
			if v != nil {
				var postBackupResponseProperties PostBackupResponseProperties
				err = json.Unmarshal(*v, &postBackupResponseProperties)
				if err != nil {
					return err
				}
				pbr.PostBackupResponseProperties = &postBackupResponseProperties
			}
		}
	}

	return nil
}

// PostBackupResponseProperties post Backup Response Properties object.
type PostBackupResponseProperties struct {
	// CloudEndpointName - cloud endpoint Name.
	CloudEndpointName *string `json:"cloudEndpointName,omitempty"`
}

// PostRestoreRequest post Restore Request
type PostRestoreRequest struct {
	// Partition - Post Restore partition.
	Partition *string `json:"partition,omitempty"`
	// ReplicaGroup - Post Restore replica group.
	ReplicaGroup *string `json:"replicaGroup,omitempty"`
	// RequestID - Post Restore request id.
	RequestID *string `json:"requestId,omitempty"`
	// AzureFileShareURI - Post Restore Azure file share uri.
	AzureFileShareURI *string `json:"azureFileShareUri,omitempty"`
	// Status - Post Restore Azure status.
	Status *string `json:"status,omitempty"`
	// SourceAzureFileShareURI - Post Restore Azure source azure file share uri.
	SourceAzureFileShareURI *string `json:"sourceAzureFileShareUri,omitempty"`
	// FailedFileList - Post Restore Azure failed file list.
	FailedFileList *string `json:"failedFileList,omitempty"`
	// RestoreFileSpec - Post Restore restore file spec array.
	RestoreFileSpec *[]RestoreFileSpec `json:"restoreFileSpec,omitempty"`
}

// PreRestoreRequest pre Restore request object.
type PreRestoreRequest struct {
	// Partition - Pre Restore partition.
	Partition *string `json:"partition,omitempty"`
	// ReplicaGroup - Pre Restore replica group.
	ReplicaGroup *string `json:"replicaGroup,omitempty"`
	// RequestID - Pre Restore request id.
	RequestID *string `json:"requestId,omitempty"`
	// AzureFileShareURI - Pre Restore Azure file share uri.
	AzureFileShareURI *string `json:"azureFileShareUri,omitempty"`
	// Status - Pre Restore Azure status.
	Status *string `json:"status,omitempty"`
	// SourceAzureFileShareURI - Pre Restore Azure source azure file share uri.
	SourceAzureFileShareURI *string `json:"sourceAzureFileShareUri,omitempty"`
	// BackupMetadataPropertyBag - Pre Restore backup metadata property bag.
	BackupMetadataPropertyBag *string `json:"backupMetadataPropertyBag,omitempty"`
	// RestoreFileSpec - Pre Restore restore file spec array.
	RestoreFileSpec *[]RestoreFileSpec `json:"restoreFileSpec,omitempty"`
	// PauseWaitForSyncDrainTimePeriodInSeconds - Pre Restore pause wait for sync drain time period in seconds.
	PauseWaitForSyncDrainTimePeriodInSeconds *int32 `json:"pauseWaitForSyncDrainTimePeriodInSeconds,omitempty"`
}

// ProxyResource the resource model definition for a ARM proxy resource. It will have everything other than
// required location and tags
type ProxyResource struct {
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// RecallActionParameters the parameters used when calling recall action on server endpoint.
type RecallActionParameters struct {
	// Pattern - Pattern of the files.
	Pattern *string `json:"pattern,omitempty"`
	// RecallPath - Recall path.
	RecallPath *string `json:"recallPath,omitempty"`
}

// RegisteredServer registered Server resource.
type RegisteredServer struct {
	autorest.Response `json:"-"`
	// RegisteredServerProperties - RegisteredServer properties.
	*RegisteredServerProperties `json:"properties,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for RegisteredServer.
func (rs RegisteredServer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rs.RegisteredServerProperties != nil {
		objectMap["properties"] = rs.RegisteredServerProperties
	}
	if rs.ID != nil {
		objectMap["id"] = rs.ID
	}
	if rs.Name != nil {
		objectMap["name"] = rs.Name
	}
	if rs.Type != nil {
		objectMap["type"] = rs.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RegisteredServer struct.
func (rs *RegisteredServer) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var registeredServerProperties RegisteredServerProperties
				err = json.Unmarshal(*v, &registeredServerProperties)
				if err != nil {
					return err
				}
				rs.RegisteredServerProperties = &registeredServerProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				rs.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				rs.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				rs.Type = &typeVar
			}
		}
	}

	return nil
}

// RegisteredServerArray array of RegisteredServer
type RegisteredServerArray struct {
	autorest.Response `json:"-"`
	// Value - Collection of Registered Server.
	Value *[]RegisteredServer `json:"value,omitempty"`
}

// RegisteredServerCreateParameters the parameters used when creating a storage sync service.
type RegisteredServerCreateParameters struct {
	// Location - Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
	Tags map[string]*string `json:"tags"`
	// RegisteredServerCreateParametersProperties - The parameters used to create the storage sync service.
	*RegisteredServerCreateParametersProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for RegisteredServerCreateParameters.
func (rscp RegisteredServerCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rscp.Location != nil {
		objectMap["location"] = rscp.Location
	}
	if rscp.Tags != nil {
		objectMap["tags"] = rscp.Tags
	}
	if rscp.RegisteredServerCreateParametersProperties != nil {
		objectMap["properties"] = rscp.RegisteredServerCreateParametersProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for RegisteredServerCreateParameters struct.
func (rscp *RegisteredServerCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				rscp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				rscp.Tags = tags
			}
		case "properties":
			if v != nil {
				var registeredServerCreateParametersProperties RegisteredServerCreateParametersProperties
				err = json.Unmarshal(*v, &registeredServerCreateParametersProperties)
				if err != nil {
					return err
				}
				rscp.RegisteredServerCreateParametersProperties = &registeredServerCreateParametersProperties
			}
		}
	}

	return nil
}

// RegisteredServerCreateParametersProperties registeredServer Properties object.
type RegisteredServerCreateParametersProperties struct {
	// ServerCertificate - Registered Server Certificate
	ServerCertificate *string `json:"serverCertificate,omitempty"`
	// AgentVersion - Registered Server Agent Version
	AgentVersion *string `json:"agentVersion,omitempty"`
	// ServerOSVersion - Registered Server OS Version
	ServerOSVersion *string `json:"serverOSVersion,omitempty"`
	// LastHeartBeat - Registered Server last heart beat
	LastHeartBeat *string `json:"lastHeartBeat,omitempty"`
	// ServerRole - Registered Server serverRole
	ServerRole *string `json:"serverRole,omitempty"`
	// ClusterID - Registered Server clusterId
	ClusterID *string `json:"clusterId,omitempty"`
	// ClusterName - Registered Server clusterName
	ClusterName *string `json:"clusterName,omitempty"`
	// ServerID - Registered Server serverId
	ServerID *string `json:"serverId,omitempty"`
	// FriendlyName - Friendly Name
	FriendlyName *string `json:"friendlyName,omitempty"`
}

// RegisteredServerProperties registeredServer Properties object.
type RegisteredServerProperties struct {
	// ServerCertificate - Registered Server Certificate
	ServerCertificate *string `json:"serverCertificate,omitempty"`
	// AgentVersion - Registered Server Agent Version
	AgentVersion *string `json:"agentVersion,omitempty"`
	// ServerOSVersion - Registered Server OS Version
	ServerOSVersion *string `json:"serverOSVersion,omitempty"`
	// ServerManagementtErrorCode - Registered Server Management Error Code
	ServerManagementtErrorCode *int32 `json:"serverManagementtErrorCode,omitempty"`
	// LastHeartBeat - Registered Server last heart beat
	LastHeartBeat *string `json:"lastHeartBeat,omitempty"`
	// ProvisioningState - Registered Server Provisioning State
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// ServerRole - Registered Server serverRole
	ServerRole *string `json:"serverRole,omitempty"`
	// ClusterID - Registered Server clusterId
	ClusterID *string `json:"clusterId,omitempty"`
	// ClusterName - Registered Server clusterName
	ClusterName *string `json:"clusterName,omitempty"`
	// ServerID - Registered Server serverId
	ServerID *string `json:"serverId,omitempty"`
	// StorageSyncServiceUID - Registered Server storageSyncServiceUid
	StorageSyncServiceUID *string `json:"storageSyncServiceUid,omitempty"`
	// LastWorkflowID - Registered Server lastWorkflowId
	LastWorkflowID *string `json:"lastWorkflowId,omitempty"`
	// LastOperationName - Resource Last Operation Name
	LastOperationName *string `json:"lastOperationName,omitempty"`
	// DiscoveryEndpointURI - Resource discoveryEndpointUri
	DiscoveryEndpointURI *string `json:"discoveryEndpointUri,omitempty"`
	// ResourceLocation - Resource Location
	ResourceLocation *string `json:"resourceLocation,omitempty"`
	// ServiceLocation - Service Location
	ServiceLocation *string `json:"serviceLocation,omitempty"`
	// FriendlyName - Friendly Name
	FriendlyName *string `json:"friendlyName,omitempty"`
	// ManagementEndpointURI - Management Endpoint Uri
	ManagementEndpointURI *string `json:"managementEndpointUri,omitempty"`
}

// RegisteredServersGroupCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type RegisteredServersGroupCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *RegisteredServersGroupCreateFuture) Result(client RegisteredServersGroupClient) (rs RegisteredServer, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.RegisteredServersGroupCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.RegisteredServersGroupCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if rs.Response.Response, err = future.GetResult(sender); err == nil && rs.Response.Response.StatusCode != http.StatusNoContent {
		rs, err = client.CreateResponder(rs.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "storagesync.RegisteredServersGroupCreateFuture", "Result", rs.Response.Response, "Failure responding to request")
		}
	}
	return
}

// RegisteredServersGroupDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type RegisteredServersGroupDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *RegisteredServersGroupDeleteFuture) Result(client RegisteredServersGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.RegisteredServersGroupDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.RegisteredServersGroupDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Resource ...
type Resource struct {
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// ResourcesMoveInfo resource Move Info.
type ResourcesMoveInfo struct {
	// TargetResourceGroup - Target resource group.
	TargetResourceGroup *string `json:"targetResourceGroup,omitempty"`
	// Resources - Collection of Resources.
	Resources *[]string `json:"resources,omitempty"`
}

// RestoreFileSpec restore file spec.
type RestoreFileSpec struct {
	// Path - Restore file spec path
	Path *string `json:"path,omitempty"`
	// Isdir - Restore file spec isdir
	Isdir *bool `json:"isdir,omitempty"`
}

// ServerEndpoint server Endpoint object.
type ServerEndpoint struct {
	autorest.Response `json:"-"`
	// ServerEndpointProperties - Server Endpoint properties.
	*ServerEndpointProperties `json:"properties,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerEndpoint.
func (se ServerEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if se.ServerEndpointProperties != nil {
		objectMap["properties"] = se.ServerEndpointProperties
	}
	if se.ID != nil {
		objectMap["id"] = se.ID
	}
	if se.Name != nil {
		objectMap["name"] = se.Name
	}
	if se.Type != nil {
		objectMap["type"] = se.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerEndpoint struct.
func (se *ServerEndpoint) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serverEndpointProperties ServerEndpointProperties
				err = json.Unmarshal(*v, &serverEndpointProperties)
				if err != nil {
					return err
				}
				se.ServerEndpointProperties = &serverEndpointProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				se.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				se.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				se.Type = &typeVar
			}
		}
	}

	return nil
}

// ServerEndpointArray array of ServerEndpoint
type ServerEndpointArray struct {
	autorest.Response `json:"-"`
	// Value - Collection of ServerEndpoint.
	Value *[]ServerEndpoint `json:"value,omitempty"`
}

// ServerEndpointCreateParameters the parameters used when creating a storage sync service.
type ServerEndpointCreateParameters struct {
	// Location - Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
	Tags map[string]*string `json:"tags"`
	// ServerEndpointCreateParametersProperties - The parameters used to create the storage sync service.
	*ServerEndpointCreateParametersProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerEndpointCreateParameters.
func (secp ServerEndpointCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if secp.Location != nil {
		objectMap["location"] = secp.Location
	}
	if secp.Tags != nil {
		objectMap["tags"] = secp.Tags
	}
	if secp.ServerEndpointCreateParametersProperties != nil {
		objectMap["properties"] = secp.ServerEndpointCreateParametersProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerEndpointCreateParameters struct.
func (secp *ServerEndpointCreateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				secp.Location = &location
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				secp.Tags = tags
			}
		case "properties":
			if v != nil {
				var serverEndpointCreateParametersProperties ServerEndpointCreateParametersProperties
				err = json.Unmarshal(*v, &serverEndpointCreateParametersProperties)
				if err != nil {
					return err
				}
				secp.ServerEndpointCreateParametersProperties = &serverEndpointCreateParametersProperties
			}
		}
	}

	return nil
}

// ServerEndpointCreateParametersProperties serverEndpoint Properties object.
type ServerEndpointCreateParametersProperties struct {
	// ServerLocalPath - Server Local path.
	ServerLocalPath *string `json:"serverLocalPath,omitempty"`
	// CloudTiering - Cloud Tiering. Possible values include: 'On', 'Off'
	CloudTiering CloudTiering `json:"cloudTiering,omitempty"`
	// VolumeFreeSpacePercent - Level of free space to be maintained by Cloud Tiering if it is enabled.
	VolumeFreeSpacePercent *int32 `json:"volumeFreeSpacePercent,omitempty"`
	// FriendlyName - Friendly Name
	FriendlyName *string `json:"friendlyName,omitempty"`
	// ServerResourceID - Server Resource Id.
	ServerResourceID *string `json:"serverResourceId,omitempty"`
}

// ServerEndpointProperties serverEndpoint Properties object.
type ServerEndpointProperties struct {
	// ServerLocalPath - Server Local path.
	ServerLocalPath *string `json:"serverLocalPath,omitempty"`
	// CloudTiering - Cloud Tiering. Possible values include: 'CloudTiering2On', 'CloudTiering2Off'
	CloudTiering CloudTiering2 `json:"cloudTiering,omitempty"`
	// VolumeFreeSpacePercent - Level of free space to be maintained by Cloud Tiering if it is enabled.
	VolumeFreeSpacePercent *int32 `json:"volumeFreeSpacePercent,omitempty"`
	// FriendlyName - Friendly Name
	FriendlyName *string `json:"friendlyName,omitempty"`
	// ServerResourceID - Server Resource Id.
	ServerResourceID *string `json:"serverResourceId,omitempty"`
	// ProvisioningState - ServerEndpoint Provisioning State
	ProvisioningState *string `json:"provisioningState,omitempty"`
	// LastWorkflowID - ServerEndpoint lastWorkflowId
	LastWorkflowID *string `json:"lastWorkflowId,omitempty"`
	// LastOperationName - Resource Last Operation Name
	LastOperationName *string `json:"lastOperationName,omitempty"`
	// SyncStatus - Sync Health Status
	SyncStatus interface{} `json:"syncStatus,omitempty"`
}

// ServerEndpointsGroupCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerEndpointsGroupCreateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerEndpointsGroupCreateFuture) Result(client ServerEndpointsGroupClient) (se ServerEndpoint, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.ServerEndpointsGroupCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.ServerEndpointsGroupCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if se.Response.Response, err = future.GetResult(sender); err == nil && se.Response.Response.StatusCode != http.StatusNoContent {
		se, err = client.CreateResponder(se.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "storagesync.ServerEndpointsGroupCreateFuture", "Result", se.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServerEndpointsGroupDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerEndpointsGroupDeleteFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerEndpointsGroupDeleteFuture) Result(client ServerEndpointsGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.ServerEndpointsGroupDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.ServerEndpointsGroupDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerEndpointsGroupRecallActionFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type ServerEndpointsGroupRecallActionFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerEndpointsGroupRecallActionFuture) Result(client ServerEndpointsGroupClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.ServerEndpointsGroupRecallActionFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.ServerEndpointsGroupRecallActionFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// ServerEndpointsGroupUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ServerEndpointsGroupUpdateFuture struct {
	azure.Future
}

// Result returns the result of the asynchronous operation.
// If the operation has not completed it will return an error.
func (future *ServerEndpointsGroupUpdateFuture) Result(client ServerEndpointsGroupClient) (se ServerEndpoint, err error) {
	var done bool
	done, err = future.Done(client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "storagesync.ServerEndpointsGroupUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		err = azure.NewAsyncOpIncompleteError("storagesync.ServerEndpointsGroupUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if se.Response.Response, err = future.GetResult(sender); err == nil && se.Response.Response.StatusCode != http.StatusNoContent {
		se, err = client.UpdateResponder(se.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "storagesync.ServerEndpointsGroupUpdateFuture", "Result", se.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ServerEndpointUpdateParameters parameters for updating an Server Endpoint.
type ServerEndpointUpdateParameters struct {
	// Tags - The user-specified tags associated with the server endpoint.
	Tags map[string]*string `json:"tags"`
	// ServerEndpointUpdateProperties - The properties of the serverendpoint.
	*ServerEndpointUpdateProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ServerEndpointUpdateParameters.
func (seup ServerEndpointUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if seup.Tags != nil {
		objectMap["tags"] = seup.Tags
	}
	if seup.ServerEndpointUpdateProperties != nil {
		objectMap["properties"] = seup.ServerEndpointUpdateProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ServerEndpointUpdateParameters struct.
func (seup *ServerEndpointUpdateParameters) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				seup.Tags = tags
			}
		case "properties":
			if v != nil {
				var serverEndpointUpdateProperties ServerEndpointUpdateProperties
				err = json.Unmarshal(*v, &serverEndpointUpdateProperties)
				if err != nil {
					return err
				}
				seup.ServerEndpointUpdateProperties = &serverEndpointUpdateProperties
			}
		}
	}

	return nil
}

// ServerEndpointUpdateProperties serverEndpoint Update Properties object.
type ServerEndpointUpdateProperties struct {
	// CloudTiering - Cloud Tiering. Possible values include: 'CloudTiering1On', 'CloudTiering1Off'
	CloudTiering CloudTiering1 `json:"cloudTiering,omitempty"`
	// VolumeFreeSpacePercent - Level of free space to be maintained by Cloud Tiering if it is enabled.
	VolumeFreeSpacePercent *int32 `json:"volumeFreeSpacePercent,omitempty"`
}

// Service storage Sync Service object.
type Service struct {
	autorest.Response `json:"-"`
	// ServiceProperties - Storage Sync Service properties.
	*ServiceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Service.
func (s Service) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.ServiceProperties != nil {
		objectMap["properties"] = s.ServiceProperties
	}
	if s.Tags != nil {
		objectMap["tags"] = s.Tags
	}
	if s.Location != nil {
		objectMap["location"] = s.Location
	}
	if s.ID != nil {
		objectMap["id"] = s.ID
	}
	if s.Name != nil {
		objectMap["name"] = s.Name
	}
	if s.Type != nil {
		objectMap["type"] = s.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Service struct.
func (s *Service) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var serviceProperties ServiceProperties
				err = json.Unmarshal(*v, &serviceProperties)
				if err != nil {
					return err
				}
				s.ServiceProperties = &serviceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				s.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				s.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		}
	}

	return nil
}

// ServiceArray array of StorageSyncServices
type ServiceArray struct {
	autorest.Response `json:"-"`
	// Value - Collection of StorageSyncServices.
	Value *[]Service `json:"value,omitempty"`
}

// ServiceCreateParameters the parameters used when creating a storage sync service.
type ServiceCreateParameters struct {
	// Location - Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for ServiceCreateParameters.
func (scp ServiceCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scp.Location != nil {
		objectMap["location"] = scp.Location
	}
	if scp.Tags != nil {
		objectMap["tags"] = scp.Tags
	}
	return json.Marshal(objectMap)
}

// ServiceProperties storage Sync Service Properties object.
type ServiceProperties struct {
	// StorageSyncServiceStatus - Storage Sync service status.
	StorageSyncServiceStatus *int32 `json:"storageSyncServiceStatus,omitempty"`
	// StorageSyncServiceUID - Storage Sync service Uid
	StorageSyncServiceUID *string `json:"storageSyncServiceUid,omitempty"`
}

// ServiceUpdateParameters parameters for updating an Storage sync service.
type ServiceUpdateParameters struct {
	// Tags - The user-specified tags associated with the storage sync service.
	Tags map[string]*string `json:"tags"`
	// Properties - The properties of the storage sync service.
	Properties interface{} `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceUpdateParameters.
func (sup ServiceUpdateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sup.Tags != nil {
		objectMap["tags"] = sup.Tags
	}
	objectMap["properties"] = sup.Properties
	return json.Marshal(objectMap)
}

// SubscriptionState subscription State object.
type SubscriptionState struct {
	// State - State of Azure Subscription. Possible values include: 'Registered', 'Unregistered', 'Warned', 'Suspended', 'Deleted'
	State Reason `json:"state,omitempty"`
	// Istransitioning - Is Transitioning
	Istransitioning *bool `json:"istransitioning,omitempty"`
	// Properties - Subscription state properties.
	Properties interface{} `json:"properties,omitempty"`
}

// SyncGroup sync Group object.
type SyncGroup struct {
	autorest.Response `json:"-"`
	// SyncGroupProperties - SyncGroup properties.
	*SyncGroupProperties `json:"properties,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SyncGroup.
func (sg SyncGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sg.SyncGroupProperties != nil {
		objectMap["properties"] = sg.SyncGroupProperties
	}
	if sg.ID != nil {
		objectMap["id"] = sg.ID
	}
	if sg.Name != nil {
		objectMap["name"] = sg.Name
	}
	if sg.Type != nil {
		objectMap["type"] = sg.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SyncGroup struct.
func (sg *SyncGroup) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var syncGroupProperties SyncGroupProperties
				err = json.Unmarshal(*v, &syncGroupProperties)
				if err != nil {
					return err
				}
				sg.SyncGroupProperties = &syncGroupProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sg.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sg.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sg.Type = &typeVar
			}
		}
	}

	return nil
}

// SyncGroupArray array of SyncGroup
type SyncGroupArray struct {
	autorest.Response `json:"-"`
	// Value - Collection of SyncGroup.
	Value *[]SyncGroup `json:"value,omitempty"`
}

// SyncGroupCreateParameters the parameters used when creating a sync group.
type SyncGroupCreateParameters struct {
	// Location - Required. Gets or sets the location of the resource. This will be one of the supported and registered Azure Geo Regions (e.g. West US, East US, Southeast Asia, etc.). The geo region of a resource cannot be changed once it is created, but if an identical geo region is specified on update, the request will succeed.
	Location *string `json:"location,omitempty"`
	// Tags - Gets or sets a list of key value pairs that describe the resource. These tags can be used for viewing and grouping this resource (across resource groups). A maximum of 15 tags can be provided for a resource. Each tag must have a key with a length no greater than 128 characters and a value with a length no greater than 256 characters.
	Tags map[string]*string `json:"tags"`
	// Properties - The parameters used to create the sync group
	Properties interface{} `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for SyncGroupCreateParameters.
func (sgcp SyncGroupCreateParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sgcp.Location != nil {
		objectMap["location"] = sgcp.Location
	}
	if sgcp.Tags != nil {
		objectMap["tags"] = sgcp.Tags
	}
	objectMap["properties"] = sgcp.Properties
	return json.Marshal(objectMap)
}

// SyncGroupProperties syncGroup Properties object.
type SyncGroupProperties struct {
	// UniqueID - Unique Id
	UniqueID *string `json:"uniqueId,omitempty"`
	// SyncGroupStatus - Sync group status
	SyncGroupStatus *string `json:"syncGroupStatus,omitempty"`
}

// TrackedResource the resource model definition for a ARM tracked top level resource
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	if tr.ID != nil {
		objectMap["id"] = tr.ID
	}
	if tr.Name != nil {
		objectMap["name"] = tr.Name
	}
	if tr.Type != nil {
		objectMap["type"] = tr.Type
	}
	return json.Marshal(objectMap)
}

// Workflow workflow resource.
type Workflow struct {
	autorest.Response `json:"-"`
	// WorkflowProperties - Workflow properties.
	*WorkflowProperties `json:"properties,omitempty"`
	// ID - Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Workflow.
func (w Workflow) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if w.WorkflowProperties != nil {
		objectMap["properties"] = w.WorkflowProperties
	}
	if w.ID != nil {
		objectMap["id"] = w.ID
	}
	if w.Name != nil {
		objectMap["name"] = w.Name
	}
	if w.Type != nil {
		objectMap["type"] = w.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Workflow struct.
func (w *Workflow) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var workflowProperties WorkflowProperties
				err = json.Unmarshal(*v, &workflowProperties)
				if err != nil {
					return err
				}
				w.WorkflowProperties = &workflowProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				w.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				w.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				w.Type = &typeVar
			}
		}
	}

	return nil
}

// WorkflowArray array of Workflow
type WorkflowArray struct {
	// Value - Collection of workflow items.
	Value *[]Workflow `json:"value,omitempty"`
}

// WorkflowProperties workflow Properties object.
type WorkflowProperties struct {
	// LastStepName - last step name
	LastStepName *string `json:"lastStepName,omitempty"`
	// Status - workflow status. Possible values include: 'Active', 'Expired', 'Succeeded', 'Aborted', 'Failed'
	Status Status `json:"status,omitempty"`
	// Operation - operation direction. Possible values include: 'Do', 'Undo', 'Cancel'
	Operation Operation `json:"operation,omitempty"`
	// Steps - workflow steps
	Steps *string `json:"steps,omitempty"`
	// LastOperationID - workflow last operation identifier.
	LastOperationID *string `json:"lastOperationId,omitempty"`
}
