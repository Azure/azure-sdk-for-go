// Copyright 2018 Microsoft Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"github.com/Azure/azure-sdk-for-go/tools/internal/modinfo"
	"github.com/Azure/azure-sdk-for-go/tools/internal/pkgs"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init <searching dir> [initial module version]",
	Short: "Initialize a package into go module with initial version",
	Long: `This tool will detect every possible service under the searching directory, 
and make them as module with initial version. The default version for new modules is v1.0.0 
or the value specified for [initial module version].
NOTE: This command is only used on local and only for initial release.
`,
	Args: cobra.RangeArgs(1, 2),
	RunE: func(cmd *cobra.Command, args []string) error {
		return theInitCommand(args)
	},
}

const (
	initialVerGo = `package %s

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

// UserAgent returns the UserAgent string to use when sending http.Requests.
func UserAgent() string {
	return "Azure-SDK-For-Go/%s %s/%s"
}

// Version returns the semantic version (see http://semver.org) of the client.
func Version() string {
	return "%s"
}

// tag: %s
`

	initialGoMod = `module %s

%s
`

	goVersion = `go 1.12`
)

var exceptFile string

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.PersistentFlags().StringVarP(&exceptFile, "exceptions", "e", "", "file for exception package list")
}

func theInitCommand(args []string) error {
	root, err := filepath.Abs(args[0])
	if err != nil {
		return fmt.Errorf("failed to get absolute path from '%s': %+v", args[0], err)
	}
	if len(args) == 2 {
		if !modinfo.IsValidModuleVersion(args[1]) {
			return fmt.Errorf("the string '%s' is not a valid module version", args[1])
		}
		startingModVer = args[1]
	}
	exceptions, err := loadExceptions(exceptFile)
	if err != nil {
		return fmt.Errorf("failed to load exceptions: %+v", err)
	}
	ps, err := pkgs.GetPkgs(root)
	if err != nil {
		return fmt.Errorf("failed to get packages: %+v", err)
	}
	var errs []error
	for _, p := range ps {
		if _, ok := exceptions[p.Dest]; ok {
			vprintf("Classical package %s, skip\n", p.Dest)
			continue
		}
		path := filepath.Join(root, p.Dest)
		tagPrefix, err := getTagPrefix(path)
		if err != nil {
			return fmt.Errorf("failed to get tag prefix: %+v", err)
		}
		vprintf("TagPrefix: %s\n", tagPrefix)
		if err := createVersionFile(root, p, tagPrefix); err != nil {
			errs = append(errs, err)
		}
		if err := createGoModFile(root, p); err != nil {
			errs = append(errs, err)
		}
	}
	// handle errors
	if len(errs) == 0 {
		return nil
	}
	for _, err := range errs {
		println(err.Error())
	}
	return fmt.Errorf("execution failed with %d errors", len(errs))
}

func createVersionFile(root string, p pkgs.Pkg, tagPrefix string) error {
	verFilePath := filepath.Join(root, p.Dest, "version.go")
	apiVersion, err := p.GetAPIVersion()
	if err != nil {
		return fmt.Errorf("failed to get api version of package %s: %+v", p.Dest, err)
	}
	tag := tagPrefix + "/" + startingModVer
	content := fmt.Sprintf(initialVerGo, p.Package.Name, startingModVer, p.Package.Name, apiVersion, startingModVer, tag)
	err = ioutil.WriteFile(verFilePath, []byte(content), 0755)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %+v", verFilePath, err)
	}
	return nil
}

func createGoModFile(root string, p pkgs.Pkg) error {
	modFilePath := filepath.Join(root, p.Dest, "go.mod")
	fullPath := filepath.Join(root, p.Dest)
	index := strings.Index(fullPath, "github.com")
	if index < 0 {
		return fmt.Errorf("failed to find github.com in filepath %s", fullPath)
	}
	importPath := strings.ReplaceAll(fullPath[index:], "\\", "/")
	content := fmt.Sprintf(initialGoMod, importPath, goVersion)
	err := ioutil.WriteFile(modFilePath, []byte(content), 0755)
	if err != nil {
		return fmt.Errorf("failed to write file %s: %+v", modFilePath, err)
	}
	return nil
}

func loadExceptions(exceptFile string) (map[string]bool, error) {
	result := make(map[string]bool)
	if exceptFile == "" {
		return result, nil
	}
	abs, err := filepath.Abs(exceptFile)
	if err != nil {
		return nil, err
	}
	file, err := os.Open(abs)
	defer file.Close()
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := scanner.Text()
		result[line] = true
	}
	return result, nil
}
